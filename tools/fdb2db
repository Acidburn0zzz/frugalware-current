#!/usr/bin/perl -w 

use strict;
use Getopt::Std;
use Data::Dumper;
use File::Find;
use DBI();
use Term::ReadPassword;

sub untarrepodb{ #repodb
    my ($repodb) = @_;
    my $dir = "/tmp/$repodb";
    die $! unless mkdir $dir;
    qx"tar xzf $repodb -C $dir";
    return $dir;
}

sub rrmdir { #dir
    qx/rm -rf $_[0]/;
}

sub getcontents { #file          # puts a textfile to an ARRAY
    my $d = shift;
    die "$! $d" unless open FILE, $d;
    my @lines = <FILE>;
    close FILE;
    return @lines;
}

sub getrepodbdata { #what from      # takes '%foo%' and gives a SCALAR
    my ($what, $from) = (shift, join '', @_);
    my ($out) = $from =~ /$what.(.*?).(:?.%|\Z)/s;
    $out =~ s/\n/ / if $out;
    return $out;
}

sub lengthb255{ # SCALAR
    my $p = shift;
    return undef unless $p;
    (length $p > 255) ? undef : $p;
}

sub readdata { #string
    my $str = shift;
    my $inp = '';
    while ($inp eq ''){print $str;$inp = <STDIN>; chomp $inp;}
    return $inp;
}

my %opts;
getopts('r:e:b:pu:vi', \%opts);

die 'Specify a repositoryname!' unless my $repo = $opts{r};
die 'Specify a version string!' unless my $fwver = $opts{e};
die 'Specify the FrugalBuild directory!' unless my $fbdir = $opts{b};

my $warn;
my $user;
$user = $opts{u} or $user = '';               
my $passw = read_password('password: ') if $opts{p};

my $db = 'mysqldb';
$db->connect({database => 'frugalware',
	      host => 'localhost',
	      user => $user,
	      password => $passw,
	  });                                 ##### ERRORCHECK!!
$passw = '';

my $pkgdir = untarrepodb $repo.'.fdb';
opendir DBDIR, $pkgdir;

while (my $pkg = readdir DBDIR){   #pkg is a dir, pkg =~ name-ver-rel 

    next if $pkg =~ /^\.{1,2}$/;
    my %pkgdata;
    ($pkgdata{FWVER}, $pkgdata{REPO}) = ($fwver, $repo);
    my @contents = getcontents "$pkgdir/$pkg/desc";
   
    for my $link (qw/NAME VERSION DESC CSIZE MD5SUM GROUPS REPLACES/){   
	$pkgdata{$link} = lengthb255 getrepodbdata '%'.$link.'%', @contents; ## WARN when too long
    }
    ($pkgdata{VERSION}, $pkgdata{PKGREL}) = split '-', $pkgdata{VERSION}; # VERSION =~ ver-rel
    
    @contents = getcontents "$pkgdir/$pkg/depends";
    for my $link (qw/PROVIDES CONFLICTS DEPENDS/){
	$pkgdata{$link} = lengthb255 getrepodbdata '%'.$link.'%', @contents;
    }

    $pkgdata{FILELIST} = join ' ', qx/tar xzOf $pkg.fpm .FILELIST/;
    $pkgdata{FILELIST} =~ s/\n//g;
    ($pkgdata{ARCH}) =  qx/tar xzOf $pkg.fpm .PKGINFO/ =~ /^arch = (.*)$/m;
    
    my $buildscript;
    find sub {
	$buildscript = $File::Find::name if $File::Find::name =~ m"$pkgdata{NAME}/FrugalBuild\Z";
	}, $fbdir;

    if (!$buildscript){
	if ($opts{i}){
	    $buildscript = readdata "Full path to the FrugalBuild script of $pkgdata{NAME}:";
	} else {
	    $warn .= "No FrugalBuild found to $pkgdata{NAME}\n";
	    $pkgdata{NVALID} = 1;
	}
    }

    ($pkgdata{M8R}) = qx"cat $buildscript" =~ /^\#.?Maintainer: (.*)$/m if $buildscript;

##### VERIFY INFO

    if (not $pkgdata{GROUPS}) {
	do{do{($pkgdata{GROUPS}) = $buildscript =~ m'.*/(.*?)/.*?/FrugalBuild'} if $buildscript} or do{
	    if ($opts{i}){
		$pkgdata{GROUPS} = readdata "Groups of $pkgdata{NAME}:";
	    } else {
		$warn .= "No groups determined for $pkgdata{NAME}\n";
		$pkgdata{NVALID} = 1;
	    }
	}
    }

    if (not $pkgdata{ARCH}){
	if ($opts{i}){
	    $pkgdata{ARCH} = readdata "Architecture of $pkgdata{NAME}:";
	} else {
	    $warn .= "No architecture determined for $pkgdata{NAME}\n";
	    $pkgdata{NVALID} = 1;
	}
    }

    $db->store(\%pkgdata) unless $pkgdata{NVALID};

    %pkgdata = ();
}

$db->disconnect;
closedir DBDIR;
rrmdir $pkgdir;

print $warn;


package mysqldb;

my $dbh;

sub connect{ # datahash
    my ($self,$datas) = @_;
    $dbh = DBI->connect("DBI:mysql:database=$datas->{database};host=$datas->{host}",
			$datas->{user}, $datas->{password},
			);
}

sub existsindb {
    my($name,$fwver,$arch) = @_;
    my $sth = $dbh->prepare("SELECT id FROM packages where pkgname='$name' and fwver='$fwver' and arch='$arch'");
    $sth->execute();
    do {$sth->finish(); return 1;} if $sth->fetchrow_hashref();
    $sth->finish();
    return 0;
}

sub store{
    shift;
    my $data = shift;
    my $values;
    for my $key (qw/NAME VERSION PKGREL GROUPS PROVIDES DEPENDS CONFLICTS REPLACES CSIZE ARCH DESC M8R MD5SUM FWVER REPO FILELIST/){
	$data->{$key} =~ s/'/\\'/g if $data->{$key};
	$values .= (($data->{$key}) ? "'$data->{$key}'" : 'NULL') . ',';
    }
    chop $values;

    if (existsindb($data->{NAME}, $data->{FWVER}, $data->{ARCH})){
	my $set = '`pkgname`=';
	for my $key (qw/NAME `pkgver` VERSION `pkgrel` PKGREL `groups` GROUPS `provides` PROVIDES `depends` DEPENDS `conflicts` CONFLICTS `replaces` REPLACES `csize` CSIZE `arch` ARCH `desc` DESC `maintainer` M8R `md5` MD5SUM `fwver` FWVER `repo` REPO `files` FILELIST/){
  	    $set .= ($data->{$key}) ? "'$data->{$key}'," : "$key=";
	}
	chop $set;
	$dbh->do("UPDATE packages set $set where pkgname='$data->{NAME}' and fwver='$data->{FWVER}' and arch='$data->{ARCH}'");
    } else {
	$dbh->do("INSERT INTO packages (`pkgname`,`pkgver`,`pkgrel`,`groups`,`provides`,`depends`,`conflicts`,`replaces`,`csize`,`arch`,`desc`,`maintainer`,`md5`,`fwver`,`repo`,`files`,`updated`) VALUES ($values, now())");
    }
}

sub disconnect{
    $dbh->disconnect();
}



1;


__END__

         pkgname   	varchar(255)    NAME r
	 pkgver  	varchar(255) 	VERSION r
	 pkgrel  	tinyint(4) 	PKGREL r
	 groups  	varchar(255) 	GROUPS r
	 provides  	varchar(255) 	PROVIDES r/d             r/d <=> repodb/depends file
	 depends  	varchar(255) 	DEPENDS r/d		r <=> repo.db/desc
	 conflicts  	varchar(255) 	CONFLICTS r/d
	 replaces  	varchar(255) 	REPLACES r
	 csize  	int(11) 	CSIZE r
	 arch  		varchar(255) 	ARCH .PKGINFO
	 desc  		varchar(255) 	DESC r
	 maintainer  	varchar(255) 	M8R FrugalBuild
	 md5  		varchar(32) 	MD5SUM r 
	 fwver  	varchar(255) 	FWVER Parameter
	 repo  		varchar(255) 	REPO Parameter
	 files  	mediumtext 	FILELIST .FILELIST


=head1 NAME

fdb2db - refresh a Frugalware database from a repository

=head1 SYNOPSIS

fdb2db [-v] -r name -e version -b dir [-p] [-u user] [-i]

=head1 DESCRIPTION

Scans the current directory for packages and a repository database,
then syncronizes a database. See DATABASE for the structure.

=head1 OPTIONS

=over 4

=item B<-r name>

The name of the repository.

=item B<-e version>

The version string of the disrtibution,

=item B<-b dir>

A parent directory of the buildscripts. ex. ../source/

=item B<-p>

Ask for a password if your database engine require.

=item B<-u user>

The user of the database if your engine require.

=item B<-i>

Be interactive. This will ask you about missing datas if nessesary.

=item B<-v>

Be verbose.

=head1 DATABASE

         pkgname   	varchar(255)    
	 pkgver  	varchar(255) 	
	 pkgrel  	tinyint(4) 	
	 groups  	varchar(255) 	
	 provides  	varchar(255) 	
	 depends  	varchar(255) 	
	 conflicts  	varchar(255) 	
	 replaces  	varchar(255) 	
	 csize  	int(11) 	
	 arch  		varchar(255) 	
	 desc  		varchar(255) 	
	 maintainer  	varchar(255) 	
	 md5  		varchar(32) 	
	 fwver  	varchar(255) 	
	 repo  		varchar(255) 	
	 files  	mediumtext 	
	 updated  	timestamp       

=head1 BUGS

Error checking in various points:
    - in the sql package
    - on $db->connect

Warn is data is too long.

Verbose mode

data verify is not comlete

table name in options

=head1 AUTHOR

Zsolt Szalai

=head1 REPORTING BUGS

Report bugs to <xbit@frugalware.org>

=head1 COPYRIGHT                                                                
                                                                                
May be copied and modified under the terms of the GNU General Public     
License v2.                                                                     
                                                                                
=cut

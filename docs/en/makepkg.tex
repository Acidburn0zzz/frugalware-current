\chapter{Appendix: How to make packages for Frugalware?}

\section{Introduction}
Frugalware stands of thousands of packages. All the files in the distribution belongs to a package. You can easily query what package does the specified file belong to. If we want to know which package /etc/frugalware-release is contained by, then we use:
\begin{verbatim}
$ pacman -Qo /etc/frugalware-release
/etc/frugalware-release is owned by frugalware 0.3pre1-2
\end{verbatim}
If you browse the FST (Frugalware Source Tree), there are currently two
repositories (or shortly repos). Their name is \textit{frugalware} and
\textit{extra}. The frugalware repo contains packages those are installed by
default. The extra repo is on the 3rd CD: localization packages and packages
that conflicts other packages in the frugalware repo or simply are not
installed by default. For example it's no good installing two MTAs at the same
time: the frugalware repo contains postfix, the extra contains sendmail. The
exim package will be in the extra repo, too.

Each repo has a source and a binary directory. The frugalware's directories are
source/ and frugalware-<arch>/. The extra's are extra/source/ and
extra/frugalware-<arch>/. The binary packages are in the binary directory of
the repo. The packages' source are a little bit more complex. Each package has
a category and each category and package have it's own directory in the source dir.

Let's see an example. You are searching for the cabextract package. The binary
package will be named frugalware-arch/cabextract-version-release-arch.fpm and
it's source will be placed in the source/apps/cabextract dir.

In the package's own dir, we store everything that is required to compile the package. You may say that we only should store the patches and so, but in our opinion it's very annoying when you want to recompile a package and because of some other reasons the original server is slow or unreachable.

Besides, there is a FrugalBuild file in each package's source directory. This is a simple shell script, that will be included by makepkg. So in the FrugalBuild script you can use everything that can be used in a shell script.

Briefly, packaging means collecting the sources, adding additional files (for example init scripts or config files) and writing the FrugalBuild script.

\section{Repoman}

Repoman is simple tool to download all packages' buildscript and compile programs from source.

The most commonly used repoman commands are the followings:
\begin{itemize}
\item {\tt repoman merge package} or simply {\tt repoman m package} builds a
package from source and installs it. You can configure the build options in the
makepkg_opts directive of {\tt /etc/repoman.conf}.

By default repoman will install the missing dependencies with pacman, clean up
the leftover work files, install the package, and write the resulting package
to the current working  directory.

\item {\tt repoman update} or simply {\tt repoman upd} updates \textit{FST} in
{\tt /var/fst}. First time repoman will download it (it may take some time!).
\end{itemize}

\section{Recompiling packages}

Before creating a new package, in this howto first we will recompile an existing package. That's very simple. In our example we will recompile the mplayer package. I assume you already downloaded the FST.

\begin {verbatim}
cd /var/fst/frugalware-current/source/xapps/mplayer
makepkg -ca
\end{verbatim}

First we enter the directory of mplayer then (like {\tt make} and
{\tt Makefile}) we run makepkg that will build the package according to the
parameters described in FrugalBuild. We usually use the -c option to clean up
the sources and the uncompressed package files after a successful build. Also
using -a is always a good idea, that way makepkg will try to autodetect
dependencies, in most cases you can detect if you missed a dependency this way.

In the next section we will see an example for a simple FrugalBuild script.

\section{A simple example}
Let's see a simple example, the FrugalBuild script of the cabextract package.
\begin{verbatim}
# Last Modified: Sun, 21 Mar 2004 16:54:50 +0100
# Compiling Time: 0.01 SBU
# Maintainer: VMiklos <vmiklos@frugalware.org>

pkgname=cabextract
pkgver=1.0
pkgrel=1
pkgdesc="a program to extract Microsoft Cabinet files"
url="http://www.kyz.uklinux.net/cabextract.php"
depends=('glibc')
groups=('apps')
archs=('i686')
up2date="elinks -dump http://www.kyz.uklinux.net/cabextract.php |grep 'cabextract source code'|sed 's/.*t-\(.*\)\.t.*/\1/'"
source=(http://www.kyz.uklinux.net/downloads/$pkgname-$pkgver.tar.gz)
sha1sums=('359c8f4ec9c62d9dac5d572269b607b2cae4fbf7')

# optimalization ok

# vim: ft=sh
\end{verbatim}

And here comes the description for each line:
\begin{verbatim}
# Last Modified: Sun, 21 Mar 2004 16:54:50 +0100
\end{verbatim}

If you modify the FrugalBuild script, you should update this field. The date
should be in English. That can be proceeded by unsetting LC\_ALL and LANG
environment variables. For example I use LC\_ALL=hu\_HU, so I simply made an
alias and took it to my ~/.bash\_login:
\begin{verbatim}
alias edate="LANG= LC_ALL= date -R"
\end{verbatim}

Updating this field will be done automatically if the build was successfull.

\begin{verbatim}
# Compiling Time: 0.01 SBU
\end{verbatim}

You should write here how much time did the package to built. Of course, this would depend on your hardware, so that we use SBUs instead of minutes as a unit.

SBU is the Static Binutils Unit, which means the time {\t repoman merge binutils} takes on your machine. By default makepkg will print out how many seconds the build took. After you built binutils, you should update your {\tt /etc/makepkg.conf}:

\begin{verbatim}
SBU="257"
\end{verbatim}

The line above will mean that compiling binutils on your machine took 257
seconds. From now makepkg will print out SBUs instead of seconts after
successfull builds, and that SBU value will be the same on everyone's machine.

\begin{verbatim}
# Maintainer: VMiklos <vmiklos@frugalware.org>
\end{verbatim}

If you will be the maintainer of the package, write your name or nick and mail
address here. If you suspect you won't maintain the package write Contributor
instead of Maintainer, and then the Maintainer will be added its line later.

\begin{verbatim}
pkgname=cabextract
\end{verbatim}

This will be the name of the package. It's allowed to contain numbers, hyphens
(-), etc., and should be lowercase.

\begin{verbatim}
pkgver=1.0
\end{verbatim}

The package's version. Hyphens are not allowed, so a 1.0-6111 will be usually converted to 1.0\_6111.

\begin{verbatim}
pkgrel=1
\end{verbatim}

Release number signs Frugalware-specific changes. If you recompile a package,
you should increase this number. If you upgrade to a newer version, don't
forget to reset this number back to 1. If you design a new package, set this to
1.

\begin{verbatim}
pkgdesc="a program to extract Microsoft Cabinet files"
\end{verbatim}

A short one-line description for the package. Usually taken from the project's
homepage or manpage.

\begin{verbatim}
url="http://www.kyz.uklinux.net/cabextract.php"
\end{verbatim}

The website of the project.

\begin{verbatim}
depends=('glibc')
\end{verbatim}

List of the dependencies of the package, defined in a bash array. Usually you
should compile a package at least two times: first with {\tt depends=()} and
then you should run {\tt chkdep -p foo.fpm} that will suggest the dependencies,
but handle that information carefully! Reading the README, INSTALL and
configure.ac files is also a good idea to find out the dependencies.

\begin{verbatim}
groups=('apps')
\end{verbatim}

It is needed to know where, in what category the package is. The most important
thing is, not to take your package in apps, base, devel, lib, multimedia or
network, if it depends on X (or of course a pkg depending on X).
Packages in the extra repository get 'somecategory-extra' group.

\begin{verbatim}
archs=('i686')
\end{verbatim}

This array defines on which architectures the given package is avalibable.
If it's not available, that will mean that {\tt gensync} will skip it
when generating package databases. If you are not able to provide a binary
package for a given arch, then don't include that in archs()! For example the
package \textit{could} be compiledn x86\_64, but you haven't compiled it
yourself, then don't include it.

\begin{verbatim}
up2date="elinks -dump http://www.kyz.uklinux.net/cabextract.php |grep 'cabextract source code'|sed 's/.*t-\(.*\)\.t.*/\1/'"
\end{verbatim}

A short command that will give us the latest stable version of the package. This helps maintainers to keep the FST up to date. Usually this string consists of three parts: an {\tt elinks -dump someurl}, a {\tt grep foo}, and a {\tt sed} command. We use the http protocol if possible, but sometimes we have to use ftp. In that case instead of {\tt elinks -dump} you should use {\tt wget -O - -q}. Of course, you could use wget all the time, but elinks is more simple. The sed command could be replaced with the combination of {\tt tr} and {\tt cut} if you prefer them and you dislike sed. The example used above would be the following with cut and tr:

\begin{verbatim}
up2date="elinks -dump http://www.kyz.uklinux.net/cabextract.php |grep 'cabextractsource code'|tr -s ' '|cut -d ' ' -f 6"
\end{verbatim}

\begin{verbatim}
source=(http://www.kyz.uklinux.net/downloads/$pkgname-$pkgver.tar.gz)
\end{verbatim}

Here you define the sources of the package in a bash array. You can use simple
filenames for patches, or additional files when you place them in the same
directory as the FrugalBuild script is in. You can use URLs if you want
{\tt makepkg} to download them automatically. It's important to place
\textit{all} sources in the package's directory including the source files
that you can download from a site.
Also when dowloading from sourceforge, please use download.sourceforge.net, and
not other mirrors (like heanet.dl.sf.net)!
If you use various random patches from unknown sources, don't expect that
somebody else will port those patches to a never version. You will have to do
the work yourself. You have been warned!

\begin{verbatim}
sha1sums=('8fde8ad86f7144943b7e4e5a2da7eddb')
\end{verbatim}

Another bash array to prevent compiling from wrong sources. Of course this is
useless if you download, run {\tt sha1sum foo.tar.gz}, if possible try fetching
sha1sums from the projects website. It's a good idea to leave a comment above
this line about where to find these sha1sums.

Finally can we define a {\tt build()} function that will build the package.
If you don't want to do anything special, probably you don't need to specify it
as the default build() will fit your needs. For the list of special functions
those can be used in build(), refer to {\tt /usr/lib/frugalware/fwmakepkg}.

If you don't have that file, you will have to install the {\tt pacman-tools}
package.

\begin{verbatim}
# optimalization ok
\end{verbatim}

This line will be added automatically to the bottom if the FrugalBuild if the
build() function used your \$CFLAGS or \$CXXFLAGS. This is handy if you want to
cross-compile on a faster machine for a slower architecture. Till the package
doesn't use our \$CFLAGS we can't cross-compile it, so please try to avoid
creating "unoptimalizated" packages. If the package doesn't contain any
architecture-dependent file, then you can add this line manually as makepkg
will not detect this.

\begin{verbatim}
# vim: ft=sh
\end{verbatim}

At the bottom of the script you could add some editor-specific info, for example this tells vim that the format of this script is in shell-script (it can't suspect that as no #!/bin/bash at the top of the file).

\section{Full reference}

Now here are the full list of directives available.

First, let's start with the \textbf{install} directive. Here you can refer to an install file (usually \$pkgname.install) to use. In the install file you can define actions to be executed after installing, after upgrading, before removing, and after removing. Here are an example, so that everything will be clear about it:

\begin{verbatim}
# $1:  the new package version
pre_install()
{
        /bin/true
}

# $1:  the new package version
post_install()
{
        /bin/true
}

# $1:  the new package version
# $2:  the old package version
pre_upgrade()
{
        /bin/true
}

# $1:  the new package version
# $2:  the old package version
post_upgrade()
{
        /bin/true
}

# $1:  the old package version
pre_remove()
{
        /bin/true
}

# $1:  the old package version
post_remove()
{
        /bin/true
}

op=$1
shift

$op $*

# vim: ft=sh
\end{verbatim}

If you want to do exactly the same after upgrading as after installing feel
free to use {\tt post\_install \$1} in the {\tt post\_upgrade()} function. If
you do not use the \$1 argument in post_intall do not pass it from
post\_upgrade().

If you do not need a function, just omit it.

So save this file as \$pkgname.install and then place in the same directory as
the FrugalBuild. That way makepkg will detect and use it.
You may specify the install script in the source array, but it is not
necessary.

The \textbf{pkgname}, \textbf{pkgver}, \textbf{pkgrel}, \textbf{url}, \textbf{source} \textbf{groups} and \textbf{md5sums} directives were discussed in the previous section.

The \textbf{groups} directive can be specified if you create packages for a project that issue their stuff in more than one tarball. The KDE project is a good example. In KDE packages we use the following line:
\begin{verbatim}
groups=('kde')
\end{verbatim}

The user can easily view or install these groups:
\begin{verbatim}
vmiklos@vmhome:~$ pacman -Sg
kde
vmiklos@vmhome:~$ su -c 'pacman -S kde'
Password:
:: group kde:
    arts kdeaccessibility kdeaddons kdeadmin kdeartwork kdebase kdebindings
    kdeedu kdegames kdegraphics kdelibs kdemultimedia kdenetwork kdepim kdesdk
    kdetoys kdeutils kdevelop kdewebdev
    Install whole content? [Y/n]
\end{verbatim}

The \textbf{backup} array is used to make some files in the package as a config file. If possible, we don't modify config files during an upgrade. For more information about this see the \textit{handling config files} section in the pacman manpage.

The \textbf{depends} array has been already discussed, except I haven't mentioned before that the elements may include version informations: for example:
\begin{verbatim}
pkgname=kdewebdev
depends=('kdelibs=3.3.0')
\end{verbatim}

Here you can use {\tt <>}, {\tt <=}, {\tt >=} or {\tt =} operators.

The \textbf{makedepends} array defines packages required only in build time. For example if the source is in SRPM format maybe alien is a build-time requirement.

In the \textbf{conflicts} array you can define a list of packages that can't be installed if you want to install this package. Let's see an another example:

\begin{verbatim}
pkgname=blackbox
conflicts=('fluxbox')
\end{verbatim}

This is required as both of them includes a {\tt bsetbg} command and the two program is different. In this case the fluxbox package also have to contain this line ({\tt conflicts=('blackbox')}). Of course, if two or more package conflicts each other, only one of them can be placed in the frugalware repo. 

The \textbf{provides} array is used to create virtual dependencies. This means postfix and sendmail also provides mta or, a better example, xfree and xorg provides x too. So qt will contain the following line:
\begin{verbatim}
pkgname=qt
depends=('x' 'libpng' 'libjpeg')
\end{verbatim}

The user has the ability to choose between xfree and xorg.

The last one in this list is the \textbf{replaces} directive. The module-init-tools package is a good example:
\begin{verbatim}
pkgname=module-init-tools
replaces=('modutils')
conflicts=('modutils')
\end{verbatim}

As you can see, we often make such new packages also conflicts with each other. Using the replaces directive when users use {\tt pacman -Su} next time, if modutils is installed (probably :)), they will be asked to remove modutils and to install module-init-tools.

Some program come with the file {\tt /usr/info/dir}. This must be erased in {\tt build()}, {\tt texinfo} must be in {\tt \$depends} and you are forced to make an install script, that regenerates the file, here is an example:
\begin{verbatim}
post_install() {
	echo -n "generating the top-level Info node... "
	mkinfodir /usr/info > /usr/info/dir 2> /dev/null
	echo "done."
}

post_upgrade() {
	post_install
}

post_remove() {
	post_install
}

op=$1
shift

$op $*
\end{verbatim}

Erasing {\tt /usr/info/dir} is done by the default build() function.

\section{Compiling the package}

That's fairly simple. In the package directory you should do exactly the same as described in the \textit{Recompiling packages} section. If you want to contribute this package to the Frugalware project, please do \textit{not} do a movepkg. Upload the whole package dir (including the binary package) to {\tt ftp://ftp.frugalware.org/incoming} and send a mail to the frugalware-devel list.

Happy packaging :)

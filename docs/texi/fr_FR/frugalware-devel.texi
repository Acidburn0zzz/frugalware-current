@node Développment, Contenu, Installation and configuration, Début
@c node-name,     next,        previous,         up

@chapter Développement

@section Création de nouveaux paquets
@subsection Introduction

Frugalware est composée de milliers de paquets. Chaque fichier de la
 distribution appartient à un paquet. Vous pouvez facilement vérifier 
à quel paquet un fichier spécifique appartient. Si vous souhaitez savoir 
quel paquet contient /etc/frugalware-release, vous devez saisir:

@verbatim
$ pacman -Qo /etc/frugalware-release
/etc/frugalware-release appartient à frugalware 0.3-3
@end verbatim

Si vous parcourez le FST (Frugalware Source Tree - arborescence des sources),
actuellement il y'a 2 dépôts [repositories (or repos in short)], dont les
noms sont frugalware et extra. 
Le dépôt frugalware contient d'avantage de paquets. Les paquets binaires du 
dépôt extra sont uniquement disponibles sur le dvd (et évidement sur les
serveurs FTP): paquets d'internationalisation et paquets en conflits avec
d'autres paquets du dépôt frugalware. Par exemple, ce n'est pas une bonne 
idée d'installer 2 MTA en même temps: le dépôt frugalware contient postfix,
 le dépôt extra contient sendmail. 
Le paquet pour exim est également dans le dépôt extra.

Chaque dépôt à un répertoire source et un répertoire binaire. Les répertoires
 du dépôt frugalware sont source/ and frugalware-$arch/. Ceux d'extra sont
 extra/source/ et extra/frugalware-$arch/. Les paquets binaires sont dans
 les répertoires binaires des dépôts. Les sources des paquets sont un peu plus
 complexes. Chaque paquet à une catégorie, et chaque paquet et chaque catégorie
 à son propre répertoire dans le répertoire source.

Voyons un exemple. Vous cherchez le paquet cabextract.
 Le paquet binaire s'appelles 
@samp{frugalware-<arch>/cabextract-<version>-<release>-<arch>.fpm} et ses 
 ses sources se trouvent dans le répertoire source/apps/cabextract.

Dans le répertoire du paquet, nous stockons tout ce qui est requit pour compiler
 le paquet. Vous pouvez penser que nous ne devrions stocker que les correctifs et 
apparentés, mais à notre avis, c'est très ennuyeux lorsque vous devez recompiler
 un paquet et que le serveur d'origine est lent ou même inaccessible pour 
d'autres raisons.

En dehors de ça, il y'a un fichier FrugalBuild dans le répertoire de chaque 
paquet. C'est un simple script shell bash, qui sera inclus par makepkg. 
Dans le script FrugalBuild vous pouvez donc utiliser tout ce que vous utiliseriez
 dans un script shell classique.

En bref, créer un paquet revient à collecter les sources, ajouter les fichiers 
supplémentaires (par exemple les scripts d'init ou les fichiers de config) et
écrire le script FrugalBuild.

@subsection Recompiler des paquets

Avant de créer un nouveau paquet, nous allons en recompiler 
un existant dans cet howto. C'est très simple. Dans notre exemple nous allons 
recompiler le paquet mplayer. Tout d'abord, vous devez télécharger 
l'arborescence de sources (FST) courante : @samp{$ repoman upd}, 
en tant que root. 
Ou, en tant qu'utilisateur classique, copier /etc/repoman.conf vers ~/.repoman.conf, 
changer le répertoire fst_root pour le faire pointer dessus (par défaut, 
cela téléchargerait les fichiers dans /var/fst, et ce l'utilisateur n'y a pas
les droits d'écriture, évidement) et exécuter repoman upd.

Avant de construire l'environnement chroot, vous devriez vous assurer
que l'utilisateur fst existe sur système. Vérifiez votre fichier /etc/passwd. 
Si l'utilisateur n'existe pas, alors veuillez vérifier dans votre fichier 
/etc/passwd.pacnew, il contient l'entrée appropriée, copier simplement cette 
ligne dans le fichier /etc/passwd.

Maintenant que vous avez l'utilisateur fst, continuer avec

@verbatim
$ cd $fst_root/source/xapps/mplayer
$ sudo makepkg -Ra
@end verbatim

D'abord nou devons entrer dans le répertoire de mplayer puis (comme make et 
Makefile) on lance makepkg, cela va construire le paquet conformément aux 
paramètres décrit dans in FrugalBuild. Nous utilisons généralement l'option -R 
pour construire le paquet dans un environnement chrooté. Chroot nécessite des 
privilèges root. Pour autoriser un groupe (par exemple le groupe devels) à 
utiliser sudo makepkg -Ra, démarrez visudo en tant que root, et ajoutez la
ligne suivante:

@samp{%devels ALL=NOPASSWD:/usr/bin/makepkg -Ra}

Le chroot sera par défaut situé dans /var/chroot. Un seul paquet peut être
construit en chroot à la fois, aussi vous voudrez peut être spécifier un 
chroot spécifique pour chaque utilisateur. Pour ce faire, modifiez la variable 
$CHROOTDIR dans votre /etc/makepkg.conf de:
@samp{export CHROOTDIR="/var/chroot"}
à
@samp{export CHROOTDIR="/var/chroot.`echo $HOME|sed 's|.*/\(.*\)$|\1|'`"}

(Voir man makepkg pour plus d'infos sur les bénéfices de construction en chroot).

Utiliser égallement l'option -a est toujours une bonne idée, ainsi makepkg va 
essayer de détecter automatiquement les dépendances. De cette façon, dans la 
plupart des cas, vous pourrez vous rendre compte si vous avez oublié une 
dépendance.

Dans la section suivante, nous allons voir un exemple de script FrugalBuild 
simple.

@subsection Un exemple simple

Voyons un exemple simple, le script FrugalBuild du paquet cabextract.

@verbatim
# Last Modified: Sun, 21 Mar 2004 16:54:50 +0100
# Compiling Time: 0.01 SBU
# Maintainer: VMiklos <vmiklos@frugalware.org>

pkgname=cabextract
pkgver=1.0
pkgrel=1
pkgdesc="a program to extract Microsoft Cabinet files"
url="http://www.kyz.uklinux.net/cabextract.php"
depends=('glibc')
groups=('apps')
archs=('i686')
up2date="elinks -dump http://www.kyz.uklinux.net/cabextract.php |grep 'cabextract source code'|sed 's/.*t-\(.*\)\.t.*/\1/'"
source=(http://www.kyz.uklinux.net/downloads/$pkgname-$pkgver.tar.gz)
sha1sums=('359c8f4ec9c62d9dac5d572269b607b2cae4fbf7')

# optimalization ok 
# vim: ft=sh
@end verbatim

Voici une description de chaque ligne:

# Last Modified: Sun, 21 Mar 2004 16:54:50 +0100

Si vous modifier un script FrugalBuild, vous devriez mettre à jour ce champ.
 La date doit être en anglais. Cela peut être réalisé en définissant les 
variables d'environnement LC_ALL et LANG. Par exemple j'utilise LC_ALL=hu_HU,
 j'ai donc fait un simple alias et l'ai ajouté à mon /.bash_login:

alias edate="LANG= LC_ALL= date -R"

La mise à jour de ce champ sera fait automatiquement si la construction est 
réussie.

# Compiling Time: 0.01 SBU

Vous devriez inscrire ici le temps qu'à prit la génération. 
Evidement, cela dépend de votre matériel, aussi nous utilisons des SBUs au lieu 
des minutes comme unité.

SBU signifie Static Binutils Unit, ce qui est le temps que repoman merge 
binutils prend sur votre machine. Par défaut makepkg va afficher combien de 
secondes la construction à prise. Après avoir construit binutils, vous devriez 
mettre à jour votre /etc/makepkg.conf:

SBU="257"

La ligne ci dessus indique que la compilation de binutils sur votre machine 
a pris 257 seconds. A partir de là, makepkg va afficher des SBUs au lieu de 
seconds après des constructions de paquets réussies, et cette valeur SBU sera la
 même sur n'importe quelle machine.

@samp{# Maintainer: VMiklos <vmiklos@@frugalware.org>}

Si vous êtes le mainteneur du paquet, inscrivez votre nom ou pseudo et votre 
adresse e-mail ici. Si vous n'allez probablement pas maintenir le paquet, 
inscrivez Contributor au lieu de Maintainer, ensuite, le mainteneur 
ajoutera sa ligne ultérieurement.

pkgname=cabextract

Ce sera le nom du paquet. On peut inscrire des chiffres, tirets (-), etc., et 
cela doit être en minuscules.

pkgver=1.0

La version du paquet. Les tirets ne sont pas autorisés, aussi 1.0-6111 sera en 
général converti en  1.0_6111.

pkgrel=1

Le numéro de release spécifique aux changement pour Frugalware. Si vous 
recompilez un paquet, vous devriez augmenter ce numéro. Si vous mettez à jour 
vers une nouvelle version, n'oubliez pas de réinitialiser ce chiffre à 1. 
Si vous créez un nouveau paquet, affectez cette valeur à 1.

pkgdesc="a program to extract Microsoft Cabinet files"

Une courte description du paquet. Généralement issue du site ou de la 
documentation du programme.

url="http://www.kyz.uklinux.net/cabextract.php"

Le site web du projet.

depends=('glibc')

La liste de dépendance du paquet, définie dans un tableau bash. 
Habituellement vous devriez compiler un paquet au moins 2 fois: une avec  
depends=(), puis executer chkdep -p foo.fpm qui suggerera les dépendances, mais 
prenez cette information avec des pincettes! 
Lire les fichier README, INSTALL et configure.ac est également une bonne idée 
pour déterminer les dépendances.

groups=('apps')

Il est nécessaire de savoir à catégorie le paquet est rattaché. 
La chose la plus importante: ne placez pas votre paquet dans apps, base, devel, 
lib, multimedia or network, s'il dépend de X (ou d'un paquet dépendant de X, 
évidement). Les paquets dans le dépôt extra reçoivent le suffixe '-extra' 
dans le nom du groupe.

archs=('i686')

Ce tableau défini pour quelles architectures le paquet est disponible. 
Si ce n'est pas disponible, cela implique que gensync va l'omettre pendant la 
génération de la base de données des paquets. Si vous n'êtes pas à même de 
fournir un paquet pour une architecture donnée, ne l'incluez pas dans archs()! 
Par exemple, peut importe si le paquet peut être compilé pour x86_64, si vous ne
l'avez pas compilé vous même, ne l'incluez pas.

up2date="elinks -dump http://www.kyz.uklinux.net/cabextract.php |grep 'cabextract source code'|sed 's/.*t-\(.*\)\.t.*/\1/'"

Une courte commande qui va nous donner la dernière version stable du programme.
Cela aide les mainteneur à tenir l'arborescence (FST) à jour. Habituellement 
cette chaîne est composée de trois parties: un elinks -dump uneurlquelconque, 
un grep foo, et une commande sed. Nous utilisons si possible le protocole http, 
mais parfois nous devons utiliser ftp. Dans ce cas, au lieu de 
@samp{elinks -dump }vous devriez utiliser @samp{wget -O - -q}. Evidement vous 
pouvez utiliser wget tout le temps, mais elinks est plus simple. La commande sed
 peut être remplacée par la combinaison de tr et cut si vous préferez. 
L'exemple précédent donnerait avec tr et cut:

up2date="elinks -dump http://www.kyz.uklinux.net/cabextract.php |grep 'cabextractsource code'|tr -s ' '|cut -d ' ' -f 6"

source=(http://www.kyz.uklinux.net/downloads/$pkgname-$pkgver.tar.gz)

Vous définissez ici les sources du paquet dans un simple tableau. 
Vous pouvez utilisez de noms de fichiers pour des correctifs, ou fichiers 
supplémentaires quand vous les placez dans le même répertoire que le script 
FrugalBuild . Vous pouvez utiliser des URL si vous souhaitez que makepkg les 
télécharge automatiquement. C'est important de placer tous les fichiers dans le  
répertoire du script FrugalBuild y inclus les fichiers sources que vous pouvez 
télécharger depuis le site.
 Par ailleurs lors d'un téléchargement sur sourceforge, veuillez utiliser 
download.sourceforge.net, et aucun autre miroir (tel que heanet.dl.sf.net)! 
Si vous utilisez des correctifs variables/aléatoires, ne vous attendez pas à ce 
que quelqu'un d'autre les mette à jour pour une version suivante. Vous aurez à 
faire le boulot vous même. Vous aurez été prévenu! 

sha1sums=('8fde8ad86f7144943b7e4e5a2da7eddb')

Un autre tableau bash pour éviter de compiler depuis de mauvaises sources. 
Évidement c'est sans intérêt si vous lancez simplement sha1sum foo.tar.gz après 
le téléchargement. Essayez de trouvez les sommes sha1 sur le site du projet si 
possible. C'est également une bonne idée de laisser un commentaire sur cette 
ligne pour indiquer où on peut trouver cette somme.

Finalement on défini une fonction build() qui va construire le paquet. Si vous 
ne voulez rien faire de particulier, vous n'aurez probablement rien à spécifier,
 la fonction build() par défaut devrait répondre à vos attentes. Pour la liste 
des fonctions spéciales qui peuvent être utilisées dans build(), référez vous à
 /usr/lib/frugalware/fwmakepkg.

Si vous n'avez pas ce fichier, vous devrez installer le paquet pacman-tools.

# optimalization ok

Cette ligne sera ajoutée automatiquement à la fin du script FrugalBuild si la 
fonction build() à utilisé vos $CFLAGS où $CXXFLAGS. C'est pratique si vous 
voulez cross-compiler sur une machine plus rapide pour une architecture plus 
lente. Tant que le paquet n'utilise pas les $CFLAGS nous ne pouvons le 
cross-compiler, aussi, essayer tant que possible de ne pas créer de paquets 
non-optimisés. Si le paquet ne contient pas de fichiers dépendant de 
l'architecture vous pouvez ajouter cette ligne manuellement car makepkg ne le 
détectera pas.

# vim: ft=sh

A la fin du script, vous pouvez ajouter des informations spécifique à l'éditeur,
 par exemple, celle ci indiquera à vim que ce script est un shell bash 
(autrement il ne peut le détecter car il n'y a pas de #!/bin/bash au début du 
fichier).

@subsection Références completes

Voici une liste complète des directives disponibles.

Tout d'abord les directives d'installation. Vous pouvez vous référer à un script
 d'installation (généralement $pkgname.install) pour l'utilisation. S'il y'a un 
fichier $pkgname.install dans le répertoire FrugalBuild, il sera automatiquement
 utilisé. dans le fichier d'installation, vous pouvez définir des actions à 
exécuter avant/après installation/mise à jour/suppression du paquet. Voici un 
exemple, dans le but de tout clarifier à ce sujet:

@verbatim
# $1:  la nouvelle version du paquet
pre_install()
{
        /bin/true
}

# $1:  la nouvelle version du paquet
post_install()
{
        /bin/true
}

# $1:  la nouvelle version du paquet
# $2:  l'ancienne version du paquet
pre_upgrade()
{
        /bin/true
}

# $1:  la nouvelle version du paquet
# $2:  l'ancienne version du paquet
post_upgrade()
{
        /bin/true
}

# $1:  l'ancienne version du paquet
pre_remove()
{
        /bin/true
}

# $1:  l'ancienne version du paquet
post_remove()
{
        /bin/true
}

op=$1
shift

$op $*

# vim: ft=sh
@end verbatim

Evidement, vous n'aurez probablement pas besoin de toutes ces fonctions, 
effacez simplement celles dont vous n'avez pas besoin. Si vous souhaitez faire 
exactement la même chose après mise à jour qu'après installation, il est 
possible d'utiliser post_install $1 dans la fonction post_upgrade().

Sauvez ce fichier en tant que $pkgname.install, comme cela makepkg l'utilisera 
automatiquement.
 Vous pouvez spécifier ce script dans le tableau des sources, mais ce n'est pas 
indispensable.

Les directives pkgname, pkgver, pkgrel, url, source et md5sums ont été 
abordées dans la section précédents.

Le tableau de backup est utile pour préserver certains fichiers tels que les 
fichiers de config. Si possible nous ne modifions pas les fichiers de config 
durant une mise à jour. Exemple:

backup=('etc/pacman.conf')

Notez qu'il n'y a pas de slash à la fin!

Pour plus d'informations à ce sujet, voir la section préservation des fichiers 
de config dans a documentation (man) de pacman.

Le tableau de dépendance n'a pas encore été abordé, si ce n'est que j'ai 
précédemment évoqué la possibilité pour les éléments d'inclure des informations 
de version, par exemple:

pkgname=kdewebdev
depends=('kdelibs=3.3.0')

Vous pour utiliser ici <>, <=, >= ou = comme opérateurs.

Le tableau makedepends défini les dépendance d'un paquet uniquement lors de la 
construction. Par exemple si les sources sont au format SRPM, alien est 
probablement nécessaire pour la construction.

Le tableau rodepends défini les paquets nécessaire uniquement lors de 
l'exécution. Cela peut utilisé dans tous les cas où inclure un paquet dans 
depends() causerait une dépendance circulaire.

Dans le tableau conflicts, vous pouvez définir une liste de paquets qui ne 
devraient pas être installés si vous voulez installer ce paquet. Voyons un 
autre exemple:

pkgname=blackbox
conflicts=('fluxbox')

C'est nécessaire car chacun d'eux inclue une commande bsetbg et les deux 
exécutables sont différents. Dans ce cas, le paquet fluxbox doit également 
contenir cette ligne: (conflicts=('blackbox')). Évidement, si deux paquets ou 
plus entrent en conflits les uns avec les autres, un seul peut être placé dans 
le dépôt frugalware.

Le tableau provides est utilisé pour fournir des dépendances virtuelles. Cela 
implique que postfix et sendmail fournissent mta ou, un meilleur exemple, xfree 
et xorg fournissent x. Ainsi qt contiendra la ligne suivante:

pkgname=qt
depends=('x' 'libpng' 'libjpeg')

L'utilisateur à alors le choix entre xorg et xfree.

La dernière directive dans la liste est replaces. Le paquet module-init-tools
 est un bon exemple:

pkgname=module-init-tools
replaces=('modutils')
conflicts=('modutils')

Comme vous pouvez le voir, nous créons souvent de nouveaux paquets qui entrent 
en conflit avec d'autres. En utilisant la directive replaces quand l'utilisateur 
lancera pacman -Su la prochaine fois, si modutils est installé (probablement:)), 
il lui sera demandé de retirer modutils et installer module-init-tools.

@subsection Compiler le paquet

C'est particulièrement simple. Dans le répertoire du paquet, vous devez faire 
exactement la même chose que décrite dans la section Recompiler des paquets. 
Si vous souhaitez soumettre ce paquet au projet Frugalware, alors rendez vous 
sur http://bugs.frugalware.org, ouvrez une demande fonctionnalité 
(feature request) et envoyer chaque fichier non téléchargeable (ie. FrugalBuild,
 scripts d'installation, patches) comme attachements.

Joyeux packaging!

@subsection Modules Kernel

Quelques mots au sujet des modules kernel. Ils sont spéciaux car même si vous 
avez installé la bonne version du paquet kernel (et kernel-source), les modules 
sont compilés pour le kernel en cours d'utilisation. Vous aurez donc à vérifier 
si le kernel correspond à celui en cours d'utilisation. A cause de cela, il y'a 
quelques règles supplémentaires pour les contenant un module kernel:

1) Doit inclure une règle depends du type kernel=version, ou version est la 
version du kernel défini dans /source/include/kernel-module.sh.

2) Il faut "Finclude" (directive) la préparation du module kernel.

3) Si vous souhaitez utiliser un script d'installation personnalisé (autrement 
dit si lancer depmod -a après l'installation/mise à jour ne vous suffit pas) 
alors le script d'install doit lancer depmod -a. Autrement le fichier de 
préparation doit inclure un script qui le fera.

4) build() doit appeller Fcheckkernel() pour s'assurer que le module sera 
compilé pour la bonne version du module.

@subsection Repoman

Repoman est un simple outil qui télécharge les scripts de construction des 
paquets et compile les programmes depuis les sources.

Les commandes repoman les plus utilisées sont les suivantes:

repoman merge package

ou simplement

repoman m package

construit un paquet depuis les sources et l'installe. Vous pouvez configurer 
les options de construction dans les directives makepkg_opts de
 /etc/repoman.conf.

Par défaut repoman installera les dépendances manquantes avec pacman, nettoiera 
les fichiers temporaires, installera le paquet, et écrira le paquet résultant 
dans le répertoire courrant.

repoman update

ou simplement

repoman upd 

met à jour l'arborescence des sources (FST) dans /var/fst. La première fois 
repoman va les télécharger (cela peut prendre du temps!).

@section Questions et réponses
@subsection Quelle est la méthode pour envoyer la mise à jour d'un paquet si je n'a pas la possibilité de le faire par darc?

@enumerate
@item Mettre à jour le script FrugalBuild.
@item Optionnel: mettre à jour les patchs/docs/etc.
@item Compiler le paquet.
@item Envoyer le nouveau .fpm dans incoming.
@item "darcs rec" et "darcs send" pour le correctif. (N'oubliez pas de définir votre identité darc!) 
@end enumerate

@subsection makepkg se termine avec <packagename>: /usr/info/dir: existe dans le système de fichiers

Au lieu de 

make DESTDIR=$startdir/pkg install

vous devriez écrire

Fmakeinstall

dans votre script FrugalBuild.
@subsection Dois mettre à jour "pkgrel" ou non?

Si le paquet doit être mis à jour par les utilisateurs, vous devrier l'incrémenter,
 sinon, non. Il n'y a pas besoin d'increment "pkgrel" si vous:

@itemize
@item avez uniquement corrigé la ligne up2date. 
@end itemize

Mais pkgrel doit être mis à jour si vous

@itemize
@item avez changé les dépendances. 
@end itemize

Si vous incrémentez pkgrel vous êtes supposé recompiler le paquet.
@subsection Je ne peux exécuter pacman -Su <package>, il me dit que la version locale est plus récente,
 mais je sais que ce n'est pas le cas!

C'est un bug dans le système de versionning du paquet, le mainteneur devrait être
 gêné par cela. Comme pacman vérifies les numéros de version (installé en fonction
 des versions des dépôts), la version du nouveau paquet devrait être plus important que 
l'ancien pour mettre à jour sans soucis. (Au moment de l'écriture par exemple phpmyadmin est affecté: 
la version locale est 2.6.3-1, la version du dépôt est 2.6.3_pl1-1, ce qui est plus 
récent, mais considéré comme inférieur par pacman.)

@subsection Qu'est-ce que 5.55 SBU signifie?

Cela à prit 5.55 fois plus longtemps pour compiler le paquet par le mainteneur
 que binutils. Ainsi si vous souhaitez savoir combien de temps cela prend pour 
compiler un paquet avec 5.55 SBU, cous devriez commencer par compiler binutils 
(makepkg vous aide, en inscrivant le nombre de secondes écoulées). Vous devrez 
ensuite multiplier ce chiffre par 5.55 pour connaître le nombre de secondes 
nécessaires à la compilation du paquet.

@subsection Pourquoi les mainteneurs râlent ils a propos du tarbal de mon nouveau paquet?

Jetons un coup d'oeil à la liste de fichiers du tarball d'eaccelerator:

$ tar -tf eaccelerator-0.9.3-1.tar.bz2
eaccelerator/
eaccelerator/eaccelerator-0.9.3.zip
eaccelerator/FrugalBuild
eaccelerator/README.Frugalware
eaccelerator/eaccelerator-0.9.3-1-i686.fpm
$

Vous devez nommer le tarball comme cela 
<pkgname>-<pkgver>-<pkgrel>.tar.bz2 (ou gz), et il devrait uniquement contenir un
répertoire <pkgname> à la racine, avec tous les fichiers nécessaires à la création 
du fpm à l'intérieur. C'est la façon la plus simple pour les mainteurs de gérer votre
tarball lors de l'ajout de votre paquet aux dépots.

@subsection Que devrais je inclure dans depends() et makedepends() 
et que ne devrais je pas y mettre? FIXME

Vous ne driez pas inclure de règles triviales pour makedepends, vous devriez seulement 
inclure ce que chkdep -p recommande. Règles triviale pour makedepends:

@itemize
@item auto*
@item make
@item gcc
@item kernel-headers
@item libtool
@item glibc 
@end itemize

N'oubliez pas: chaque dépendance (depends) est également une dépendance de construction (makedepends)!

@subsection A quoi correspondent les différents tableaux de dépendances?

@itemize 
@item  @samp{depends} Doit contenir tous les paquets dont celui-ci dépend, 
pour la construction aisin que pour le fonctionnement.
@item  @samp{makedepends} correspond au paquets nécessaires à la construction de celui-ci.
@item  @samp{rodepends} sert aux dépendances uniquement liées a l'éxecution; 
par exemple un paquet de "liste de mots" (sans exécutable) nécessite un paquet qui puisse 
les traiter comme un "annuaire".
@item  @samp{provides} c'est un nom alternatif pour le paquet. L'utilisation principale 
répond aux paquet effectuant la même tâche; eg. hunspell-en et hunspell-de fournissent 
tous deux hunspell-dict, et hunspell dépend hunspell-dict au lieu d'un langage spécifique. 
(Parfois ces paquets sont en conflit, comme postfix qui fournit _et_ entre en conflit avec mta,
 ainsi qu'exim - de cette facon, il ne peut y'avoir qu'un seul mta installé à la fois, sans 
besoin de connaître le nom des autres MTA.) 
@end itemize

Soyez prudent avec les dépendances cyclique: pacman peut les gérer, mais pas makepkg.

@subsection Comment puis-je faire marcher PHP avec mon nouveau paquet eaccelerator/n'importe quelle extension?

Comme un paquet A ne doit pas interférer avec les fichiers de config d'un paquet B, 
vous devriez écrire un fichier README.Frugalware, décrivant comment activer/utiliser 
l'extension, incluez le dans source() et utilisez Fdoc README.Frugalware.

@subsection Comment puis-je cross-compiler (paquet) un programme dépendant de l'architecture (non-binaire)?

Vous devriez modifier carch et chost dans /etc/makepkg.conf et 
construire le paquet à nouveau.

@subsection Devrais je reconstruire un paquet (non-binaire) après avoir retiré une entrée de archs()?

Non.

@subsection Quel est le moyen le plus simple/rapide/pratique de mettre à jour un paquet?

@itemize
@item makepkg -d vous indique le nouveau numéro de version à indiquer dans FrugalBuild
@item makepkg -d à nouveau (cela devrait échouer sur la vérification des sommes)
@item makepkg -dg >>FrugalBuild génère les bonnes sommes dans FB (vous devriez vérifier à nouveau)
@item sudo makepkg -R génère le fpm en chroot 
@end itemize

@subsection repoman upd ne peut créer /var/fst/ car il existe déja

Su root et

cd /var/fst && mv * frugalware-current

@subsection Comment puis-je accéder au serveur central de FrugalWare (les miroirs sont trop lent pour moi)?

darcs get --partial http://darcs.frugalware.org/repos/frugalware-current

Cela crée un dépôt local pour vous, qui est une copie du dépôt central. Pour le mettre à jour, exécuter 

darcs pull

à l'intérieur. C'est tout pour avoir une copie en lecture seule; si vous voulez utiliser darcs pour 
envoyer des correctifs (darcs send), alors vous devriez lire les docs de Darcs pour configurer votre nom
 (@uref{http://darcs.net/manual/node5.html#author_prefs},
 email (@uref{http://darcs.net/manual/node5.html#SECTION00510060000000000000}),
 etc.

@subsection Que devrais-je écrire comme nom de patch et commentaires sur darcs rec?

Le nom du patch devrait être le même que celui du  fpm (mais sans .fpm, évidement);
 et le commentaire long doit uniquement contenir ce que vous avez fait pour créer ce
 patch (eg. "added i686 to archs()" ou quelque chose du genre).

@subsection Je voudrais voir mes accents dans l'affichage de darcs!

echo "export DARCS_DONT_ESCAPE_ISPRINT=1" >>~/.bash_profile

et cela définira vos locales correctement.

@subsection Où devrais je placer mes commentaires sur un paquet?

Vous voulez dire README.Frugalware. Il doit être dans le tableau source() et à 
la fin de build() vous devez utiliser:

Fdoc README.Frugalware

@subsection Je souhaites travailler avec la dernière version de pacman&co, comment faire?

@verbatim
darcs get --partial http://darcs.frugalware.org/repos/pacman-tools
cd pacman-tools
make dist
@end verbatim

Vous aurez un tout nouveau .tar.gz. Indiquez le dans le FrugalBuild de pacman-tools, 
corrigez la somme, créer le nouveau paquet pacman-tools (makepkg -fuck helps [note de trad: non, même pas moi, mais ça détend de lire ça à la fin d'un long fichier])
 et installer le. C'est tout (et si vous ne comprenez pas, lisez à nouveau, 
et si ce n'est toujours pas clair, alors attendez la prochaine mise à jour standard de pacman pacman-tools
car vous n'en avez pas vraiment besoin)...


@subsection Quel est la manière de gérer les locales pour un nouveau paquet? Comment devrais-je les nommer?

Jettez un coup d'oeil à hunspell (>=1.0.8, en attente d'envoi au moment de l'écriture).
 Il y'a un paquet hunspell, qui dépend de hunspell-dict. Il n'y a pas de
de paquet nommé hunspell-dict, mais il est fourni par les paquets localisés locale.
 Les plus importants sont -en (==en_US), -hu (==hu_HU), -de (==de_DE),
 -fr (==fr_FR), -it (==it_IT), -es (==es_ES) and -sk (==sk_SK). 
les autres: -en_US, -de_CH, -es_MX.

Les paquets -xx les installateurs autre que CD (ie. netinst, DVD).

@section Notes rapides pour developpeurs
@itemize
@item Si vou n'utilisez pas de macros F* macros dans votre build(),
 alors vous aurez besoin d'un || return 1.
@item Les librairies (.sos) doivent être exécutables.
@item Nettoyer les binaires n'est pas nécessaire car c'est fait automatiquement par makepkg.
@item Si un script $pkgname.install existe, il est utilisé automatiquement,
 pas besoin de le spécifier dans FrugalBuild ni dans l'install ni comme source.
@item Si vous utilisez scrollkeeper-update ou update-desktop-database ou similaire,
 alors vous devez les inclures (scrollkeeper, desktop-file-utils etc.)
 dans les dépendances.
@item Au lieu de Fmake; Fmakeinstall vous pouvez utiliser Fbuild
 (qui est == Fpatchall && Fmake && Fmakeinstall).
@item Si vous utilisez une commande F*, $Fdestdir ou $Fsrcdir ne sont pas nécessaires. En général. ;)
@item license="GPL2" n'est plus requis, mais c'est une habitude de BMH.
@item Vous pouvez utiliser makepkg -g au lieu de makepkg -G pour obtenir
 sha1sums() au lieu de md5sums().
@item Si un programme dépend d'un toolkit graphique,
 alors il doit avoir un groupe x*.
@item Un paquet ne peut avoir qu'un contributeur: la première personne
 qui a écrit le script FrugalBuild associé.
@item Si le groupe d'un paquet change, vous n'avez pas besoin de le reconstruire,
 repoman cl suffit.
@item Pour désactiver ccache, ajoutez un switch -B switch à makepkg. En même temps,
 lisez man makepkg. ;)
@item Le nom d'un paquet ne peut contenir que [A-Za-z0-9+_-], pkgrel et
 pkgver: [A-Za-z0-9+_].
@item La référence complète de uid/gid ne fait actuellement pas partie de la doc, mais peut être trouvée
 à (http://darcs.frugalware.org/darcsweb/darcsweb.cgi?r=frugalware-current;a=headblob;f=/docs/ids.txt) 
@end itemize

@section Choses à faire (TODO)

Vous pouvez voir les choses en attente (TODO) sur le
BTS [Bug Tracking System] (@uref{http://bugs.frugalware.org}) ou la section TODO du wiki.

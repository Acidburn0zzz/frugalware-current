This is the first (and most important) loader speed hack: instead of walking
the entire directory tree, stat()ing every file, and running a regex on it,
we just stat the directoires themselves, and attempt to open the files.

The directory search order has also been arranged to be more optimal.

Appending linux/ to every directory name should probably go, but causes
mysterious segfaults deep in hardware access, with a smashed stack. Tricky.

Also, ignore requests to load speedo and GLcore, which shouldn't be loaded in
any case.

Author: Daniel Stone <daniel.stone@ubuntu.com>

diff -urN xc/programs/Xserver/hw/xfree86.orig/common/xf86Config.c xc/programs/Xserver/hw/xfree86/common/xf86Config.c
--- xc/programs/Xserver/hw/xfree86.orig/common/xf86Config.c	2005-02-03 09:26:09.738057304 +1100
+++ xc/programs/Xserver/hw/xfree86/common/xf86Config.c	2005-02-03 09:30:06.446072216 +1100
@@ -248,6 +248,9 @@
     char **modulearray;
     pointer *optarray;
     XF86LoadPtr modp;
+    /* we pretend these modules don't exist */
+    char *ignore[] = { "GLcore", "speedo" };
+    int i = 0, doignore = 0;
     
     /*
      * make sure the config file has been parsed and that we have a
@@ -282,6 +285,17 @@
     if (xf86configptr->conf_modules) {
 	modp = xf86configptr->conf_modules->mod_load_lst;
 	while (modp) {
+	    for (i = 0, doignore = 0; i < 2; i++) {
+                if (strcmp(modp->load_name, ignore[i]) == 0) {
+                    xf86Msg(X_WARNING, "Ignoring request to load module %s\n",
+                            modp->load_name);
+		    doignore = 1;
+		}
+            }
+	    if (doignore) {
+                modp = (XF86LoadPtr) modp->list.next;
+                continue;
+           }
 	    modulearray[count] = modp->load_name;
 	    optarray[count] = modp->load_opt;
 	    count++;
--- xc/programs/Xserver/hw/xfree86.orig/drivers/cirrus/Imakefile	2005-02-03 09:26:10.458947712 +1100
+++ xc/programs/Xserver/hw/xfree86/drivers/cirrus/Imakefile	2005-02-03 09:26:15.968110192 +1100
@@ -79,13 +79,13 @@
 
 InstallObjectModule(cirrus,$(MODULEDIR),drivers)
 
-SubDriverObjectModuleTarget(cirrus_alpine,$(AOBJS))
+ObjectModuleTarget(cirrus_alpine,$(AOBJS))
 
-InstallSubDriverObjectModule(cirrus_alpine,$(MODULEDIR),drivers)
+InstallObjectModule(cirrus_alpine,$(MODULEDIR),drivers)
 
-SubDriverObjectModuleTarget(cirrus_laguna,$(LOBJS))
+ObjectModuleTarget(cirrus_laguna,$(LOBJS))
 
-InstallSubDriverObjectModule(cirrus_laguna,$(MODULEDIR),drivers)
+InstallObjectModule(cirrus_laguna,$(MODULEDIR),drivers)
 
 #if !defined(XF86DriverSDK)
 InstallModuleManPage(cirrus)
@@ -113,5 +113,5 @@
 InstallDriverSDKNonExecFile(lg_xaa.h,$(DRIVERSDKDIR)/drivers/cirrus)
 
 InstallDriverSDKObjectModule(cirrus,$(DRIVERSDKMODULEDIR),drivers)
-InstallDriverSDKObjectSubModule(cirrus_alpine,$(DRIVERSDKMODULEDIR),drivers)
-InstallDriverSDKObjectSubModule(cirrus_laguna,$(DRIVERSDKMODULEDIR),drivers)
+InstallDriverSDKObjectModule(cirrus_alpine,$(DRIVERSDKMODULEDIR),drivers)
+InstallDriverSDKObjectModule(cirrus_laguna,$(DRIVERSDKMODULEDIR),drivers)
--- xc/programs/Xserver/hw/xfree86.orig/drivers/nv/Imakefile	2005-02-03 09:26:10.835890408 +1100
+++ xc/programs/Xserver/hw/xfree86/drivers/nv/Imakefile	2005-02-03 09:26:15.968110192 +1100
@@ -79,8 +79,8 @@
 
 InstallObjectModule(nv,$(MODULEDIR),drivers)
 
-SubDriverObjectModuleTarget(riva128,$(R_OBJS))
-InstallSubDriverObjectModule(riva128,$(MODULEDIR),drivers)
+ObjectModuleTarget(riva128,$(R_OBJS))
+InstallObjectModule(riva128,$(MODULEDIR),drivers)
 
 
 #if !defined(XF86DriverSDK)
@@ -122,5 +122,5 @@
 InstallDriverSDKNonExecFile(nv_hw.c,$(DRIVERSDKDIR)/drivers/nv)
 
 InstallDriverSDKObjectModule(nv,$(DRIVERSDKMODULEDIR),drivers)
-InstallDriverSDKObjectSubModule(riva128,$(DRIVERSDKMODULEDIR),drivers)
+InstallDriverSDKObjectModule(riva128,$(DRIVERSDKMODULEDIR),drivers)
 
--- xc/programs/Xserver/hw/xfree86.orig/loader/loadmod.c	2005-02-03 09:26:11.962719104 +1100
+++ xc/programs/Xserver/hw/xfree86/loader/loadmod.c	2005-02-03 09:26:16.014103200 +1100
@@ -204,89 +204,16 @@
 
 /* Standard set of module subdirectories to search, in order of preference */
 static const char *stdSubdirs[] = {
-    "drivers/",
+    "",
+    "fonts/",
     "input/",
+    "drivers/",
     "multimedia/",
     "extensions/",
-    "fonts/",
     "internal/",
-    "",
     NULL
 };
 
-/*
- * Standard set of module name patterns to check, in order of preference
- * These are regular expressions (suitable for use with POSIX regex(3)).
- */
-static PatternRec stdPatterns[] = {
-    {"^lib(.*)\\.so$",},
-    {"^lib(.*)\\.a$",},
-    {"(.*)_drv\\.so$",},
-    {"(.*)_drv\\.o$",},
-    {"(.*)\\.so$",},
-    {"(.*)\\.a$",},
-    {"(.*)\\.o$",},
-    {NULL,}
-};
-
-static PatternPtr
-InitPatterns(const char **patternlist)
-{
-    char errmsg[80];
-    int i, e;
-    PatternPtr patterns = NULL;
-    PatternPtr p = NULL;
-    static int firstTime = 1;
-    const char **s;
-
-    if (firstTime) {
-	/* precompile stdPatterns */
-	firstTime = 0;
-	for (p = stdPatterns; p->pattern; p++)
-	    if ((e = regcomp(&p->rex, p->pattern, REG_EXTENDED)) != 0) {
-		regerror(e, &p->rex, errmsg, sizeof(errmsg));
-		FatalError("InitPatterns: regcomp error for `%s': %s\n",
-			   p->pattern, errmsg);
-	    }
-    }
-
-    if (patternlist) {
-	for (i = 0, s = patternlist; *s; i++, s++)
-	    if (*s == DEFAULT_LIST)
-		i += sizeof(stdPatterns) / sizeof(stdPatterns[0]) - 1 - 1;
-	patterns = xalloc((i + 1) * sizeof(PatternRec));
-	if (!patterns) {
-	    return NULL;
-	}
-	for (i = 0, s = patternlist; *s; i++, s++)
-	    if (*s != DEFAULT_LIST) {
-		p = patterns + i;
-		p->pattern = *s;
-		if ((e = regcomp(&p->rex, p->pattern, REG_EXTENDED)) != 0) {
-		    regerror(e, &p->rex, errmsg, sizeof(errmsg));
-		    ErrorF("InitPatterns: regcomp error for `%s': %s\n",
-			   p->pattern, errmsg);
-		    i--;
-		}
-	    } else {
-		for (p = stdPatterns; p->pattern; p++, i++)
-		    patterns[i] = *p;
-		if (p != stdPatterns)
-		    i--;
-	    }
-	patterns[i].pattern = NULL;
-    } else
-	patterns = stdPatterns;
-    return patterns;
-}
-
-static void
-FreePatterns(PatternPtr patterns)
-{
-    if (patterns && patterns != stdPatterns)
-	xfree(patterns);
-}
-
 static const char **
 InitSubdirs(const char **subdirlist)
 {
@@ -396,20 +323,24 @@
 
 static char *
 FindModule(const char *module, const char *dir, const char **subdirlist,
-	   PatternPtr patterns)
+	   PatternPtr unused)
 {
-    char buf[PATH_MAX + 1];
+    char buf[PATH_MAX + 1], tmpBuf[PATH_MAX + 1];
     char *dirpath = NULL;
     char *name = NULL;
     struct stat stat_buf;
     int len, dirlen;
-    char *fp;
     DIR *d;
     const char **subdirs = NULL;
-    PatternPtr p = NULL;
     const char **s;
     struct dirent *dp;
-    regmatch_t match[2];
+    int i = 0;
+
+#ifdef DLOPEN_HACK
+    char *suffix[] = { "so", "a", "o" };
+#else
+    char *suffix[] = { "a", "o", "so" };
+#endif
 
     subdirs = InitSubdirs(subdirlist);
     if (!subdirs)
@@ -431,39 +362,23 @@
 	strcpy(buf, dirpath);
 	strcat(buf, *s);
 	/*xf86Msg(X_INFO,"OS2DIAG: FindModule: buf=%s\n",buf); */
-	fp = buf + dirlen;
-	if (stat(buf, &stat_buf) == 0 && S_ISDIR(stat_buf.st_mode) &&
-	    (d = opendir(buf))) {
-	    if (buf[dirlen - 1] != '/') {
-		buf[dirlen++] = '/';
-		fp++;
-	    }
-	    while ((dp = readdir(d))) {
-		if (dirlen + strlen(dp->d_name) + 1 > PATH_MAX)
-		    continue;
-		strcpy(fp, dp->d_name);
-		if (!(stat(buf, &stat_buf) == 0 && S_ISREG(stat_buf.st_mode)))
-		    continue;
-		for (p = patterns; p->pattern; p++) {
-		    if (regexec(&p->rex, dp->d_name, 2, match, 0) == 0 &&
-			match[1].rm_so != -1) {
-			len = match[1].rm_eo - match[1].rm_so;
-			if (len == strlen(module) &&
-			    strncmp(module, dp->d_name + match[1].rm_so,
-				    len) == 0) {
-			    /*xf86Msg(X_INFO,"OS2DIAG: matching %s\n",buf); */
-			    name = buf;
-			    break;
-			}
-		    }
-		}
-		if (name)
-		    break;
-	    }
-	    closedir(d);
-	    if (name)
-		break;
-	}
+        if ((stat(buf, &stat_buf) == 0) && S_ISDIR(stat_buf.st_mode)) {
+            if (buf[dirlen - 1] != '/') {
+                buf[dirlen++] = '/';
+            }
+	    for (i = 0; i < 3 && !name; i++) {
+                snprintf(tmpBuf, PATH_MAX, "%slib%s.%s", buf, module,
+                         suffix[i]);
+                if (stat(tmpBuf, &stat_buf) == 0)
+                    name = tmpBuf;
+                else {
+                    snprintf(tmpBuf, PATH_MAX, "%s%s_drv.%s", buf, module,
+                             suffix[i]);
+                    if (stat(tmpBuf, &stat_buf) == 0)
+                        name = tmpBuf;
+                }
+            }
+        }
     }
     FreeSubdirs(subdirs);
     if (dirpath != dir)
@@ -476,18 +391,15 @@
 }
 
 char **
-LoaderListDirs(const char **subdirlist, const char **patternlist)
+LoaderListDirs(const char **subdirlist, const char **unused)
 {
     char buf[PATH_MAX + 1];
     char **pathlist;
     char **elem;
     const char **subdirs;
     const char **s;
-    PatternPtr patterns;
-    PatternPtr p;
     DIR *d;
     struct dirent *dp;
-    regmatch_t match[2];
     struct stat stat_buf;
     int len, dirlen;
     char *fp;
@@ -501,11 +413,6 @@
 	FreePathList(pathlist);
 	return NULL;
     }
-    if (!(patterns = InitPatterns(patternlist))) {
-	FreePathList(pathlist);
-	FreeSubdirs(subdirs);
-	return NULL;
-    }
 
     for (elem = pathlist; *elem; elem++) {
 	for (s = subdirs; *s; s++) {
@@ -513,52 +420,24 @@
 		continue;
 	    strcpy(buf, *elem);
 	    strcat(buf, *s);
-	    fp = buf + dirlen;
-	    if (stat(buf, &stat_buf) == 0 && S_ISDIR(stat_buf.st_mode) &&
-		(d = opendir(buf))) {
+	    if (d = opendir(buf)) {
 		if (buf[dirlen - 1] != '/') {
 		    buf[dirlen++] = '/';
-		    fp++;
 		}
 		while ((dp = readdir(d))) {
 		    if (dirlen + strlen(dp->d_name) > PATH_MAX)
 			continue;
-		    strcpy(fp, dp->d_name);
 		    if (!(stat(buf, &stat_buf) == 0 &&
 			  S_ISREG(stat_buf.st_mode)))
 			continue;
-		    for (p = patterns; p->pattern; p++) {
-			if (regexec(&p->rex, dp->d_name, 2, match, 0) == 0 &&
-			    match[1].rm_so != -1) {
-			    len = match[1].rm_eo - match[1].rm_so;
-			    save = listing;
-			    listing = xrealloc(listing,
-					       (n + 2) * sizeof(char *));
-			    if (!listing) {
-				if (save) {
-				    save[n] = NULL;
-				    FreeStringList(save);
-				}
-				FreePathList(pathlist);
-				FreeSubdirs(subdirs);
-				FreePatterns(patterns);
-				return NULL;
-			    }
-			    listing[n] = xalloc(len + 1);
-			    if (!listing[n]) {
-				FreeStringList(listing);
-				FreePathList(pathlist);
-				FreeSubdirs(subdirs);
-				FreePatterns(patterns);
-				return NULL;
-			    }
-			    strncpy(listing[n], dp->d_name + match[1].rm_so,
-				    len);
-			    listing[n][len] = '\0';
-			    n++;
-			    break;
-			}
-		    }
+                    fp = LoaderGetCanonicalName(buf, NULL);
+                    if (fp && strcmp(buf, fp) != 0) {
+			listing = xrealloc(listing, (n + 2)*sizeof(char *));
+                        listing[n] = xalloc(strlen(fp) + 1);
+			strncpy(listing[n], fp, strlen(fp));
+			listing[n][strlen(fp)] = '\0';
+			n++;
+                    }
 		}
 		closedir(d);
 	    }
@@ -748,7 +627,7 @@
 
 ModuleDescPtr
 LoadSubModule(ModuleDescPtr parent, const char *module,
-	      const char **subdirlist, const char **patternlist,
+	      const char **subdirlist, const char **unused,
 	      pointer options, const XF86ModReqInfo * modreq,
 	      int *errmaj, int *errmin)
 {
@@ -773,7 +652,7 @@
 	return NULL;
     }
 
-    submod = LoadModule(module, NULL, subdirlist, patternlist, options,
+    submod = LoadModule(module, NULL, subdirlist, NULL, options,
 			modreq, errmaj, errmin);
     if (submod) {
 	parent->child = AddSibling(parent->child, submod);
@@ -824,12 +703,7 @@
  * subdirlist   A NULL terminated list of subdirectories to search.  When
  *              NULL, the default "stdSubdirs" list is used.  The default
  *              list is also substituted for entries with value DEFAULT_LIST.
- * patternlist  A NULL terminated list of regular expressions used to find
- *              module filenames.  Each regex should contain exactly one
- *              subexpression that corresponds to the canonical module name.
- *              When NULL, the default "stdPatterns" list is used.  The
- *              default list is also substituted for entries with value
- *              DEFAULT_LIST.
+ * patternlist  This parameter is deprecated, and should always be NULL.
  * options      A NULL terminated list of Options that are passed to the
  *              module's SetupProc function.
  * modreq       An optional XF86ModReqInfo* containing
@@ -854,7 +728,7 @@
 
 ModuleDescPtr
 LoadModule(const char *module, const char *path, const char **subdirlist,
-	   const char **patternlist, pointer options,
+	   const char **unused, pointer options,
 	   const XF86ModReqInfo * modreq, int *errmaj, int *errmin)
 {
     XF86ModuleData *initdata = NULL;
@@ -865,15 +739,14 @@
     char *p = NULL;
     ModuleDescPtr ret = NULL;
     int wasLoaded = 0;
-    PatternPtr patterns = NULL;
     int noncanonical = 0;
     char *m = NULL;
 
     /*xf86Msg(X_INFO,"OS2DIAG: LoadModule: %s\n",module); */
     xf86MsgVerb(X_INFO, 3, "LoadModule: \"%s\"", module);
 
-    patterns = InitPatterns(patternlist);
-    name = LoaderGetCanonicalName(module, patterns);
+    name = LoaderGetCanonicalName(module, NULL);
+
     noncanonical = (name && strcmp(module, name) != 0);
     if (noncanonical) {
 	xf86ErrorFVerb(3, " (%s)\n", name);
@@ -925,7 +798,7 @@
 #endif
     path_elem = pathlist;
     while (!found && *path_elem != NULL) {
-	found = FindModule(m, *path_elem, subdirlist, patterns);
+	found = FindModule(m, *path_elem, subdirlist, NULL);
 	path_elem++;
 	/*
 	 * When the module name isn't the canonical name, search for the
@@ -1035,7 +908,6 @@
 
   LoadModule_exit:
     FreePathList(pathlist);
-    FreePatterns(patterns);
     TestFree(found);
     TestFree(name);
     TestFree(p);
@@ -1266,13 +1138,11 @@
 
 /* Given a module path or file name, return the module's canonical name */
 static char *
-LoaderGetCanonicalName(const char *modname, PatternPtr patterns)
+LoaderGetCanonicalName(const char *modname, PatternPtr unused)
 {
-    char *str;
+    char *str, tmpBuf[102];
     const char *s;
     int len;
-    PatternPtr p;
-    regmatch_t match[2];
 
     /* Strip off any leading path */
     s = strrchr(modname, '/');
@@ -1281,17 +1151,14 @@
     else
 	s++;
 
-    /* Find the first regex that is matched */
-    for (p = patterns; p->pattern; p++)
-	if (regexec(&p->rex, s, 2, match, 0) == 0 && match[1].rm_so != -1) {
-	    len = match[1].rm_eo - match[1].rm_so;
-	    str = xalloc(len + 1);
-	    if (!str)
-		return NULL;
-	    strncpy(str, s + match[1].rm_so, len);
-	    str[len] = '\0';
-	    return str;
-	}
+    if (sscanf(s, "lib%s.a", tmpBuf) == 1)
+        return xstrdup(tmpBuf);
+    if (sscanf(s, "%s_drv.o", tmpBuf) == 1)
+        return xstrdup(tmpBuf);
+    if (sscanf(s, "lib%s.so", tmpBuf) == 1)
+        return xstrdup(tmpBuf);
+    if (sscanf(s, "%s_drv.so", tmpBuf) == 1)
+        return xstrdup(tmpBuf);
 
     /* If there is no match, return the whole name minus the leading path */
     return xstrdup(s);

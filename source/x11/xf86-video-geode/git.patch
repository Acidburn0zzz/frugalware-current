diff --git a/src/geode_msr.c b/src/geode_msr.c
index b7c56d9..8f57939 100644
--- a/src/geode_msr.c
+++ b/src/geode_msr.c
@@ -33,18 +33,36 @@
 #include <fcntl.h>
 #include <sys/types.h>
 #include <errno.h>
+
+#ifdef __OpenBSD__
+#include <sys/ioctl.h>
+#include <machine/amdmsr.h>
+#endif
+
 #include "os.h"
 #include "geode.h"
 
+#ifdef __OpenBSD__
+#define _PATH_MSRDEV	"/dev/amdmsr"
+#define X_PRIVSEP
+#else
+#define _PATH_MSRDEV	"/dev/cpu/0/msr"
+#endif
+
 static int
 _msr_open(void)
 {
     static int msrfd = 0;
 
     if (msrfd == 0) {
-        msrfd = open("/dev/cpu/0/msr", O_RDWR);
+#ifdef X_PRIVSEP
+        msrfd = priv_open_device(_PATH_MSRDEV);
+#else
+        msrfd = open(_PATH_MSRDEV, O_RDWR);
+#endif
         if (msrfd == -1)
-            ErrorF("Unable to open /dev/cpu/0/msr: %d\n", errno);
+            FatalError("Unable to open %s: %s\n", _PATH_MSRDEV,
+                strerror(errno));
     }
 
     return msrfd;
@@ -53,6 +71,19 @@ _msr_open(void)
 int
 GeodeReadMSR(unsigned long addr, unsigned long *lo, unsigned long *hi)
 {
+#ifdef __OpenBSD__
+    struct amdmsr_req req;
+    int fd = _msr_open();
+
+    req.addr = addr;
+
+    if (ioctl(fd, RDMSR, &req) == -1)
+	FatalError("Unable to read MSR at address %0x06x: %s\n", addr,
+	    strerror(errno));
+
+    *hi = req.val >> 32;
+    *lo = req.val & 0xffffffff;
+#else
     unsigned int data[2];
     int fd = _msr_open();
     int ret;
@@ -72,13 +103,24 @@ GeodeReadMSR(unsigned long addr, unsigned long *lo, unsigned long *hi)
 
     *hi = data[1];
     *lo = data[0];
-
+#endif
     return 0;
 }
 
 int
 GeodeWriteMSR(unsigned long addr, unsigned long lo, unsigned long hi)
 {
+#ifdef __OpenBSD__
+    struct amdmsr_req req;
+    int fd = _msr_open();
+
+    req.addr = addr;
+    req.val = (u_int64_t) hi << 32 | (u_int64_t)lo;
+
+    if (ioctl(fd, WRMSR, &req) == -1)
+        FatalError("Unable to write MSR at address 0x%06x: %s\n", addr,
+            strerror(errno));
+#else
     unsigned int data[2];
     int fd = _msr_open();
 
@@ -93,6 +135,6 @@ GeodeWriteMSR(unsigned long addr, unsigned long lo, unsigned long hi)
 
     if (write(fd, (void *) data, 8) != 8)
         return -1;
-
+#endif
     return 0;
 }
diff --git a/src/gx_driver.c b/src/gx_driver.c
index 7f44e19..ab57df1 100644
--- a/src/gx_driver.c
+++ b/src/gx_driver.c
@@ -32,6 +32,9 @@
 #endif
 
 #include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/mman.h>
 
 #include "xf86.h"
 #include "xf86_OSproc.h"
@@ -322,7 +325,6 @@ map_pci_mem(ScrnInfoPtr pScrni, int vram,
             struct pci_device *dev, int bar, int size)
 {
     void *ptr;
-    void **result = (void **) &ptr;
     int map_size = size ? size : dev->regions[bar].size;
 
     int err = pci_device_map_range(dev,
@@ -330,12 +332,18 @@ map_pci_mem(ScrnInfoPtr pScrni, int vram,
                                    map_size,
                                    PCI_DEV_MAP_FLAG_WRITABLE |
                                    (vram ? PCI_DEV_MAP_FLAG_WRITE_COMBINE : 0),
-                                   result);
+                                   &ptr);
 
     if (err)
         return NULL;
     return ptr;
 }
+
+static inline int
+unmap_pci_mem(ScrnInfoPtr pScrni, struct pci_device *dev, void *ptr, int size)
+{
+    return pci_device_unmap_range(dev, ptr, size);
+}
 #endif
 
 extern unsigned long gfx_gx2_scratch_base;
@@ -373,8 +381,19 @@ GXMapMem(ScrnInfoPtr pScrni)
 
     gfx_gx2_scratch_base = pGeode->FBAvail - 0x4000;
 
+#ifndef XSERVER_LIBPCIACCESS
     XpressROMPtr = xf86MapVidMem(index, VIDMEM_FRAMEBUFFER, 0xF0000, 0x10000);
-
+#else
+    {
+        int fd = open("/dev/mem", O_RDWR);
+        if (fd < 0) {
+            xf86DrvMsg(index, X_ERROR, "Failed to open /dev/mem: %m\n");
+            return FALSE;
+        }
+        XpressROMPtr = mmap(NULL, 0x10000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0xF0000);
+        close(fd);
+    }
+#endif
     pGeode->FBBase = gfx_virt_fbptr;
 
     if ((!gfx_virt_regptr) || (!gfx_virt_gpptr) ||
@@ -395,9 +414,9 @@ GXMapMem(ScrnInfoPtr pScrni)
 */
 
 static Bool
-GXCheckVGA(ScrnInfoPtr pScrni)
+GXCheckVGA(ScrnInfoPtr pScrni, EntityInfoPtr pEnt)
 {
-
+#ifndef XSERVER_LIBPCIACCESS
     unsigned char *ptr;
     const char *vgasig = "IBM VGA Compatible";
     int ret;
@@ -413,6 +432,11 @@ GXCheckVGA(ScrnInfoPtr pScrni)
     xf86UnMapVidMem(pScrni->scrnIndex, (pointer) ptr, strlen(vgasig));
 
     return ret ? FALSE : TRUE;
+#else
+    pciVideoPtr pci = xf86GetPciInfoForEntity(pEnt->index);
+
+    return pci_device_is_boot_vga(pci);
+#endif
 }
 
 static Bool
@@ -443,7 +467,7 @@ GXPreInit(ScrnInfoPtr pScrni, int flags)
     if (pGeode == NULL)
         return FALSE;
 
-    useVGA = GXCheckVGA(pScrni);
+    useVGA = GXCheckVGA(pScrni, pEnt);
 
     if (flags & PROBE_DETECT) {
         GeodeProbeDDC(pScrni, pEnt->index);
@@ -591,12 +615,18 @@ GXPreInit(ScrnInfoPtr pScrni, int flags)
     panelgeo = xf86GetOptValString(GeodeOptions, GX_OPTION_PANEL_GEOMETRY);
 
     if ((s = xf86GetOptValString(GeodeOptions, GX_OPTION_ACCEL_METHOD))) {
+#if defined(XF86XAA) && defined(XF86EXA)
         if (!xf86NameCmp(s, "XAA"))
             pGeode->useEXA = FALSE;
         else if (xf86NameCmp(s, "EXA"))
             xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
                        "Unknown accleration method %s.  Defaulting to XAA.\n",
                        s);
+#elif defined(XF86EXA)
+        pGeode->useEXA = TRUE;
+#else
+        pGeode->useEXA = FALSE;
+#endif
     }
 
     xf86DrvMsg(pScrni->scrnIndex, X_INFO,
@@ -752,11 +782,21 @@ GXUnmapMem(ScrnInfoPtr pScrni)
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     /* unmap all the memory map's */
-
+#ifndef XSERVER_LIBPCIACCESS
     xf86UnMapVidMem(pScrni->scrnIndex, gfx_virt_regptr, GX_CPU_REG_SIZE);
     xf86UnMapVidMem(pScrni->scrnIndex, gfx_virt_gpptr, GX_GP_REG_SIZE);
     xf86UnMapVidMem(pScrni->scrnIndex, gfx_virt_vidptr, GX_VID_REG_SIZE);
     xf86UnMapVidMem(pScrni->scrnIndex, gfx_virt_fbptr, pGeode->FBAvail);
+#else
+    pciVideoPtr pci = xf86GetPciInfoForEntity(pGeode->pEnt->index);
+
+    unmap_pci_mem(pScrni, pci, gfx_virt_regptr, GX_CPU_REG_SIZE);
+    unmap_pci_mem(pScrni, pci, gfx_virt_gpptr, GX_GP_REG_SIZE);
+    unmap_pci_mem(pScrni, pci, gfx_virt_vidptr, GX_VID_REG_SIZE);
+    unmap_pci_mem(pScrni, pci, gfx_virt_fbptr, pGeode->FBAvail);
+
+    munmap(XpressROMPtr, 0x10000);
+#endif
     return TRUE;
 }
 
diff --git a/src/lx_driver.c b/src/lx_driver.c
index 146578e..c68f715 100644
--- a/src/lx_driver.c
+++ b/src/lx_driver.c
@@ -33,6 +33,9 @@
 
 #include <stdio.h>
 #include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/mman.h>
 
 #include "xf86.h"
 #include "xf86_OSproc.h"
@@ -155,7 +158,6 @@ map_pci_mem(ScrnInfoPtr pScrni, int vram,
             struct pci_device *dev, int bar, int size)
 {
     void *ptr;
-    void **result = (void **) &ptr;
     int map_size = size ? size : dev->regions[bar].size;
 
     int err = pci_device_map_range(dev,
@@ -163,7 +165,7 @@ map_pci_mem(ScrnInfoPtr pScrni, int vram,
                                    map_size,
                                    PCI_DEV_MAP_FLAG_WRITABLE |
                                    (vram ? PCI_DEV_MAP_FLAG_WRITE_COMBINE : 0),
-                                   result);
+                                   &ptr);
 
     if (err)
         return NULL;
@@ -235,7 +237,19 @@ LXMapMem(ScrnInfoPtr pScrni)
                              pGeode->FBAvail);
     gp_set_command_buffer_base(cmd_bfr_phys, 0, pGeode->CmdBfrSize);
 
+#ifndef XSERVER_LIBPCIACCESS
     XpressROMPtr = xf86MapVidMem(index, VIDMEM_FRAMEBUFFER, 0xF0000, 0x10000);
+#else
+    {
+        int fd = open("/dev/mem", O_RDWR);
+        if (fd < 0) {
+            xf86DrvMsg(index, X_ERROR, "Failed to open /dev/mem: %m\n");
+            return FALSE;
+        }
+        XpressROMPtr = mmap(NULL, 0x10000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0xF0000);
+        close(fd);
+    }
+#endif
 
     pGeode->FBBase = cim_fb_ptr;
 
@@ -253,9 +267,9 @@ LXMapMem(ScrnInfoPtr pScrni)
 */
 
 static Bool
-LXCheckVGA(ScrnInfoPtr pScrni)
+LXCheckVGA(ScrnInfoPtr pScrni, EntityInfoPtr pEnt)
 {
-
+#ifndef XSERVER_LIBPCIACCESS
     unsigned char *ptr;
     const char *vgasig = "IBM VGA Compatible";
     int ret;
@@ -271,6 +285,11 @@ LXCheckVGA(ScrnInfoPtr pScrni)
     xf86UnMapVidMem(pScrni->scrnIndex, (pointer) ptr, strlen(vgasig));
 
     return ret ? FALSE : TRUE;
+#else
+    pciVideoPtr pci = xf86GetPciInfoForEntity(pEnt->index);
+
+    return pci_device_is_boot_vga(pci);
+#endif
 }
 
 static Bool
@@ -310,7 +329,7 @@ LXPreInit(ScrnInfoPtr pScrni, int flags)
     if (pGeode == NULL)
         return FALSE;
 
-    pGeode->useVGA = LXCheckVGA(pScrni);
+    pGeode->useVGA = LXCheckVGA(pScrni, pEnt);
     pGeode->VGAActive = FALSE;
     pGeode->pEnt = pEnt;
 
@@ -611,6 +630,8 @@ LXUnmapMem(ScrnInfoPtr pScrni)
     xf86UnMapVidMem(pScrni->scrnIndex, (pointer) cim_vg_ptr, LX_VG_REG_SIZE);
     xf86UnMapVidMem(pScrni->scrnIndex, (pointer) cim_vid_ptr, LX_VID_REG_SIZE);
     xf86UnMapVidMem(pScrni->scrnIndex, (pointer) cim_vip_ptr, LX_VIP_REG_SIZE);
+
+    xf86UnMapVidMem(pScrni->scrnIndex, XpressROMPtr, 0x10000);
 #else
     GeodeRec *pGeode = GEODEPTR(pScrni);
     pciVideoPtr pci = xf86GetPciInfoForEntity(pGeode->pEnt->index);
@@ -620,9 +641,9 @@ LXUnmapMem(ScrnInfoPtr pScrni)
     unmap_pci_mem(pScrni, pci, cim_vid_ptr, LX_VID_REG_SIZE);
     unmap_pci_mem(pScrni, pci, cim_vip_ptr, LX_VIP_REG_SIZE);
     unmap_pci_mem(pScrni, pci, cim_fb_ptr, pGeode->FBAvail + CIM_CMD_BFR_SZ);
-#endif
 
-    xf86UnMapVidMem(pScrni->scrnIndex, XpressROMPtr, 0x10000);
+    munmap(XpressROMPtr, 0x10000);
+#endif
 
     return TRUE;
 }
diff --git a/src/lx_memory.c b/src/lx_memory.c
index f26d280..992446f 100644
--- a/src/lx_memory.c
+++ b/src/lx_memory.c
@@ -22,6 +22,9 @@
  * contributors may be used to endorse or promote products derived from this
  * software without specific prior written permission.
  */
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
 
 #include "xf86.h"
 #include "geode.h"

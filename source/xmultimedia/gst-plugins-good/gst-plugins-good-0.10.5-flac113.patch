--- gst-plugins-good-0.10.5/ext/flac/gstflacdec.c.flac	2006-10-16 20:22:46.000000000 +0200
+++ gst-plugins-good-0.10.5/ext/flac/gstflacdec.c	2006-12-30 22:03:36.000000000 +0100
@@ -56,6 +56,12 @@
 
 #include <gst/tag/tag.h>
 
+#if !defined(FLAC_API_VERSION_CURRENT) || FLAC_API_VERSION_CURRENT < 8
+#define LEGACY_FLAC
+#else
+#undef LEGACY_FLAC
+#endif
+
 GST_DEBUG_CATEGORY_STATIC (flacdec_debug);
 #define GST_CAT_DEFAULT flacdec_debug
 
@@ -93,9 +99,13 @@
 static void gst_flac_dec_setup_seekable_decoder (GstFlacDec * flacdec);
 static void gst_flac_dec_setup_stream_decoder (GstFlacDec * flacdec);
 
+#ifdef LEGACY_FLAC
 static FLAC__SeekableStreamDecoderReadStatus
 gst_flac_dec_read_seekable (const FLAC__SeekableStreamDecoder * decoder,
     FLAC__byte buffer[], unsigned *bytes, void *client_data);
+static FLAC__StreamDecoderReadStatus
+gst_flac_dec_read_stream (const FLAC__StreamDecoder * decoder,
+    FLAC__byte buffer[], unsigned *bytes, void *client_data);
 static FLAC__SeekableStreamDecoderSeekStatus
 gst_flac_dec_seek (const FLAC__SeekableStreamDecoder * decoder,
     FLAC__uint64 position, void *client_data);
@@ -107,9 +117,6 @@
     FLAC__uint64 * length, void *client_data);
 static FLAC__bool gst_flac_dec_eof (const FLAC__SeekableStreamDecoder * decoder,
     void *client_data);
-static FLAC__StreamDecoderReadStatus
-gst_flac_dec_read_stream (const FLAC__StreamDecoder * decoder,
-    FLAC__byte buffer[], unsigned *bytes, void *client_data);
 static FLAC__StreamDecoderWriteStatus
 gst_flac_dec_write_seekable (const FLAC__SeekableStreamDecoder * decoder,
     const FLAC__Frame * frame,
@@ -123,13 +130,38 @@
     const FLAC__StreamMetadata * metadata, void *client_data);
 static void gst_flac_dec_metadata_callback_stream (const FLAC__StreamDecoder *
     decoder, const FLAC__StreamMetadata * metadata, void *client_data);
-static void gst_flac_dec_metadata_callback (GstFlacDec * flacdec,
-    const FLAC__StreamMetadata * metadata);
 static void gst_flac_dec_error_callback_seekable (const
     FLAC__SeekableStreamDecoder * decoder,
     FLAC__StreamDecoderErrorStatus status, void *client_data);
 static void gst_flac_dec_error_callback_stream (const FLAC__StreamDecoder *
     decoder, FLAC__StreamDecoderErrorStatus status, void *client_data);
+#else
+static FLAC__StreamDecoderReadStatus
+gst_flac_dec_read_seekable (const FLAC__StreamDecoder * decoder,
+    FLAC__byte buffer[], size_t *bytes, void *client_data);
+static FLAC__StreamDecoderReadStatus
+gst_flac_dec_read_stream (const FLAC__StreamDecoder * decoder,
+    FLAC__byte buffer[], size_t *bytes, void *client_data);
+static FLAC__StreamDecoderSeekStatus
+gst_flac_dec_seek (const FLAC__StreamDecoder * decoder,
+    FLAC__uint64 position, void *client_data);
+static FLAC__StreamDecoderTellStatus
+gst_flac_dec_tell (const FLAC__StreamDecoder * decoder,
+    FLAC__uint64 * position, void *client_data);
+static FLAC__StreamDecoderLengthStatus
+gst_flac_dec_length (const FLAC__StreamDecoder * decoder,
+    FLAC__uint64 * length, void *client_data);
+static FLAC__bool gst_flac_dec_eof (const FLAC__StreamDecoder * decoder,
+    void *client_data);
+static FLAC__StreamDecoderWriteStatus
+gst_flac_dec_write_stream (const FLAC__StreamDecoder * decoder,
+    const FLAC__Frame * frame,
+    const FLAC__int32 * const buffer[], void *client_data);
+static void gst_flac_dec_metadata_callback_stream (const FLAC__StreamDecoder *
+    decoder, const FLAC__StreamMetadata * metadata, void *client_data);
+static void gst_flac_dec_error_callback_stream (const FLAC__StreamDecoder *
+    decoder, FLAC__StreamDecoderErrorStatus status, void *client_data);
+#endif
 
 GST_BOILERPLATE (GstFlacDec, gst_flac_dec, GstElement, GST_TYPE_ELEMENT);
 #define GST_FLAC_DEC_SRC_CAPS                             \
@@ -212,7 +244,11 @@
 gst_flac_dec_reset_decoders (GstFlacDec * flacdec)
 {
   if (flacdec->seekable_decoder) {
+#ifdef LEGACY_FLAC
     FLAC__seekable_stream_decoder_delete (flacdec->seekable_decoder);
+#else
+    FLAC__stream_decoder_delete (flacdec->seekable_decoder);
+#endif
     flacdec->seekable_decoder = NULL;
   }
 
@@ -238,6 +274,7 @@
 {
   gst_flac_dec_reset_decoders (dec);
 
+#ifdef LEGACY_FLAC
   dec->seekable_decoder = FLAC__seekable_stream_decoder_new ();
 
   FLAC__seekable_stream_decoder_set_read_callback (dec->seekable_decoder,
@@ -259,6 +296,12 @@
   FLAC__seekable_stream_decoder_set_error_callback (dec->seekable_decoder,
       gst_flac_dec_error_callback_seekable);
   FLAC__seekable_stream_decoder_set_client_data (dec->seekable_decoder, dec);
+#else
+  dec->seekable_decoder = FLAC__stream_decoder_new ();
+
+  FLAC__stream_decoder_set_metadata_respond (dec->seekable_decoder, FLAC__METADATA_TYPE_VORBIS_COMMENT);
+  FLAC__stream_decoder_set_md5_checking (dec->seekable_decoder, false); /* no point calculating since it's never checked here */
+#endif
 }
 
 static void
@@ -270,17 +313,21 @@
 
   dec->stream_decoder = FLAC__stream_decoder_new ();
 
+#ifdef LEGACY_FLAC
   FLAC__stream_decoder_set_read_callback (dec->stream_decoder,
       gst_flac_dec_read_stream);
   FLAC__stream_decoder_set_write_callback (dec->stream_decoder,
       gst_flac_dec_write_stream);
-  FLAC__stream_decoder_set_metadata_respond (dec->stream_decoder,
-      FLAC__METADATA_TYPE_VORBIS_COMMENT);
   FLAC__stream_decoder_set_metadata_callback (dec->stream_decoder,
       gst_flac_dec_metadata_callback_stream);
   FLAC__stream_decoder_set_error_callback (dec->stream_decoder,
       gst_flac_dec_error_callback_stream);
   FLAC__stream_decoder_set_client_data (dec->stream_decoder, dec);
+#else
+  FLAC__stream_decoder_set_md5_checking (dec->stream_decoder, false); /* no point calculating since it's never checked here */
+#endif
+  FLAC__stream_decoder_set_metadata_respond (dec->stream_decoder,
+      FLAC__METADATA_TYPE_VORBIS_COMMENT);
 }
 
 static void
@@ -544,6 +591,7 @@
   }
 }
 
+#ifdef LEGACY_FLAC
 static void
 gst_flac_dec_metadata_callback_seekable (const FLAC__SeekableStreamDecoder * d,
     const FLAC__StreamMetadata * metadata, void *client_data)
@@ -552,6 +600,7 @@
 
   gst_flac_dec_metadata_callback (dec, metadata);
 }
+#endif
 
 static void
 gst_flac_dec_metadata_callback_stream (const FLAC__StreamDecoder * decoder,
@@ -587,12 +636,14 @@
   dec->last_flow = GST_FLOW_ERROR;
 }
 
+#ifdef LEGACY_FLAC
 static void
 gst_flac_dec_error_callback_seekable (const FLAC__SeekableStreamDecoder * d,
     FLAC__StreamDecoderErrorStatus status, void *client_data)
 {
   gst_flac_dec_error_callback (GST_FLAC_DEC (client_data), status);
 }
+#endif
 
 static void
 gst_flac_dec_error_callback_stream (const FLAC__StreamDecoder * d,
@@ -601,9 +652,15 @@
   gst_flac_dec_error_callback (GST_FLAC_DEC (client_data), status);
 }
 
+#ifdef LEGACY_FLAC
 static FLAC__SeekableStreamDecoderSeekStatus
 gst_flac_dec_seek (const FLAC__SeekableStreamDecoder * decoder,
     FLAC__uint64 position, void *client_data)
+#else
+static FLAC__StreamDecoderSeekStatus
+gst_flac_dec_seek (const FLAC__StreamDecoder * decoder,
+    FLAC__uint64 position, void *client_data)
+#endif
 {
   GstFlacDec *flacdec;
 
@@ -612,12 +669,22 @@
   GST_DEBUG ("seek %" G_GINT64_FORMAT, position);
   flacdec->offset = position;
 
+#ifdef LEGACY_FLAC
   return FLAC__SEEKABLE_STREAM_DECODER_SEEK_STATUS_OK;
+#else
+  return FLAC__STREAM_DECODER_SEEK_STATUS_OK;
+#endif
 }
 
+#ifdef LEGACY_FLAC
 static FLAC__SeekableStreamDecoderTellStatus
 gst_flac_dec_tell (const FLAC__SeekableStreamDecoder * decoder,
     FLAC__uint64 * position, void *client_data)
+#else
+static FLAC__StreamDecoderTellStatus
+gst_flac_dec_tell (const FLAC__StreamDecoder * decoder,
+    FLAC__uint64 * position, void *client_data)
+#endif
 {
   GstFlacDec *flacdec;
 
@@ -627,12 +694,22 @@
 
   GST_DEBUG ("tell %" G_GINT64_FORMAT, *position);
 
+#ifdef LEGACY_FLAC
   return FLAC__SEEKABLE_STREAM_DECODER_TELL_STATUS_OK;
+#else
+  return FLAC__STREAM_DECODER_TELL_STATUS_OK;
+#endif
 }
 
+#ifdef LEGACY_FLAC
 static FLAC__SeekableStreamDecoderLengthStatus
 gst_flac_dec_length (const FLAC__SeekableStreamDecoder * decoder,
     FLAC__uint64 * length, void *client_data)
+#else
+static FLAC__StreamDecoderLengthStatus
+gst_flac_dec_length (const FLAC__StreamDecoder * decoder,
+    FLAC__uint64 * length, void *client_data)
+#endif
 {
   GstFlacDec *flacdec;
   GstFormat fmt = GST_FORMAT_BYTES;
@@ -642,22 +719,40 @@
   flacdec = GST_FLAC_DEC (client_data);
 
   if (!(peer = gst_pad_get_peer (flacdec->sinkpad)))
+#ifdef LEGACY_FLAC
     return FLAC__SEEKABLE_STREAM_DECODER_LENGTH_STATUS_ERROR;
+#else
+    return FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR;
+#endif
   gst_pad_query_duration (peer, &fmt, &len);
   gst_object_unref (peer);
   if (fmt != GST_FORMAT_BYTES || len == -1)
+#ifdef LEGACY_FLAC
     return FLAC__SEEKABLE_STREAM_DECODER_LENGTH_STATUS_ERROR;
+#else
+    return FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR;
+#endif
 
   *length = len;
 
   GST_DEBUG ("length %" G_GINT64_FORMAT, *length);
 
+#ifdef LEGACY_FLAC
   return FLAC__SEEKABLE_STREAM_DECODER_LENGTH_STATUS_OK;
+#else
+  return FLAC__STREAM_DECODER_LENGTH_STATUS_OK;
+#endif
 }
 
+#ifdef LEGACY_FLAC
 static FLAC__bool
 gst_flac_dec_eof (const FLAC__SeekableStreamDecoder * decoder,
     void *client_data)
+#else
+static FLAC__bool
+gst_flac_dec_eof (const FLAC__StreamDecoder * decoder,
+    void *client_data)
+#endif
 {
   GstFlacDec *flacdec;
   GstFormat fmt;
@@ -685,9 +780,15 @@
   return ret;
 }
 
+#ifdef LEGACY_FLAC
 static FLAC__SeekableStreamDecoderReadStatus
 gst_flac_dec_read_seekable (const FLAC__SeekableStreamDecoder * decoder,
     FLAC__byte buffer[], unsigned *bytes, void *client_data)
+#else
+static FLAC__StreamDecoderReadStatus
+gst_flac_dec_read_seekable (const FLAC__StreamDecoder * decoder,
+    FLAC__byte buffer[], size_t *bytes, void *client_data)
+#endif
 {
   GstFlacDec *flacdec;
   GstBuffer *buf;
@@ -696,7 +797,11 @@
 
   if (gst_pad_pull_range (flacdec->sinkpad, flacdec->offset, *bytes,
           &buf) != GST_FLOW_OK)
+#ifdef LEGACY_FLAC
     return FLAC__SEEKABLE_STREAM_DECODER_READ_STATUS_ERROR;
+#else
+    return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
+#endif
 
   GST_DEBUG ("Read %d bytes at %" G_GUINT64_FORMAT,
       GST_BUFFER_SIZE (buf), flacdec->offset);
@@ -705,12 +810,22 @@
   gst_buffer_unref (buf);
   flacdec->offset += *bytes;
 
+#ifdef LEGACY_FLAC
   return FLAC__SEEKABLE_STREAM_DECODER_READ_STATUS_OK;
+#else
+  return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
+#endif
 }
 
+#ifdef LEGACY_FLAC
 static FLAC__StreamDecoderReadStatus
 gst_flac_dec_read_stream (const FLAC__StreamDecoder * decoder,
     FLAC__byte buffer[], unsigned *bytes, void *client_data)
+#else
+static FLAC__StreamDecoderReadStatus
+gst_flac_dec_read_stream (const FLAC__StreamDecoder * decoder,
+    FLAC__byte buffer[], size_t *bytes, void *client_data)
+#endif
 {
   GstFlacDec *dec = GST_FLAC_DEC (client_data);
   guint len;
@@ -880,6 +995,7 @@
   return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
 }
 
+#ifdef LEGACY_FLAC
 static FLAC__StreamDecoderWriteStatus
 gst_flac_dec_write_seekable (const FLAC__SeekableStreamDecoder * decoder,
     const FLAC__Frame * frame,
@@ -887,6 +1003,7 @@
 {
   return gst_flac_dec_write (GST_FLAC_DEC (client_data), frame, buffer);
 }
+#endif
 
 static FLAC__StreamDecoderWriteStatus
 gst_flac_dec_write_stream (const FLAC__StreamDecoder * decoder,
@@ -900,7 +1017,12 @@
 gst_flac_dec_loop (GstPad * sinkpad)
 {
   GstFlacDec *flacdec;
+#ifdef LEGACY_FLAC
   FLAC__SeekableStreamDecoderState s;
+#else
+  FLAC__StreamDecoderState s;
+  FLAC__StreamDecoderInitStatus is;
+#endif
 
   flacdec = GST_FLAC_DEC (GST_OBJECT_PARENT (sinkpad));
 
@@ -908,9 +1030,15 @@
 
   if (flacdec->init) {
     GST_DEBUG_OBJECT (flacdec, "initializing decoder");
+#ifdef LEGACY_FLAC
     s = FLAC__seekable_stream_decoder_init (flacdec->seekable_decoder);
     if (s != FLAC__SEEKABLE_STREAM_DECODER_OK)
       goto analyze_state;
+#else
+    is = FLAC__stream_decoder_init_stream (flacdec->seekable_decoder, gst_flac_dec_read_seekable, gst_flac_dec_seek, gst_flac_dec_tell, gst_flac_dec_length, gst_flac_dec_eof, gst_flac_dec_write_stream, gst_flac_dec_metadata_callback_stream, gst_flac_dec_error_callback_stream, flacdec);
+    if (is != FLAC__STREAM_DECODER_INIT_STATUS_OK)
+      goto analyze_state;
+#endif
     /*    FLAC__seekable_stream_decoder_process_metadata (flacdec->seekable_decoder); */
     flacdec->init = FALSE;
   }
@@ -920,15 +1048,31 @@
   flacdec->last_flow = GST_FLOW_OK;
 
   GST_LOG_OBJECT (flacdec, "processing single");
+#ifdef LEGACY_FLAC
   FLAC__seekable_stream_decoder_process_single (flacdec->seekable_decoder);
+#else
+  FLAC__stream_decoder_process_single (flacdec->seekable_decoder);
+#endif
 
 analyze_state:
 
   GST_LOG_OBJECT (flacdec, "done processing, checking encoder state");
+#ifdef LEGACY_FLAC
   s = FLAC__seekable_stream_decoder_get_state (flacdec->seekable_decoder);
+#else
+  s = FLAC__stream_decoder_get_state (flacdec->seekable_decoder);
+#endif
   switch (s) {
+#ifdef LEGACY_FLAC
     case FLAC__SEEKABLE_STREAM_DECODER_OK:
-    case FLAC__SEEKABLE_STREAM_DECODER_SEEKING:{
+    case FLAC__SEEKABLE_STREAM_DECODER_SEEKING:
+#else
+    case FLAC__STREAM_DECODER_SEARCH_FOR_METADATA:
+    case FLAC__STREAM_DECODER_READ_METADATA:
+    case FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC:
+    case FLAC__STREAM_DECODER_READ_FRAME:
+#endif
+    {
       GST_DEBUG_OBJECT (flacdec, "everything ok");
 
       if (flacdec->last_flow != GST_FLOW_OK &&
@@ -956,9 +1100,18 @@
       return;
     }
 
-    case FLAC__SEEKABLE_STREAM_DECODER_END_OF_STREAM:{
+#ifdef LEGACY_FLAC
+    case FLAC__SEEKABLE_STREAM_DECODER_END_OF_STREAM:
+#else
+    case FLAC__STREAM_DECODER_END_OF_STREAM:
+#endif
+    {
       GST_DEBUG_OBJECT (flacdec, "EOS");
+#ifdef LEGACY_FLAC
       FLAC__seekable_stream_decoder_reset (flacdec->seekable_decoder);
+#else
+      FLAC__stream_decoder_reset (flacdec->seekable_decoder);
+#endif
 
       if ((flacdec->segment.flags & GST_SEEK_FLAG_SEGMENT) != 0) {
         if (flacdec->segment.duration > 0) {
@@ -972,6 +1125,7 @@
       goto eos_and_pause;
     }
 
+#ifdef LEGACY_FLAC
     case FLAC__SEEKABLE_STREAM_DECODER_MEMORY_ALLOCATION_ERROR:
     case FLAC__SEEKABLE_STREAM_DECODER_STREAM_DECODER_ERROR:
     case FLAC__SEEKABLE_STREAM_DECODER_READ_ERROR:
@@ -979,11 +1133,23 @@
     case FLAC__SEEKABLE_STREAM_DECODER_ALREADY_INITIALIZED:
     case FLAC__SEEKABLE_STREAM_DECODER_INVALID_CALLBACK:
     case FLAC__SEEKABLE_STREAM_DECODER_UNINITIALIZED:
+#else
+    case FLAC__STREAM_DECODER_OGG_ERROR:
+    case FLAC__STREAM_DECODER_SEEK_ERROR:
+    case FLAC__STREAM_DECODER_ABORTED:
+    case FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR:
+    case FLAC__STREAM_DECODER_UNINITIALIZED:
+#endif
     default:{
       /* fixme: this error sucks -- should try to figure out when/if an more
          specific error was already sent via the callback */
+#ifdef LEGACY_FLAC
       GST_ELEMENT_ERROR (flacdec, STREAM, DECODE, (NULL),
           ("%s", FLAC__SeekableStreamDecoderStateString[s]));
+#else
+      GST_ELEMENT_ERROR (flacdec, STREAM, DECODE, (NULL),
+          ("%s", FLAC__StreamDecoderStateString[s]));
+#endif
       goto eos_and_pause;
     }
   }
@@ -1113,11 +1279,19 @@
 
   if (dec->init) {
     GST_DEBUG_OBJECT (dec, "initializing decoder");
+#ifdef LEGACY_FLAC
     s = FLAC__stream_decoder_init (dec->stream_decoder);
     if (s != FLAC__STREAM_DECODER_SEARCH_FOR_METADATA) {
       GST_ELEMENT_ERROR (GST_ELEMENT (dec), LIBRARY, INIT, (NULL), (NULL));
       return GST_FLOW_ERROR;
     }
+#else
+    s = FLAC__stream_decoder_init_stream (dec->stream_decoder, gst_flac_dec_read_stream, NULL, NULL, NULL, NULL, gst_flac_dec_write_stream, gst_flac_dec_metadata_callback_stream, gst_flac_dec_error_callback_stream, dec);
+    if (s != FLAC__STREAM_DECODER_INIT_STATUS_OK) {
+      GST_ELEMENT_ERROR (GST_ELEMENT (dec), LIBRARY, INIT, (NULL), (NULL));
+      return GST_FLOW_ERROR;
+    }
+#endif
     GST_DEBUG_OBJECT (dec, "initialized (framed=%d)", dec->framed);
     dec->init = FALSE;
   }
@@ -1598,8 +1772,13 @@
   flacdec->seeking = TRUE;
 
   seek_ok =
+#ifdef LEGACY_FLAC
       FLAC__seekable_stream_decoder_seek_absolute (flacdec->seekable_decoder,
       segment.start);
+#else
+      FLAC__stream_decoder_seek_absolute (flacdec->seekable_decoder,
+      segment.start);
+#endif
 
   flacdec->seeking = FALSE;
 
--- gst-plugins-good-0.10.5/ext/flac/gstflacdec.h.flac	2006-08-22 14:28:24.000000000 +0200
+++ gst-plugins-good-0.10.5/ext/flac/gstflacdec.h	2006-12-30 21:53:17.000000000 +0100
@@ -41,7 +41,11 @@
 struct _GstFlacDec {
   GstElement     element;
 
+#if !defined(FLAC_API_VERSION_CURRENT) || FLAC_API_VERSION_CURRENT < 8
   FLAC__SeekableStreamDecoder *seekable_decoder; /* for pull-based operation  */
+#else
+  FLAC__StreamDecoder         *seekable_decoder; /* for pull-based operation  */
+#endif
 
   FLAC__StreamDecoder         *stream_decoder;   /* for chain-based operation */
   GstAdapter                  *adapter;
--- gst-plugins-good-0.10.5/ext/flac/gstflacenc.c.flac	2006-10-16 20:22:46.000000000 +0200
+++ gst-plugins-good-0.10.5/ext/flac/gstflacenc.c	2006-12-30 22:06:32.000000000 +0100
@@ -29,6 +29,12 @@
 #include <gst/tag/tag.h>
 #include <gst/gsttagsetter.h>
 
+#if !defined(FLAC_API_VERSION_CURRENT) || FLAC_API_VERSION_CURRENT < 8
+#define LEGACY_FLAC
+#else
+#undef LEGACY_FLAC
+#endif
+
 
 static const GstElementDetails flacenc_details =
 GST_ELEMENT_DETAILS ("FLAC audio encoder",
@@ -108,6 +114,7 @@
 static GstStateChangeReturn gst_flac_enc_change_state (GstElement * element,
     GstStateChange transition);
 
+#ifdef LEGACY_FLAC
 static FLAC__StreamEncoderWriteStatus
 gst_flac_enc_write_callback (const FLAC__SeekableStreamEncoder * encoder,
     const FLAC__byte buffer[], unsigned bytes,
@@ -118,6 +125,18 @@
 static FLAC__SeekableStreamEncoderTellStatus
 gst_flac_enc_tell_callback (const FLAC__SeekableStreamEncoder * encoder,
     FLAC__uint64 * absolute_byte_offset, void *client_data);
+#else
+static FLAC__StreamEncoderWriteStatus
+gst_flac_enc_write_callback (const FLAC__StreamEncoder * encoder,
+    const FLAC__byte buffer[], size_t bytes,
+    unsigned samples, unsigned current_frame, void *client_data);
+static FLAC__StreamEncoderSeekStatus
+gst_flac_enc_seek_callback (const FLAC__StreamEncoder * encoder,
+    FLAC__uint64 absolute_byte_offset, void *client_data);
+static FLAC__StreamEncoderTellStatus
+gst_flac_enc_tell_callback (const FLAC__StreamEncoder * encoder,
+    FLAC__uint64 * absolute_byte_offset, void *client_data);
+#endif
 
 typedef struct
 {
@@ -302,7 +321,11 @@
   gst_pad_use_fixed_caps (flacenc->srcpad);
   gst_element_add_pad (GST_ELEMENT (flacenc), flacenc->srcpad);
 
+#ifdef LEGACY_FLAC
   flacenc->encoder = FLAC__seekable_stream_encoder_new ();
+#else
+  flacenc->encoder = FLAC__stream_encoder_new ();
+#endif
 
   flacenc->offset = 0;
   flacenc->samples_written = 0;
@@ -315,7 +338,11 @@
 {
   GstFlacEnc *flacenc = GST_FLAC_ENC (object);
 
+#ifdef LEGACY_FLAC
   FLAC__seekable_stream_encoder_delete (flacenc->encoder);
+#else
+  FLAC__stream_encoder_delete (flacenc->encoder);
+#endif
 
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
@@ -360,8 +387,13 @@
       FLAC__metadata_object_new (FLAC__METADATA_TYPE_VORBIS_COMMENT);
   gst_tag_list_foreach (copy, add_one_tag, flacenc);
 
+#ifdef LEGACY_FLAC
   if (FLAC__seekable_stream_encoder_set_metadata (flacenc->encoder,
           flacenc->meta, 1) != true)
+#else
+  if (FLAC__stream_encoder_set_metadata (flacenc->encoder,
+          flacenc->meta, 1) != true)
+#endif
     g_warning ("Dude, i'm already initialized!");
   gst_tag_list_free (copy);
 }
@@ -371,13 +403,22 @@
 {
   GstFlacEnc *flacenc;
   GstStructure *structure;
+#ifdef LEGACY_FLAC
   FLAC__SeekableStreamEncoderState state;
+#else
+  FLAC__StreamEncoderInitStatus init_status;
+#endif
 
   /* takes a ref on flacenc */
   flacenc = GST_FLAC_ENC (gst_pad_get_parent (pad));
 
+#ifdef LEGACY_FLAC
   if (FLAC__seekable_stream_encoder_get_state (flacenc->encoder) !=
       FLAC__SEEKABLE_STREAM_ENCODER_UNINITIALIZED)
+#else
+  if (FLAC__stream_encoder_get_state (flacenc->encoder) !=
+      FLAC__STREAM_ENCODER_UNINITIALIZED)
+#endif
     goto encoder_already_initialized;
 
   structure = gst_caps_get_structure (caps, 0);
@@ -397,6 +438,7 @@
 
   gst_caps_unref (caps);
 
+#ifdef LEGACY_FLAC
   FLAC__seekable_stream_encoder_set_bits_per_sample (flacenc->encoder,
       flacenc->depth);
   FLAC__seekable_stream_encoder_set_sample_rate (flacenc->encoder,
@@ -412,12 +454,25 @@
       gst_flac_enc_tell_callback);
 
   FLAC__seekable_stream_encoder_set_client_data (flacenc->encoder, flacenc);
+#else
+  FLAC__stream_encoder_set_bits_per_sample (flacenc->encoder, flacenc->depth);
+  FLAC__stream_encoder_set_sample_rate (flacenc->encoder, flacenc->sample_rate);
+  FLAC__stream_encoder_set_channels (flacenc->encoder, flacenc->channels);
+#endif
 
   gst_flac_enc_set_metadata (flacenc);
 
+#ifdef LEGACY_FLAC
   state = FLAC__seekable_stream_encoder_init (flacenc->encoder);
   if (state != FLAC__STREAM_ENCODER_OK)
     goto failed_to_initialize;
+#else
+  init_status = FLAC__stream_encoder_init_stream (flacenc->encoder,
+      gst_flac_enc_write_callback, gst_flac_enc_seek_callback,
+      gst_flac_enc_tell_callback, NULL, flacenc);
+  if (init_status != FLAC__STREAM_ENCODER_INIT_STATUS_OK)
+    goto failed_to_initialize;
+#endif
 
   gst_object_unref (flacenc);
 
@@ -451,6 +506,7 @@
 {
   flacenc->quality = quality;
 
+#ifdef LEGACY_FLAC
 #define DO_UPDATE(name, val, str)                                               \
   G_STMT_START {                                                                \
     if (FLAC__seekable_stream_encoder_get_##name (flacenc->encoder) !=          \
@@ -460,6 +516,17 @@
       g_object_notify (G_OBJECT (flacenc), str);                                \
     }                                                                           \
   } G_STMT_END
+#else
+#define DO_UPDATE(name, val, str)                                               \
+  G_STMT_START {                                                                \
+    if (FLAC__stream_encoder_get_##name (flacenc->encoder) !=                   \
+        flacenc_params[quality].val) {                                          \
+      FLAC__stream_encoder_set_##name (flacenc->encoder,                        \
+          flacenc_params[quality].val);                                         \
+      g_object_notify (G_OBJECT (flacenc), str);                                \
+    }                                                                           \
+  } G_STMT_END
+#endif
 
   g_object_freeze_notify (G_OBJECT (flacenc));
 
@@ -490,9 +557,15 @@
   return TRUE;
 }
 
+#ifdef LEGACY_FLAC
 static FLAC__SeekableStreamEncoderSeekStatus
 gst_flac_enc_seek_callback (const FLAC__SeekableStreamEncoder * encoder,
     FLAC__uint64 absolute_byte_offset, void *client_data)
+#else
+static FLAC__StreamEncoderSeekStatus
+gst_flac_enc_seek_callback (const FLAC__StreamEncoder * encoder,
+    FLAC__uint64 absolute_byte_offset, void *client_data)
+#endif
 {
   GstFlacEnc *flacenc;
   GstEvent *event;
@@ -501,7 +574,11 @@
   flacenc = GST_FLAC_ENC (client_data);
 
   if (flacenc->stopped)
+#ifdef LEGACY_FLAC
     return FLAC__SEEKABLE_STREAM_ENCODER_SEEK_STATUS_OK;
+#else
+    return FLAC__STREAM_ENCODER_SEEK_STATUS_OK;
+#endif
 
   event = gst_event_new_new_segment (TRUE, 1.0, GST_FORMAT_BYTES,
       absolute_byte_offset, GST_BUFFER_OFFSET_NONE, 0);
@@ -525,13 +602,24 @@
 
   flacenc->offset = absolute_byte_offset;
 
+#ifdef LEGACY_FLAC
   return FLAC__SEEKABLE_STREAM_ENCODER_SEEK_STATUS_OK;
+#else
+  return FLAC__STREAM_ENCODER_SEEK_STATUS_OK;
+#endif
 }
 
+#ifdef LEGACY_FLAC
 static FLAC__StreamEncoderWriteStatus
 gst_flac_enc_write_callback (const FLAC__SeekableStreamEncoder * encoder,
     const FLAC__byte buffer[], unsigned bytes,
     unsigned samples, unsigned current_frame, void *client_data)
+#else
+static FLAC__StreamEncoderWriteStatus
+gst_flac_enc_write_callback (const FLAC__StreamEncoder * encoder,
+    const FLAC__byte buffer[], size_t bytes,
+    unsigned samples, unsigned current_frame, void *client_data)
+#endif
 {
   GstFlowReturn ret;
   GstFlacEnc *flacenc;
@@ -577,15 +665,25 @@
   return FLAC__STREAM_ENCODER_WRITE_STATUS_OK;
 }
 
+#ifdef LEGACY_FLAC
 static FLAC__SeekableStreamEncoderTellStatus
 gst_flac_enc_tell_callback (const FLAC__SeekableStreamEncoder * encoder,
     FLAC__uint64 * absolute_byte_offset, void *client_data)
+#else
+static FLAC__StreamEncoderTellStatus
+gst_flac_enc_tell_callback (const FLAC__StreamEncoder * encoder,
+    FLAC__uint64 * absolute_byte_offset, void *client_data)
+#endif
 {
   GstFlacEnc *flacenc = GST_FLAC_ENC (client_data);
 
   *absolute_byte_offset = flacenc->offset;
 
+#ifdef LEGACY_FLAC
   return FLAC__SEEKABLE_STREAM_ENCODER_TELL_STATUS_OK;
+#else
+  return FLAC__STREAM_ENCODER_TELL_STATUS_OK;
+#endif
 }
 
 static gboolean
@@ -629,7 +727,11 @@
       break;
     }
     case GST_EVENT_EOS:
+#ifdef LEGACY_FLAC
       FLAC__seekable_stream_encoder_finish (flacenc->encoder);
+#else
+      FLAC__stream_encoder_finish (flacenc->encoder);
+#endif
       ret = gst_pad_event_default (pad, event);
       break;
     case GST_EVENT_TAG:
@@ -686,8 +788,13 @@
 
   gst_buffer_unref (buffer);
 
+#ifdef LEGACY_FLAC
   res = FLAC__seekable_stream_encoder_process_interleaved (flacenc->encoder,
       (const FLAC__int32 *) data, samples / flacenc->channels);
+#else
+  res = FLAC__stream_encoder_process_interleaved (flacenc->encoder,
+      (const FLAC__int32 *) data, samples / flacenc->channels);
+#endif
 
   g_free (data);
 
@@ -712,52 +819,112 @@
       gst_flac_enc_update_quality (this, g_value_get_enum (value));
       break;
     case PROP_STREAMABLE_SUBSET:
+#ifdef LEGACY_FLAC
       FLAC__seekable_stream_encoder_set_streamable_subset (this->encoder,
           g_value_get_boolean (value));
+#else
+      FLAC__stream_encoder_set_streamable_subset (this->encoder,
+          g_value_get_boolean (value));
+#endif
       break;
     case PROP_MID_SIDE_STEREO:
+#ifdef LEGACY_FLAC
       FLAC__seekable_stream_encoder_set_do_mid_side_stereo (this->encoder,
           g_value_get_boolean (value));
+#else
+      FLAC__stream_encoder_set_do_mid_side_stereo (this->encoder,
+          g_value_get_boolean (value));
+#endif
       break;
     case PROP_LOOSE_MID_SIDE_STEREO:
+#ifdef LEGACY_FLAC
       FLAC__seekable_stream_encoder_set_loose_mid_side_stereo (this->encoder,
           g_value_get_boolean (value));
+#else
+      FLAC__stream_encoder_set_loose_mid_side_stereo (this->encoder,
+          g_value_get_boolean (value));
+#endif
       break;
     case PROP_BLOCKSIZE:
+#ifdef LEGACY_FLAC
       FLAC__seekable_stream_encoder_set_blocksize (this->encoder,
           g_value_get_uint (value));
+#else
+      FLAC__stream_encoder_set_blocksize (this->encoder,
+          g_value_get_uint (value));
+#endif
       break;
     case PROP_MAX_LPC_ORDER:
+#ifdef LEGACY_FLAC
       FLAC__seekable_stream_encoder_set_max_lpc_order (this->encoder,
           g_value_get_uint (value));
+#else
+      FLAC__stream_encoder_set_max_lpc_order (this->encoder,
+          g_value_get_uint (value));
+#endif
       break;
     case PROP_QLP_COEFF_PRECISION:
+#ifdef LEGACY_FLAC
       FLAC__seekable_stream_encoder_set_qlp_coeff_precision (this->encoder,
           g_value_get_uint (value));
+#else
+      FLAC__stream_encoder_set_qlp_coeff_precision (this->encoder,
+          g_value_get_uint (value));
+#endif
       break;
     case PROP_QLP_COEFF_PREC_SEARCH:
+#ifdef LEGACY_FLAC
       FLAC__seekable_stream_encoder_set_do_qlp_coeff_prec_search (this->encoder,
           g_value_get_boolean (value));
+#else
+      FLAC__stream_encoder_set_do_qlp_coeff_prec_search (this->encoder,
+          g_value_get_boolean (value));
+#endif
       break;
     case PROP_ESCAPE_CODING:
+#ifdef LEGACY_FLAC
       FLAC__seekable_stream_encoder_set_do_escape_coding (this->encoder,
           g_value_get_boolean (value));
+#else
+      FLAC__stream_encoder_set_do_escape_coding (this->encoder,
+          g_value_get_boolean (value));
+#endif
       break;
     case PROP_EXHAUSTIVE_MODEL_SEARCH:
+#ifdef LEGACY_FLAC
       FLAC__seekable_stream_encoder_set_do_exhaustive_model_search (this->
           encoder, g_value_get_boolean (value));
+#else
+      FLAC__stream_encoder_set_do_exhaustive_model_search (this->
+          encoder, g_value_get_boolean (value));
+#endif
       break;
     case PROP_MIN_RESIDUAL_PARTITION_ORDER:
+#ifdef LEGACY_FLAC
       FLAC__seekable_stream_encoder_set_min_residual_partition_order (this->
           encoder, g_value_get_uint (value));
+#else
+      FLAC__stream_encoder_set_min_residual_partition_order (this->
+          encoder, g_value_get_uint (value));
+#endif
       break;
     case PROP_MAX_RESIDUAL_PARTITION_ORDER:
+#ifdef LEGACY_FLAC
       FLAC__seekable_stream_encoder_set_max_residual_partition_order (this->
           encoder, g_value_get_uint (value));
+#else
+      FLAC__stream_encoder_set_max_residual_partition_order (this->
+          encoder, g_value_get_uint (value));
+#endif
       break;
     case PROP_RICE_PARAMETER_SEARCH_DIST:
+#ifdef LEGACY_FLAC
       FLAC__seekable_stream_encoder_set_rice_parameter_search_dist (this->
           encoder, g_value_get_uint (value));
+#else
+      FLAC__stream_encoder_set_rice_parameter_search_dist (this->
+          encoder, g_value_get_uint (value));
+#endif
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -780,59 +947,119 @@
       g_value_set_enum (value, this->quality);
       break;
     case PROP_STREAMABLE_SUBSET:
+#ifdef LEGACY_FLAC
       g_value_set_boolean (value,
           FLAC__seekable_stream_encoder_get_streamable_subset (this->encoder));
+#else
+      g_value_set_boolean (value,
+          FLAC__stream_encoder_get_streamable_subset (this->encoder));
+#endif
       break;
     case PROP_MID_SIDE_STEREO:
+#ifdef LEGACY_FLAC
       g_value_set_boolean (value,
           FLAC__seekable_stream_encoder_get_do_mid_side_stereo (this->encoder));
+#else
+      g_value_set_boolean (value,
+          FLAC__stream_encoder_get_do_mid_side_stereo (this->encoder));
+#endif
       break;
     case PROP_LOOSE_MID_SIDE_STEREO:
+#ifdef LEGACY_FLAC
       g_value_set_boolean (value,
           FLAC__seekable_stream_encoder_get_loose_mid_side_stereo (this->
               encoder));
+#else
+      g_value_set_boolean (value,
+          FLAC__stream_encoder_get_loose_mid_side_stereo (this->encoder));
+#endif
       break;
     case PROP_BLOCKSIZE:
+#ifdef LEGACY_FLAC
       g_value_set_uint (value,
           FLAC__seekable_stream_encoder_get_blocksize (this->encoder));
+#else
+      g_value_set_uint (value,
+          FLAC__stream_encoder_get_blocksize (this->encoder));
+#endif
       break;
     case PROP_MAX_LPC_ORDER:
+#ifdef LEGACY_FLAC
       g_value_set_uint (value,
           FLAC__seekable_stream_encoder_get_max_lpc_order (this->encoder));
+#else
+      g_value_set_uint (value,
+          FLAC__stream_encoder_get_max_lpc_order (this->encoder));
+#endif
       break;
     case PROP_QLP_COEFF_PRECISION:
+#ifdef LEGACY_FLAC
       g_value_set_uint (value,
           FLAC__seekable_stream_encoder_get_qlp_coeff_precision (this->
               encoder));
+#else
+      g_value_set_uint (value,
+          FLAC__stream_encoder_get_qlp_coeff_precision (this->encoder));
+#endif
       break;
     case PROP_QLP_COEFF_PREC_SEARCH:
+#ifdef LEGACY_FLAC
       g_value_set_boolean (value,
           FLAC__seekable_stream_encoder_get_do_qlp_coeff_prec_search (this->
               encoder));
+#else
+      g_value_set_boolean (value,
+          FLAC__stream_encoder_get_do_qlp_coeff_prec_search (this->encoder));
+#endif
       break;
     case PROP_ESCAPE_CODING:
+#ifdef LEGACY_FLAC
       g_value_set_boolean (value,
           FLAC__seekable_stream_encoder_get_do_escape_coding (this->encoder));
+#else
+      g_value_set_boolean (value,
+          FLAC__stream_encoder_get_do_escape_coding (this->encoder));
+#endif
       break;
     case PROP_EXHAUSTIVE_MODEL_SEARCH:
+#ifdef LEGACY_FLAC
       g_value_set_boolean (value,
           FLAC__seekable_stream_encoder_get_do_exhaustive_model_search (this->
               encoder));
+#else
+      g_value_set_boolean (value,
+          FLAC__stream_encoder_get_do_exhaustive_model_search (this->encoder));
+#endif
       break;
     case PROP_MIN_RESIDUAL_PARTITION_ORDER:
+#ifdef LEGACY_FLAC
       g_value_set_uint (value,
           FLAC__seekable_stream_encoder_get_min_residual_partition_order (this->
               encoder));
+#else
+      g_value_set_uint (value,
+          FLAC__stream_encoder_get_min_residual_partition_order (this->encoder));
+#endif
       break;
     case PROP_MAX_RESIDUAL_PARTITION_ORDER:
+#ifdef LEGACY_FLAC
       g_value_set_uint (value,
           FLAC__seekable_stream_encoder_get_max_residual_partition_order (this->
               encoder));
+#else
+      g_value_set_uint (value,
+          FLAC__stream_encoder_get_max_residual_partition_order (this->encoder));
+#endif
       break;
     case PROP_RICE_PARAMETER_SEARCH_DIST:
+#ifdef LEGACY_FLAC
       g_value_set_uint (value,
           FLAC__seekable_stream_encoder_get_rice_parameter_search_dist (this->
               encoder));
+#else
+      g_value_set_uint (value,
+          FLAC__stream_encoder_get_rice_parameter_search_dist (this->encoder));
+#endif
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -864,11 +1091,19 @@
     case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
+#ifdef LEGACY_FLAC
       if (FLAC__seekable_stream_encoder_get_state (flacenc->encoder) !=
-          FLAC__STREAM_ENCODER_UNINITIALIZED) {
+          FLAC__SEEKABLE_STREAM_ENCODER_UNINITIALIZED) {
         flacenc->stopped = TRUE;
         FLAC__seekable_stream_encoder_finish (flacenc->encoder);
       }
+#else
+      if (FLAC__stream_encoder_get_state (flacenc->encoder) !=
+          FLAC__STREAM_ENCODER_UNINITIALIZED) {
+        flacenc->stopped = TRUE;
+        FLAC__stream_encoder_finish (flacenc->encoder);
+      }
+#endif
       flacenc->offset = 0;
       flacenc->samples_written = 0;
       if (flacenc->meta) {
--- gst-plugins-good-0.10.5/ext/flac/gstflacenc.h.flac	2006-06-01 23:07:23.000000000 +0200
+++ gst-plugins-good-0.10.5/ext/flac/gstflacenc.h	2006-12-30 21:53:17.000000000 +0100
@@ -54,7 +54,11 @@
   gboolean       stopped;
   FLAC__int32   *data;
 
+#if !defined(FLAC_API_VERSION_CURRENT) || FLAC_API_VERSION_CURRENT < 8
   FLAC__SeekableStreamEncoder *encoder;
+#else
+  FLAC__StreamEncoder *encoder;
+#endif
   FLAC__StreamMetadata **meta;
 
   GstTagList *     tags;
--- gst-plugins-good-0.10.5/configure.ac.flac	2006-12-21 15:20:44.000000000 +0100
+++ gst-plugins-good-0.10.5/configure.ac	2006-12-30 21:55:48.000000000 +0100
@@ -551,14 +551,14 @@
 dnl *** FLAC ***
 translit(dnm, m, l) AM_CONDITIONAL(USE_FLAC, true)
 GST_CHECK_FEATURE(FLAC, [FLAC lossless audio], flac, [
-  GST_CHECK_LIBHEADER(FLAC, FLAC, FLAC__seekable_stream_encoder_new, -lm, FLAC/all.h, FLAC_LIBS="-lFLAC -lm")
+  GST_CHECK_LIBHEADER(FLAC, FLAC, FLAC__stream_encoder_new, -lm -logg, FLAC/all.h, FLAC_LIBS="-lFLAC -lm -logg")
   dnl API change in FLAC 1.1.1, so require that...
   dnl (this check will also fail with FLAC 1.1.3 which changed API again
   dnl and with which our plugin does not compile or work yet)
   if test x$HAVE_FLAC = xyes; then
-    AC_CHECK_DECL(FLAC__SEEKABLE_STREAM_ENCODER_TELL_ERROR,
+    AC_CHECK_DECL(FLAC__STREAM_ENCODER_TELL_STATUS_ERROR,
                   HAVE_FLAC="yes", HAVE_FLAC="no", [
-#include <FLAC/seekable_stream_encoder.h>
+#include <FLAC/stream_encoder.h>
                   ])
   fi
   AC_SUBST(FLAC_LIBS)

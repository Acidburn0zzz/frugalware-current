diff --git a/dracut b/dracut
index cf27b23..4bc0db3 100755
--- a/dracut
+++ b/dracut
@@ -59,6 +59,8 @@ Creates initial ramdisk images for preloading modules
   --nomdadmconf         Do not include local /etc/mdadm.conf
   --lvmconf             Include local /etc/lvm/lvm.conf
   --nolvmconf           Do not include local /etc/lvm/lvm.conf
+  --fscks [LIST]        Add a space-separated list of fsck helpers.
+  --nofscks             Inhibit installation of any fsck helpers.
   -h, --help            This message
   --debug               Output debug information of the build process
   --profile             Output profile information of the build process
@@ -204,12 +206,12 @@ while (($# > 0)); do
         --filesystems) push_arg filesystems_l        "$@" || shift;;
         -I|--install)  push_arg install_items        "$@" || shift;;
         --fwdir)       push_arg fw_dir_l             "$@" || shift;;
+        --fscks)       push_arg fscks_l              "$@" || shift;;
+        --nofscks)     nofscks_l="yes";;
         -k|--kmoddir)  read_arg drivers_dir_l        "$@" || shift;;
         -c|--conf)     read_arg conffile             "$@" || shift;;
         --confdir)     read_arg confdir              "$@" || shift;;
         -L|--stdlog)   read_arg stdloglvl_l          "$@" || shift;;
-        -I|--install)  read_arg install_items        "$@" || shift;;
-        --fwdir)       read_arg fw_dir_l             "$@" || shift;;
         --compress)    read_arg compress_l           "$@" || shift;;
         --prefix)      read_arg prefix_l             "$@" || shift;;
         -f|--force)    force=yes;;
@@ -265,6 +267,7 @@ fi
 
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
 export PATH
+unset LD_LIBRARY_PATH
 
 [[ $debug ]] && {
     export PS4='${BASH_SOURCE}@${LINENO}(${FUNCNAME[0]}): ';
@@ -323,6 +326,12 @@ if (( ${#add_drivers_l[@]} )); then
     done
 fi
 
+if (( ${#fscks_l[@]} )); then
+    while pop fscks_l val; do
+        fscks+=" $val "
+    done
+fi
+
 # these options override the stuff in the config file
 if (( ${#dracutmodules_l[@]} )); then
     dracutmodules=''
@@ -378,6 +387,7 @@ stdloglvl=$((stdloglvl + verbosity_mod_l))
 [[ $do_strip ]] || do_strip=no
 [[ $compress_l ]] && compress=$compress_l
 [[ $show_modules_l ]] && show_modules=$show_modules_l
+[[ $nofscks_l ]] && nofscks="yes"
 # eliminate IFS hackery when messing with fw_dir
 fw_dir=${fw_dir//:/ }
 
@@ -406,6 +416,13 @@ else
     exit 1
 fi
 
+# Verify bash version, curret minimum is 3.1
+if (( ${BASH_VERSINFO[0]} < 3 ||
+    ( ${BASH_VERSINFO[0]} == 3 && ${BASH_VERSINFO[1]} < 1 ) )); then
+    dfatal 'You need at least Bash 3.1 to use dracut, sorry.'
+    exit 1
+fi
+
 dracutfunctions=$dracutbasedir/dracut-functions
 export dracutfunctions
 
@@ -471,6 +488,10 @@ fi
 
 readonly TMPDIR=/var/tmp
 readonly initdir=$(mktemp --tmpdir=/var/tmp/ -d -t initramfs.XXXXXX)
+[ -d "$initdir" ] || {
+    dfatal "mktemp failed."
+    exit 1
+}
 
 # clean up after ourselves no matter how we die.
 trap 'ret=$?;[[ $keep ]] && echo "Not removing $initdir." >&2 || rm -rf "$initdir";exit $ret;' EXIT
@@ -483,7 +504,7 @@ chmod 755 "$initdir"
 export initdir dracutbasedir dracutmodules drivers \
     fw_dir drivers_dir debug no_kernel kernel_only \
     add_drivers mdadmconf lvmconf filesystems \
-    use_fstab libdir usrlibdir \
+    use_fstab libdir usrlibdir fscks nofscks \
     stdloglvl sysloglvl fileloglvl kmsgloglvl logfile \
     debug
 
@@ -509,7 +530,7 @@ if [[ $kernel_only != yes ]]; then
         fi
     done
 
-    for d in proc sys sysroot root run run/lock run/initramfs; do
+    for d in dev proc sys sysroot root run run/lock run/initramfs; do
         if [ -h "/$d" ]; then
             inst "/$d"
         else
@@ -642,14 +663,14 @@ type hardlink &>/dev/null && {
 
 if strstr "$modules_loaded" " fips " && command -v prelink >/dev/null; then
     for i in $initdir/bin/* \
-       $initdir/bin/* \
+       $initdir/sbin/* \
        $initdir/usr/bin/* \
        $initdir/usr/sbin/*; do
        [ -x $i ] && prelink -u $i &>/dev/null
     done
 fi
 
-if ! ( cd "$initdir"; find . |cpio -R 0:0 -H newc -o --quiet | \
+if ! ( cd "$initdir"; find . |cpio -R 0:0 -H newc -o --quiet| \
     $compress > "$outfile"; ); then
     dfatal "dracut: creation of $outfile failed"
     exit 1
diff --git a/dracut-functions b/dracut-functions
index 936d3c3..a5d6d1f 100755
--- a/dracut-functions
+++ b/dracut-functions
@@ -83,28 +83,30 @@ print_vars() {
 }
 
 normalize_path() {
-    p=$1
-    while [[ ${p#*//*} != $p ]]; do
-        p=${p/\/\///}
-    done
-    echo $p
+    shopt -q -s extglob
+    set -- "${1//+(\/)//}"
+    shopt -q -u extglob
+    echo "${1%/}"
 }
 
 convert_abs_rel() {
-    local __current __absolute __abssize __cursize __i __level __newpath
+    local __current __absolute __abssize __cursize __newpath __oldifs
+    local -i __i __level
 #    PS4='${BASH_SOURCE}@${LINENO}(${FUNCNAME[0]}): ';
 
-    if [[ "$1" == "$2" ]]
-    then
-        echo "."
-        return
-    fi
-    __current=$(normalize_path "$1")
-    __absolute=$(normalize_path "$2")
-    IFS="/"
+    set -- "$(normalize_path "$1")" "$(normalize_path "$2")"
+
+    # corner case #1 - self looping link
+    [[ "$1" == "$2" ]] && { echo "${1##*/}"; return; }
 
-    __current=($__current)
-    __absolute=($__absolute)
+    # corner case #2 - own dir link
+    [[ "${1%/*}" == "$2" ]] && { echo "."; return; }
+
+    __oldifs="$IFS"
+    IFS="/"
+    __current=($1)
+    __absolute=($2)
+    IFS="$__oldifs"
 
     __abssize=${#__absolute[@]}
     __cursize=${#__current[@]}
@@ -266,26 +268,20 @@ check_vol_slaves() {
 }
 
 # Install a directory, keeping symlinks as on the original system.
-# Example: if /lib64 points to /lib on the host, "inst_dir /lib/file"
+# Example: if /lib points to /lib64 on the host, "inst_dir /lib/file"
 # will create ${initdir}/lib64, ${initdir}/lib64/file,
 # and a symlink ${initdir}/lib -> lib64.
 inst_dir() {
-    local _file=""
-    local _oldifs="$IFS"
-    local _part
-    local _dir="$1"
-    IFS="/"
-    set -- $_dir
-    IFS=$_oldifs
-    _dir="$@"
-    [[ -e ${initdir}$_dir ]] && return 0
+    [[ -e ${initdir}/"$1" ]] && return 0  # already there
 
-    # iterate over parent directories
-    for _part in $_dir; do
-        [[ $_part ]] || continue
-        _file="$_file/$_part"
-        [[ -e ${initdir}$_file ]] && continue
+    local _dir="$1" _part="${1%/*}" _file
+    while [[ "$_part" != "${_part%/*}" ]] && ! [[ -e "${initdir}/${_part}" ]]; do
+        _dir="$_part $_dir"
+        _part=${_part%/*}
+    done
 
+    # iterate over parent directories
+    for _file in $_dir; do
         if [[ -L $_file ]]; then
             # create link as the original
             local target=$(readlink -f "$_file")
@@ -294,12 +290,12 @@ inst_dir() {
             inst_dir "$target"
             inst_symlink "$_file"
         else
-            [[ -h ${initdir}$_file ]] && _file=$(readlink "${initdir}$_file")
+            [[ -h ${initdir}/$_file ]] && _file=$(readlink "${initdir}/$_file")
             # create directory
-            mkdir -m 0755 -p "${initdir}$_file" || return 1
+            [[ -e "${initdir}/$_file" ]] || mkdir -m 0755 -p "${initdir}/$_file" || return 1
             if [[ -d "$_file" ]]; then
-                chmod --reference="$_file" "${initdir}$_file"
-                chmod u+w "${initdir}$_file"
+                chmod --reference="$_file" "${initdir}/$_file"
+                chmod u+w "${initdir}/$_file"
             fi
         fi
     done
@@ -310,20 +306,21 @@ inst_dir() {
 # Location of the image dir is assumed to be $initdir
 # We never overwrite the target if it exists.
 inst_simple() {
-    local _src target
-    [[ -f $1 ]] || return 1
-    _src=$1 target="${2:-$1}"
-    if ! [[ -d ${initdir}$target ]]; then
-        [[ -e ${initdir}$target ]] && return 0
-        [[ -h ${initdir}$target ]] && return 0
+    [[ -f "$1" ]] || return 1
+    strstr "$1" "/" || return 1
+
+    local _src=$1 target="${2:-$1}"
+    if ! [[ -d ${initdir}/$target ]]; then
+        [[ -e ${initdir}/$target ]] && return 0
+        [[ -h ${initdir}/$target ]] && return 0
         inst_dir "${target%/*}"
     fi
     # install checksum files also
     if [[ -e "${_src%/*}/.${_src##*/}.hmac" ]]; then
-        inst_simple "${_src%/*}/.${_src##*/}.hmac" "${target%/*}/.${target##*/}.hmac"
+        inst "${_src%/*}/.${_src##*/}.hmac" "${target%/*}/.${target##*/}.hmac"
     fi
     ddebug "Installing $_src"
-    cp -pfL "$_src" "${initdir}$target" 
+    cp --sparse=always -pfL "$_src" "${initdir}/$target" 
 }
 
 # find symlinks linked to given library file
@@ -355,24 +352,25 @@ rev_lib_symlinks() {
 # It handles making symlinks according to how the original library
 # is referenced.
 inst_library() {
-    local _src=$1 _dest=${2:-$1} _lib _reallib _symlink
-    [[ -e $initdir$_dest ]] && return 0
+    local _src="$1" _dest=${2:-$1} _lib _reallib _symlink
+    strstr "$1" "/" || return 1
+    [[ -e $initdir/$_dest ]] && return 0
     if [[ -L $_src ]]; then
         # install checksum files also
         if [[ -e "${_src%/*}/.${_src##*/}.hmac" ]]; then
-            inst_simple "${_src%/*}/.${_src##*/}.hmac" "${_dest%/*}/.${_dest##*/}.hmac"
+            inst "${_src%/*}/.${_src##*/}.hmac" "${_dest%/*}/.${_dest##*/}.hmac"
         fi
         _reallib=$(readlink -f "$_src")
         inst_simple "$_reallib" "$_reallib"
         inst_dir "${_dest%/*}"
-        ln -sfn $(convert_abs_rel "${_dest}" "${_reallib}") "${initdir}${_dest}"
+        ln -sfn $(convert_abs_rel "${_dest}" "${_reallib}") "${initdir}/${_dest}"
     else
         inst_simple "$_src" "$_dest"
     fi
 
     # Create additional symlinks.  See rev_symlinks description.
     for _symlink in $(rev_lib_symlinks $_src) $(rev_lib_symlinks $_reallib); do
-        [[ ! -e $initdir$_symlink ]] && {
+        [[ ! -e $initdir/$_symlink ]] && {
             ddebug "Creating extra symlink: $_symlink"
             inst_symlink $_symlink
         }
@@ -400,7 +398,7 @@ inst_binary() {
     _bin=$(find_binary "$1") || return 1
     _target=${2:-$_bin}
     inst_symlink $_bin $_target && return 0
-    [[ -e $initdir$_target ]] && return 0
+    [[ -e $initdir/$_target ]] && return 0
 
     # If the binary being installed is also a library, add it to the loop.
     _so_regex='([^ ]*/lib[^/]*/[^ ]*\.so[^ ]*)'
@@ -418,7 +416,7 @@ inst_binary() {
         fi
         [[ $_line =~ $_so_regex ]] || continue
         _file=${BASH_REMATCH[1]}
-        [[ -e ${initdir}$_file ]] && continue
+        [[ -e ${initdir}/$_file ]] && continue
 
         # See if we are loading an optimized version of a shared lib.
         if [[ $_file =~ $_lib_regex ]]; then
@@ -443,19 +441,22 @@ inst_binary() {
 # same as above, except for shell scripts.
 # If your shell script does not start with shebang, it is not a shell script.
 inst_script() {
-    [[ -f $1 ]] || return 1
+    local _bin
+    _bin=$(find_binary "$1") || return 1
+    shift
     local _line _shebang_regex
-    read -r -n 80 _line <"$1"
+    read -r -n 80 _line <"$_bin"
     # If debug is set, clean unprintable chars to prevent messing up the term
     [[ $debug ]] && _line=$(echo -n "$_line" | tr -c -d '[:print:][:space:]')
     _shebang_regex='(#! *)(/[^ ]+).*'
     [[ $_line =~ $_shebang_regex ]] || return 1
-    inst "${BASH_REMATCH[2]}" && inst_simple "$@"
+    inst "${BASH_REMATCH[2]}" && inst_binary "$_bin" "$@"
 }
 
 # same as above, but specialized for symlinks
 inst_symlink() {
-    local _src=$1 _target=$initdir${2:-$1} _realsrc
+    local _src=$1 _target=$initdir/${2:-$1} _realsrc
+    strstr "$1" "/" || return 1
     [[ -L $1 ]] || return 1
     [[ -L $_target ]] && return 0
     _realsrc=$(readlink -f "$_src")
@@ -480,12 +481,14 @@ inst_rules() {
     inst_dir "/lib/udev/rules.d"
     inst_dir "$_target"
     for _rule in "$@"; do
-        for r in /lib/udev/rules.d /etc/udev/rules.d; do
-            if [[ -f $r/$_rule ]]; then
-                _found="$r/$_rule"
-                inst_simple "$_found"
-            fi
-        done
+        if [ "${rule#/}" = "$rule" ]; then
+            for r in /lib/udev/rules.d /etc/udev/rules.d; do
+                if [[ -f $r/$_rule ]]; then
+                    _found="$r/$_rule"
+                    inst_simple "$_found"
+                fi
+            done
+        fi
         for r in '' ./ $dracutbasedir/rules.d/; do
             if [[ -f ${r}$_rule ]]; then
                 _found="${r}$_rule"
@@ -518,7 +521,7 @@ inst() {
 
 [[ $hookdirs ]] || {
     hookdirs="cmdline pre-udev pre-trigger netroot initqueue pre-mount"
-    hookdirs+=" pre-pivot mount emergency emergency-shutdown shutdown"
+    hookdirs+=" pre-pivot mount emergency shutdown-emergency shutdown"
     export hookdirs
 }
 
@@ -537,6 +540,34 @@ inst_hook() {
     inst_simple "$3" "/lib/dracut/hooks/${1}/${2}${3##*/}"
 }
 
+# install any of listed files
+#
+# If first argument is '-d' and second some destination path, first accessible
+# source is installed into this path, otherwise it will installed in the same
+# path as source.  If none of listed files was installed, function return 1.
+# On first successful installation it returns with 0 status.
+#
+# Example:
+#
+# inst_any -d /bin/foo /bin/bar /bin/baz
+#
+# Lets assume that /bin/baz exists, so it will be installed as /bin/foo in
+# initramfs.
+inst_any() {
+    local to f
+
+    [[ $1 = '-d' ]] && to="$2" && shift 2
+
+    for f in "$@"; do
+        if [[ -e $f ]]; then
+            [[ $to ]] && inst "$f" "$to" && return 0
+            inst "$f" && return 0
+        fi
+    done
+
+    return 1
+}
+
 dracut_install() {
     local _optional=no
     if [[ $1 = '-o' ]]; then
@@ -760,13 +791,14 @@ check_module_dir() {
 # Install a single kernel module along with any firmware it may require.
 # $1 = full path to kernel module to install
 install_kmod_with_fw() {
-    local _modname=${1##*/} _fwdir _found _fw
-    _modname=${_modname%.ko*}
     # no need to go further if the module is already installed
     [[ -e "${initdir}/lib/modules/$kernel/${1##*/lib/modules/$kernel/}" ]] \
         && return 0
     inst_simple "$1" "/lib/modules/$kernel/${1##*/lib/modules/$kernel/}" \
         || return $?
+
+    local _modname=${1##*/} _fwdir _found _fw
+    _modname=${_modname%.ko*}
     for _fw in $(modinfo -k $kernel -F firmware $1 2>/dev/null); do
         _found=''
         for _fwdir in $fw_dir; do
@@ -794,10 +826,11 @@ install_kmod_with_fw() {
 #      It will be passed the full path to the found kernel module
 # $2 = module to get dependencies for
 # rest of args = arguments to modprobe
+# _fderr specifies FD passed from surrounding scope
 for_each_kmod_dep() {
     local _func=$1 _kmod=$2 _cmd _modpath _options _found=0
     shift 2
-    modprobe "$@" --ignore-install --show-depends $_kmod 2>"$initdir/modprobe.err" | (
+    modprobe "$@" --ignore-install --show-depends $_kmod 2>&${_fderr} | (
         while read _cmd _modpath _options; do
             [[ $_cmd = insmod ]] || continue
             $_func ${_modpath} || exit $?
@@ -806,9 +839,6 @@ for_each_kmod_dep() {
         [[ $_found -eq 0 ]] && exit 1
         exit 0
     )
-    egrep -v 'FATAL: Module .* not found.' "$initdir/modprobe.err" | derror
-    rm -f "$initdir/modprobe.err"
-    return $?
 }
 
 # filter kernel modules to install certain modules that meet specific
@@ -840,85 +870,96 @@ filter_kernel_modules_by_path () (
         esac
     done
 )
-
-# filter kernel modules to install certain modules that meet specific
-# requirements.
-# $1 = function to call with module name to filter.
-#      This function will be passed the full path to the module to test.
-# The behaviour of this function can vary depending on whether $hostonly is set.
-# If it is, we will only look at modules that are already in memory.
-# If it is not, we will look at all kernel modules
-# This function returns the full filenames of modules that match $1
-filter_kernel_modules () (
-    local _modname _filtercmd
+find_kernel_modules_by_path () (
     if ! [[ $hostonly ]]; then
-        _filtercmd='find "$srcmods/kernel/drivers" "$srcmods/extra"'
-        _filtercmd+=' "$srcmods/weak-updates" -name "*.ko" -o -name "*.ko.gz"'
-        _filtercmd+=' 2>/dev/null'
+        find "$srcmods/kernel/$1" "$srcmods/extra" "$srcmods/weak-updates" \
+          -name "*.ko" -o -name "*.ko.gz" 2>/dev/null
     else
-        _filtercmd='cut -d " " -f 1 </proc/modules|xargs modinfo -F filename '
-        _filtercmd+='-k $kernel 2>/dev/null'
+        cut -d " " -f 1 </proc/modules \
+        | xargs modinfo -F filename -k $kernel 2>/dev/null
     fi
-    for _modname in $(eval $_filtercmd); do
-        case $_modname in
-            *.ko) "$1" "$_modname" && echo "$_modname";;
-            *.ko.gz) gzip -dc "$_modname" > $initdir/$$.ko
-                $1 $initdir/$$.ko && echo "$_modname"
-                rm -f $initdir/$$.ko
-                ;;
-        esac
-    done
 )
 
+filter_kernel_modules () {
+    filter_kernel_modules_by_path  drivers  "$1"
+}
+
+find_kernel_modules () {
+    find_kernel_modules_by_path  drivers
+}
+
 # install kernel modules along with all their dependencies.
 instmods() {
     [[ $no_kernel = yes ]] && return
-    local _mod _mpargs _moddirname
-    local _ret=0
-    while (($# > 0)); do
-        _mod=${1%.ko*}
+    # called [sub]functions inherit _fderr
+    local _fderr=9
+
+    function inst1mod() {
+        local _mod="$1"
         case $_mod in
             =*)
                 # This introduces 2 incompatible meanings for =* arguments
                 # to instmods.  We need to decide which one to keep.
                 if [[ $_mod = =ata && -f $srcmods/modules.block ]]; then
-                    instmods $_mpargs \
-                        $(egrep 'ata|ahci' "${srcmods}/modules.block")
+                    ( [[ "$_mpargs" ]] && echo $_mpargs
+                      egrep 'ata|ahci' "${srcmods}/modules.block" ) \
+                    | instmods
                 elif [ -f $srcmods/modules.${_mod#=} ]; then
-                    instmods $_mpargs $(cat ${srcmods}/modules.${_mod#=} )
+                    ( [[ "$_mpargs" ]] && echo $_mpargs
+                      cat "${srcmods}/modules.${_mod#=}" ) \
+                    | instmods
                 else
-                    instmods $_mpargs $(find "$srcmods" -path "*/${_mod#=}/*")
+                    ( [[ "$_mpargs" ]] && echo $_mpargs
+                      find "$srcmods" -path "*/${_mod#=}/*" ) \
+                    | instmods
                 fi
                 ;;
-            --*)
-                _mod=${_mod##*/}
-                _mpargs+=" $_mod";;
-            i2o_scsi) shift; continue;; # Do not load this diagnostic-only module
+            --*) _mpargs+=" $_mod" ;;
+            i2o_scsi) return ;; # Do not load this diagnostic-only module
             *)  _mod=${_mod##*/}
+
                 # if we are already installed, skip this module and go on
                 # to the next one.
-                [[ -f $initdir/$1 ]] && { shift; continue; }
+                [[ -f $initdir/$1 ]] && return
+
                 # If we are building a host-specific initramfs and this
                 # module is not already loaded, move on to the next one.
                 [[ $hostonly ]] && ! grep -qe "\<${_mod//-/_}\>" /proc/modules \
-                    && ! echo $add_drivers | grep -qe "\<${_mod}\>" && {
-                        shift; continue
-                    }
+                    && ! echo $add_drivers | grep -qe "\<${_mod}\>" \
+                    && return
 
                 # We use '-d' option in modprobe only if modules prefix path
                 # differs from default '/'.  This allows us to use Dracut with
                 # old version of modprobe which doesn't have '-d' option.
-                _moddirname=${srcmods%%/lib/modules/*}
+                local _moddirname=${srcmods%%/lib/modules/*}
                 [[ -n ${_moddirname} ]] && _moddirname="-d ${_moddirname}/"
 
                 # ok, load the module, all its dependencies, and any firmware
                 # it may require
                 for_each_kmod_dep install_kmod_with_fw $_mod \
-                    --set-version $kernel ${_moddirname}
+                    --set-version $kernel ${_moddirname} $_mpargs
                 ((_ret+=$?))
                 ;;
         esac
-        shift
-    done
-    return $_ret
+    }
+
+    function instmods_1() {
+        local _ret=0 _mod _mpargs
+        if (($# == 0)); then  # filenames from stdin
+            while read _mod; do
+                inst1mod "${_mod%.ko*}"
+            done
+        fi
+        while (($# > 0)); do  # filenames as arguments
+            inst1mod ${1%.ko*}
+            shift
+        done
+        return $_ret
+    }
+
+    # Capture all stderr from modprobe to _fderr. We could use {var}>...
+    # redirections, but that would make dracut require bash4 at least.
+    eval "( instmods_1 \"\$@\" ) ${_fderr}>&1" \
+    | egrep -v 'FATAL: Module .* not found.' | derror
+    return $?
 }
diff --git a/dracut-logger b/dracut-logger
index d85cbaf..f1b3a7e 100755
--- a/dracut-logger
+++ b/dracut-logger
@@ -271,12 +271,8 @@ _dlvl2syslvl() {
 #   - @c INFO to @c info
 #   - @c DEBUG and @c TRACE both to @c debug
 _do_dlog() {
-    [ -z "$maxloglvl" ] && return 0
     local lvl="$1"; shift
     local lvlc=$(_lvl2char "$lvl") || return 0
-
-    [ $lvl -le $maxloglvl ] || return 0
-
     local msg="$lvlc: $*"
 
     [ $lvl -le $stdloglvl ] && echo "$msg" >&2
@@ -307,6 +303,9 @@ _do_dlog() {
 # dwarn "This is a warning"
 # echo "This is a warning" | dwarn
 dlog() {
+    [ -z "$maxloglvl" ] && return 0
+    [ $1 -le $maxloglvl ] || return 0
+
     if [ $# -gt 1 ]; then
         _do_dlog "$@"
     else
@@ -314,7 +313,6 @@ dlog() {
             _do_dlog "$1" "$line"
         done
     fi
-    [ -n "$debug" ] && set -x || :
 }
 
 ## @brief Logs message at TRACE level (6)
@@ -324,6 +322,7 @@ dlog() {
 dtrace() {
     set +x
     dlog 6 "$@"
+    [ -n "$debug" ] && set -x || :
 }
 
 ## @brief Logs message at DEBUG level (5)
@@ -333,6 +332,7 @@ dtrace() {
 ddebug() {
     set +x
     dlog 5 "$@"
+    [ -n "$debug" ] && set -x || :
 }
 
 ## @brief Logs message at INFO level (4)
@@ -342,6 +342,7 @@ ddebug() {
 dinfo() {
     set +x
     dlog 4 "$@"
+    [ -n "$debug" ] && set -x || :
 }
 
 ## @brief Logs message at WARN level (3)
@@ -351,6 +352,7 @@ dinfo() {
 dwarn() {
     set +x
     dlog 3 "$@"
+    [ -n "$debug" ] && set -x || :
 }
 
 ## @brief It's an alias to dwarn() function.
@@ -360,6 +362,7 @@ dwarn() {
 dwarning() {
     set +x
     dwarn "$@"
+    [ -n "$debug" ] && set -x || :
 }
 
 ## @brief Logs message at ERROR level (2)
@@ -369,6 +372,7 @@ dwarning() {
 derror() {
     set +x
     dlog 2 "$@"
+    [ -n "$debug" ] && set -x || :
 }
 
 ## @brief Logs message at FATAL level (1)
@@ -378,4 +382,5 @@ derror() {
 dfatal() {
     set +x
     dlog 1 "$@"
+    [ -n "$debug" ] && set -x || :
 }
diff --git a/dracut.8.xml b/dracut.8.xml
index 11ea8c3..d4689ee 100644
--- a/dracut.8.xml
+++ b/dracut.8.xml
@@ -1,5 +1,6 @@
 <?xml version='1.0' encoding='UTF-8'?>
 <!-- This document was created with Syntext Serna Free. --><!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
+<!-- vim: set ts=8 sts=2 sw=2 et: -->
 <refentry id="dracut8">
   <refentryinfo>
     <title>dracut</title>
@@ -229,6 +230,41 @@ include in the generic initramfs. This parameter can be specified multiple times
         </varlistentry>
         <varlistentry>
           <term>
+            <option>--lvmconf</option>
+          </term>
+          <listitem>
+            <para>include local <filename>/etc/lvm/lvm.conf</filename></para>
+          </listitem>
+        </varlistentry>
+        <varlistentry>
+          <term>
+            <option>--nolvmconf</option>
+          </term>
+          <listitem>
+            <para>do not include local <filename>/etc/lvm/lvm.conf</filename></para>
+          </listitem>
+        </varlistentry>
+        <varlistentry>
+          <term>
+            <option>--fscks [LIST]</option>
+          </term>
+          <listitem>
+            <para>add a space-separated list of fsck tools, in addition to
+              <filename>dracut.conf</filename>'s specification; the
+              installation is opportunistic (non-existing tools are ignored)
+            </para>
+          </listitem>
+        </varlistentry>
+        <varlistentry>
+          <term>
+            <option>--nofscks</option>
+          </term>
+          <listitem>
+            <para>inhibit installation of any fsck tools</para>
+          </listitem>
+        </varlistentry>
+        <varlistentry>
+          <term>
             <option>--strip</option>
           </term>
           <listitem>
@@ -245,10 +281,10 @@ include in the generic initramfs. This parameter can be specified multiple times
         </varlistentry>
         <varlistentry>
           <term>
-            <option>--prefix</option>
+            <option>--prefix&nbsp;<replaceable>&lt;dir&gt;</replaceable></option>
           </term>
           <listitem>
-            <para>prefix initramfs files with /run/initramfs/</para>
+            <para>prefix initramfs files with the specified directory</para>
           </listitem>
         </varlistentry>
         <varlistentry>
@@ -256,7 +292,7 @@ include in the generic initramfs. This parameter can be specified multiple times
             <option>--noprefix</option>
           </term>
           <listitem>
-            <para>do not prefix initramfs files with /run/initramfs/ (default)</para>
+            <para>do not prefix initramfs files (default)</para>
           </listitem>
         </varlistentry>
         <varlistentry>
diff --git a/dracut.conf b/dracut.conf
index 8684328..a502066 100644
--- a/dracut.conf
+++ b/dracut.conf
@@ -29,3 +29,12 @@ mdadmconf="yes"
 
 # install local /etc/lvm/lvm.conf
 lvmconf="yes"
+
+# A list of fsck tools to install. If it's not specified, module's hardcoded
+# default is used, currently: "umount mount /sbin/fsck* xfs_db xfs_check
+# xfs_repair e2fsck jfs_fsck reiserfsck btrfsck". The installation is
+# opportunistic, so non-existing tools are just ignored.
+#fscks=""
+
+# inhibit installation of any fsck tools
+#nofscks="yes"
diff --git a/dracut.conf.5.xml b/dracut.conf.5.xml
index 697e655..169e11b 100644
--- a/dracut.conf.5.xml
+++ b/dracut.conf.5.xml
@@ -1,5 +1,6 @@
 <?xml version='1.0' encoding='UTF-8'?>
 <!-- This document was created with Syntext Serna Free. --><!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
+<!-- vim: set ts=8 sts=2 sw=2 et: -->
 <refentry id="dracutconf5">
   <refentryinfo>
     <title>dracut.conf</title>
@@ -156,6 +157,27 @@ initramfs.</para>
       </varlistentry>
       <varlistentry>
         <term>
+          <envar>fscks=&quot;&nbsp;<replaceable>&lt;fsck tools&gt;</replaceable>&nbsp;&quot;</envar>
+        </term>
+        <listitem>
+          <para>Add a space-separated list of fsck tools. If nothing is
+            specified, the default is: &quot;<replaceable>umount mount
+            /sbin/fsck* xfs_db xfs_check xfs_repair e2fsck jfs_fsck
+            reiserfsck btrfsck</replaceable>&quot;
+          </para>
+          <para>The installation is opportunistic (non-existing tools are ignored).</para>
+        </listitem>
+      </varlistentry>
+      <varlistentry>
+        <term>
+          <envar>nofscks=&quot;<replaceable>{yes}</replaceable>&quot;</envar>
+        </term>
+        <listitem>
+          <para>If specified, inhibit installation of any fsck tools.</para>
+        </listitem>
+      </varlistentry>
+      <varlistentry>
+        <term>
           <envar>kernel_only=&quot;<replaceable>{yes|no}</replaceable>&quot;</envar>
         </term>
         <listitem>
diff --git a/dracut.kernel.7.xml b/dracut.kernel.7.xml
index 894b640..7cd7b81 100644
--- a/dracut.kernel.7.xml
+++ b/dracut.kernel.7.xml
@@ -1,5 +1,6 @@
 <?xml version='1.0' encoding='UTF-8'?>
 <!-- This document was created with Syntext Serna Free. --><!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" []>
+<!-- vim: set ts=8 sts=2 sw=2 et: -->
 <refentry id="dracutkernel7">
   <refentryinfo>
     <title>dracut.kernel</title>
@@ -343,6 +344,12 @@ This parameter can be specified multiple times.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
+          <term><envar>rd.md.ddf</envar>=0</term>
+          <listitem>
+            <para>disable MD RAID for SNIA ddf raids, use DM RAID instead</para>
+          </listitem>
+        </varlistentry>
+        <varlistentry>
           <term>
             <envar>rd.md.conf</envar>=0
           </term>
@@ -696,11 +703,17 @@ rd.znet=ctc,0.0.0600,0.0.0601,0.0.0602,protocol=bar</programlisting></para>
       <title>Plymouth Boot Splash</title>
       <variablelist>
         <varlistentry>
-          <term><envar>rd.plymouth</envar>=0</term>
+          <term><envar>plymouth.enable</envar>=0</term>
           <listitem>
             <para>disable the plymouth bootsplash.</para>
           </listitem>
         </varlistentry>
+        <varlistentry>
+          <term><envar>rd.plymouth</envar>=0</term>
+          <listitem>
+            <para>disable the plymouth bootsplash only for the initramfs.</para>
+          </listitem>
+        </varlistentry>
       </variablelist>
     </refsect2>
    <refsect2>
@@ -1256,6 +1269,14 @@ set in the configuration files.</para>
           <para>Can contain additional command line options.</para>
         </listitem>
       </varlistentry>
+      <varlistentry>
+        <term>
+          <filename>/etc/cmdline.d/*.conf</filename>
+        </term>
+        <listitem>
+          <para>Can contain additional command line options.</para>
+        </listitem>
+      </varlistentry>
     </variablelist>
   </refsect1>
   <refsect1>
diff --git a/dracut.spec b/dracut.spec
index 4a71942..eaa39a0 100644
--- a/dracut.spec
+++ b/dracut.spec
@@ -11,7 +11,7 @@ Version: xxx
 Release: xxx
 
 Summary: Initramfs generator using udev
-%if 0%{?fedora}
+%if 0%{?fedora} || 0%{?rhel} > 6
 Group: System Environment/Base
 %endif
 %if 0%{?suse_version}
@@ -24,15 +24,15 @@ URL: https://dracut.wiki.kernel.org/
 Source0: http://www.kernel.org/pub/linux/utils/boot/dracut/dracut-%{version}.tar.bz2
 
 BuildArch: noarch
-BuildRequires: dash bash
-%if 0%{?fedora}
+BuildRequires: dash bash git
+%if 0%{?fedora} || 0%{?rhel} > 6
 BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)
 %endif
 %if 0%{?suse_version}
 BuildRoot: %{_tmppath}/%{name}-%{version}-build
 %endif
 
-%if 0%{?fedora}
+%if 0%{?fedora} || 0%{?rhel} > 6
 BuildRequires: docbook-style-xsl docbook-dtds libxslt
 %endif
 
@@ -72,18 +72,13 @@ Requires: module-init-tools >= 3.7-9
 Requires: sed
 Requires: tar
 Requires: udev
+Requires: util-linux >= 2.20
 
-%if 0%{?fedora}
-Requires: util-linux >= 2.16
+%if 0%{?fedora} || 0%{?rhel} > 6
 Requires: initscripts >= 8.63-1
 Requires: plymouth >= 0.8.0-0.2009.29.09.19.1
 %endif
 
-%if 0%{?suse_version}
-Requires: util-linux >= 2.16
-%endif
-
-
 %description
 Dracut contains tools to create a bootable initramfs for 2.6 Linux kernels.
 Unlike existing implementations, dracut does hard-code as little as possible
@@ -101,7 +96,7 @@ Requires: nbd
 Requires: iproute
 Requires: bridge-utils
 
-%if 0%{?fedora}
+%if 0%{?fedora} || 0%{?rhel} > 6
 Requires: iscsi-initiator-utils
 Requires: nfs-utils
 Requires: dhclient
@@ -119,7 +114,7 @@ Provides:  dracut-generic = %{version}-%{release}
 This package requires everything which is needed to build a generic
 all purpose initramfs with network support with dracut.
 
-%if 0%{?fedora}
+%if 0%{?fedora} || 0%{?rhel} > 6
 %package fips
 Summary: Dracut modules to build a dracut initramfs with an integrity check
 Requires: %{name} = %{version}-%{release}
@@ -155,12 +150,20 @@ This package contains tools to assemble the local initrd and host configuration.
 
 %prep
 %setup -q -n %{name}-%{version}
+git init
+git config user.email "dracut-maint@redhat.com"
+git config user.name "Fedora dracut team"
+git add .
+git commit -a -q -m "%{version} baseline."
+
+# Apply all the patches.
+git am -p1 %{patches}
 
 %build
 make
 
 %install
-%if 0%{?fedora}
+%if 0%{?fedora} || 0%{?rhel} > 6
 rm -rf $RPM_BUILD_ROOT
 %endif
 make install DESTDIR=$RPM_BUILD_ROOT sbindir=/sbin \
@@ -168,7 +171,7 @@ make install DESTDIR=$RPM_BUILD_ROOT sbindir=/sbin \
 
 echo %{name}-%{version}-%{release} > $RPM_BUILD_ROOT/%{_datadir}/dracut/modules.d/10rpmversion/dracut-version
 
-%if 0%{?fedora} == 0
+%if 0%{?fedora} == 0 && 0%{?rhel} == 0
 rm -fr $RPM_BUILD_ROOT/%{_datadir}/dracut/modules.d/01fips
 %endif
 
@@ -181,7 +184,7 @@ mkdir -p $RPM_BUILD_ROOT%{_localstatedir}/log
 touch $RPM_BUILD_ROOT%{_localstatedir}/log/dracut.log
 mkdir -p $RPM_BUILD_ROOT%{_sharedstatedir}/initramfs
 
-%if 0%{?fedora}
+%if 0%{?fedora} || 0%{?rhel} > 6
 install -m 0644 dracut.conf.d/fedora.conf.example $RPM_BUILD_ROOT/etc/dracut.conf.d/01-dist.conf
 install -m 0644 dracut.conf.d/fips.conf.example $RPM_BUILD_ROOT/etc/dracut.conf.d/40-fips.conf
 %endif
@@ -214,7 +217,7 @@ rm -rf $RPM_BUILD_ROOT
 %{_datadir}/dracut/dracut-functions
 %{_datadir}/dracut/dracut-logger
 %config(noreplace) /etc/dracut.conf
-%if 0%{?fedora} || 0%{?suse_version}
+%if 0%{?fedora} || 0%{?suse_version} || 0%{?rhel} > 6
 %config /etc/dracut.conf.d/01-dist.conf
 %endif
 %dir /etc/dracut.conf.d
@@ -247,6 +250,7 @@ rm -rf $RPM_BUILD_ROOT
 %{_datadir}/dracut/modules.d/95zfcp
 %{_datadir}/dracut/modules.d/95terminfo
 %{_datadir}/dracut/modules.d/95udev-rules
+%{_datadir}/dracut/modules.d/96securityfs
 %{_datadir}/dracut/modules.d/97biosdevname
 %{_datadir}/dracut/modules.d/97masterkey
 %{_datadir}/dracut/modules.d/98ecryptfs
@@ -271,7 +275,7 @@ rm -rf $RPM_BUILD_ROOT
 %{_datadir}/dracut/modules.d/45ifcfg
 %{_datadir}/dracut/modules.d/95znet
 
-%if 0%{?fedora}
+%if 0%{?fedora} || 0%{?rhel} > 6
 %files fips
 %defattr(-,root,root,0755)
 %{_datadir}/dracut/modules.d/01fips
diff --git a/git2spec.pl b/git2spec.pl
index 2ea74c8..9db42aa 100755
--- a/git2spec.pl
+++ b/git2spec.pl
@@ -19,20 +19,12 @@ sub last_tag {
 sub create_patches {
     my $tag=shift;
     my $num=0;
-    open( GIT, 'git format-patch --no-renames -N --no-signature '.$tag.' |');
+    open( GIT, 'git format-patch -N --no-signature '.$tag.' |');
     @lines=<GIT>;
     close GIT;         # be done
     return @lines;
 };
 
-sub filter_patch {
-	my $patch=shift;
-	open(P, $patch);
-	@lines=<P>;
-	close(P);
-	grep (/^ 0 files changed/, @lines);
-}
-
 use POSIX qw(strftime);
 my $datestr = strftime "%Y%m%d", gmtime;
 
@@ -55,22 +47,11 @@ while(<>) {
 	print $_;
 	$num=1;
 	for(@patches) {
-	    next if filter_patch $_;
 	    print "Patch$num: $_";
 	    $num++;
 	}
 	print "\n";
     }
-    elsif (/^%setup/) {
-	print $_;
-	$num=1;
-	for(@patches) {
-	    next if filter_patch $_;
-	    print "%patch$num -p1\n";
-	    $num++;
-	}
-	print "\n";
-    }
     else {
 	print $_;
     }
diff --git a/modules.d/10i18n/console_init b/modules.d/10i18n/console_init
index 110cb0a..b46046b 100755
--- a/modules.d/10i18n/console_init
+++ b/modules.d/10i18n/console_init
@@ -22,6 +22,7 @@ set_terminal() {
         stty -F ${dev} iutf8
     else
         printf '\033%%@' >&7
+        stty -F ${dev} -iutf8
     fi
 }
 
diff --git a/modules.d/10i18n/module-setup.sh b/modules.d/10i18n/module-setup.sh
index 5c09100..6248607 100755
--- a/modules.d/10i18n/module-setup.sh
+++ b/modules.d/10i18n/module-setup.sh
@@ -150,22 +150,24 @@ install() {
             inst_simple ${kbddir}/unimaps/${FONT_UNIMAP}.uni
         fi
 
+        shopt -q -s nocasematch
         if [[ ${UNICODE} ]]
         then
-            if [[ ${UNICODE^^} = YES || ${UNICODE} = 1 ]]
+            if [[ ${UNICODE} = YES || ${UNICODE} = 1 ]]
             then
                 UNICODE=1
-            elif [[ ${UNICODE^^} = NO || ${UNICODE} = 0 ]]
+            elif [[ ${UNICODE} = NO || ${UNICODE} = 0 ]]
             then
                 UNICODE=0
             else
                 UNICODE=''
             fi
         fi
-        if [[ ! ${UNICODE} && ${LANG^^} =~ .*\.UTF-?8 ]]
+        if [[ ! ${UNICODE} && ${LANG} =~ .*\.UTF-?8 ]]
         then
             UNICODE=1
         fi
+        shopt -q -u nocasematch
 
         mksubdirs ${initdir}${I18N_CONF}
         mksubdirs ${initdir}${VCONFIG_CONF}
diff --git a/modules.d/40network/module-setup.sh b/modules.d/40network/module-setup.sh
index 39366b6..fbf6f34 100755
--- a/modules.d/40network/module-setup.sh
+++ b/modules.d/40network/module-setup.sh
@@ -24,15 +24,40 @@ depends() {
 installkernel() {
     # Include wired net drivers, excluding wireless
 
-    net_module_test() {
+    net_module_filter() {
         local _net_drivers='eth_type_trans|register_virtio_device'
         local _unwanted_drivers='/(wireless|isdn|uwb)/'
-        egrep -q $_net_drivers "$1" && \
-            egrep -qv 'iw_handler_get_spy' "$1" && \
-            [[ ! $1 =~ $_unwanted_drivers ]]
+        # subfunctions inherit following FDs
+        local _merge=8 _side2=9
+        function nmf1() {
+            local _fname _fcont
+            while read _fname; do
+                [[ $_fname =~ $_unwanted_drivers ]] && continue
+                case "$_fname" in
+                    *.ko)    _fcont="$(<        $_fname)" ;;
+                    *.ko.gz) _fcont="$(gzip -dc $_fname)" ;;
+                esac
+                [[   $_fcont =~ $_net_drivers
+                && ! $_fcont =~ iw_handler_get_spy ]] \
+                && echo "$_fname"
+            done
+        }
+        function rotor() {
+            local _f1 _f2
+            while read _f1; do
+                echo "$_f1"
+                if read _f2; then
+                    echo "$_f2" 1>&${_side2}
+                fi
+            done | nmf1 1>&${_merge}
+        }
+        # Use two parallel streams to filter alternating modules.
+        set +x
+        eval "( ( rotor ) ${_side2}>&1 | nmf1 ) ${_merge}>&1"
+        [[ $debug ]] && set -x
     }
 
-    instmods $(filter_kernel_modules_by_path drivers/net net_module_test)
+    find_kernel_modules_by_path drivers/net | net_module_filter | instmods
 
     instmods ecb arc4
     # bridge modules
diff --git a/modules.d/40network/netroot b/modules.d/40network/netroot
index 462da51..9d996cc 100755
--- a/modules.d/40network/netroot
+++ b/modules.d/40network/netroot
@@ -119,7 +119,7 @@ if [ -n "$netroot_ip" ]; then
     fi
 fi
 if [ -n "$dest" ] && ! arping -q -f -w 60 -I $netif $dest ; then
-    die "Resolving $dest via ARP on $netif failed"
+    dinfo "Resolving $dest via ARP on $netif failed"
 fi
 
 # Source netroot hooks before we start the handler
diff --git a/modules.d/50plymouth/plymouth-pretrigger.sh b/modules.d/50plymouth/plymouth-pretrigger.sh
index 25ed06f..534948e 100755
--- a/modules.d/50plymouth/plymouth-pretrigger.sh
+++ b/modules.d/50plymouth/plymouth-pretrigger.sh
@@ -2,7 +2,7 @@
 # -*- mode: shell-script; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
 # ex: ts=8 sw=4 sts=4 et filetype=sh
 
-if getargbool 1 rd.plymouth -n rd_NO_PLYMOUTH; then
+if getargbool 1 plymouth.enable && getargbool 1 rd.plymouth -n rd_NO_PLYMOUTH; then
     [ -c /dev/null ] || mknod -m 0666 /dev/null c 1 3
     # first trigger graphics subsystem
     udevadm trigger --action=add --attr-match=class=0x030000 >/dev/null 2>&1
diff --git a/modules.d/90crypt/crypt-lib.sh b/modules.d/90crypt/crypt-lib.sh
old mode 100644
new mode 100755
index 2797a7a..69f14d0
--- a/modules.d/90crypt/crypt-lib.sh
+++ b/modules.d/90crypt/crypt-lib.sh
@@ -47,7 +47,7 @@ ask_for_password() {
 
     { flock -s 9;
         # Prompt for password with plymouth, if installed and running.
-        if [ -x /bin/plymouth ]; then
+        if [ -x /bin/plymouth ] && /bin/plymouth --ping; then
             /bin/plymouth ask-for-password \
                 --prompt "$ply_prompt" --number-of-tries=$ply_tries \
                 --command="$ply_cmd"
diff --git a/modules.d/90crypt/cryptroot-ask.sh b/modules.d/90crypt/cryptroot-ask.sh
index f8e1bd8..9b8f8c2 100755
--- a/modules.d/90crypt/cryptroot-ask.sh
+++ b/modules.d/90crypt/cryptroot-ask.sh
@@ -22,6 +22,9 @@ NEWROOT=${NEWROOT:-"/sysroot"}
 # default luksname - luks-UUID
 luksname=$2
 
+# fallback to passphrase
+ask_passphrase=1
+
 # if device name is /dev/dm-X, convert to /dev/mapper/name
 if [ "${1##/dev/dm-}" != "$1" ]; then
     device="/dev/mapper/$(dmsetup info -c --noheadings -o name "$1")"
@@ -63,12 +66,21 @@ fi
 
 info "luksOpen $device $luksname"
 
-if [ -n "$(getarg rd.luks.key)" ]; then
+while [ -n "$(getarg rd.luks.key)" ]; do
     if tmp=$(getkey /tmp/luks.keys $device); then
         keydev="${tmp%%:*}"
         keypath="${tmp#*:}"
     else
-        info "No key found for $device.  Will try later."
+        if [ $# -eq 3 ]; then
+            if [ $3 -eq 0 ]; then
+                info "No key found for $device.  Fallback to passphrase mode."
+                break
+            fi
+            info "No key found for $device.  Will try $3 time(s) more later."
+            set -- "$1" "$2" "$(($3 - 1))"
+        else
+            info "No key found for $device.  Will try later."
+        fi
         initqueue --unique --onetime --settled \
             --name cryptroot-ask-$luksname \
             $(command -v cryptroot-ask) "$@"
@@ -80,7 +92,10 @@ if [ -n "$(getarg rd.luks.key)" ]; then
     readkey "$keypath" "$keydev" "$device" \
         | cryptsetup -d - luksOpen "$device" "$luksname"
     unset keypath keydev
-else
+    ask_passphrase=0
+    break
+done    
+if [ $ask_passphrase -ne 0 ]; then
     luks_open="$(command -v cryptsetup) luksOpen"
     ask_for_password --ply-tries 5 \
         --ply-cmd "$luks_open -T1 $device $luksname" \
diff --git a/modules.d/90crypt/parse-crypt.sh b/modules.d/90crypt/parse-crypt.sh
index 7ec232a..2ab3a9f 100755
--- a/modules.d/90crypt/parse-crypt.sh
+++ b/modules.d/90crypt/parse-crypt.sh
@@ -11,6 +11,7 @@ else
     } > /etc/udev/rules.d/70-luks.rules.new
 
     LUKS=$(getargs rd.luks.uuid rd_LUKS_UUID)
+    tout=$(getarg rd.luks.key.tout)
 
     if [ -n "$LUKS" ]; then
         for luksid in $LUKS; do
@@ -20,11 +21,25 @@ else
                 printf -- 'ENV{ID_FS_UUID}=="*%s*", ' $luksid
                 printf -- 'RUN+="%s --unique --onetime ' $(command -v initqueue)
                 printf -- '--name cryptroot-ask-%%k %s ' $(command -v cryptroot-ask)
-                printf -- '$env{DEVNAME} luks-$env{ID_FS_UUID}"\n'
+                printf -- '$env{DEVNAME} luks-$env{ID_FS_UUID} %s"\n' $tout
             } >> /etc/udev/rules.d/70-luks.rules.new
 
-            printf -- '[ -e /dev/disk/by-uuid/*%s* ]\n' $luksid \
-                >> $hookdir/initqueue/finished/90-crypt.sh
+
+            [ -e $hookdir/initqueue/finished/90-crypt.sh ] || \
+            {
+                printf -- 'UUIDS=:\n'
+                printf -- 'for dm in /dev/dm-*; do\n'
+                printf -- '[ -e "$dm" ] || exit 1\n'
+                printf -- 'dmid=`/sbin/dmsetup info -c -o uuid --noheadings "$dm"`\n'
+                printf -- 'uuid=${dmid#CRYPT-LUKS*-}\n'
+                printf -- '[ "x$uuid" = "x$dmid" ] && continue\n'
+                printf -- 'UUIDS="${UUIDS}${uuid%%%%-*}:"\n'
+                printf -- 'done\n'
+            } > $hookdir/initqueue/finished/90-crypt.sh
+            uuid=$luksid
+            while [ "$uuid" != "${uuid#*-}" ]; do uuid=${uuid%%-*}${uuid#*-}; done
+            printf -- '[ "x${UUIDS#*:%s*:}" != "x$UUIDS" ] || exit 1\n' $uuid >> $hookdir/initqueue/finished/90-crypt.sh
+
             {
                 printf -- '[ -e /dev/disk/by-uuid/*%s* ] || ' $luksid
                 printf -- 'warn "crypto LUKS UUID "%s" not found"\n' $luksid
@@ -34,7 +49,7 @@ else
         {
             printf -- 'ENV{ID_FS_TYPE}=="crypto_LUKS", RUN+="%s ' $(command -v initqueue)
             printf -- '--unique --onetime --name cryptroot-ask-%%k '
-            printf -- '%s $env{DEVNAME} luks-$env{ID_FS_UUID}"\n' $(command -v cryptroot-ask)
+            printf -- '%s $env{DEVNAME} luks-$env{ID_FS_UUID} %s"\n' $(command -v cryptroot-ask) $tout
         } >> /etc/udev/rules.d/70-luks.rules.new
     fi
 
diff --git a/modules.d/90crypt/parse-keydev.sh b/modules.d/90crypt/parse-keydev.sh
old mode 100644
new mode 100755
diff --git a/modules.d/90dm/dm-shutdown.sh b/modules.d/90dm/dm-shutdown.sh
old mode 100644
new mode 100755
diff --git a/modules.d/90dmraid/61-dmraid-imsm.rules b/modules.d/90dmraid/61-dmraid-imsm.rules
index d87fce7..73ba58e 100644
--- a/modules.d/90dmraid/61-dmraid-imsm.rules
+++ b/modules.d/90dmraid/61-dmraid-imsm.rules
@@ -10,6 +10,7 @@ ENV{ID_FS_TYPE}=="linux_raid_member", GOTO="dm_end"
 ENV{ID_FS_TYPE}!="*_raid_member", , GOTO="dm_end"
 
 ENV{ID_FS_TYPE}=="isw_raid_member", ENV{rd_NO_MDIMSM}!="?*", GOTO="dm_end"
+ENV{ID_FS_TYPE}=="ddf_raid_member", ENV{rd_NO_MDDDF}!="?*", GOTO="dm_end"
 
 ENV{rd_NO_DM}=="?*", GOTO="dm_end"
 
diff --git a/modules.d/90dmraid/parse-dm.sh b/modules.d/90dmraid/parse-dm.sh
index 059c396..fe38d35 100755
--- a/modules.d/90dmraid/parse-dm.sh
+++ b/modules.d/90dmraid/parse-dm.sh
@@ -12,3 +12,7 @@ if  ! command -v mdadm >/dev/null || ! getargbool 1 rd.md.imsm -n rd_NO_MDIMSM |
     udevproperty rd_NO_MDIMSM=1
 fi
 
+if  ! command -v mdadm >/dev/null || ! getargbool 1 rd.md.ddf -n rd_NO_MDDDF || getarg noddfmd; then
+    info "rd.md.ddf=0: no MD RAID for SNIA ddf raids"
+    udevproperty rd_NO_MDDDF=1
+fi
diff --git a/modules.d/90dmsquash-live/dmsquash-live-genrules.sh b/modules.d/90dmsquash-live/dmsquash-live-genrules.sh
index ce1ca82..aa0654b 100755
--- a/modules.d/90dmsquash-live/dmsquash-live-genrules.sh
+++ b/modules.d/90dmsquash-live/dmsquash-live-genrules.sh
@@ -4,17 +4,11 @@
 case "$root" in
   live:/dev/*)
     {
-        printf 'KERNEL=="%s", SYMLINK+="live"\n' \
-            ${root#live:/dev/}
-        printf 'SYMLINK=="%s", SYMLINK+="live"\n' \
-            ${root#live:/dev/}
-    } >> $UDEVRULESD/99-live-mount.rules
-    {
         printf 'KERNEL=="%s", RUN+="/sbin/initqueue --settled --onetime --unique /sbin/dmsquash-live-root $env{DEVNAME}"\n' \
             ${root#live:/dev/}
         printf 'SYMLINK=="%s", RUN+="/sbin/initqueue --settled --onetime --unique /sbin/dmsquash-live-root $env{DEVNAME}"\n' \
             ${root#live:/dev/}
-    } >> $UDEVRULESD/99-live-squash.rules
+    } >> /etc/udev/rules.d/99-live-squash.rules
     echo '[ -e /dev/root ]' > $hookdir/initqueue/finished/dmsquash.sh
   ;;
   live:*)
diff --git a/modules.d/90dmsquash-live/dmsquash-live-root b/modules.d/90dmsquash-live/dmsquash-live-root
index 265de19..b704139 100755
--- a/modules.d/90dmsquash-live/dmsquash-live-root
+++ b/modules.d/90dmsquash-live/dmsquash-live-root
@@ -3,6 +3,8 @@
 # ex: ts=8 sw=4 sts=4 et filetype=sh
 
 type getarg >/dev/null 2>&1 || . /lib/dracut-lib.sh
+type det_fs >/dev/null 2>&1 || . /lib/fs-lib.sh
+
 [ -f /tmp/root.info ] && . /tmp/root.info
 
 PATH=/usr/sbin:/usr/bin:/sbin:/bin
@@ -43,9 +45,7 @@ fi
 
 # determine filesystem type for a filesystem image
 det_img_fs() {
-    local _img="$1" _loop=$(losetup -f) _fs
-    losetup $_loop $_img; _fs=$(det_fs $_loop); losetup -d $_loop
-    echo $_fs
+    blkid -s TYPE -u noraid -o value "$1"
 }
 
 for arg in $CMDLINE; do case $arg in ro|rw) liverw=$arg ;; esac; done
@@ -54,11 +54,13 @@ mkdir -m 0755 -p /run/initramfs/live
 if [ -f $livedev ]; then
     # no mount needed - we've already got the LiveOS image in initramfs
     # check filesystem type and handle accordingly
-    case `det_img_fs $livedev` in
-        squashfs) SQUASHED=$livedev ;;
+    fstype=$(det_img_fs $livedev)
+    case $fstype in
+        squashfs) SQUASHED=$livedev;;
         auto) die "cannot mount live image (unknown filesystem type)" ;;
         *) FSIMG=$livedev ;;
     esac
+    [ -e /sys/fs/$fstype ] || modprobe $fstype
 else
     mount -n -t $fstype -o ${liverw:-ro} $livedev /run/initramfs/live
     if [ "$?" != "0" ]; then
diff --git a/modules.d/90dmsquash-live/module-setup.sh b/modules.d/90dmsquash-live/module-setup.sh
index 684655f..de1eed6 100755
--- a/modules.d/90dmsquash-live/module-setup.sh
+++ b/modules.d/90dmsquash-live/module-setup.sh
@@ -5,7 +5,7 @@
 check() {
     # a live host-only image doesn't really make a lot of sense
     [[ $hostonly ]] && return 1
-    return 0
+    return 255
 }
 
 depends() {
diff --git a/modules.d/90dmsquash-live/parse-dmsquash-live.sh b/modules.d/90dmsquash-live/parse-dmsquash-live.sh
index 6e0db29..5cbcd2c 100755
--- a/modules.d/90dmsquash-live/parse-dmsquash-live.sh
+++ b/modules.d/90dmsquash-live/parse-dmsquash-live.sh
@@ -41,7 +41,7 @@ case "$liveroot" in
     live:/*.[Ii][Mm][Gg]|/*.[Ii][Mm][Gg])
         [ -f "${root#live:}" ] && rootok=1 ;;
 esac
-info "root was $root, liveroot is now $liveroot"
+info "liveroot was $liveroot, is now $root"
 
 # make sure that init doesn't complain
 [ -z "$root" ] && root="live"
diff --git a/modules.d/90kernel-modules/module-setup.sh b/modules.d/90kernel-modules/module-setup.sh
index 245ec0b..db4b276 100755
--- a/modules.d/90kernel-modules/module-setup.sh
+++ b/modules.d/90kernel-modules/module-setup.sh
@@ -9,6 +9,32 @@ installkernel() {
 
             egrep -q "$blockfuncs" "$1"
         }
+        block_module_filter() {
+            local _blockfuncs='ahci_init_controller|ata_scsi_ioctl|scsi_add_host|blk_init_queue|register_mtd_blktrans|scsi_esp_register|register_virtio_device'
+            # subfunctions inherit following FDs
+            local _merge=8 _side2=9
+            function bmf1() {
+                local _f
+                while read _f; do case "$_f" in
+                    *.ko)    [[ $(<         $_f) =~ $_blockfuncs ]] && echo "$_f" ;;
+                    *.ko.gz) [[ $(gzip -dc <$_f) =~ $_blockfuncs ]] && echo "$_f" ;;
+                    esac
+                done
+            }
+            function rotor() {
+                local _f1 _f2
+                while read _f1; do
+                    echo "$_f1"
+                    if read _f2; then
+                        echo "$_f2" 1>&${_side2}
+                    fi
+                done | bmf1 1>&${_merge}
+            }
+            # Use two parallel streams to filter alternating modules.
+            set +x
+            eval "( ( rotor ) ${_side2}>&1 | bmf1 ) ${_merge}>&1"
+            [[ $debug ]] && set -x
+        }
         hostonly='' instmods sr_mod sd_mod scsi_dh scsi_dh_rdac scsi_dh_emc
         hostonly='' instmods pcmcia firewire-ohci
         hostonly='' instmods usb_storage sdhci sdhci-pci
@@ -18,7 +44,7 @@ installkernel() {
         # install unix socket support
         hostonly='' instmods unix
         instmods "=drivers/pcmcia" =ide "=drivers/usb/storage"
-        instmods $(filter_kernel_modules block_module_test)
+        find_kernel_modules  |  block_module_filter  |  instmods
         # if not on hostonly mode, install all known filesystems,
         # if the required list is not set via the filesystems variable
         if ! [[ $hostonly ]]; then
diff --git a/modules.d/90livenet/module-setup.sh b/modules.d/90livenet/module-setup.sh
index 3ae72de..5cfbb75 100755
--- a/modules.d/90livenet/module-setup.sh
+++ b/modules.d/90livenet/module-setup.sh
@@ -4,7 +4,8 @@
 check() {
     # a live, host-only image doesn't really make a lot of sense
     [[ $hostonly ]] && return 1
-    return 0
+    command -v wget >/dev/null || return 1
+    return 255
 }
 
 depends() {
@@ -15,7 +16,9 @@ depends() {
 install() {
     dracut_install wget
     mkdir -m 0755 -p "$initdir/etc/ssl/certs"
-    if ! inst_simple /etc/ssl/certs/ca-bundle.crt; then
+    if ! inst_any -t /etc/ssl/certs/ca-bundle.crt \
+            /etc/ssl/certs/ca-bundle.crt \
+            /etc/ssl/certs/ca-certificates.crt; then
         dwarn "Couldn't find SSL CA cert bundle; HTTPS won't work."
     fi
 
diff --git a/modules.d/90livenet/parse-livenet.sh b/modules.d/90livenet/parse-livenet.sh
index 78fc906..323fd4a 100755
--- a/modules.d/90livenet/parse-livenet.sh
+++ b/modules.d/90livenet/parse-livenet.sh
@@ -12,8 +12,8 @@ liveurl="${liveurl#live:}"
 case "$liveurl" in
     http://*|https://*|ftp://*)
         netroot="livenet:$liveurl"
+        root="livenet" # quiet complaints from init
         rootok=1 ;;
 esac
 
-root="livenet" # quiet complaints from init
 echo '[ -e /dev/root ]' > $hookdir/initqueue/finished/livenet.sh
diff --git a/modules.d/90lvm/64-lvm.rules b/modules.d/90lvm/64-lvm.rules
index 487d08a..ab827a9 100644
--- a/modules.d/90lvm/64-lvm.rules
+++ b/modules.d/90lvm/64-lvm.rules
@@ -13,7 +13,7 @@ PROGRAM=="/bin/sh -c 'for i in $sys/$devpath/holders/dm-[0-9]*; do [ -e $$i ] &&
     GOTO="lvm_end"
 
 RUN+="/sbin/initqueue --settled --onetime --unique /sbin/lvm_scan"
-RUN+="/sbin/initqueue --timeout --onetime --unique /sbin/lvm_scan --partial"
+RUN+="/sbin/initqueue --timeout --name 51-lvm_scan --onetime --unique /sbin/lvm_scan --partial"
 RUN+="/bin/sh -c '>/tmp/.lvm_scan-%k;'"
 
 LABEL="lvm_end"
diff --git a/modules.d/90mdraid/65-md-incremental-imsm.rules b/modules.d/90mdraid/65-md-incremental-imsm.rules
index 4fc8428..139a599 100644
--- a/modules.d/90mdraid/65-md-incremental-imsm.rules
+++ b/modules.d/90mdraid/65-md-incremental-imsm.rules
@@ -2,87 +2,48 @@
 # automatically cause mdadm to be run.
 # See udev(8) for syntax
 
-ACTION!="add|change", GOTO="md_inc_end"
-SUBSYSTEM!="block", GOTO="md_inc_end"
-ENV{ID_FS_TYPE}!="linux_raid_member|isw_raid_member", GOTO="md_inc_end"
+ACTION!="add|change", GOTO="md_end"
+SUBSYSTEM!="block", GOTO="md_end"
+ENV{rd_NO_MD}=="?*", GOTO="md_end"
+KERNEL=="md*", GOTO="md_end"
 
-ENV{ID_FS_TYPE}=="isw_raid_member", ENV{rd_NO_MDIMSM}=="?*", GOTO="md_inc_end"
+ENV{ID_FS_TYPE}=="ddf_raid_member|isw_raid_member|linux_raid_member", GOTO="md_try"
+GOTO="md_end"
 
-ENV{rd_NO_MD}=="?*", GOTO="md_inc_end"
+LABEL="md_try"
+ENV{ID_FS_TYPE}=="isw_raid_member", ENV{rd_NO_MDIMSM}=="?*", GOTO="md_end"
+ENV{ID_FS_TYPE}=="ddf_raid_member", ENV{rd_NO_MDDDF}=="?*", GOTO="md_end"
 
-PROGRAM=="/bin/sh -c 'for i in $sys/$devpath/holders/md[0-9]*; do [ -e $$i ] && exit 0; done; exit 1;' ", \
-    GOTO="md_inc_end"
-
-ENV{DEVTYPE}!="partition", \
-    RUN+="/sbin/partx -d --nr 1-1024 $env{DEVNAME}"
-
-KERNEL!="md*", IMPORT{program}="/sbin/mdadm --examine --export $tempnode"
-
-# UUID CHECK
-
-LABEL="do_md_inc"
-
-#
-# if rd_MDADMCONF do not assemble incrementally
-# defer auto assembly until the udev queue is settled
-#
-ENV{rd_MDADMCONF}!="?*", GOTO="md_auto_end"
-
-RUN+="/sbin/initqueue --finished --unique --name md_finished /sbin/md_finished.sh"
-RUN+="/sbin/initqueue --timeout --onetime --unique /sbin/mdadm_auto"
-
-GOTO="md_inc_end"
-
-LABEL="md_auto_end"
+# already done ?
+PROGRAM="/bin/sh -c 'for i in $sys/$devpath/holders/md[0-9_]*; do [ -e $$i ] && exit 0; done; exit 1;' ", \
+    GOTO="md_end"
 
+# for native arrays - array's uuid has to be specified
+# for containers - container's uuid has to be specified
+# TODO : how to get embedded array's uuid having container's component ?
 #
-# Incrementally build the md array
-#
-RUN+="/sbin/mdadm -I $env{DEVNAME}"
+# UUID CHECK
 
-RUN+="/sbin/initqueue --finished --unique --name md_finished /sbin/md_finished.sh"
+ENV{DEVTYPE}!="partition", \
+    RUN+="/sbin/partx -d --nr 1-1024 $env{DEVNAME}"
 
-LABEL="md_inc_end"
+RUN+="/sbin/initqueue --timeout --name 50-mdraid_start --onetime --unique /sbin/mdraid_start"
 
+# if rd_MDADMCONF is set, do not assemble incrementally;
+# defer conf-based assembly until the udev queue is settled
 #
-# Handle non-container raid arrays
-#
-ACTION=="add|change", \
-	KERNEL=="md[0-9]*|md/*", \
-	ENV{MD_LEVEL}!="container", \
-	ENV{MD_CONTAINER}!="?*", \
-        ENV{rd_MDADMCONF}!="?*", \
-        ENV{rd_NO_MD}!="?*", \
-	GOTO="do_raidstart"
+ENV{rd_MDADMCONF}!="?*", GOTO="md_incremental"
 
-GOTO="end_raidstart"
+RUN+="/sbin/initqueue --settled --onetime --unique /sbin/mdadm_auto"
 
-LABEL="do_raidstart"
-
-# check if array is not inactive anymore
-TEST=="md/array_state", ATTR{md/array_state}!="|inactive", GOTO="end_raidstart"
-
-RUN+="/sbin/initqueue --finished --unique --name md_finished /sbin/md_finished.sh"
-RUN+="/sbin/initqueue --timeout --onetime --unique /sbin/mdraid_start"
-
-LABEL="end_raidstart"
+GOTO="md_end"
 
 #
-# Handle container raid arrays
+# Incrementally build the md array; this will automatically assemble
+# any eventual containers as well (imsm, ddf)
 #
-ACTION=="add|change", \
-	KERNEL=="md[0-9]*|md/*", \
-	ENV{DEVTYPE}!="partition", \
-	ENV{MD_LEVEL}=="container", \
-        ENV{rd_MDADMCONF}!="?*", \
-        ENV{rd_NO_MD}!="?*", \
-	GOTO="do_container"
+LABEL="md_incremental"
 
-GOTO="end_container"
-
-LABEL="do_container"
-
-RUN+="/sbin/initqueue --finished --unique --name md_finished /sbin/md_finished.sh"
-RUN+="/sbin/initqueue --timeout --onetime --unique --name mdcontainer_start-%k /sbin/mdcontainer_start $env{DEVNAME}"
+RUN+="/sbin/mdadm -I $env{DEVNAME}"
 
-LABEL="end_container"
+LABEL="md_end"
diff --git a/modules.d/90mdraid/md-noddf.sh b/modules.d/90mdraid/md-noddf.sh
new file mode 100755
index 0000000..bc46dd7
--- /dev/null
+++ b/modules.d/90mdraid/md-noddf.sh
@@ -0,0 +1,5 @@
+#!/bin/sh
+# -*- mode: shell-script; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
+# ex: ts=8 sw=4 sts=4 et filetype=sh
+info "rd.md.ddf=0: no MD RAID for SNIA ddf raids"
+udevproperty rd_NO_MDDDF=1
diff --git a/modules.d/90mdraid/md-noimsm.sh b/modules.d/90mdraid/md-noimsm.sh
index bc9cf7f..8272f86 100755
--- a/modules.d/90mdraid/md-noimsm.sh
+++ b/modules.d/90mdraid/md-noimsm.sh
@@ -2,4 +2,4 @@
 # -*- mode: shell-script; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
 # ex: ts=8 sw=4 sts=4 et filetype=sh
 info "rd.md.imsm=0: no MD RAID for imsm/isw raids"
-udevproperty rd_NO_MDIMSM=1
\ No newline at end of file
+udevproperty rd_NO_MDIMSM=1
diff --git a/modules.d/90mdraid/md-shutdown.sh b/modules.d/90mdraid/md-shutdown.sh
old mode 100644
new mode 100755
diff --git a/modules.d/90mdraid/md_finished.sh b/modules.d/90mdraid/md_finished.sh
deleted file mode 100755
index cde0966..0000000
--- a/modules.d/90mdraid/md_finished.sh
+++ /dev/null
@@ -1,9 +0,0 @@
-#!/bin/sh
-# -*- mode: shell-script; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
-# ex: ts=8 sw=4 sts=4 et filetype=sh
-for f in $hookdir/initqueue/settled/mdcontainer_start* $hookdir/initqueue/settled/mdraid_start* $hookdir/initqueue/settled/mdadm_auto*; do
-    [ -e $f ] && exit 1
-done
-
-$UDEV_QUEUE_EMPTY >/dev/null 2>&1 || exit 1
-exit 0
diff --git a/modules.d/90mdraid/mdadm_auto.sh b/modules.d/90mdraid/mdadm_auto.sh
index 915fb28..9b61bf5 100755
--- a/modules.d/90mdraid/mdadm_auto.sh
+++ b/modules.d/90mdraid/mdadm_auto.sh
@@ -4,4 +4,4 @@
 type getarg >/dev/null 2>&1 || . /lib/dracut-lib.sh
 
 info "Autoassembling MD Raid"
-mdadm -As --auto=yes --run 2>&1 | vinfo
+mdadm -As --auto=yes 2>&1 | vinfo
diff --git a/modules.d/90mdraid/mdcontainer_start.sh b/modules.d/90mdraid/mdcontainer_start.sh
deleted file mode 100755
index e7dd3ef..0000000
--- a/modules.d/90mdraid/mdcontainer_start.sh
+++ /dev/null
@@ -1,12 +0,0 @@
-#!/bin/sh
-# -*- mode: shell-script; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
-# ex: ts=8 sw=4 sts=4 et filetype=sh
-type getarg >/dev/null 2>&1 || . /lib/dracut-lib.sh
-
-md=$1
-udevadm control --stop-exec-queue
-# and activate any containers
-mdadm -IR $md 2>&1 | vinfo
-ln -s $(command -v mdraid-cleanup) $hookdir/pre-pivot/30-mdraid-cleanup.sh 2>/dev/null
-ln -s $(command -v mdraid-cleanup) $hookdir/pre-pivot/31-mdraid-cleanup.sh 2>/dev/null
-udevadm control --start-exec-queue
diff --git a/modules.d/90mdraid/mdraid-cleanup.sh b/modules.d/90mdraid/mdraid-cleanup.sh
index add02e0..3ffa2d3 100755
--- a/modules.d/90mdraid/mdraid-cleanup.sh
+++ b/modules.d/90mdraid/mdraid-cleanup.sh
@@ -2,18 +2,22 @@
 # -*- mode: shell-script; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
 # ex: ts=8 sw=4 sts=4 et filetype=sh
 
-# stop everything which is not busy
-for i in /dev/md* /dev/md/*; do
-    [ -b $i ] || continue
+type getarg >/dev/null 2>&1 || . /lib/dracut-lib.sh
 
-    mddetail=$(udevadm info --query=property --name=$i)
-    case "$mddetail" in
-        *MD_LEVEL=container*)
-        ;;
-        *DEVTYPE=partition*)
-        ;;
-        *)
-            mdadm --stop $i >/dev/null 2>&1
-            ;;
-    esac
+containers=""
+for md in /dev/md[0-9_]*; do
+    [ -b "$md" ] || continue
+    udevinfo="$(udevadm info --query=env --name=$md)"
+    strstr "$udevinfo" "DEVTYPE=partition" && continue
+    if strstr "$udevinfo" "MD_LEVEL=container"; then
+        containers="$containers $md"
+        continue
+    fi
+    mdadm -S "$md" >/dev/null 2>&1
 done
+
+for md in $containers; do
+    mdadm -S "$md" >/dev/null 2>&1
+done
+
+unset containers udevinfo
diff --git a/modules.d/90mdraid/mdraid_start.sh b/modules.d/90mdraid/mdraid_start.sh
index 4aa7f82..f4b7ad0 100755
--- a/modules.d/90mdraid/mdraid_start.sh
+++ b/modules.d/90mdraid/mdraid_start.sh
@@ -3,24 +3,34 @@
 # ex: ts=8 sw=4 sts=4 et filetype=sh
 
 type getarg >/dev/null 2>&1 || . /lib/dracut-lib.sh
-# run mdadm if udev has settled
-info "Assembling MD RAID arrays"
-udevadm control --stop-exec-queue
-mdadm -As --auto=yes --run 2>&1 | vinfo
-mdadm -Is --run 2>&1 | vinfo
+_md_force_run() {
+    local _udevinfo
+    local _path_s
+    local _path_d
+    # try to force-run anything not running yet
+    for md in /dev/md[0-9_]*; do
+        [ -b "$md" ] || continue
+        _udevinfo="$(udevadm info --query=env --name="$md")"
+        strstr "$_udevinfo" "MD_LEVEL=container" && continue
+        strstr "$_udevinfo" "DEVTYPE=partition" && continue
 
-# there could still be some leftover devices
-# which have had a container added
-for md in /dev/md[0-9]* /dev/md/*; do
-    [ -b "$md" ] || continue
-    udevinfo="$(udevadm info --query=env --name=$md)"
-    strstr "$udevinfo" "MD_UUID=" && continue
-    strstr "$udevinfo" "MD_LEVEL=container" && continue
-    strstr "$udevinfo" "DEVTYPE=partition" && continue
-    mdadm --run "$md" 2>&1 | vinfo
-done
-unset udevinfo
+        _path_s="/sys/$(udevadm info -q path -n "$md")/md/array_state"
+        [ ! -r "$_path_s" ] && continue
 
-ln -s $(command -v mdraid-cleanup) $hookdir/pre-pivot/30-mdraid-cleanup.sh 2>/dev/null
-ln -s $(command -v mdraid-cleanup) $hookdir/pre-pivot/31-mdraid-cleanup.sh 2>/dev/null
-udevadm control --start-exec-queue
+        # inactive ?
+        [ "$(cat "$_path_s")" != "inactive" ] && continue
+
+        mdadm -R "$md" 2>&1 | vinfo
+
+        # still inactive ?
+        [ "$(cat "$_path_s")" = "inactive" ] && continue
+
+        _path_d="${_path_s%/*}/degraded"
+        [ ! -r "$_path_d" ] && continue
+
+        # workaround for mdmon bug
+        [ "$(cat "$_path_d")" -gt "0" ] && mdmon --takeover "$md"
+    done
+}
+
+_md_force_run
diff --git a/modules.d/90mdraid/module-setup.sh b/modules.d/90mdraid/module-setup.sh
index de7785d..fe793bb 100755
--- a/modules.d/90mdraid/module-setup.sh
+++ b/modules.d/90mdraid/module-setup.sh
@@ -20,7 +20,7 @@ check() {
             check_block_and_slaves is_mdraid "$_rootdev" || return 1
         else
             # root is not on a block device, use the shotgun approach
-            blkid | egrep -q '(linux|isw)_raid' || return 1
+            blkid | egrep -q '(linux|isw|ddf)_raid' || return 1
         fi
     }
 
@@ -37,7 +37,7 @@ installkernel() {
 }
 
 install() {
-    dracut_install mdadm partx
+    dracut_install mdadm partx cat
 
 
      # XXX: mdmon really needs to run as non-root?
@@ -50,13 +50,22 @@ install() {
 
     if [ ! -x /lib/udev/vol_id ]; then
         inst_rules 64-md-raid.rules
+        # remove incremental assembly from stock rules, so they don't shadow
+        # 65-md-inc*.rules and its fine-grained controls, or cause other problems
+        # when we explicitly don't want certain components to be incrementally
+        # assembled
+        sed -i -r -e '/RUN\+?="[[:alpha:]/]*mdadm[[:blank:]]+(--incremental|-I)[[:blank:]]+(\$env\{DEVNAME\}|\$tempnode)"/d' "${initdir}/lib/udev/rules.d/64-md-raid.rules"
     fi
 
     inst_rules "$moddir/65-md-incremental-imsm.rules"
 
+    # guard against pre-3.0 mdadm versions, that can't handle containers
     if ! mdadm -Q -e imsm /dev/null &> /dev/null; then
         inst_hook pre-trigger 30 "$moddir/md-noimsm.sh"
     fi
+    if ! mdadm -Q -e ddf /dev/null &> /dev/null; then
+        inst_hook pre-trigger 30 "$moddir/md-noddf.sh"
+    fi
 
     if [[ $hostonly ]] || [[ $mdadmconf = "yes" ]]; then
         if [ -f /etc/mdadm.conf ]; then
@@ -72,9 +81,7 @@ install() {
     inst_hook pre-udev 30 "$moddir/mdmon-pre-udev.sh"
 
     inst "$moddir/mdraid_start.sh" /sbin/mdraid_start
-    inst "$moddir/mdcontainer_start.sh" /sbin/mdcontainer_start
     inst "$moddir/mdadm_auto.sh" /sbin/mdadm_auto
-    inst "$moddir/md_finished.sh" /sbin/md_finished.sh
     inst_hook pre-trigger 30 "$moddir/parse-md.sh"
     inst "$moddir/mdraid-cleanup.sh" /sbin/mdraid-cleanup
     inst_hook shutdown 30 "$moddir/md-shutdown.sh"
diff --git a/modules.d/90mdraid/parse-md.sh b/modules.d/90mdraid/parse-md.sh
index 6d1b615..b85a3a3 100755
--- a/modules.d/90mdraid/parse-md.sh
+++ b/modules.d/90mdraid/parse-md.sh
@@ -13,12 +13,14 @@ else
             [ -e "$f" ] || continue
             while read line; do
                 if [ "${line%%UUID CHECK}" != "$line" ]; then
+                    printf 'IMPORT{program}="/sbin/mdadm --examine --export $tempnode"\n'
                     for uuid in $MD_UUID; do
-                        printf 'ENV{MD_UUID}=="%s", GOTO="do_md_inc"\n' $uuid
+                        printf 'ENV{MD_UUID}=="%s", GOTO="md_uuid_ok"\n' $uuid
                     done;
-                    printf 'GOTO="md_inc_end"\n';
+                    printf 'GOTO="md_end"\n'
+                    printf 'LABEL="md_uuid_ok"\n'
                 else
-                    echo $line;
+                    echo "$line"
                 fi
             done < "${f}" > "${f}.new"
             mv "${f}.new" "$f"
@@ -34,6 +36,7 @@ fi
 
 if ! getargbool 1 rd.md.conf -n rd_NO_MDADMCONF; then
     rm -f /etc/mdadm/mdadm.conf /etc/mdadm.conf
+    ln -s $(command -v mdraid-cleanup) $hookdir/pre-pivot/31-mdraid-cleanup.sh 2>/dev/null
 fi
 
 # noiswmd nodmraid for anaconda / rc.sysinit compatibility
@@ -42,3 +45,9 @@ if ! getargbool 1 rd.md.imsm -n rd_NO_MDIMSM || getarg noiswmd || getarg nodmrai
     info "no MD RAID for imsm/isw raids"
     udevproperty rd_NO_MDIMSM=1
 fi
+
+# same thing with ddf containers
+if ! getargbool 1 rd.md.ddf -n rd_NO_MDDDF || getarg noddfmd || getarg nodmraid; then
+    info "no MD RAID for SNIA ddf raids"
+    udevproperty rd_NO_MDDDF=1
+fi
diff --git a/modules.d/90multipath/module-setup.sh b/modules.d/90multipath/module-setup.sh
index e9a47fc..43f0a3d 100755
--- a/modules.d/90multipath/module-setup.sh
+++ b/modules.d/90multipath/module-setup.sh
@@ -33,13 +33,20 @@ depends() {
 }
 
 installkernel() {
-    mp_mod_test() {
-        local mpfuncs='scsi_register_device_handler|dm_dirty_log_type_register|dm_register_path_selector|dm_register_target'
-        egrep -q "$mpfuncs" "$1"
+    set +x
+    mp_mod_filter() {
+        local _mpfuncs='scsi_register_device_handler|dm_dirty_log_type_register|dm_register_path_selector|dm_register_target'
+        local _f
+        while read _f; do case "$_f" in
+            *.ko)    [[ $(<         $_f) =~ $_mpfuncs ]] && echo "$_f" ;;
+            *.ko.gz) [[ $(gzip -dc <$_f) =~ $_mpfuncs ]] && echo "$_f" ;;
+            esac
+        done
     }
 
-    instmods $(filter_kernel_modules_by_path drivers/scsi mp_mod_test)
-    instmods $(filter_kernel_modules_by_path drivers/md mp_mod_test)
+    ( find_kernel_modules_by_path drivers/scsi;
+      find_kernel_modules_by_path drivers/md )  |  mp_mod_filter  |  instmods
+    [[ $debug ]] && set -x
 }
 
 install() {
diff --git a/modules.d/91crypt-gpg/crypt-gpg-lib.sh b/modules.d/91crypt-gpg/crypt-gpg-lib.sh
old mode 100644
new mode 100755
diff --git a/modules.d/95iscsi/module-setup.sh b/modules.d/95iscsi/module-setup.sh
index 3db40ea..b7771ab 100755
--- a/modules.d/95iscsi/module-setup.sh
+++ b/modules.d/95iscsi/module-setup.sh
@@ -42,11 +42,17 @@ depends() {
 
 installkernel() {
     instmods iscsi_tcp iscsi_ibft crc32c
-    iscsi_module_test() {
+    iscsi_module_filter() {
         local _iscsifuncs='iscsi_register_transport'
-        fgrep -q "$_iscsifuncs" "$1"
+        local _f
+        while read _f; do case "$_f" in
+            *.ko)    [[ $(<         $_f) =~ $_iscsifuncs ]] && echo "$_f" ;;
+            *.ko.gz) [[ $(gzip -dc <$_f) =~ $_iscsifuncs ]] && echo "$_f" ;;
+            esac
+        done
     }
-    instmods $(filter_kernel_modules_by_path drivers/scsi iscsi_module_test)
+    find_kernel_modules_by_path drivers/scsi \
+    | iscsi_module_filter  |  instmods
 }
 
 install() {
diff --git a/modules.d/95resume/resume-genrules.sh b/modules.d/95resume/resume-genrules.sh
index 06b9544..e1afc26 100755
--- a/modules.d/95resume/resume-genrules.sh
+++ b/modules.d/95resume/resume-genrules.sh
@@ -17,7 +17,7 @@ if [ -n "$resume" ]; then
             ${resume#/dev/};
         printf "SYMLINK==\"%s\", ACTION==\"add|change\", SYMLINK+=\"/dev/resume\"\n" \
             ${resume#/dev/};
-    } >> $UDEVRULESD/99-resume-link.rules
+    } >> /etc/udev/rules.d/99-resume-link.rules
 
     {
         if [ -x /usr/sbin/resume ]; then
diff --git a/modules.d/95rootfs-block/block-genrules.sh b/modules.d/95rootfs-block/block-genrules.sh
index 4a50aac..a2310a0 100755
--- a/modules.d/95rootfs-block/block-genrules.sh
+++ b/modules.d/95rootfs-block/block-genrules.sh
@@ -8,7 +8,7 @@ if [ "${root%%:*}" = "block" ]; then
             ${root#block:/dev/}
         printf 'SYMLINK=="%s", SYMLINK+="root"\n' \
             ${root#block:/dev/}
-    } >> $UDEVRULESD/99-root.rules
+    } >> /etc/udev/rules.d/99-root.rules
 
     printf '[ -e "%s" ] && { ln -s "%s" /dev/root 2>/dev/null; rm "$job"; }\n' \
         "${root#block:}" "${root#block:}" > $hookdir/initqueue/settled/blocksymlink.sh
diff --git a/modules.d/95udev-rules/module-setup.sh b/modules.d/95udev-rules/module-setup.sh
index 5bd5d59..5f8bae8 100755
--- a/modules.d/95udev-rules/module-setup.sh
+++ b/modules.d/95udev-rules/module-setup.sh
@@ -7,7 +7,9 @@ install() {
     # FIXME: would be nice if we didn't have to know which rules to grab....
     # ultimately, /lib/initramfs/rules.d or somesuch which includes links/copies
     # of the rules we want so that we just copy those in would be best
-    dracut_install udevd udevadm
+    dracut_install udevadm
+    [ -x /sbin/udevd ] && dracut_install udevd
+
     for i in /etc/udev/udev.conf /etc/group; do
         inst_simple $i
     done
@@ -49,15 +51,26 @@ install() {
         fw_unit_symlinks.sh \
         hid2hci \
         path_id \
+        input_id \
         scsi_id \
         usb_id \
         vol_id \
         pcmcia-socket-startup \
         pcmcia-check-broken-cis \
+        udevd \
         ; do
         [ -e /lib/udev/$_i ] && dracut_install /lib/udev/$_i
+        [ -e /usr/lib/udev/$_i ] && dracut_install /usr/lib/udev/$_i
     done
 
+    if ! [ -e "$initdir/sbin/udevd" ]; then
+        if [ -x /usr/lib/udev/udevd ]; then
+            ln -s /usr/lib/udev/udevd "$initdir/sbin/udevd"
+        elif [ -x /lib/udev/udevd ]; then
+            ln -s /lib/udev/udevd "$initdir/sbin/udevd"
+        fi
+    fi
+
     [ -f /etc/arch-release ] && \
         inst "$moddir/load-modules.sh" /lib/udev/load-modules.sh
 
diff --git a/modules.d/96securityfs/module-setup.sh b/modules.d/96securityfs/module-setup.sh
new file mode 100755
index 0000000..fbe3aa3
--- /dev/null
+++ b/modules.d/96securityfs/module-setup.sh
@@ -0,0 +1,15 @@
+#!/bin/bash
+# -*- mode: shell-script; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
+# ex: ts=8 sw=4 sts=4 et filetype=sh
+
+check() {
+    return 255
+}
+
+depends() {
+    return 0
+}
+
+install() {
+    inst_hook cmdline 60 "$moddir/securityfs.sh"
+}
diff --git a/modules.d/96securityfs/securityfs.sh b/modules.d/96securityfs/securityfs.sh
new file mode 100755
index 0000000..03ee4dd
--- /dev/null
+++ b/modules.d/96securityfs/securityfs.sh
@@ -0,0 +1,10 @@
+#!/bin/sh
+# -*- mode: shell-script; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
+# ex: ts=8 sw=4 sts=4 et filetype=sh
+
+SECURITYFSDIR="/sys/kernel/security"
+export SECURITYFSDIR
+
+if ! ismounted "${SECURITYFSDIR}"; then
+   mount -t securityfs -o nosuid,noexec,nodev securityfs ${SECURITYFSDIR} >/dev/null 2>&1
+fi
diff --git a/modules.d/98integrity/module-setup.sh b/modules.d/98integrity/module-setup.sh
index cab9027..7d5771c 100755
--- a/modules.d/98integrity/module-setup.sh
+++ b/modules.d/98integrity/module-setup.sh
@@ -7,7 +7,7 @@ check() {
 }
 
 depends() {
-    echo masterkey
+    echo masterkey securityfs
     return 0
 }
 
diff --git a/modules.d/99base/dracut-lib.sh b/modules.d/99base/dracut-lib.sh
index 50b1ed2..8d294ee 100755
--- a/modules.d/99base/dracut-lib.sh
+++ b/modules.d/99base/dracut-lib.sh
@@ -24,7 +24,7 @@ str_replace() {
 
     while strstr "${in}" "$s"; do
         chop="${in%%$s*}"
-        out="${out}${chop# }$r"
+        out="${out}${chop}$r"
         in="${in#*$s}"
     done
     echo "${out}${in}"
@@ -32,15 +32,22 @@ str_replace() {
 
 _getcmdline() {
     local _line
+    local _i
     unset _line
     if [ -z "$CMDLINE" ]; then
         if [ -e /etc/cmdline ]; then
-            while read _line; do
+            while read -r _line; do
                 CMDLINE_ETC="$CMDLINE_ETC $_line";
             done </etc/cmdline;
         fi
-        read CMDLINE </proc/cmdline;
-        CMDLINE="$CMDLINE $CMDLINE_ETC"
+        for _i in /etc/cmdline.d/*.conf; do
+            [ -e "$_i" ] || continue
+            while read -r _line; do
+                CMDLINE_ETC_D="$CMDLINE_ETC_D $_line";
+            done <"$_i";
+        done
+        read -r CMDLINE </proc/cmdline;
+        CMDLINE="$CMDLINE_ETC_D $CMDLINE_ETC $CMDLINE"
     fi
 }
 
@@ -544,3 +551,12 @@ foreach_uuid_until() (
 
     return 1
 )
+
+usable_root() {
+    local _d
+    [ -d $1 ] || return 1
+    for _d in proc sys dev; do
+        [ -e "$1"/$_d ] || return 1
+    done
+    return 0
+}
diff --git a/modules.d/99base/init b/modules.d/99base/init
index 90128c7..36b2152 100755
--- a/modules.d/99base/init
+++ b/modules.d/99base/init
@@ -8,6 +8,8 @@
 # Harald Hoyer <harald@redhat.com>
 # Jeremy Katz <katzj@redhat.com>
 
+export -p > /tmp/export.orig
+
 wait_for_loginit()
 {
     set +x
@@ -84,12 +86,6 @@ RD_DEBUG=""
 [ ! -d /sys/kernel ] && \
     mount -t sysfs -o nosuid,noexec,nodev sysfs /sys >/dev/null 2>&1
 
-SECURITYFSDIR="/sys/kernel/security"
-export SECURITYFSDIR
-if ! ismounted "${SECURITYFSDIR}"; then
-    mount -t securityfs -o nosuid,noexec,nodev ${SECURITYFSDIR} ${SECURITYFSDIR} >/dev/null 2>&1
-fi
-
 if [ -x /lib/systemd/systemd-timestamp ]; then
     RD_TIMESTAMP=$(/lib/systemd/systemd-timestamp)
 else
@@ -205,7 +201,8 @@ getarg 'rd.break=pre-trigger' 'rdbreak=pre-trigger' && emergency_shell -n pre-tr
 source_hook pre-trigger
 
 # then the rest
-udevadm trigger --action=add $udevtriggeropts  >/dev/null 2>&1
+udevadm trigger --type=subsystems --action=add >/dev/null 2>&1
+udevadm trigger --type=devices --action=add >/dev/null 2>&1
 
 getarg 'rd.break=initqueue' 'rdbreak=initqueue' && emergency_shell -n initqueue "Break before initqueue"
 
@@ -246,25 +243,20 @@ while :; do
     # no more udev jobs and queues empty.
     sleep 0.5
 
-    # dirty hack for some cdrom drives,
-    # which report no medium for quiet
-    # some time.
-    for cdrom in /sys/block/sr*; do
-        [ -e "$cdrom" ] || continue
-        # skip, if cdrom medium was already found
-        strstr "$(udevadm info --query=env --path=${cdrom##/sys})" \
-            ID_CDROM_MEDIA && continue
-
-        if [ -e "$cdrom"/events_poll_msecs -a ! -e "/tmp/.poll_${cdrom##*/}" ]; then
-            msecs=$(while read a; do echo $a;done < "$cdrom"/events_poll_msecs)
-            if [ "$msecs" = "-1" ]; then
-                echo 250 > "$cdrom"/events_poll_msecs
-                > "/tmp/.poll_${cdrom##*/}"
-            fi
-        else
+    if [ ! -e /sys/module/block/parameters/events_dfl_poll_msecs ]; then
+        # if the kernel does not support autopolling
+        # then we have to do a
+        # dirty hack for some cdrom drives,
+        # which report no medium for quiet
+        # some time.
+        for cdrom in /sys/block/sr*; do
+            [ -e "$cdrom" ] || continue
+            # skip, if cdrom medium was already found
+            strstr "$(udevadm info --query=env --path=${cdrom##/sys})" \
+                ID_CDROM_MEDIA && continue
             echo change > "$cdrom/uevent"
-        fi
-    done
+        done
+    fi
 
     if [ $main_loop -gt $(($RDRETRY/2)) ]; then
 	for job in $hookdir/initqueue/timeout/*.sh; do
@@ -283,14 +275,6 @@ unset queuetriggered
 unset main_loop
 unset RDRETRY
 
-# reset cdrom polling
-for cdrom in /sys/block/sr*; do
-    [ -e "$cdrom" ] || continue
-    if [ -e "$cdrom"/events_poll_msecs ]; then
-        echo -1 > "$cdrom"/events_poll_msecs
-    fi
-done
-
 # pre-mount happens before we try to mount the root filesystem,
 # and happens once.
 getarg 'rd.break=pre-mount' 'rdbreak=pre-mount' && emergency_shell -n pre-mount "Break pre-mount"
@@ -302,10 +286,18 @@ getarg 'rd.break=mount' 'rdbreak=mount' && emergency_shell -n mount "Break mount
 # be sourced any number of times. As soon as one suceeds, no more are sourced.
 i=0
 while :; do
-    [ -d "$NEWROOT/proc" ] && break;
+    if ismounted "$NEWROOT"; then
+        usable_root "$NEWROOT" && break;
+        umount "$NEWROOT"
+    fi
     for f in $hookdir/mount/*.sh; do
         [ -f "$f" ] && . "$f"
-        [ -d "$NEWROOT/proc" ] && break;
+        if ismounted "$NEWROOT"; then
+            usable_root "$NEWROOT" && break;
+            warn "$NEWROOT has no proper rootfs layout, ignoring and removing offending mount hook"
+            umount "$NEWROOT"
+            rm -f "$f"
+        fi
     done
 
     i=$(($i+1))
@@ -361,7 +353,6 @@ done
     emergency_shell
 }
 
-getarg rd.break rdbreak && emergency_shell -n switch_root "Break before switch_root"
 
 if [ $UDEVVERSION -lt 168 ]; then
     # stop udev queue before killing it
@@ -395,6 +386,8 @@ for i in $(export -p); do
             unset "$i";;
     esac
 done
+. /tmp/export.orig 2>/dev/null || :
+rm -f /tmp/export.orig
 
 initargs=""
 read CLINE </proc/cmdline
@@ -443,6 +436,10 @@ fi
 
 wait_for_loginit
 
+# remove helper symlink
+[ -h /dev/root ] && rm -f /dev/root
+
+getarg rd.break rdbreak && emergency_shell -n switch_root "Break before switch_root"
 info "Switching root"
 
 unset PS4
diff --git a/modules.d/99base/initqueue b/modules.d/99base/initqueue
index 21b1c61..2c06a0b 100755
--- a/modules.d/99base/initqueue
+++ b/modules.d/99base/initqueue
@@ -19,8 +19,8 @@ while [ $# -gt 0 ]; do
             qname="/settled";;
         --finished)
             qname="/finished";;
-	--timeout)
-	    qname="/timeout";;
+        --timeout)
+            qname="/timeout";;
         --unique)
             unique="yes";;
         --name)
diff --git a/modules.d/99fs-lib/fs-lib.sh b/modules.d/99fs-lib/fs-lib.sh
index f7b20dd..772d5c0 100755
--- a/modules.d/99fs-lib/fs-lib.sh
+++ b/modules.d/99fs-lib/fs-lib.sh
@@ -59,7 +59,7 @@ fsck_able() {
             ;;
         btrfs)
             type btrfsck >/dev/null 2>&1 &&
-            _drv="_drv=btrfsck fsck_drv_com" &&
+            _drv="_drv=none fsck_drv_btrfs" &&
             return 0
             ;;
         *)
@@ -104,6 +104,37 @@ fsck_drv_xfs() {
     return $_ret
 }
 
+fsck_drv_btrfs() {
+    local _ret
+
+    # fs must be cleanly mounted (and umounted) first, before attempting any
+    # btrfs tools - if this works, nothing else should be needed
+    # note, that user is always dropped into the shell, if the filesystem is
+    # not mountable or if -f flag is found among _fop
+    mkdir -p /tmp/.btrfs
+
+    info "trying to mount $_dev"
+    if mount -t btrfs "$_dev" "/tmp/.btrfs" >/dev/null 2>&1; then
+        _ret=0
+        info "btrfs: $_dev is clean"
+        umount "$_dev" >/dev/null 2>&1
+    else
+        _ret=4
+        warn "*** $_dev is unmountable"
+    fi
+    if [ $_ret -gt 0 ] || strstr "$_fop" "-f"; then
+        warn "*** Dropping you to a shell. You have"
+        warn "*** btrfsck available."
+        warn "*** Note that if btrfs didn't mount properly, it's"
+        warn "*** probably pretty serious condition."
+        emergency_shell -n "(Repair filesystem)"
+    fi
+
+    rm -r /tmp/.btrfs
+    return $_ret
+}
+
+
 # common code for checkers that follow usual subset of options and return codes
 fsck_drv_com() {
     local _ret
@@ -146,7 +177,7 @@ fsck_drv_std() {
 # returns 255 if filesystem wasn't checked at all (e.g. due to lack of
 # necessary tools or insufficient options)
 fsck_single() {
-    local FSTAB_FILE=/etc/fstab.fslib
+    local FSTAB_FILE=/etc/fstab.empty
     local _dev="$1"
     local _fs="${2:-auto}"
     local _fop="$3"
@@ -166,23 +197,23 @@ fsck_single() {
 # takes list of filesystems to check in parallel; we don't rely on automatic
 # checking based on fstab, so empty one is passed
 fsck_batch() {
-    local FSTAB_FILE=/etc/fstab.fslib
+    local FSTAB_FILE=/etc/fstab.empty
     local _drv=fsck
     local _dev
     local _ret
     local _out
 
-    [ $# -eq 0 ] && return 255
+    [ $# -eq 0 ] || ! type fsck >/dev/null 2>&1 && return 255
 
     info "Checking filesystems (fsck -M -T -a):"
     for _dev in "$@"; do
         info "    $_dev"
     done
 
+    export FSTAB_FILE
     _out="$(fsck -M -T "$@" -- -a)"
     _ret=$?
 
-    export FSTAB_FILE
     fsck_tail
 
     return $_ret
diff --git a/modules.d/99fs-lib/module-setup.sh b/modules.d/99fs-lib/module-setup.sh
index cbf69a5..68ea9b1 100755
--- a/modules.d/99fs-lib/module-setup.sh
+++ b/modules.d/99fs-lib/module-setup.sh
@@ -11,13 +11,22 @@ depends() {
 }
 
 install() {
-    dracut_install -o umount mount xfs_db xfs_check xfs_repair
-    dracut_install -o e2fsck
-    dracut_install -o jfs_fsck
-    dracut_install -o reiserfsck
-    dracut_install -o btrfsck
-    dracut_install -o /sbin/fsck*
+    local _helpers
 
     inst "$moddir/fs-lib.sh" "/lib/fs-lib.sh"
-    touch ${initdir}/etc/fstab.fslib
+    touch ${initdir}/etc/fstab.empty
+
+    [[ "$nofscks" = "yes" ]] && return
+
+    if [[ "$fscks" = "${fscks#*[^ ]*}" ]]; then
+        _helpers="\
+            umount mount /sbin/fsck*
+            xfs_db xfs_check xfs_repair
+            e2fsck jfs_fsck reiserfsck btrfsck
+        "
+    else
+        _helpers="$fscks"
+    fi
+
+    dracut_install -o $_helpers
 }
diff --git a/profile.py b/profile.py
new file mode 100644
index 0000000..e1d0cab
--- /dev/null
+++ b/profile.py
@@ -0,0 +1,58 @@
+#
+# parse the output of "dracut --profile" and produce profiling information
+#
+# Copyright 2011 Harald Hoyer <harald@redhat.com>
+# Copyright 2011 Red Hat, Inc.  All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+import sys
+import operator
+import re
+loglines = sys.stdin
+
+logpats  = r'[+]+[ \t]+([^ \t]+)[ \t]+([^ \t:]+):[ ]+.*'
+
+logpat   = re.compile(logpats)
+
+groups   = (logpat.match(line) for line in loglines)
+tuples   = (g.groups() for g in groups if g)
+
+def gen_times(t):
+    oldx=None
+    for x in t:
+        fx=float(x[0])
+        if oldx:
+            #print fx - float(oldx[0]), x[0], x[1], oldx[0], oldx[1]
+            yield (fx - float(oldx[0]), oldx[1])
+
+        oldx = x
+
+colnames = ('time','line')
+
+log      = (dict(zip(colnames,t)) for t in gen_times(tuples))
+
+if __name__ == '__main__':
+    e={}
+    for x in log:
+        if not x['line'] in e:
+            e[x['line']] = x['time']
+        else:
+            e[x['line']] += x['time']
+
+    sorted_x = sorted(e.iteritems(), key=operator.itemgetter(1), reverse=True)
+    for x in sorted_x:
+        print x[0], x[1]
+
diff --git a/test/TEST-16-DMSQUASH/99-idesymlinks.rules b/test/TEST-16-DMSQUASH/99-idesymlinks.rules
new file mode 100644
index 0000000..d557790
--- /dev/null
+++ b/test/TEST-16-DMSQUASH/99-idesymlinks.rules
@@ -0,0 +1,8 @@
+ACTION=="add|change", SUBSYSTEM=="block", ENV{DEVTYPE}=="disk", KERNEL=="hda", SYMLINK+="sda"
+ACTION=="add|change", SUBSYSTEM=="block", ENV{DEVTYPE}=="partition", KERNEL=="hda*", SYMLINK+="sda$env{MINOR}"
+ACTION=="add|change", SUBSYSTEM=="block", ENV{DEVTYPE}=="disk", KERNEL=="hdb", SYMLINK+="sdb"
+ACTION=="add|change", SUBSYSTEM=="block", ENV{DEVTYPE}=="partition", KERNEL=="hdb*", SYMLINK+="sdb$env{MINOR}"
+ACTION=="add|change", SUBSYSTEM=="block", ENV{DEVTYPE}=="disk", KERNEL=="hdc", SYMLINK+="sdc"
+ACTION=="add|change", SUBSYSTEM=="block", ENV{DEVTYPE}=="partition", KERNEL=="hdc*", SYMLINK+="sdc$env{MINOR}"
+ACTION=="add|change", SUBSYSTEM=="block", ENV{DEVTYPE}=="disk", KERNEL=="hdd", SYMLINK+="sdd"
+ACTION=="add|change", SUBSYSTEM=="block", ENV{DEVTYPE}=="partition", KERNEL=="hdd*", SYMLINK+="sdd$env{MINOR}"
diff --git a/test/TEST-16-DMSQUASH/Makefile b/test/TEST-16-DMSQUASH/Makefile
new file mode 100644
index 0000000..bc0ddb6
--- /dev/null
+++ b/test/TEST-16-DMSQUASH/Makefile
@@ -0,0 +1,10 @@
+all:
+	@make -s --no-print-directory -C ../.. all
+	@basedir=../.. testdir=../ ./test.sh --all
+setup:
+	@make --no-print-directory -C ../.. all
+	@basedir=../.. testdir=../ ./test.sh --setup
+clean:
+	@basedir=../.. testdir=../ ./test.sh --clean
+run:
+	@basedir=../.. testdir=../ ./test.sh --run
diff --git a/test/TEST-16-DMSQUASH/create.py b/test/TEST-16-DMSQUASH/create.py
new file mode 100644
index 0000000..15d29ff
--- /dev/null
+++ b/test/TEST-16-DMSQUASH/create.py
@@ -0,0 +1,186 @@
+#!/usr/bin/python -tt
+#
+# livecd-creator : Creates Live CD based for Fedora.
+#
+# Copyright 2007, Red Hat  Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; version 2 of the License.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Library General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+import os
+import os.path
+import sys
+import time
+import optparse
+import logging
+import shutil
+from distutils.dir_util import copy_tree
+
+import imgcreate
+from imgcreate.fs import makedirs
+
+class myLiveImageCreator(imgcreate.x86LiveImageCreator):
+    def install(self, repo_urls = {}):
+        copy_tree("root-source", self._instroot)
+
+    def configure(self):
+        self._create_bootconfig()
+
+    def _get_kernel_versions(self):
+        ret = {}
+        version=os.uname()
+        version=version[2]
+        ret["kernel-" + version] = [version]
+        return ret
+
+    def __sanity_check(self):
+        pass
+
+class Usage(Exception):
+    def __init__(self, msg = None, no_error = False):
+        Exception.__init__(self, msg, no_error)
+
+def parse_options(args):
+    parser = optparse.OptionParser()
+
+    imgopt = optparse.OptionGroup(parser, "Image options",
+                                  "These options define the created image.")
+    imgopt.add_option("-c", "--config", type="string", dest="kscfg",
+                      help="Path or url to kickstart config file")
+    imgopt.add_option("-b", "--base-on", type="string", dest="base_on",
+                      help="Add packages to an existing live CD iso9660 image.")
+    imgopt.add_option("-f", "--fslabel", type="string", dest="fslabel",
+                      help="File system label (default based on config name)")
+    # Provided for img-create compatibility
+    imgopt.add_option("-n", "--name", type="string", dest="fslabel",
+                      help=optparse.SUPPRESS_HELP)
+    imgopt.add_option("", "--image-type", type="string", dest="image_type",
+                      help=optparse.SUPPRESS_HELP)
+    imgopt.add_option("", "--compression-type", type="string", dest="compress_type",
+                      help="Compression type recognized by mksquashfs "
+                           "(default xz needs a 2.6.38+ kernel, gzip works "
+                           "with all kernels, lzo needs a 2.6.36+ kernel, lzma "
+                           "needs custom kernel.) Set to 'None' to force read "
+                           "from base_on.",
+                      default="xz")
+    imgopt.add_option("", "--releasever", type="string", dest="releasever",
+                      default=None,
+                      help="Value to substitute for $releasever in kickstart repo urls")
+    parser.add_option_group(imgopt)
+
+    # options related to the config of your system
+    sysopt = optparse.OptionGroup(parser, "System directory options",
+                                  "These options define directories used on your system for creating the live image")
+    sysopt.add_option("-t", "--tmpdir", type="string",
+                      dest="tmpdir", default="/var/tmp",
+                      help="Temporary directory to use (default: /var/tmp)")
+    sysopt.add_option("", "--cache", type="string",
+                      dest="cachedir", default=None,
+                      help="Cache directory to use (default: private cache")
+    parser.add_option_group(sysopt)
+
+    imgcreate.setup_logging(parser)
+
+    # debug options not recommended for "production" images
+    # Start a shell in the chroot for post-configuration.
+    parser.add_option("-l", "--shell", action="store_true", dest="give_shell",
+                      help=optparse.SUPPRESS_HELP)
+    # Don't compress the image.
+    parser.add_option("-s", "--skip-compression", action="store_true", dest="skip_compression",
+                      help=optparse.SUPPRESS_HELP)
+    parser.add_option("", "--skip-minimize", action="store_true", dest="skip_minimize",
+                      help=optparse.SUPPRESS_HELP)
+
+    (options, args) = parser.parse_args()
+
+    # Pretend to be a image-creator if called with that name
+    options.image_type = 'livecd'
+    if options.image_type not in ('livecd', 'image'):
+        raise Usage("'%s' is a recognized image type" % options.image_type)
+
+    # image-create compatibility: Last argument is kickstart file
+    if len(args) == 1:
+        options.kscfg = args.pop()
+    if len(args):
+        raise Usage("Extra arguments given")
+
+    if options.base_on and not os.path.isfile(options.base_on):
+        raise Usage("Image file '%s' does not exist" %(options.base_on,))
+    if options.image_type == 'livecd':
+        if options.fslabel and len(options.fslabel) > imgcreate.FSLABEL_MAXLEN:
+            raise Usage("CD labels are limited to 32 characters")
+        if options.fslabel and options.fslabel.find(" ") != -1:
+            raise Usage("CD labels cannot contain spaces.")
+
+    return options
+
+def main():
+    try:
+        options = parse_options(sys.argv[1:])
+    except Usage, (msg, no_error):
+        if no_error:
+            out = sys.stdout
+            ret = 0
+        else:
+            out = sys.stderr
+            ret = 2
+        if msg:
+            print >> out, msg
+        return ret
+
+    if os.geteuid () != 0:
+        print >> sys.stderr, "You must run %s as root" % sys.argv[0]
+        return 1
+
+    if options.fslabel:
+        fslabel = options.fslabel
+        name = fslabel
+    else:
+        name = "livecd"
+
+        fslabel = "LiveCD"
+        logging.info("Using label '%s' and name '%s'" % (fslabel, name))
+
+    ks = imgcreate.read_kickstart(options.kscfg)
+
+    creator = myLiveImageCreator(ks, name,
+                                 fslabel=fslabel,
+                                 releasever=options.releasever,
+                                 tmpdir=os.path.abspath(options.tmpdir))
+
+    creator.compress_type = options.compress_type
+    creator.skip_compression = options.skip_compression
+    creator.skip_minimize = options.skip_minimize
+    if options.cachedir:
+        options.cachedir = os.path.abspath(options.cachedir)
+
+    try:
+        creator.mount(options.base_on, options.cachedir)
+        creator.install()
+        creator.configure()
+        if options.give_shell:
+            print "Launching shell. Exit to continue."
+            print "----------------------------------"
+            creator.launch_shell()
+        creator.unmount()
+        creator.package()
+    except imgcreate.CreatorError, e:
+        logging.error(u"Error creating Live CD : %s" % e)
+        return 1
+    finally:
+        creator.cleanup()
+
+    return 0
+
+if __name__ == "__main__":
+    sys.exit(main())
diff --git a/test/TEST-16-DMSQUASH/cryptroot-ask b/test/TEST-16-DMSQUASH/cryptroot-ask
new file mode 100755
index 0000000..db27c5b
--- /dev/null
+++ b/test/TEST-16-DMSQUASH/cryptroot-ask
@@ -0,0 +1,6 @@
+#!/bin/sh
+
+[ -b /dev/mapper/$2 ] && exit 0
+echo -n test >/keyfile
+/sbin/cryptsetup luksOpen $1 $2 </keyfile
+
diff --git a/test/TEST-16-DMSQUASH/hard-off.sh b/test/TEST-16-DMSQUASH/hard-off.sh
new file mode 100755
index 0000000..12c3d5a
--- /dev/null
+++ b/test/TEST-16-DMSQUASH/hard-off.sh
@@ -0,0 +1,3 @@
+#!/bin/sh
+getarg rd.shell || poweroff -f
+getarg failme && poweroff -f
diff --git a/test/TEST-16-DMSQUASH/livecd-fedora-minimal.ks b/test/TEST-16-DMSQUASH/livecd-fedora-minimal.ks
new file mode 100644
index 0000000..88637ae
--- /dev/null
+++ b/test/TEST-16-DMSQUASH/livecd-fedora-minimal.ks
@@ -0,0 +1,22 @@
+lang en_US.UTF-8
+keyboard us
+timezone US/Eastern
+auth --useshadow --enablemd5
+selinux --enforcing
+firewall --disabled
+part / --size 1024
+
+repo --name=fedora --mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-16&arch=$basearch
+
+%packages
+@core
+anaconda-runtime
+bash
+kernel
+passwd
+policycoreutils
+chkconfig
+authconfig
+rootfiles
+
+%end
diff --git a/test/TEST-16-DMSQUASH/test-init b/test/TEST-16-DMSQUASH/test-init
new file mode 100755
index 0000000..616bf68
--- /dev/null
+++ b/test/TEST-16-DMSQUASH/test-init
@@ -0,0 +1,17 @@
+#!/bin/sh
+export PATH=/sbin:/bin:/usr/sbin:/usr/bin
+strstr() { [ "${1#*$2*}" != "$1" ]; }
+CMDLINE=$(while read line; do echo $line;done < /proc/cmdline)
+plymouth --quit
+exec >/dev/console 2>&1
+echo "dracut-root-block-success" >/dev/sda
+export TERM=linux
+export PS1='initramfs-test:\w\$ '
+[ -f /etc/mtab ] || ln -sfn /proc/mounts /etc/mtab
+[ -f /etc/fstab ] || ln -sfn /proc/mounts /etc/fstab
+stty sane
+echo "made it to the rootfs!"
+strstr "$CMDLINE" "rd.shell" && sh -i
+echo "Powering down."
+mount -n -o remount,ro /
+poweroff -f
diff --git a/test/TEST-16-DMSQUASH/test.sh b/test/TEST-16-DMSQUASH/test.sh
new file mode 100755
index 0000000..5d8075c
--- /dev/null
+++ b/test/TEST-16-DMSQUASH/test.sh
@@ -0,0 +1,66 @@
+#!/bin/bash
+TEST_DESCRIPTION="root filesystem on a LiveCD dmsquash filesystem"
+
+KVERSION=${KVERSION-$(uname -r)}
+
+# Uncomment this to debug failures
+#DEBUGFAIL="rd.shell rd.break"
+
+test_run() {
+    $testdir/run-qemu -boot order=d -cdrom livecd.iso -hda root.img -m 256M -nographic \
+	-net none -kernel /boot/vmlinuz-$KVERSION \
+	-append "root=live:CDLABEL=LiveCD live rw quiet rd.retry=3 rd.info console=ttyS0,115200n81 selinux=0 rd.debug $DEBUGFAIL" \
+	-initrd initramfs.testing
+    grep -m 1 -q dracut-root-block-success root.img || return 1
+}
+
+test_setup() {
+    mkdir -p overlay
+    (
+	initdir=overlay
+	. $basedir/dracut-functions
+	dracut_install poweroff shutdown
+	inst_hook emergency 000 ./hard-off.sh
+	inst_simple ./99-idesymlinks.rules /etc/udev/rules.d/99-idesymlinks.rules
+    )
+
+    dd if=/dev/null of=root.img seek=100
+
+    sudo $basedir/dracut -l -i overlay / \
+	-a "debug" \
+	-d "piix ide-gd_mod ata_piix ext3 sd_mod" \
+	-f initramfs.testing $KVERSION || return 1
+
+    mkdir -p root-source
+    kernel=$KVERSION
+    # Create what will eventually be our root filesystem onto an overlay
+    (
+	initdir=root-source
+	. $basedir/dracut-functions
+	dracut_install sh df free ls shutdown poweroff stty cat ps ln ip route \
+	    /lib/terminfo/l/linux mount dmesg ifconfig dhclient mkdir cp ping dhclient \
+	    umount strace less
+	inst "$basedir/modules.d/40network/dhclient-script" "/sbin/dhclient-script"
+	inst "$basedir/modules.d/40network/ifup" "/sbin/ifup"
+	dracut_install grep syslinux isohybrid
+	for f in /usr/share/syslinux/*; do
+	    inst_simple "$f"
+	done
+	inst ./test-init /sbin/init
+	inst ./initramfs.testing "/boot/initramfs-$KVERSION.img"
+	inst /boot/vmlinuz-$KVERSION
+	find_binary plymouth >/dev/null && dracut_install plymouth
+	(cd "$initdir"; mkdir -p dev sys proc etc var/run tmp )
+	cp -a /etc/ld.so.conf* $initdir/etc
+	sudo ldconfig -r "$initdir"
+    )
+    python create.py -d -c livecd-fedora-minimal.ks
+    exit 0
+}
+
+test_cleanup() {
+    rm -fr overlay root-source
+    rm -f root.img initramfs.makeroot initramfs.testing livecd.iso
+}
+
+. $testdir/test-functions
diff --git a/test/TEST-40-NBD/client-init b/test/TEST-40-NBD/client-init
index 22dacd9..eb65b76 100755
--- a/test/TEST-40-NBD/client-init
+++ b/test/TEST-40-NBD/client-init
@@ -5,6 +5,7 @@ while read dev fs fstype opts rest; do
     [ "$dev" = "rootfs" ] && continue
     [ "$fs" != "/" ] && continue
     echo "nbd-OK $fstype $opts" >/dev/sda
+    echo "nbd-OK $fstype $opts" 
     break
 done < /proc/mounts
 export TERM=linux
diff --git a/test/TEST-40-NBD/create-root.sh b/test/TEST-40-NBD/create-root.sh
index bd866e4..4bef5f1 100755
--- a/test/TEST-40-NBD/create-root.sh
+++ b/test/TEST-40-NBD/create-root.sh
@@ -14,6 +14,7 @@ lvm vgcreate dracut /dev/mapper/dracut_crypt_test && \
 lvm lvcreate -l 100%FREE -n root dracut && \
 lvm vgchange -ay && \
 mke2fs -j /dev/dracut/root && \
+/sbin/tune2fs -e continue /dev/dracut/root && \
 mkdir -p /sysroot && \
 mount /dev/dracut/root /sysroot && \
 cp -a -t /sysroot /source/* && \
diff --git a/test/TEST-40-NBD/test.sh b/test/TEST-40-NBD/test.sh
index 675ffd4..c5603fd 100755
--- a/test/TEST-40-NBD/test.sh
+++ b/test/TEST-40-NBD/test.sh
@@ -40,7 +40,7 @@ client_test() {
     local found opts nbdinfo
 
     [[ $fstype ]] || fstype=ext3
-    [[ $fsopt ]] || fsopt="errors=continue"
+    [[ $fsopt ]] || fsopt="ro"
 
     echo "CLIENT TEST START: $test_name"
 
@@ -198,7 +198,7 @@ make_encrypted_root() {
     (
 	initdir=overlay
 	. $basedir/dracut-functions
-	dracut_install mke2fs poweroff cp umount
+	dracut_install mke2fs poweroff cp umount tune2fs
 	inst_hook initqueue 01 ./create-root.sh
 	inst_simple ./99-idesymlinks.rules /etc/udev/rules.d/99-idesymlinks.rules
     )

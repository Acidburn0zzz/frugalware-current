diff -Naur linux-2.6.25/block/blk-barrier.c linux-2.6.25-uml-hack/block/blk-barrier.c
--- linux-2.6.25/block/blk-barrier.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.25-uml-hack/block/blk-barrier.c	2008-04-29 01:09:53.000000000 +0200
@@ -53,7 +53,7 @@
 /*
  * Cache flushing for ordered writes handling
  */
-inline unsigned blk_ordered_cur_seq(struct request_queue *q)
+unsigned blk_ordered_cur_seq(struct request_queue *q)
 {
 	if (!q->ordseq)
 		return 0;
diff -Naur linux-2.6.25/block/elevator.c linux-2.6.25-uml-hack/block/elevator.c
--- linux-2.6.25/block/elevator.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.25-uml-hack/block/elevator.c	2008-04-29 01:05:47.000000000 +0200
@@ -69,7 +69,7 @@
 /*
  * can we safely merge with this request?
  */
-inline int elv_rq_merge_ok(struct request *rq, struct bio *bio)
+int elv_rq_merge_ok(struct request *rq, struct bio *bio)
 {
 	if (!rq_mergeable(rq))
 		return 0;
diff -Naur linux-2.6.25/fs/block_dev.c linux-2.6.25-uml-hack/fs/block_dev.c
--- linux-2.6.25/fs/block_dev.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.25-uml-hack/fs/block_dev.c	2008-04-29 01:00:56.000000000 +0200
@@ -38,7 +38,7 @@
 	return container_of(inode, struct bdev_inode, vfs_inode);
 }
 
-inline struct block_device *I_BDEV(struct inode *inode)
+struct block_device *I_BDEV(struct inode *inode)
 {
 	return &BDEV_I(inode)->bdev;
 }
diff -Naur linux-2.6.25/fs/buffer.c linux-2.6.25-uml-hack/fs/buffer.c
--- linux-2.6.25/fs/buffer.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.25-uml-hack/fs/buffer.c	2008-04-29 00:55:45.000000000 +0200
@@ -46,8 +46,7 @@
 
 #define BH_ENTRY(list) list_entry((list), struct buffer_head, b_assoc_buffers)
 
-inline void
-init_buffer(struct buffer_head *bh, bh_end_io_t *handler, void *private)
+void init_buffer(struct buffer_head *bh, bh_end_io_t *handler, void *private)
 {
 	bh->b_end_io = handler;
 	bh->b_private = private;
diff -Naur linux-2.6.25/fs/reiserfs/do_balan.c linux-2.6.25-uml-hack/fs/reiserfs/do_balan.c
--- linux-2.6.25/fs/reiserfs/do_balan.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.25-uml-hack/fs/reiserfs/do_balan.c	2008-04-29 01:06:38.000000000 +0200
@@ -29,7 +29,7 @@
 					   is interrupting do_balance */
 #endif
 
-inline void do_balance_mark_leaf_dirty(struct tree_balance *tb,
+void do_balance_mark_leaf_dirty(struct tree_balance *tb,
 				       struct buffer_head *bh, int flag)
 {
 	journal_mark_dirty(tb->transaction_handle,
diff -Naur linux-2.6.25/fs/reiserfs/inode.c linux-2.6.25-uml-hack/fs/reiserfs/inode.c
--- linux-2.6.25/fs/reiserfs/inode.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.25-uml-hack/fs/reiserfs/inode.c	2008-04-29 01:20:30.000000000 +0200
@@ -101,7 +101,7 @@
 //
 // when key is 0, do not set version and short key
 //
-inline void make_le_item_head(struct item_head *ih, const struct cpu_key *key,
+void make_le_item_head(struct item_head *ih, const struct cpu_key *key,
 			      int version,
 			      loff_t offset, int type, int length,
 			      int entry_count /*or ih_free_space */ )
diff -Naur linux-2.6.25/fs/reiserfs/namei.c linux-2.6.25-uml-hack/fs/reiserfs/namei.c
--- linux-2.6.25/fs/reiserfs/namei.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.25-uml-hack/fs/reiserfs/namei.c	2008-04-29 01:11:15.000000000 +0200
@@ -62,7 +62,7 @@
 }
 
 // de_bh, de_ih, de_deh (points to first element of array), de_item_num is set
-inline void set_de_name_and_namelen(struct reiserfs_dir_entry *de)
+void set_de_name_and_namelen(struct reiserfs_dir_entry *de)
 {
 	struct reiserfs_de_head *deh = de->de_deh + de->de_entry_num;
 
diff -Naur linux-2.6.25/fs/reiserfs/stree.c linux-2.6.25-uml-hack/fs/reiserfs/stree.c
--- linux-2.6.25/fs/reiserfs/stree.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.25-uml-hack/fs/reiserfs/stree.c	2008-04-29 01:50:34.000000000 +0200
@@ -57,7 +57,7 @@
 #include <linux/quotaops.h>
 
 /* Does the buffer contain a disk block which is in the tree. */
-inline int B_IS_IN_TREE(const struct buffer_head *p_s_bh)
+int B_IS_IN_TREE(const struct buffer_head *p_s_bh)
 {
 
 	RFALSE(B_LEVEL(p_s_bh) > MAX_HEIGHT,
@@ -69,7 +69,7 @@
 //
 // to gets item head in le form
 //
-inline void copy_item_head(struct item_head *p_v_to,
+void copy_item_head(struct item_head *p_v_to,
 			   const struct item_head *p_v_from)
 {
 	memcpy(p_v_to, p_v_from, IH_SIZE);
@@ -81,7 +81,7 @@
    Returns: -1 if key1 < key2 
    0 if key1 == key2
    1 if key1 > key2 */
-inline int comp_short_keys(const struct reiserfs_key *le_key,
+int comp_short_keys(const struct reiserfs_key *le_key,
 			   const struct cpu_key *cpu_key)
 {
 	__u32 n;
@@ -133,7 +133,7 @@
 	return 0;
 }
 
-inline int comp_short_le_keys(const struct reiserfs_key *key1,
+int comp_short_le_keys(const struct reiserfs_key *key1,
 			      const struct reiserfs_key *key2)
 {
 	__u32 *p_s_1_u32, *p_s_2_u32;
@@ -150,7 +150,7 @@
 	return 0;
 }
 
-inline void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from)
+void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from)
 {
 	int version;
 	to->on_disk_key.k_dir_id = le32_to_cpu(from->k_dir_id);
@@ -165,7 +165,7 @@
 
 // this does not say which one is bigger, it only returns 1 if keys
 // are not equal, 0 otherwise
-inline int comp_le_keys(const struct reiserfs_key *k1,
+int comp_le_keys(const struct reiserfs_key *k1,
 			const struct reiserfs_key *k2)
 {
 	return memcmp(k1, k2, sizeof(struct reiserfs_key));
@@ -289,7 +289,7 @@
 }
 
 /* Get delimiting key of the buffer at the path and its right neighbor. */
-inline const struct reiserfs_key *get_rkey(const struct treepath *p_s_chk_path,
+const struct reiserfs_key *get_rkey(const struct treepath *p_s_chk_path,
 					   const struct super_block *p_s_sb)
 {
 	int n_position, n_path_offset = p_s_chk_path->path_length;
diff -Naur linux-2.6.25/fs/udf/partition.c linux-2.6.25-uml-hack/fs/udf/partition.c
--- linux-2.6.25/fs/udf/partition.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.25-uml-hack/fs/udf/partition.c	2008-04-29 01:31:15.000000000 +0200
@@ -28,7 +28,7 @@
 #include <linux/slab.h>
 #include <linux/buffer_head.h>
 
-inline uint32_t udf_get_pblock(struct super_block *sb, uint32_t block,
+uint32_t udf_get_pblock(struct super_block *sb, uint32_t block,
 			       uint16_t partition, uint32_t offset)
 {
 	struct udf_sb_info *sbi = UDF_SB(sb);
diff -Naur linux-2.6.25/include/net/dst.h linux-2.6.25-uml-hack/include/net/dst.h
--- linux-2.6.25/include/net/dst.h	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.25-uml-hack/include/net/dst.h	2008-04-29 12:18:14.000000000 +0200
@@ -240,7 +240,7 @@
 }
 
 /* Output packet to network from transport.  */
-static inline int dst_output(struct sk_buff *skb)
+static int dst_output(struct sk_buff *skb)
 {
 	return skb->dst->output(skb);
 }
diff -Naur linux-2.6.25/mm/filemap.c linux-2.6.25-uml-hack/mm/filemap.c
--- linux-2.6.25/mm/filemap.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.25-uml-hack/mm/filemap.c	2008-04-29 00:54:51.000000000 +0200
@@ -1827,7 +1827,7 @@
  * Returns appropriate error code that caller should return or
  * zero in case that write should be allowed.
  */
-inline int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk)
+int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk)
 {
 	struct inode *inode = file->f_mapping->host;
 	unsigned long limit = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;
diff -Naur linux-2.6.25/net/ipv4/ip_output.c linux-2.6.25-uml-hack/net/ipv4/ip_output.c
--- linux-2.6.25/net/ipv4/ip_output.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.25-uml-hack/net/ipv4/ip_output.c	2008-04-29 01:19:38.000000000 +0200
@@ -85,7 +85,7 @@
 int sysctl_ip_default_ttl __read_mostly = IPDEFTTL;
 
 /* Generate a checksum for an outgoing IP datagram. */
-__inline__ void ip_send_check(struct iphdr *iph)
+void ip_send_check(struct iphdr *iph)
 {
 	iph->check = 0;
 	iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
diff -Naur linux-2.6.25/net/ipv6/ip6_input.c linux-2.6.25-uml-hack/net/ipv6/ip6_input.c
--- linux-2.6.25/net/ipv6/ip6_input.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.25-uml-hack/net/ipv6/ip6_input.c	2008-04-29 22:48:29.000000000 +0200
@@ -47,7 +47,7 @@
 
 
 
-inline int ip6_rcv_finish( struct sk_buff *skb)
+int ip6_rcv_finish( struct sk_buff *skb)
 {
 	if (skb->dst == NULL)
 		ip6_route_input(skb);
diff -Naur linux-2.6.25/net/ipv6/mcast.c linux-2.6.25-uml-hack/net/ipv6/mcast.c
--- linux-2.6.25/net/ipv6/mcast.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.25-uml-hack/net/ipv6/mcast.c	2008-04-29 22:57:04.000000000 +0200
@@ -1446,7 +1446,7 @@
 	return dev_queue_xmit(skb);
 }
 
-static inline int mld_dev_queue_xmit(struct sk_buff *skb)
+static int mld_dev_queue_xmit(struct sk_buff *skb)
 {
 	return NF_HOOK(PF_INET6, NF_INET_POST_ROUTING, skb, NULL, skb->dev,
 		       mld_dev_queue_xmit2);

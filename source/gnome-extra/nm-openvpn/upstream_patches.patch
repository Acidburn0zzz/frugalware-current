diff --git Makefile.am Makefile.am
index 558cfe9..d39827d 100644
--- Makefile.am
+++ Makefile.am
@@ -1,9 +1,9 @@
 AUTOMAKE_OPTIONS = foreign
 
-SUBDIRS = shared src
+SUBDIRS = shared src properties po
 
 if WITH_GNOME
-SUBDIRS += auth-dialog properties po
+SUBDIRS += auth-dialog
 endif
 
 dbusservicedir = $(sysconfdir)/dbus-1/system.d
@@ -19,7 +19,7 @@ install-data-hook:
 	mkdir -p $(DESTDIR)$(sysconfdir)/NetworkManager/VPN
 	sed -e "1s|^|# This file is obsoleted by a file in $(NM_VPN_SERVICE_DIR)\n\n|" \
 	    -e 's|[@]LIBEXECDIR[@]|$(libexecdir)|g' \
-	    -e 's|[@]PLUGINDIR[@]|$(libdir)/NetworkManager|g' \
+	    -e 's|[@]PLUGINDIR[@]|@NM_PLUGIN_DIR@|g' \
 	    <$(srcdir)/nm-openvpn-service.name.in \
 	    >$(DESTDIR)$(sysconfdir)/NetworkManager/VPN/nm-openvpn-service.name
 
@@ -28,29 +28,31 @@ uninstall-hook:
 endif
 
 appdatadir = $(datadir)/appdata
-appdata_DATA = $(appdata_in_files:.xml.in=.xml)
+appdata_files = $(appdata_in_files:.xml.in=.xml)
+if WITH_GNOME
+appdata_DATA = $(appdata_files)
+endif
 appdata_in_files = appdata/network-manager-openvpn.metainfo.xml.in
 @INTLTOOL_XML_RULE@
 
 nm-openvpn-service.name: $(srcdir)/nm-openvpn-service.name.in
 	sed -e 's|[@]LIBEXECDIR[@]|$(libexecdir)|g' \
-	    -e 's|[@]PLUGINDIR[@]/|@NM_PLUGIN_DIR@|g' \
+	    -e 's|[@]PLUGINDIR[@]/|@NM_PLUGIN_DIR_NAME_FILE@|g' \
 	    $^ >$@
 
 DISTCHECK_CONFIGURE_FLAGS = \
-	--with-tests=yes \
 	--enable-more-warnings=yes
 
 EXTRA_DIST = nm-openvpn-service.name.in \
              $(dbusservice_DATA)  \
              $(appdata_in_files)  \
-             $(appdata_DATA)      \
+             $(appdata_files)     \
              intltool-extract.in  \
              intltool-merge.in    \
              intltool-update.in
 
 CLEANFILES = $(nmvpnservice_DATA) \
-             $(appdata_DATA)
+             $(appdata_files)
 
 DISTCLEANFILES = intltool-extract intltool-merge intltool-update
 
diff --git NEWS NEWS
index 62a0bfa..ea11c76 100644
--- NEWS
+++ NEWS
@@ -1,16 +1,4 @@
 =======================================================
-NetworkManagerg-openvpn-1.2.2
-Overview of changes since NetworkManager-openvpn-1.2
-=======================================================
-
-This is a new stable release of NetworkManager-openvpn.  Notable changes include:
-
-* Fixed validation of proxy port
-* Use a proper name for the AppStream metadata
-* Updated Hungarian translation
-
-
-=======================================================
 NetworkManagerg-openvpn-1.2
 Overview of changes since network-manager-openvpn-1.0
 =======================================================
diff --git auth-dialog/main.c auth-dialog/main.c
index 760467e..df06d95 100644
--- auth-dialog/main.c
+++ auth-dialog/main.c
@@ -22,23 +22,18 @@
  *               2005 Tim Niemueller [www.niemueller.de]
  */
 
-#include "config.h"
+#include "nm-default.h"
 
 #include <errno.h>
 #include <string.h>
 #include <stdlib.h>
 #include <gtk/gtk.h>
 
-#define SECRET_API_SUBJECT_TO_CHANGE
 #include <libsecret/secret.h>
 
-#include "nm-default.h"
-
-#include <nm-vpn-service-plugin.h>
 #include <nma-vpn-password-dialog.h>
 
 #include "utils.h"
-#include "nm-openvpn-service-defines.h"
 
 #define KEYRING_UUID_TAG "connection-uuid"
 #define KEYRING_SN_TAG "setting-name"
diff --git configure.ac configure.ac
index 5f2d037..aba4ce1 100644
--- configure.ac
+++ configure.ac
@@ -1,7 +1,7 @@
 AC_PREREQ(2.52)
 
 AC_INIT(NetworkManager-openvpn,
-        1.2.2,
+        1.3.0,
         https://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager,
         NetworkManager-openvpn)
 AM_INIT_AUTOMAKE([1.9 subdir-objects tar-ustar no-dist-gzip dist-xz])
@@ -50,10 +50,25 @@ AC_SUBST([ACLOCAL_AMFLAGS])
 dnl
 dnl GNOME support
 dnl
-AC_ARG_WITH(gnome, AS_HELP_STRING([--without-gnome], [Build NetworkManager-openvpn without GNOME support, e.g. vpn service only]))
-AM_CONDITIONAL(WITH_GNOME, test x"$with_gnome" != xno)
-AC_ARG_WITH(libnm-glib, AS_HELP_STRING([--without-libnm-glib], [Build NetworkManager-openvpn without libnm-glib comatibility]))
-AM_CONDITIONAL(WITH_LIBNM_GLIB, test x"$with_libnm_glib" != xno)
+AC_ARG_WITH(gnome, AS_HELP_STRING([--without-gnome], [Build NetworkManager-openvpn without GNOME support, e.g. vpn service only]), [], [with_gnome_specified=no])
+AC_ARG_WITH(libnm-glib, AS_HELP_STRING([--without-libnm-glib], [Build NetworkManager-openvpn without libnm-glib comatibility]), [], [with_libnm_glib_specified=no])
+if test "$with_libnm_glib_specified" != no -a "$with_libnm_glib" != no; then
+	if test "$with_gnome_specified" != no -a "$with_gnome" == no; then
+		AC_MSG_ERROR(Building --with-libnm-glib conflicts with --without-gnome)
+	fi
+fi
+if test "$with_gnome" != no; then
+	with_gnome=yes
+fi
+if test "$with_libnm_glib_specified" == no; then
+	with_libnm_glib="$with_gnome"
+fi
+if test "$with_libnm_glib" != no; then
+	with_libnm_glib=yes
+fi
+AM_CONDITIONAL(WITH_GNOME, test "$with_gnome" != no)
+AM_CONDITIONAL(WITH_LIBNM_GLIB, test "$with_libnm_glib" != no)
+
 AC_ARG_ENABLE(absolute-paths, AS_HELP_STRING([--enable-absolute-paths], [Use absolute paths to in .name files. Useful for development. (default is no)]))
 
 GETTEXT_PACKAGE=NetworkManager-openvpn
@@ -71,7 +86,11 @@ if test x"$with_gnome" != xno; then
 	GTK_CFLAGS="$GTK_CFLAGS -DGDK_VERSION_MIN_REQUIRED=GDK_VERSION_3_4"
 
 	PKG_CHECK_MODULES(LIBNMA, libnma >= 1.2.0)
-	PKG_CHECK_MODULES(LIBSECRET, libsecret-unstable)
+	PKG_CHECK_MODULES(LIBSECRET, libsecret-1 >= 0.18, [], [
+		dnl We use the secret service API that went stable in 0.18
+		PKG_CHECK_MODULES(LIBSECRET, libsecret-unstable)
+		LIBSECRET_CFLAGS="$LIBSECRET_CFLAGS -DSECRET_API_SUBJECT_TO_CHANGE"
+	])
 
 	if test x"$with_libnm_glib" != xno; then
 		PKG_CHECK_MODULES(LIBNM_GTK, libnm-gtk >= 1.2.0)
@@ -90,27 +109,20 @@ PKG_CHECK_MODULES(LIBNM, libnm >= 1.2.0)
 LIBNM_CFLAGS="$LIBNM_CFLAGS -DNM_VERSION_MIN_REQUIRED=NM_VERSION_1_2"
 LIBNM_CFLAGS="$LIBNM_CFLAGS -DNM_VERSION_MAX_ALLOWED=NM_VERSION_1_2"
 
-NM_VPN_SERVICE_DIR=`$PKG_CONFIG pkg-config --define-variable prefix='\${prefix}' --variable vpnservicedir libnm`
+NM_VPN_SERVICE_DIR=`$PKG_CONFIG --define-variable prefix='\${prefix}' --variable vpnservicedir libnm`
 AC_SUBST(NM_VPN_SERVICE_DIR)
 
 NM_COMPILER_WARNINGS
 
-test x"$enable_absolute_paths" = x"yes" && NM_PLUGIN_DIR='$(libdir)/NetworkManager/'
+NM_PLUGIN_DIR="$libdir/NetworkManager"
 AC_SUBST(NM_PLUGIN_DIR)
-
-dnl
-dnl Tests
-dnl
-AC_ARG_WITH(tests, AS_HELP_STRING([--with-tests], [Build NetworkManager tests]))
-AM_CONDITIONAL(WITH_TESTS, test "x$with_tests" = "xyes")
-case $with_tests in
-    yes)
-        with_tests=yes
-        ;;
-    *)
-        with_tests=no
-        ;;
-esac
+if test x"$enable_absolute_paths" == x"yes"; then
+	NM_PLUGIN_DIR_NAME_FILE="$NM_PLUGIN_DIR/"
+else
+	enable_absolute_paths=no
+	NM_PLUGIN_DIR_NAME_FILE=""
+fi
+AC_SUBST(NM_PLUGIN_DIR_NAME_FILE)
 
 dnl
 dnl Distribution version string
@@ -120,19 +132,6 @@ if ! test x"$ac_distver" = x""; then
   AC_DEFINE_UNQUOTED(DIST_VERSION, "$ac_distver", [Define the distribution version string])
 fi
 
-AC_ARG_WITH(more-asserts,
-            AS_HELP_STRING([--with-more-asserts=level], [Enable more assertions for debugging (default: 0)]),
-            [more_asserts=${with_more_asserts}],
-            [more_asserts=no])
-if test "${more_asserts}" = "no"; then
-    more_asserts=0
-else
-    if test "${more_asserts}" = "yes"; then
-        more_asserts=100
-    fi
-fi
-AC_DEFINE_UNQUOTED(NM_MORE_ASSERTS, $more_asserts, [Define if more asserts are enabled])
-
 AC_CONFIG_FILES([
 Makefile
 src/Makefile
@@ -144,3 +143,10 @@ po/Makefile.in
 shared/Makefile
 ])
 AC_OUTPUT
+
+echo ""
+echo "Build configuration: "
+echo "  --with-gnome=$with_gnome"
+echo "  --with-libnm-glib=$with_libnm_glib"
+echo "  --enable-absolute-paths=$enable_absolute_paths"
+echo "  --enable-more-warnings=$set_more_warnings"
diff --git m4/compiler_warnings.m4 m4/compiler_warnings.m4
index 95ad3fb..77dcc7a 100644
--- m4/compiler_warnings.m4
+++ m4/compiler_warnings.m4
@@ -1,33 +1,106 @@
+dnl Check whether a particular compiler flag works with code provided,
+dnl disable it in CFLAGS if the check fails.
+AC_DEFUN([NM_COMPILER_WARNING], [
+	CFLAGS_SAVED="$CFLAGS"
+	CFLAGS="$CFLAGS -Werror -W$1"
+	AC_MSG_CHECKING(whether -W$1 works)
+
+	AC_COMPILE_IFELSE([AC_LANG_SOURCE([[]])], [
+		AC_COMPILE_IFELSE([AC_LANG_SOURCE([[$2]])], [
+			AC_MSG_RESULT(yes)
+			CFLAGS="$CFLAGS_SAVED -W$1"
+		],[
+			AC_MSG_RESULT(no)
+			CFLAGS="$CFLAGS_SAVED -Wno-$1"
+		])
+	],[
+		AC_MSG_RESULT(not supported)
+		CFLAGS="$CFLAGS_SAVED"
+	])
+])
+
 AC_DEFUN([NM_COMPILER_WARNINGS],
 [AC_ARG_ENABLE(more-warnings,
 	AS_HELP_STRING([--enable-more-warnings], [Possible values: no/yes/error]),
-	set_more_warnings="$enableval",set_more_warnings=error)
+	set_more_warnings="$enableval",set_more_warnings=yes)
 AC_MSG_CHECKING(for more warnings)
 if test "$GCC" = "yes" -a "$set_more_warnings" != "no"; then
 	AC_MSG_RESULT(yes)
-	CFLAGS="-Wall -std=gnu89 $CFLAGS"
+
+	dnl This is enabled in clang by default, makes little sense,
+	dnl and causes the build to abort with -Werror.
+	CFLAGS_SAVED="$CFLAGS"
+	CFLAGS="$CFLAGS -Qunused-arguments"
+	AC_COMPILE_IFELSE([AC_LANG_SOURCE([])], [], CFLAGS="$CFLAGS_SAVED")
+	unset CFLAGS_SAVED
+
+	dnl clang only warns about unknown warnings, unless
+	dnl called with "-Werror=unknown-warning-option"
+	dnl Test if the compiler supports that, and if it does
+	dnl attach it to the CFLAGS.
+	NM_COMPILER_WARNING([unknown-warning-option], [])
+
+	CFLAGS_SAVED="$CFLAGS"
+	CFLAGS_MORE_WARNINGS="-Wall -std=gnu89"
+
+	if test "x$set_more_warnings" = xerror; then
+		CFLAGS_MORE_WARNINGS="$CFLAGS_MORE_WARNINGS -Werror"
+	fi
 
 	for option in -Wshadow -Wmissing-declarations -Wmissing-prototypes \
-		      -Wdeclaration-after-statement -Wstrict-prototypes \
+		      -Wdeclaration-after-statement -Wformat-security \
 		      -Wfloat-equal -Wno-unused-parameter -Wno-sign-compare \
-		      -fno-strict-aliasing -Wno-unused-but-set-variable; do
-		SAVE_CFLAGS="$CFLAGS"
-		CFLAGS="$CFLAGS $option"
-		AC_MSG_CHECKING([whether gcc understands $option])
+		      -Wno-duplicate-decl-specifier \
+		      -Wstrict-prototypes \
+		      -fno-strict-aliasing -Wno-unused-but-set-variable \
+		      -Wundef -Wimplicit-function-declaration \
+		      -Wpointer-arith -Winit-self \
+		      -Wmissing-include-dirs -Wno-pragmas; do
+		dnl GCC 4.4 does not warn when checking for -Wno-* flags (https://gcc.gnu.org/wiki/FAQ#wnowarning)
+		CFLAGS="-Werror $CFLAGS_MORE_WARNINGS $(printf '%s' "$option" | sed 's/^-Wno-/-W/')  $CFLAGS_SAVED"
+		AC_MSG_CHECKING([whether compiler understands $option])
 		AC_TRY_COMPILE([], [],
 			has_option=yes,
 			has_option=no,)
-		if test $has_option = no; then
-			CFLAGS="$SAVE_CFLAGS"
+		if test $has_option != no; then
+			CFLAGS_MORE_WARNINGS="$CFLAGS_MORE_WARNINGS $option"
 		fi
 		AC_MSG_RESULT($has_option)
 		unset has_option
-		unset SAVE_CFLAGS
 	done
 	unset option
-	if test "x$set_more_warnings" = xerror; then
-		CFLAGS="$CFLAGS -Werror"
-	fi
+
+	CFLAGS="$CFLAGS_SAVED"
+	unset CFLAGS_SAVED
+
+	dnl Disable warnings triggered by known compiler problems
+
+	dnl https://bugzilla.gnome.org/show_bug.cgi?id=745821
+	NM_COMPILER_WARNING([unknown-attributes], [#include <glib.h>])
+
+	dnl https://bugzilla.gnome.org/show_bug.cgi?id=744473
+	NM_COMPILER_WARNING([typedef-redefinition], [#include <gio/gio.h>])
+
+	dnl https://llvm.org/bugs/show_bug.cgi?id=21614
+	NM_COMPILER_WARNING([array-bounds],
+		[#include <string.h>]
+		[void f () { strcmp ("something", "0"); }]
+	)
+
+	dnl https://llvm.org/bugs/show_bug.cgi?id=22949
+	NM_COMPILER_WARNING([parentheses-equality],
+		[#include <sys/wait.h>]
+		[void f () { if (WIFCONTINUED(0)) return; }]
+	)
+
+	dnl systemd-dhcp's log_internal macro and our handle_warn are sometimes
+	dnl used in void context,u sometimes in int. Makes clang unhappy.
+	NM_COMPILER_WARNING([unused-value],
+		[#define yolo ({ (666 + 666); })]
+		[int f () { int i = yolo; yolo; return i; }]
+	)
+
+	CFLAGS="$CFLAGS_MORE_WARNINGS $CFLAGS"
 else
 	AC_MSG_RESULT(no)
 fi
diff --git po/POTFILES.in po/POTFILES.in
index 5113f1b..945a1f5 100644
--- po/POTFILES.in
+++ po/POTFILES.in
@@ -4,8 +4,10 @@ appdata/network-manager-openvpn.metainfo.xml.in
 auth-dialog/main.c
 properties/auth-helpers.c
 properties/import-export.c
-properties/nm-openvpn.c
-shared/nm-shared-utils.c
+properties/nm-openvpn-editor-plugin.c
+properties/nm-openvpn-editor.c
+shared/nm-utils/nm-shared-utils.c
+shared/nm-vpn/nm-vpn-plugin-utils.c
 src/nm-openvpn-service.c
 src/nm-openvpn-service-openvpn-helper.c
 [type: gettext/glade]properties/nm-openvpn-dialog.ui
diff --git po/es.po po/es.po
index 88aa3e3..738b610 100644
--- po/es.po
+++ po/es.po
@@ -16,8 +16,8 @@ msgstr ""
 "Project-Id-Version: NetworkManager-openvpn.HEAD\n"
 "Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
 "product=NetworkManager&keywords=I18N+L10N&component=VPN: openvpn\n"
-"POT-Creation-Date: 2016-02-25 14:18+0000\n"
-"PO-Revision-Date: 2016-02-26 08:42+0100\n"
+"POT-Creation-Date: 2016-04-14 10:36+0000\n"
+"PO-Revision-Date: 2016-04-28 15:20+0200\n"
 "Last-Translator: Daniel Mustieles <daniel.mustieles@gmail.com>\n"
 "Language-Team: Español; Castellano <gnome-es-list@gnome.org>\n"
 "Language: \n"
@@ -27,6 +27,28 @@ msgstr ""
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
 "X-Generator: Gtranslator 2.91.6\n"
 
+#: ../appdata/network-manager-openvpn.appdata.xml.in.h:1
+#| msgid "OpenVPN"
+msgid "OpenVPN client"
+msgstr "Cliente de OpenVPN"
+
+#: ../appdata/network-manager-openvpn.appdata.xml.in.h:2
+msgid "Client for OpenVPN virtual private networks"
+msgstr "Cliente para redes privadas virtuales OpenVPN"
+
+#: ../appdata/network-manager-openvpn.appdata.xml.in.h:3
+msgid "Support for configuring OpenVPN virtual private network connections."
+msgstr "Soporte para configurar conexiones a redes privadas virtuales OpenVPN"
+
+#: ../appdata/network-manager-openvpn.appdata.xml.in.h:4
+msgid "OpenVPN is a popular and flexible free-software VPN solution."
+msgstr ""
+"OpenVPN es una solución VPN flexible y popular, y además es software libre."
+
+#: ../appdata/network-manager-openvpn.appdata.xml.in.h:5
+msgid "The NetworkManager Developers"
+msgstr "Los desarrolladores de NetworkManager"
+
 #: ../auth-dialog/main.c:180
 #, c-format
 msgid "Authenticate VPN %s"
@@ -77,8 +99,8 @@ msgstr "Elija un certificado de una autoridad certificadora…"
 msgid "Choose an OpenVPN static key..."
 msgstr "Elija una clave estática OpenVPN…"
 
-#: ../properties/auth-helpers.c:369 ../properties/auth-helpers.c:1110
-#: ../properties/auth-helpers.c:1742
+#: ../properties/auth-helpers.c:369 ../properties/auth-helpers.c:1111
+#: ../properties/auth-helpers.c:1800
 msgid "None"
 msgstr "Ninguno"
 
@@ -94,254 +116,273 @@ msgstr "Certificados PEM (*.pem, *.crt, *.key, *.cer)"
 msgid "OpenVPN Static Keys (*.key)"
 msgstr "Claves estáticas OpenVPN (*.key)"
 
-#: ../properties/auth-helpers.c:1014 ../properties/auth-helpers.c:1102
+#: ../properties/auth-helpers.c:1015 ../properties/auth-helpers.c:1103
 msgid "Default"
 msgstr "Predeterminado"
 
-#: ../properties/auth-helpers.c:1112
+#: ../properties/auth-helpers.c:1113
 msgid "RSA MD-4"
 msgstr "RSA MD-4"
 
-#: ../properties/auth-helpers.c:1114
+#: ../properties/auth-helpers.c:1115
 msgid "MD-5"
 msgstr "MD5"
 
-#: ../properties/auth-helpers.c:1116
+#: ../properties/auth-helpers.c:1117
 msgid "SHA-1"
 msgstr "SHA-1"
 
-#: ../properties/auth-helpers.c:1118
+#: ../properties/auth-helpers.c:1119
 msgid "SHA-224"
 msgstr "SHA-224"
 
-#: ../properties/auth-helpers.c:1120
+#: ../properties/auth-helpers.c:1121
 msgid "SHA-256"
 msgstr "SHA-256"
 
-#: ../properties/auth-helpers.c:1122
+#: ../properties/auth-helpers.c:1123
 msgid "SHA-384"
 msgstr "SHA-384"
 
-#: ../properties/auth-helpers.c:1124
+#: ../properties/auth-helpers.c:1125
 msgid "SHA-512"
 msgstr "SHA-512"
 
-#: ../properties/auth-helpers.c:1126
+#: ../properties/auth-helpers.c:1127
 msgid "RIPEMD-160"
 msgstr "RIPEMD-160"
 
-#: ../properties/auth-helpers.c:1177
+#: ../properties/auth-helpers.c:1178 ../properties/auth-helpers.c:1244
 msgid "Server"
 msgstr "Servidor"
 
-#: ../properties/auth-helpers.c:1182
+#: ../properties/auth-helpers.c:1183 ../properties/auth-helpers.c:1249
 msgid "Client"
 msgstr "Cliente"
 
-#: ../properties/auth-helpers.c:1450 ../properties/nm-openvpn-dialog.ui.h:41
+#: ../properties/auth-helpers.c:1498 ../properties/nm-openvpn-dialog.ui.h:41
 msgid "Not required"
 msgstr "No necesario"
 
-#: ../properties/auth-helpers.c:1452
+#: ../properties/auth-helpers.c:1500
 msgid "HTTP"
 msgstr "HTTP"
 
-#: ../properties/auth-helpers.c:1454
+#: ../properties/auth-helpers.c:1502
 msgid "SOCKS"
 msgstr "SOCKS"
 
-#: ../properties/auth-helpers.c:1639
+#: ../properties/auth-helpers.c:1686
 msgid "TUN"
 msgstr "TUN"
 
-#: ../properties/auth-helpers.c:1641
+#: ../properties/auth-helpers.c:1688
 msgid "TAP"
 msgstr "TAP"
 
 #. interface name is max 15 chars
-#: ../properties/auth-helpers.c:1648
+#: ../properties/auth-helpers.c:1695
 msgid "(automatic)"
 msgstr "(automático)"
 
-#: ../properties/auth-helpers.c:1809
+#: ../properties/auth-helpers.c:1867
 msgid "ping-exit"
 msgstr "ping-exit"
 
-#: ../properties/auth-helpers.c:1811
+#: ../properties/auth-helpers.c:1869
 msgid "ping-restart"
 msgstr "ping-restart"
 
-#: ../properties/import-export.c:142
+#: ../properties/import-export.c:189
 #, c-format
-msgid "option %s expects between %u and %u arguments"
-msgstr "opción %s se esperaba entre %u y %u argumentos"
+#| msgid "option %s expects between %u and %u arguments"
+msgid "option %s expects between %u and %u argument"
+msgid_plural "option %s expects between %u and %u arguments"
+msgstr[0] "la opción %s espera entre %u y %u argumento"
+msgstr[1] "la opción %s espera entre %u y %u argumentos"
 
-#: ../properties/import-export.c:144
+#: ../properties/import-export.c:194
 #, c-format
 msgid "option %s expects no arguments"
 msgstr "opción %s no espera argumentos"
 
-#: ../properties/import-export.c:146
+#: ../properties/import-export.c:196
 #, c-format
+#| msgid "option %s expects exactly one argument"
 msgid "option %s expects exactly one argument"
-msgstr "opción %s espera exactamente un argumento"
+msgid_plural "option %s expects exactly %u arguments"
+msgstr[0] "la opción %s espera exactamente un argumento"
+msgstr[1] "la opción %s espera exactamente %u argumentos"
 
-#: ../properties/import-export.c:148
+#: ../properties/import-export.c:225
 #, c-format
-msgid "option %s expects exactly %u arguments"
-msgstr "opción %s espera exactamente %u argumentos"
+msgid "argument %s of \"%s\" can not be empty"
+msgstr "el argumento %s de «%s» no puede estar vacío"
 
-#: ../properties/import-export.c:178
+#: ../properties/import-export.c:227
+#, c-format
+msgid "argument of \"%s\" can not be empty"
+msgstr ""
+
+#: ../properties/import-export.c:243
+#, c-format
+msgid "argument %s of \"%s\" must be UTF-8 encoded"
+msgstr "el argumento %s de «%s» debe estar codificado en UTF-8"
+
+#: ../properties/import-export.c:245
+#, c-format
+msgid "argument of \"%s\" must be UTF-8 encoded"
+msgstr ""
+
+#: ../properties/import-export.c:269
 #, c-format
 msgid "invalid %uth argument to '%s' where number expected"
 msgstr "argumento %uth no válido en <<%s>> donde se espera un número"
 
-#: ../properties/import-export.c:209
+#: ../properties/import-export.c:300
 #, c-format
 msgid "invalid %uth argument to '%s' where IPv4 address expected"
 msgstr "argumento %uth no válido en <<%s>> donde se espera una dirección IPv4"
 
-#: ../properties/import-export.c:237
+#: ../properties/import-export.c:328
 #, c-format
 msgid "invalid %uth key-direction argument to '%s'"
 msgstr "argumento %uth dirección-llave invalida en <<%s>>"
 
-#: ../properties/import-export.c:251
+#: ../properties/import-export.c:342
 #, c-format
 msgid "invalid %uth argument to '%s'"
 msgstr "Argumento %uth no válido en «%s»"
 
-#: ../properties/import-export.c:365
+#: ../properties/import-export.c:458
 #, c-format
 msgid "unterminated %s at position %lld"
 msgstr "sin terminar %s en la posición %lld"
 
-#: ../properties/import-export.c:366
+#: ../properties/import-export.c:459
 msgid "double quote"
 msgstr "comillas dobles"
 
-#: ../properties/import-export.c:366
+#: ../properties/import-export.c:459
 msgid "single quote"
 msgstr "comilla simple"
 
-#: ../properties/import-export.c:375
+#: ../properties/import-export.c:468
 #, c-format
 msgid "trailing escaping backslash at position %lld"
 msgstr "barra invertida de escape en la posición %lld"
 
-#: ../properties/import-export.c:494
+#: ../properties/import-export.c:589
 #, c-format
 msgid "unable to read HTTP proxy auth file"
 msgstr "incapaz de leer el archivo de autenticación de proxy HTTP"
 
-#: ../properties/import-export.c:512
+#: ../properties/import-export.c:607
 #, c-format
 msgid "cannot read user/password from HTTP proxy auth file"
 msgstr ""
 "no se puede leer usuario/contraseña del archivo de autenticación proxy HTTP"
 
-#: ../properties/import-export.c:574
+#: ../properties/import-export.c:615
+#, fuzzy, c-format
+#| msgid "cannot read user/password from HTTP proxy auth file"
+msgid "user/password from HTTP proxy auth file must be UTF-8 encoded"
+msgstr ""
+"no se puede leer usuario/contraseña del archivo de autenticación proxy HTTP"
+
+#: ../properties/import-export.c:677
 #, c-format
 msgid "'%s' is not a directory"
 msgstr "«%s» no es una carpeta"
 
-#: ../properties/import-export.c:582
+#: ../properties/import-export.c:685
 #, c-format
 msgid "cannot create '%s' directory"
 msgstr "no se puede crear la carpeta «%s»"
 
-#: ../properties/import-export.c:602
+#: ../properties/import-export.c:705
 #, c-format
 msgid "cannot write <%s> blob from line %ld to file (%s)"
 msgstr "no se puede escribir <%s> de la línea %ld en el archivo (%s)"
 
-#: ../properties/import-export.c:619
+#: ../properties/import-export.c:722
 #, c-format
 msgid "cannot write <%s> blob from line %ld to file '%s'"
 msgstr "no se puede escribir <%s> de la línea %ld en el archivo «%s»"
 
-#: ../properties/import-export.c:822
-#, c-format
-msgid "unsupported comp-lzo argument"
-msgstr "argumento comp-lzo no soportado"
-
-#: ../properties/import-export.c:870
+#: ../properties/import-export.c:885 ../properties/import-export.c:1191
 #, c-format
-msgid "empty %s service argument"
-msgstr "argumento de servicio «%s» vacío"
+msgid "invalid option"
+msgstr "opción no válida"
 
-#: ../properties/import-export.c:911
+#: ../properties/import-export.c:917
 #, c-format
-msgid "missing remote argument"
-msgstr "falta argumento remoto"
+msgid "unsupported comp-lzo argument"
+msgstr "argumento comp-lzo no soportado"
 
-#: ../properties/import-export.c:915
+#: ../properties/import-export.c:1005
 #, c-format
 msgid "remote cannot contain space"
 msgstr "remoto no puede contener espacios"
 
-#: ../properties/import-export.c:919
+#: ../properties/import-export.c:1009
 #, c-format
 msgid "remote cannot contain comma"
 msgstr "remoto no puede contener coma"
 
-#: ../properties/import-export.c:930
+#: ../properties/import-export.c:1020
 #, c-format
 msgid "remote expects protocol either udp or remote"
 msgstr "remoto esperaba protocolo udp o remoto"
 
-#: ../properties/import-export.c:1021
-#, c-format
-msgid "missing certificate file name"
-msgstr "falta el nombre de archivo del certificado"
-
-#: ../properties/import-export.c:1092
-#, c-format
-msgid "empty tls-remote argument"
-msgstr "argumento tls-remoto vacío"
-
-#: ../properties/import-export.c:1103
-#, c-format
-msgid "invalid option"
-msgstr "opción no válida"
-
-#: ../properties/import-export.c:1210
+#: ../properties/import-export.c:1304
 #, c-format
 msgid "unsupported blob/xml element"
 msgstr "elemento blob/xml no soportado"
 
-#: ../properties/import-export.c:1239
+#: ../properties/import-export.c:1333
 #, c-format
 msgid "unterminated blob element <%s>"
 msgstr "elemento blob sin terminar <%s>"
 
-#: ../properties/import-export.c:1289
+#: ../properties/import-export.c:1383
 #, c-format
 msgid "configuration error: %s (line %ld)"
 msgstr "error de configuración: %s (línea %ld)"
 
-#: ../properties/import-export.c:1290
+#: ../properties/import-export.c:1384
 msgid "unknown or unsupported option"
 msgstr "opción desconocida o no soportada"
 
-#: ../properties/import-export.c:1300
+#: ../properties/import-export.c:1394
 msgid "The file to import wasn't a valid OpenVPN client configuration"
 msgstr ""
 "El archivo que importar no era una configuración del cliente OpenVPN válida."
 
-#: ../properties/import-export.c:1308
+#: ../properties/import-export.c:1402
 msgid "The file to import wasn't a valid OpenVPN configure (no remote)"
 msgstr ""
 "El archivo que importar no era una configuración OpenVPN válida (no remoto)"
 
-#: ../properties/import-export.c:1449
-msgid "could not open file for writing"
-msgstr "no se pudo abrir el archivo para escritura"
+#: ../properties/import-export.c:1635
+#| msgid "missing remote argument"
+msgid "missing path argument"
+msgstr "falta argumento de la ruta"
+
+#: ../properties/import-export.c:1645
+#| msgid "not a valid OpenVPN configuration file"
+msgid "connection is not a valid OpenVPN connection"
+msgstr "no es una conexión OpenVPN válida"
 
-#: ../properties/import-export.c:1460
+#: ../properties/import-export.c:1654
 msgid "connection was incomplete (missing gateway)"
 msgstr "la conexión estaba incompleta (falta la puerta de enlace)"
 
+#: ../properties/import-export.c:1955
+#, c-format
+msgid "failed to write file: %s"
+msgstr "falló al escribir en el archivo: %s"
+
 #: ../properties/nm-openvpn.c:44
 msgid "OpenVPN"
 msgstr "OpenVPN"
@@ -350,34 +391,250 @@ msgstr "OpenVPN"
 msgid "Compatible with the OpenVPN server."
 msgstr "Compatible con el servidor OpenVPN."
 
-#: ../properties/nm-openvpn.c:326
+#: ../properties/nm-openvpn.c:329
 msgid "Certificates (TLS)"
 msgstr "Certificados (TLS)"
 
-#: ../properties/nm-openvpn.c:337
+#: ../properties/nm-openvpn.c:340
 msgid "Password"
 msgstr "Contraseña"
 
-#: ../properties/nm-openvpn.c:350
+#: ../properties/nm-openvpn.c:353
 msgid "Password with Certificates (TLS)"
 msgstr "Contraseña con certificados (TLS)"
 
-#: ../properties/nm-openvpn.c:362
+#: ../properties/nm-openvpn.c:365
 msgid "Static Key"
 msgstr "Clave estática"
 
-#: ../properties/nm-openvpn.c:510
+#: ../properties/nm-openvpn.c:513
 msgid "could not create openvpn object"
 msgstr "No se pudo crear el objeto openvpn"
 
-#: ../properties/nm-openvpn.c:536
+#: ../properties/nm-openvpn.c:539
 msgid "could not load UI widget"
 msgstr "no se pudo cargar el widget de la IU"
 
-#: ../properties/nm-openvpn.c:627
+#: ../properties/nm-openvpn.c:630
 msgid "unknown OpenVPN file extension"
 msgstr "extensión de archivo de OpenVPN desconocida"
 
+#: ../shared/nm-shared-utils.c:174
+#, c-format
+msgid "object class '%s' has no property named '%s'"
+msgstr ""
+
+#: ../shared/nm-shared-utils.c:181
+#, c-format
+msgid "property '%s' of object class '%s' is not writable"
+msgstr ""
+
+#: ../shared/nm-shared-utils.c:188
+#, c-format
+msgid ""
+"construct property \"%s\" for object '%s' can't be set after construction"
+msgstr ""
+
+#: ../shared/nm-shared-utils.c:196
+#, c-format
+msgid "'%s::%s' is not a valid property name; '%s' is not a GObject subtype"
+msgstr ""
+
+#: ../shared/nm-shared-utils.c:205
+#, c-format
+msgid "unable to set property '%s' of type '%s' from value of type '%s'"
+msgstr ""
+
+#: ../shared/nm-shared-utils.c:216
+#, c-format
+msgid ""
+"value \"%s\" of type '%s' is invalid or out of range for property '%s' of "
+"type '%s'"
+msgstr ""
+
+#: ../src/nm-openvpn-service.c:359
+#, c-format
+msgid "invalid address '%s'"
+msgstr "dirección «%s» no válida"
+
+#: ../src/nm-openvpn-service.c:371
+#, c-format
+msgid "invalid integer property '%s' or out of range [%d -> %d]"
+msgstr "propiedad entera «%s» no válida o fuera de rango [%d -> %d]"
+
+#. Translators: keep "yes" and "no" untranslated!
+#: ../src/nm-openvpn-service.c:382
+#, c-format
+msgid "invalid boolean property '%s' (not yes or no)"
+msgstr "propiedad booleana «%s» no válida (no es «sí» o «no»)"
+
+#: ../src/nm-openvpn-service.c:389
+#, c-format
+msgid "unhandled property '%s' type %s"
+msgstr "propiedad «%s» de tipo %s no controlada"
+
+#: ../src/nm-openvpn-service.c:400
+#, c-format
+msgid "property '%s' invalid or not supported"
+msgstr "propiedad «%s» no válida o no soportada"
+
+#: ../src/nm-openvpn-service.c:416
+msgid "No VPN configuration options."
+msgstr "No hay opciones de configuración de VPN."
+
+#: ../src/nm-openvpn-service.c:585
+msgid "A username is required."
+msgstr "Se requiere un nombre de usuario."
+
+#: ../src/nm-openvpn-service.c:589
+msgid "A password is required."
+msgstr "Se requiere una contraseña."
+
+#: ../src/nm-openvpn-service.c:592
+msgid "A username and password are required."
+msgstr "Se requiere un nombre de usuario y una contraseña."
+
+#: ../src/nm-openvpn-service.c:612
+msgid "A private key password is required."
+msgstr "Se requiere una contraseña de la clave privada."
+
+#: ../src/nm-openvpn-service.c:625
+msgid "An HTTP Proxy username is required."
+msgstr "Se requiere un nombre de usuario para el proxy HTTP."
+
+#: ../src/nm-openvpn-service.c:629
+msgid "An HTTP Proxy password is required."
+msgstr "Se requiere una contraseña para el proxy HTTP."
+
+#: ../src/nm-openvpn-service.c:632
+msgid "An HTTP Proxy username and password are required."
+msgstr "Se requiere un nombre de usuario y una contraseña para el proxy HTTP."
+
+#: ../src/nm-openvpn-service.c:1114
+msgid "Could not find the openvpn binary."
+msgstr "No se pudo encontrar el ejecutable de openvpn."
+
+#: ../src/nm-openvpn-service.c:1124
+msgid "Invalid HMAC auth."
+msgstr "Autenticación HMAC no válida."
+
+#: ../src/nm-openvpn-service.c:1134 ../src/nm-openvpn-service.c:1834
+msgid "Invalid connection type."
+msgstr "Tipo de conexión no válido."
+
+#: ../src/nm-openvpn-service.c:1169 ../src/nm-openvpn-service.c:1179
+#, c-format
+msgid "Invalid port number '%s'."
+msgstr "Número de puerto no válido «%s»."
+
+#: ../src/nm-openvpn-service.c:1196
+#, c-format
+msgid "Invalid proto '%s'."
+msgstr "Protocolo «%s» no válido."
+
+#: ../src/nm-openvpn-service.c:1242
+#, c-format
+msgid "Invalid proxy type '%s'."
+msgstr "Tipo de proxy «%s» no válido."
+
+#: ../src/nm-openvpn-service.c:1265
+#, c-format
+msgid "Invalid ping duration '%s'."
+msgstr "Duración «%s» de ping no válida."
+
+#: ../src/nm-openvpn-service.c:1279
+#, c-format
+msgid "Invalid ping-exit duration '%s'."
+msgstr "Duración «%s» de ping-exit no válida."
+
+#: ../src/nm-openvpn-service.c:1293
+#, c-format
+msgid "Invalid ping-restart duration '%s'."
+msgstr "Duración «%s» de ping-restart no válida."
+
+#: ../src/nm-openvpn-service.c:1345
+#, c-format
+msgid "Invalid keysize '%s'."
+msgstr "Tamaño de clave «%s» no válido."
+
+#: ../src/nm-openvpn-service.c:1402
+#, c-format
+msgid "Invalid reneg seconds '%s'."
+msgstr "Número de segundos de regenociación «%s» no válidos."
+
+#: ../src/nm-openvpn-service.c:1434
+#, c-format
+msgid "Invalid TUN MTU size '%s'."
+msgstr "Tamaño de MTU del TUN «%s» no válido."
+
+#: ../src/nm-openvpn-service.c:1449
+#, c-format
+msgid "Invalid fragment size '%s'."
+msgstr "Tamaño de fragmento «%s» no válido."
+
+#: ../src/nm-openvpn-service.c:1525
+msgid "Missing required local IP address for static key mode."
+msgstr "Falta la dirección IP local para el modo de clave estática."
+
+#: ../src/nm-openvpn-service.c:1537
+msgid "Missing required remote IP address for static key mode."
+msgstr "Falta la dirección IP remota para el modo de clave estática."
+
+#: ../src/nm-openvpn-service.c:1562
+#, c-format
+msgid "Unknown connection type '%s'."
+msgstr "Tipo de conexión «%s» desconocido."
+
+#: ../src/nm-openvpn-service.c:1587
+#, c-format
+msgid "User '%s' not found, check NM_OPENVPN_USER."
+msgstr "Usuario «%s» no encontrado, compruebe NM_OPENVPN_USER."
+
+#: ../src/nm-openvpn-service.c:1601
+#, c-format
+msgid "Group '%s' not found, check NM_OPENVPN_GROUP."
+msgstr "Grupo «%s» no encontrado, compruebe NM_OPENVPN_GROUP."
+
+#: ../src/nm-openvpn-service.c:1748 ../src/nm-openvpn-service.c:1825
+#: ../src/nm-openvpn-service.c:1859
+msgid ""
+"Could not process the request because the VPN connection settings were "
+"invalid."
+msgstr ""
+"No se pudo procesar la solicitud porque la configuración de la conexión VPN "
+"no es válida."
+
+#: ../src/nm-openvpn-service.c:1757
+msgid ""
+"Could not process the request because the openvpn connection type was "
+"invalid."
+msgstr ""
+"No se pudo procesar la solicitud porque el tipo de la conexión openvpn no es "
+"válido."
+
+#: ../src/nm-openvpn-service.c:1872
+msgid "Unhandled pending authentication."
+msgstr "Autenticación pendiente no manejada."
+
+#: ../src/nm-openvpn-service.c:1990
+msgid "Don't quit when VPN connection terminates"
+msgstr "No salir cuando la conexión VPN termine"
+
+#: ../src/nm-openvpn-service.c:1991
+msgid "Enable verbose debug logging (may expose passwords)"
+msgstr ""
+"Activar el registro de depurado detallado (puede mostrar las contraseñas)"
+
+#: ../src/nm-openvpn-service.c:1992
+msgid "D-Bus name to use for this instance"
+msgstr "Nombre D-Bus que usar para esta instancia"
+
+#: ../src/nm-openvpn-service.c:2018
+msgid ""
+"nm-openvpn-service provides integrated OpenVPN capability to NetworkManager."
+msgstr ""
+"nm-openvpn-service proporciona la integración de OpenVPN con NetworkManager."
+
 #: ../properties/nm-openvpn-dialog.ui.h:1
 msgid " "
 msgstr " "
@@ -863,18 +1120,57 @@ msgstr ""
 "opción: remote-cert-tls client|server"
 
 #: ../properties/nm-openvpn-dialog.ui.h:111
+#, fuzzy
+#| msgid "_Verify peer (server) certificate usage signature"
+msgid "_Verify peer (server) certificate nsCertType designation"
+msgstr "_Verificar el uso de la firma del certificado del par (servidor)"
+
+#: ../properties/nm-openvpn-dialog.ui.h:112
+#, fuzzy
+#| msgid ""
+#| "Require that peer certificate was signed with an explicit key usage and "
+#| "extended key usage based on RFC3280 TLS rules."
+msgid ""
+"Require that peer certificate was signed with an explicit nsCertType "
+"designation."
+msgstr ""
+"Requerir que el certificado del par esté firmado usando una clave explícita "
+"y una clave extendida basada en las reglas RFC3280 de TLS."
+
+#: ../properties/nm-openvpn-dialog.ui.h:113
+#, fuzzy
+#| msgid "_Remote peer certificate TLS type:"
+msgid "_Remote peer certificate nsCert designation:"
+msgstr "Tipo de certificado TLS del par _remoto:"
+
+#: ../properties/nm-openvpn-dialog.ui.h:114
+#, fuzzy
+#| msgid ""
+#| "Require that peer certificate was signed with an explicit key usage and "
+#| "extended key usage based on RFC3280 TLS rules.\n"
+#| "config: remote-cert-tls client|server"
+msgid ""
+"Require that peer certificate was signed with an explicit nsCertType "
+"designation.\n"
+"config: ns-cert-type client|server"
+msgstr ""
+"Requerir que el certificado del par esté firmado usando una clave explícita "
+"y una clave extendida basada en las reglas RFC3280 de TLS.\n"
+"opción: remote-cert-tls client|server"
+
+#: ../properties/nm-openvpn-dialog.ui.h:116
 msgid "Use additional _TLS authentication"
 msgstr "Usar autenticación TLS adicional"
 
-#: ../properties/nm-openvpn-dialog.ui.h:112
+#: ../properties/nm-openvpn-dialog.ui.h:117
 msgid "Add an additional layer of HMAC authentication."
 msgstr "Añadir una capa adicional de autenticación HMAC."
 
-#: ../properties/nm-openvpn-dialog.ui.h:113
+#: ../properties/nm-openvpn-dialog.ui.h:118
 msgid "Key _Direction:"
 msgstr "Dirección de la clave:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:114
+#: ../properties/nm-openvpn-dialog.ui.h:119
 msgid ""
 "Add an additional layer of HMAC authentication on top of the TLS control "
 "channel to protect against DoS attacks.\n"
@@ -884,7 +1180,7 @@ msgstr ""
 "control para protegerse de ataques de DoS.\n"
 "opción: tls-auth <file> [direction]"
 
-#: ../properties/nm-openvpn-dialog.ui.h:116
+#: ../properties/nm-openvpn-dialog.ui.h:121
 msgid ""
 "Direction parameter for static key mode.\n"
 "If key direction is used, it must be the opposite of that used on the VPN "
@@ -898,15 +1194,15 @@ msgstr ""
 "seguro de qué valor usar, contacte con el administrador de su sistema.\n"
 "opción: tls-auth <file> [direction]"
 
-#: ../properties/nm-openvpn-dialog.ui.h:119
+#: ../properties/nm-openvpn-dialog.ui.h:124
 msgid "Key _File:"
 msgstr "Archivo de clave:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:120
+#: ../properties/nm-openvpn-dialog.ui.h:125
 msgid "TLS Authentication"
 msgstr "Autenticación TLS"
 
-#: ../properties/nm-openvpn-dialog.ui.h:121
+#: ../properties/nm-openvpn-dialog.ui.h:126
 msgid ""
 "Proxy type: HTTP or Socks.\n"
 "config: http-proxy or socks-proxy"
@@ -914,11 +1210,11 @@ msgstr ""
 "Tipo de proxy: HTTP o Socks.\n"
 "opción: http-proxy or socks-proxy"
 
-#: ../properties/nm-openvpn-dialog.ui.h:123
+#: ../properties/nm-openvpn-dialog.ui.h:128
 msgid "Proxy _Type:"
 msgstr "Tipo de proxy:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:124
+#: ../properties/nm-openvpn-dialog.ui.h:129
 msgid ""
 "<i>Select this option if your organization requires the use of a proxy "
 "server to access the Internet.</i>"
@@ -926,11 +1222,11 @@ msgstr ""
 "<i>Seleccionar esta opción si su organización requiere usar un servidor "
 "proxy para acceder a Internet.</i>"
 
-#: ../properties/nm-openvpn-dialog.ui.h:125
+#: ../properties/nm-openvpn-dialog.ui.h:130
 msgid "Server _Address:"
 msgstr "Dirección del servidor:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:126
+#: ../properties/nm-openvpn-dialog.ui.h:131
 msgid ""
 "Connect to remote host through a proxy with this address.\n"
 "config: http-proxy or socks-proxy"
@@ -938,11 +1234,11 @@ msgstr ""
 "Conectar a un equipo remoto a través de un proxy con esta dirección.\n"
 "opción: http-proxy or socks-proxy"
 
-#: ../properties/nm-openvpn-dialog.ui.h:128
+#: ../properties/nm-openvpn-dialog.ui.h:133
 msgid "_Port:"
 msgstr "Puerto:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:129
+#: ../properties/nm-openvpn-dialog.ui.h:134
 msgid ""
 "Connect to remote host through a proxy with this port.\n"
 "config: http-proxy or socks-proxy"
@@ -950,11 +1246,11 @@ msgstr ""
 "Conectar a un equipo remoto a través de un proxy con este puerto.\n"
 "opción: http-proxy or socks-proxy"
 
-#: ../properties/nm-openvpn-dialog.ui.h:131
+#: ../properties/nm-openvpn-dialog.ui.h:136
 msgid "_Retry indefinitely when errors occur"
 msgstr "_Reintentar indefinidamente cuando haya errores"
 
-#: ../properties/nm-openvpn-dialog.ui.h:132
+#: ../properties/nm-openvpn-dialog.ui.h:137
 msgid ""
 "Retry indefinitely on proxy errors. It simulates a SIGUSR1 reset.\n"
 "config: http-proxy-retry or socks-proxy-retry"
@@ -963,216 +1259,45 @@ msgstr ""
 "SIGUSR1.\n"
 "opción: http-proxy-retry or socks-proxy-retry"
 
-#: ../properties/nm-openvpn-dialog.ui.h:134
+#: ../properties/nm-openvpn-dialog.ui.h:139
 msgid "Proxy _Username:"
 msgstr "Usuario del proxy:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:135
+#: ../properties/nm-openvpn-dialog.ui.h:140
 msgid "Proxy Passwor_d:"
 msgstr "Contraseña del proxy:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:136
+#: ../properties/nm-openvpn-dialog.ui.h:141
 msgid "HTTP/Socks proxy username passed to OpenVPN when prompted for it."
 msgstr ""
 "Nombre de usuario del proxy HTTP/Socks pasado a OpenVPN cuando se solicita."
 
-#: ../properties/nm-openvpn-dialog.ui.h:137
+#: ../properties/nm-openvpn-dialog.ui.h:142
 msgid "HTTP/Socks proxy password passed to OpenVPN when prompted for it."
 msgstr "Contraseña del proxy HTTP/Socks pasada a OpenVPN cuando se solicita."
 
-#: ../properties/nm-openvpn-dialog.ui.h:138
+#: ../properties/nm-openvpn-dialog.ui.h:143
 msgid "_Show password"
 msgstr "Mostrar contraseña"
 
-#: ../properties/nm-openvpn-dialog.ui.h:139
+#: ../properties/nm-openvpn-dialog.ui.h:144
 msgid "Proxies"
 msgstr "Proxies"
 
-#: ../src/nm-openvpn-service.c:358
-#, c-format
-msgid "invalid address '%s'"
-msgstr "dirección «%s» no válida"
-
-#: ../src/nm-openvpn-service.c:370
-#, c-format
-msgid "invalid integer property '%s' or out of range [%d -> %d]"
-msgstr "propiedad entera «%s» no válida o fuera de rango [%d -> %d]"
-
-#. Translators: keep "yes" and "no" untranslated!
-#: ../src/nm-openvpn-service.c:381
-#, c-format
-msgid "invalid boolean property '%s' (not yes or no)"
-msgstr "propiedad booleana «%s» no válida (no es «sí» o «no»)"
-
-#: ../src/nm-openvpn-service.c:388
-#, c-format
-msgid "unhandled property '%s' type %s"
-msgstr "propiedad «%s» de tipo %s no controlada"
-
-#: ../src/nm-openvpn-service.c:399
-#, c-format
-msgid "property '%s' invalid or not supported"
-msgstr "propiedad «%s» no válida o no soportada"
-
-#: ../src/nm-openvpn-service.c:415
-msgid "No VPN configuration options."
-msgstr "No hay opciones de configuración de VPN."
-
-#: ../src/nm-openvpn-service.c:584
-msgid "A username is required."
-msgstr "Se requiere un nombre de usuario."
-
-#: ../src/nm-openvpn-service.c:588
-msgid "A password is required."
-msgstr "Se requiere una contraseña."
-
-#: ../src/nm-openvpn-service.c:591
-msgid "A username and password are required."
-msgstr "Se requiere un nombre de usuario y una contraseña."
-
-#: ../src/nm-openvpn-service.c:611
-msgid "A private key password is required."
-msgstr "Se requiere una contraseña de la clave privada."
-
-#: ../src/nm-openvpn-service.c:624
-msgid "An HTTP Proxy username is required."
-msgstr "Se requiere un nombre de usuario para el proxy HTTP."
+#~ msgid "option %s expects exactly %u arguments"
+#~ msgstr "opción %s espera exactamente %u argumentos"
 
-#: ../src/nm-openvpn-service.c:628
-msgid "An HTTP Proxy password is required."
-msgstr "Se requiere una contraseña para el proxy HTTP."
+#~ msgid "empty %s service argument"
+#~ msgstr "argumento de servicio «%s» vacío"
 
-#: ../src/nm-openvpn-service.c:631
-msgid "An HTTP Proxy username and password are required."
-msgstr "Se requiere un nombre de usuario y una contraseña para el proxy HTTP."
+#~ msgid "missing certificate file name"
+#~ msgstr "falta el nombre de archivo del certificado"
 
-#: ../src/nm-openvpn-service.c:1095
-msgid "Could not find the openvpn binary."
-msgstr "No se pudo encontrar el ejecutable de openvpn."
-
-#: ../src/nm-openvpn-service.c:1105
-msgid "Invalid HMAC auth."
-msgstr "Autenticación HMAC no válida."
-
-#: ../src/nm-openvpn-service.c:1115 ../src/nm-openvpn-service.c:1803
-msgid "Invalid connection type."
-msgstr "Tipo de conexión no válido."
-
-#: ../src/nm-openvpn-service.c:1150 ../src/nm-openvpn-service.c:1160
-#, c-format
-msgid "Invalid port number '%s'."
-msgstr "Número de puerto no válido «%s»."
-
-#: ../src/nm-openvpn-service.c:1177
-#, c-format
-msgid "Invalid proto '%s'."
-msgstr "Protocolo «%s» no válido."
-
-#: ../src/nm-openvpn-service.c:1223
-#, c-format
-msgid "Invalid proxy type '%s'."
-msgstr "Tipo de proxy «%s» no válido."
-
-#: ../src/nm-openvpn-service.c:1246
-#, c-format
-msgid "Invalid ping duration '%s'."
-msgstr "Duración «%s» de ping no válida."
-
-#: ../src/nm-openvpn-service.c:1260
-#, c-format
-msgid "Invalid ping-exit duration '%s'."
-msgstr "Duración «%s» de ping-exit no válida."
-
-#: ../src/nm-openvpn-service.c:1274
-#, c-format
-msgid "Invalid ping-restart duration '%s'."
-msgstr "Duración «%s» de ping-restart no válida."
-
-#: ../src/nm-openvpn-service.c:1324
-#, c-format
-msgid "Invalid keysize '%s'."
-msgstr "Tamaño de clave «%s» no válido."
-
-#: ../src/nm-openvpn-service.c:1374
-#, c-format
-msgid "Invalid reneg seconds '%s'."
-msgstr "Número de segundos de regenociación «%s» no válidos."
-
-#: ../src/nm-openvpn-service.c:1406
-#, c-format
-msgid "Invalid TUN MTU size '%s'."
-msgstr "Tamaño de MTU del TUN «%s» no válido."
-
-#: ../src/nm-openvpn-service.c:1421
-#, c-format
-msgid "Invalid fragment size '%s'."
-msgstr "Tamaño de fragmento «%s» no válido."
-
-#: ../src/nm-openvpn-service.c:1497
-msgid "Missing required local IP address for static key mode."
-msgstr "Falta la dirección IP local para el modo de clave estática."
-
-#: ../src/nm-openvpn-service.c:1509
-msgid "Missing required remote IP address for static key mode."
-msgstr "Falta la dirección IP remota para el modo de clave estática."
-
-#: ../src/nm-openvpn-service.c:1534
-#, c-format
-msgid "Unknown connection type '%s'."
-msgstr "Tipo de conexión «%s» desconocido."
-
-#: ../src/nm-openvpn-service.c:1559
-#, c-format
-msgid "User '%s' not found, check NM_OPENVPN_USER."
-msgstr "Usuario «%s» no encontrado, compruebe NM_OPENVPN_USER."
-
-#: ../src/nm-openvpn-service.c:1573
-#, c-format
-msgid "Group '%s' not found, check NM_OPENVPN_GROUP."
-msgstr "Grupo «%s» no encontrado, compruebe NM_OPENVPN_GROUP."
-
-#: ../src/nm-openvpn-service.c:1717 ../src/nm-openvpn-service.c:1794
-#: ../src/nm-openvpn-service.c:1828
-msgid ""
-"Could not process the request because the VPN connection settings were "
-"invalid."
-msgstr ""
-"No se pudo procesar la solicitud porque la configuración de la conexión VPN "
-"no es válida."
-
-#: ../src/nm-openvpn-service.c:1726
-msgid ""
-"Could not process the request because the openvpn connection type was "
-"invalid."
-msgstr ""
-"No se pudo procesar la solicitud porque el tipo de la conexión openvpn no es "
-"válido."
-
-#: ../src/nm-openvpn-service.c:1841
-msgid "Unhandled pending authentication."
-msgstr "Autenticación pendiente no manejada."
-
-#: ../src/nm-openvpn-service.c:1959
-msgid "Don't quit when VPN connection terminates"
-msgstr "No salir cuando la conexión VPN termine"
-
-#: ../src/nm-openvpn-service.c:1960
-msgid "Enable verbose debug logging (may expose passwords)"
-msgstr ""
-"Activar el registro de depurado detallado (puede mostrar las contraseñas)"
-
-#: ../src/nm-openvpn-service.c:1961
-msgid "D-Bus name to use for this instance"
-msgstr "Nombre D-Bus que usar para esta instancia"
-
-#: ../src/nm-openvpn-service.c:1987
-msgid ""
-"nm-openvpn-service provides integrated OpenVPN capability to NetworkManager."
-msgstr ""
-"nm-openvpn-service proporciona la integración de OpenVPN con NetworkManager."
+#~ msgid "empty tls-remote argument"
+#~ msgstr "argumento tls-remoto vacío"
 
-#~ msgid "not a valid OpenVPN configuration file"
-#~ msgstr "no es un archivo de configuración de OpenVPN válido"
+#~ msgid "could not open file for writing"
+#~ msgstr "no se pudo abrir el archivo para escritura"
 
 #~ msgid "VPN Connection Manager (OpenVPN)"
 #~ msgstr "Gestor de conexiones VPN (OpenVPN)"
diff --git po/pl.po po/pl.po
index 56ef8a4..7f337e9 100644
--- po/pl.po
+++ po/pl.po
@@ -11,8 +11,8 @@ msgid ""
 msgstr ""
 "Project-Id-Version: network-manager-openvpn\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2016-04-14 16:30+0200\n"
-"PO-Revision-Date: 2016-04-14 16:32+0200\n"
+"POT-Creation-Date: 2016-05-07 00:33+0200\n"
+"PO-Revision-Date: 2016-05-07 00:34+0200\n"
 "Last-Translator: Piotr Drąg <piotrdrag@gmail.com>\n"
 "Language-Team: Polish <gnomepl@aviary.pl>\n"
 "Language: pl\n"
@@ -24,174 +24,174 @@ msgstr ""
 "X-Poedit-Language: Polish\n"
 "X-Poedit-Country: Poland\n"
 
-#: ../appdata/network-manager-openvpn.appdata.xml.in.h:1
+#: ../appdata/network-manager-openvpn.metainfo.xml.in.h:1
 msgid "OpenVPN client"
 msgstr "Klient OpenVPN"
 
-#: ../appdata/network-manager-openvpn.appdata.xml.in.h:2
+#: ../appdata/network-manager-openvpn.metainfo.xml.in.h:2
 msgid "Client for OpenVPN virtual private networks"
 msgstr "Klient dla wirtualnych sieci prywatnych OpenVPN"
 
-#: ../appdata/network-manager-openvpn.appdata.xml.in.h:3
+#: ../appdata/network-manager-openvpn.metainfo.xml.in.h:3
 msgid "Support for configuring OpenVPN virtual private network connections."
 msgstr "Obsługa konfigurowania połączeń wirtualnych sieci prywatnych OpenVPN."
 
-#: ../appdata/network-manager-openvpn.appdata.xml.in.h:4
+#: ../appdata/network-manager-openvpn.metainfo.xml.in.h:4
 msgid "OpenVPN is a popular and flexible free-software VPN solution."
 msgstr ""
 "OpenVPN to popularne i elastyczne oprogramowanie VPN na wolnej licencji."
 
-#: ../appdata/network-manager-openvpn.appdata.xml.in.h:5
+#: ../appdata/network-manager-openvpn.metainfo.xml.in.h:5
 msgid "The NetworkManager Developers"
 msgstr "Programiści projektu NetworkManager"
 
-#: ../auth-dialog/main.c:180
+#: ../auth-dialog/main.c:176
 #, c-format
 msgid "Authenticate VPN %s"
 msgstr "Uwierzytelnianie VPN %s"
 
-#: ../auth-dialog/main.c:187 ../properties/nm-openvpn-dialog.ui.h:21
+#: ../auth-dialog/main.c:183 ../properties/nm-openvpn-dialog.ui.h:21
 msgid "Password:"
 msgstr "Hasło:"
 
-#: ../auth-dialog/main.c:194
+#: ../auth-dialog/main.c:190
 msgid "Certificate password:"
 msgstr "Hasło certyfikatu:"
 
-#: ../auth-dialog/main.c:201
+#: ../auth-dialog/main.c:197
 msgid "HTTP proxy password:"
 msgstr "Hasło pośrednika HTTP:"
 
-#: ../auth-dialog/main.c:239
+#: ../auth-dialog/main.c:235
 msgid "Authenticate VPN"
 msgstr "Uwierzytelnianie VPN"
 
-#: ../auth-dialog/main.c:248
+#: ../auth-dialog/main.c:244
 msgid "Certificate pass_word:"
 msgstr "Hasło _certyfikatu:"
 
-#: ../auth-dialog/main.c:254
+#: ../auth-dialog/main.c:250
 msgid "_HTTP proxy password:"
 msgstr "_Hasło pośrednika HTTP:"
 
-#: ../auth-dialog/main.c:518
+#: ../auth-dialog/main.c:514
 #, c-format
 msgid "You need to authenticate to access the Virtual Private Network '%s'."
 msgstr ""
 "Aby uzyskać dostęp do wirtualnej sieci prywatnej „%s”, należy się "
 "uwierzytelnić."
 
-#: ../properties/auth-helpers.c:167
+#: ../properties/auth-helpers.c:164
 msgid "Choose your personal certificate..."
 msgstr "Wybierz certyfikat prywatny…"
 
-#: ../properties/auth-helpers.c:185
+#: ../properties/auth-helpers.c:182
 msgid "Choose your private key..."
 msgstr "Wybierz klucz prywatny…"
 
-#: ../properties/auth-helpers.c:301
+#: ../properties/auth-helpers.c:298
 msgid "Choose a Certificate Authority certificate..."
 msgstr "Wybierz certyfikat CA…"
 
-#: ../properties/auth-helpers.c:345
+#: ../properties/auth-helpers.c:342
 msgid "Choose an OpenVPN static key..."
 msgstr "Wybierz klucz statyczny OpenVPN…"
 
-#: ../properties/auth-helpers.c:369 ../properties/auth-helpers.c:1111
-#: ../properties/auth-helpers.c:1800
+#: ../properties/auth-helpers.c:366 ../properties/auth-helpers.c:1108
+#: ../properties/auth-helpers.c:1797
 msgid "None"
 msgstr "Brak"
 
-#: ../properties/auth-helpers.c:811
+#: ../properties/auth-helpers.c:808
 msgid "PEM or PKCS#12 certificates (*.pem, *.crt, *.key, *.cer, *.p12)"
 msgstr "Certyfikaty PEM lub PKCS#12 (*.pem, *.crt, *.key, *.cer, *.p12)"
 
-#: ../properties/auth-helpers.c:812
+#: ../properties/auth-helpers.c:809
 msgid "PEM certificates (*.pem, *.crt, *.key, *.cer)"
 msgstr "Certyfikaty PEM (*.pem, *.crt, *.key, *.cer)"
 
-#: ../properties/auth-helpers.c:872
+#: ../properties/auth-helpers.c:869
 msgid "OpenVPN Static Keys (*.key)"
 msgstr "Klucze statyczne OpenVPN (*.key)"
 
-#: ../properties/auth-helpers.c:1015 ../properties/auth-helpers.c:1103
+#: ../properties/auth-helpers.c:1012 ../properties/auth-helpers.c:1100
 msgid "Default"
 msgstr "Domyślny"
 
-#: ../properties/auth-helpers.c:1113
+#: ../properties/auth-helpers.c:1110
 msgid "RSA MD-4"
 msgstr "RSA MD-4"
 
-#: ../properties/auth-helpers.c:1115
+#: ../properties/auth-helpers.c:1112
 msgid "MD-5"
 msgstr "MD-5"
 
-#: ../properties/auth-helpers.c:1117
+#: ../properties/auth-helpers.c:1114
 msgid "SHA-1"
 msgstr "SHA-1"
 
-#: ../properties/auth-helpers.c:1119
+#: ../properties/auth-helpers.c:1116
 msgid "SHA-224"
 msgstr "SHA-224"
 
-#: ../properties/auth-helpers.c:1121
+#: ../properties/auth-helpers.c:1118
 msgid "SHA-256"
 msgstr "SHA-256"
 
-#: ../properties/auth-helpers.c:1123
+#: ../properties/auth-helpers.c:1120
 msgid "SHA-384"
 msgstr "SHA-384"
 
-#: ../properties/auth-helpers.c:1125
+#: ../properties/auth-helpers.c:1122
 msgid "SHA-512"
 msgstr "SHA-512"
 
-#: ../properties/auth-helpers.c:1127
+#: ../properties/auth-helpers.c:1124
 msgid "RIPEMD-160"
 msgstr "RIPEMD-160"
 
-#: ../properties/auth-helpers.c:1178 ../properties/auth-helpers.c:1244
+#: ../properties/auth-helpers.c:1175 ../properties/auth-helpers.c:1241
 msgid "Server"
 msgstr "Serwer"
 
-#: ../properties/auth-helpers.c:1183 ../properties/auth-helpers.c:1249
+#: ../properties/auth-helpers.c:1180 ../properties/auth-helpers.c:1246
 msgid "Client"
 msgstr "Klient"
 
-#: ../properties/auth-helpers.c:1498 ../properties/nm-openvpn-dialog.ui.h:41
+#: ../properties/auth-helpers.c:1495 ../properties/nm-openvpn-dialog.ui.h:41
 msgid "Not required"
 msgstr "Niewymagane"
 
-#: ../properties/auth-helpers.c:1500
+#: ../properties/auth-helpers.c:1497
 msgid "HTTP"
 msgstr "HTTP"
 
-#: ../properties/auth-helpers.c:1502
+#: ../properties/auth-helpers.c:1499
 msgid "SOCKS"
 msgstr "SOCKS"
 
-#: ../properties/auth-helpers.c:1686
+#: ../properties/auth-helpers.c:1683
 msgid "TUN"
 msgstr "TUN"
 
-#: ../properties/auth-helpers.c:1688
+#: ../properties/auth-helpers.c:1685
 msgid "TAP"
 msgstr "TAP"
 
 #. interface name is max 15 chars
-#: ../properties/auth-helpers.c:1695
+#: ../properties/auth-helpers.c:1692
 msgid "(automatic)"
 msgstr "(automatycznie)"
 
-#: ../properties/auth-helpers.c:1867
+#: ../properties/auth-helpers.c:1864
 msgid "ping-exit"
 msgstr "ping-exit"
 
-#: ../properties/auth-helpers.c:1869
+#: ../properties/auth-helpers.c:1866
 msgid "ping-restart"
 msgstr "ping-restart"
 
-#: ../properties/import-export.c:189
+#: ../properties/import-export.c:185
 #, c-format
 msgid "option %s expects between %u and %u argument"
 msgid_plural "option %s expects between %u and %u arguments"
@@ -199,12 +199,12 @@ msgstr[0] "opcja %s oczekuje między %u a %u parametrem"
 msgstr[1] "opcja %s oczekuje między %u a %u parametrami"
 msgstr[2] "opcja %s oczekuje między %u a %u parametrami"
 
-#: ../properties/import-export.c:194
+#: ../properties/import-export.c:190
 #, c-format
 msgid "option %s expects no arguments"
 msgstr "opcja %s oczekuje zero parametrów"
 
-#: ../properties/import-export.c:196
+#: ../properties/import-export.c:192
 #, c-format
 msgid "option %s expects exactly one argument"
 msgid_plural "option %s expects exactly %u arguments"
@@ -212,208 +212,208 @@ msgstr[0] "opcja %s oczekuje dokładnie jednego parametru"
 msgstr[1] "opcja %s oczekuje dokładnie %u parametrów"
 msgstr[2] "opcja %s oczekuje dokładnie %u parametrów"
 
-#: ../properties/import-export.c:225
+#: ../properties/import-export.c:221
 #, c-format
 msgid "argument %s of \"%s\" can not be empty"
 msgstr "parametr %s „%s” nie może być pusty"
 
-#: ../properties/import-export.c:227
+#: ../properties/import-export.c:223
 #, c-format
 msgid "argument of \"%s\" can not be empty"
 msgstr "parametr „%s” nie może być pusty"
 
-#: ../properties/import-export.c:243
+#: ../properties/import-export.c:239
 #, c-format
 msgid "argument %s of \"%s\" must be UTF-8 encoded"
 msgstr "parametr %s „%s” musi być zakodowany w UTF-8"
 
-#: ../properties/import-export.c:245
+#: ../properties/import-export.c:241
 #, c-format
 msgid "argument of \"%s\" must be UTF-8 encoded"
 msgstr "parametr „%s” musi być zakodowany w UTF-8"
 
-#: ../properties/import-export.c:269
+#: ../properties/import-export.c:265
 #, c-format
 msgid "invalid %uth argument to '%s' where number expected"
 msgstr "nieprawidłowy parametr numer %u dla „%s”, przekroczono numer"
 
-#: ../properties/import-export.c:300
+#: ../properties/import-export.c:296
 #, c-format
 msgid "invalid %uth argument to '%s' where IPv4 address expected"
 msgstr "nieprawidłowy parametr numer %u dla „%s”, oczekiwano adresu IPv4"
 
-#: ../properties/import-export.c:328
+#: ../properties/import-export.c:324
 #, c-format
 msgid "invalid %uth key-direction argument to '%s'"
 msgstr "nieprawidłowy parametr „key-direction” numer %u dla „%s”"
 
-#: ../properties/import-export.c:342
+#: ../properties/import-export.c:338
 #, c-format
 msgid "invalid %uth argument to '%s'"
 msgstr "nieprawidłowy parametr numer %u dla „%s”"
 
-#: ../properties/import-export.c:458
+#: ../properties/import-export.c:454
 #, c-format
 msgid "unterminated %s at position %lld"
 msgstr "niezakończony %s w położeniu %lld"
 
-#: ../properties/import-export.c:459
+#: ../properties/import-export.c:455
 msgid "double quote"
 msgstr "podwójny cudzysłów"
 
-#: ../properties/import-export.c:459
+#: ../properties/import-export.c:455
 msgid "single quote"
 msgstr "pojedynczy cudzysłów"
 
-#: ../properties/import-export.c:468
+#: ../properties/import-export.c:464
 #, c-format
 msgid "trailing escaping backslash at position %lld"
 msgstr "kończący sterujący wsteczny ukośnik w położeniu %lld"
 
-#: ../properties/import-export.c:589
+#: ../properties/import-export.c:585
 #, c-format
 msgid "unable to read HTTP proxy auth file"
 msgstr "nie można odczytać pliku uwierzytelniania pośrednika HTTP"
 
-#: ../properties/import-export.c:607
+#: ../properties/import-export.c:603
 #, c-format
 msgid "cannot read user/password from HTTP proxy auth file"
 msgstr ""
 "nie można odczytać użytkownika/hasła z pliku uwierzytelniania pośrednika HTTP"
 
-#: ../properties/import-export.c:615
+#: ../properties/import-export.c:611
 #, c-format
 msgid "user/password from HTTP proxy auth file must be UTF-8 encoded"
 msgstr ""
 "użytkownik/hasło z pliku uwierzytelniania pośrednika HTTP musi być "
 "zakodowane w UTF-8"
 
-#: ../properties/import-export.c:677
+#: ../properties/import-export.c:673
 #, c-format
 msgid "'%s' is not a directory"
 msgstr "„%s” nie jest katalogiem"
 
-#: ../properties/import-export.c:685
+#: ../properties/import-export.c:681
 #, c-format
 msgid "cannot create '%s' directory"
 msgstr "nie można utworzyć katalogu „%s”"
 
-#: ../properties/import-export.c:705
+#: ../properties/import-export.c:701
 #, c-format
 msgid "cannot write <%s> blob from line %ld to file (%s)"
 msgstr "nie można zapisać „blob” <%s> z wiersza %ld do pliku (%s)"
 
-#: ../properties/import-export.c:722
+#: ../properties/import-export.c:718
 #, c-format
 msgid "cannot write <%s> blob from line %ld to file '%s'"
 msgstr "nie można zapisać „blob” <%s> z wiersza %ld do pliku „%s”"
 
-#: ../properties/import-export.c:885 ../properties/import-export.c:1191
+#: ../properties/import-export.c:881 ../properties/import-export.c:1187
 #, c-format
 msgid "invalid option"
 msgstr "nieprawidłowa opcja"
 
-#: ../properties/import-export.c:917
+#: ../properties/import-export.c:913
 #, c-format
 msgid "unsupported comp-lzo argument"
 msgstr "nieobsługiwany parametr „comp-lzo”"
 
-#: ../properties/import-export.c:1005
+#: ../properties/import-export.c:1001
 #, c-format
 msgid "remote cannot contain space"
 msgstr "parametr „remote” nie może zawierać spacji"
 
-#: ../properties/import-export.c:1009
+#: ../properties/import-export.c:1005
 #, c-format
 msgid "remote cannot contain comma"
 msgstr "parametr „remote” nie może zawierać przecinków"
 
-#: ../properties/import-export.c:1020
+#: ../properties/import-export.c:1016
 #, c-format
 msgid "remote expects protocol either udp or remote"
 msgstr "parametr „remote” oczekuje protokołu „udp” lub „remote”"
 
-#: ../properties/import-export.c:1304
+#: ../properties/import-export.c:1300
 #, c-format
 msgid "unsupported blob/xml element"
 msgstr "nieobsługiwany element „blob/xml”"
 
-#: ../properties/import-export.c:1333
+#: ../properties/import-export.c:1329
 #, c-format
 msgid "unterminated blob element <%s>"
 msgstr "niezakończony element „blob” <%s>"
 
-#: ../properties/import-export.c:1383
+#: ../properties/import-export.c:1379
 #, c-format
 msgid "configuration error: %s (line %ld)"
 msgstr "błąd konfiguracji: %s (wiersz %ld)"
 
-#: ../properties/import-export.c:1384
+#: ../properties/import-export.c:1380
 msgid "unknown or unsupported option"
 msgstr "nieznana lub nieobsługiwana opcja"
 
-#: ../properties/import-export.c:1394
+#: ../properties/import-export.c:1390
 msgid "The file to import wasn't a valid OpenVPN client configuration"
 msgstr "Importowany plik nie jest prawidłową konfiguracją klienta OpenVPN"
 
-#: ../properties/import-export.c:1402
+#: ../properties/import-export.c:1398
 msgid "The file to import wasn't a valid OpenVPN configure (no remote)"
 msgstr ""
 "Importowany plik nie jest prawidłową konfiguracją OpenVPN (brak „remote”)"
 
-#: ../properties/import-export.c:1635
+#: ../properties/import-export.c:1631
 msgid "missing path argument"
 msgstr "brak parametru ścieżki"
 
-#: ../properties/import-export.c:1645
+#: ../properties/import-export.c:1641
 msgid "connection is not a valid OpenVPN connection"
 msgstr "połączenie nie jest prawidłowym połączeniem OpenVPN"
 
-#: ../properties/import-export.c:1654
+#: ../properties/import-export.c:1650
 msgid "connection was incomplete (missing gateway)"
 msgstr "niepełne połączenie (brak bramy)"
 
-#: ../properties/import-export.c:1955
+#: ../properties/import-export.c:1951
 #, c-format
 msgid "failed to write file: %s"
 msgstr "zapisanie pliku się nie powiodło: %s"
 
-#: ../properties/nm-openvpn.c:44
+#: ../properties/nm-openvpn-editor-plugin.c:44
 msgid "OpenVPN"
 msgstr "OpenVPN"
 
-#: ../properties/nm-openvpn.c:45
+#: ../properties/nm-openvpn-editor-plugin.c:45
 msgid "Compatible with the OpenVPN server."
 msgstr "Zgodny z serwerem OpenVPN."
 
-#: ../properties/nm-openvpn.c:329
+#: ../properties/nm-openvpn-editor-plugin.c:81
+msgid "unknown OpenVPN file extension"
+msgstr "nieznane rozszerzenie pliku OpenVPN"
+
+#: ../properties/nm-openvpn-editor.c:309
 msgid "Certificates (TLS)"
 msgstr "Certyfikaty (TLS)"
 
-#: ../properties/nm-openvpn.c:340
+#: ../properties/nm-openvpn-editor.c:320
 msgid "Password"
 msgstr "Hasło"
 
-#: ../properties/nm-openvpn.c:353
+#: ../properties/nm-openvpn-editor.c:333
 msgid "Password with Certificates (TLS)"
 msgstr "Hasło z certyfikatami (TLS)"
 
-#: ../properties/nm-openvpn.c:365
+#: ../properties/nm-openvpn-editor.c:345
 msgid "Static Key"
 msgstr "Klucz statyczny"
 
-#: ../properties/nm-openvpn.c:513
+#: ../properties/nm-openvpn-editor.c:500
 msgid "could not create openvpn object"
 msgstr "nie można utworzyć obiektu openvpn"
 
-#: ../properties/nm-openvpn.c:539
+#: ../properties/nm-openvpn-editor.c:526
 msgid "could not load UI widget"
 msgstr "nie można wczytać widżetu interfejsu użytkownika"
 
-#: ../properties/nm-openvpn.c:630
-msgid "unknown OpenVPN file extension"
-msgstr "nieznane rozszerzenie pliku OpenVPN"
-
 #: ../shared/nm-shared-utils.c:174
 #, c-format
 msgid "object class '%s' has no property named '%s'"
@@ -453,12 +453,31 @@ msgstr ""
 "wartość „%s” typu „%s” jest nieprawidłowa lub spoza zakresu dla właściwości "
 "„%s” typu „%s”"
 
-#: ../src/nm-openvpn-service.c:359
+#: ../shared/nm-vpn-plugin-utils.c:80
+#, c-format
+msgid "missing plugin file \"%s\""
+msgstr "brak pliku wtyczki „%s”"
+
+#: ../shared/nm-vpn-plugin-utils.c:86
+#, c-format
+msgid "cannot load editor plugin: %s"
+msgstr "nie można wczytać wtyczki edytora: %s"
+
+#: ../shared/nm-vpn-plugin-utils.c:95
+#, c-format
+msgid "cannot load factory %s from plugin: %s"
+msgstr "nie można wczytać generatora %s z wtyczki: %s"
+
+#: ../shared/nm-vpn-plugin-utils.c:121
+msgid "unknown error creating editor instance"
+msgstr "nieznany błąd podczas tworzenia wystąpienia edytora"
+
+#: ../src/nm-openvpn-service.c:354
 #, c-format
 msgid "invalid address '%s'"
 msgstr "nieprawidłowy adres „%s”"
 
-#: ../src/nm-openvpn-service.c:371
+#: ../src/nm-openvpn-service.c:366
 #, c-format
 msgid "invalid integer property '%s' or out of range [%d -> %d]"
 msgstr ""
@@ -466,142 +485,142 @@ msgstr ""
 "%d]"
 
 #. Translators: keep "yes" and "no" untranslated!
-#: ../src/nm-openvpn-service.c:382
+#: ../src/nm-openvpn-service.c:377
 #, c-format
 msgid "invalid boolean property '%s' (not yes or no)"
 msgstr ""
 "nieprawidłowa własność zmiennej logicznej „%s” (nie wynosi „yes” lub „no”)"
 
-#: ../src/nm-openvpn-service.c:389
+#: ../src/nm-openvpn-service.c:384
 #, c-format
 msgid "unhandled property '%s' type %s"
 msgstr "nieobsługiwana własność „%s” typu „%s”"
 
-#: ../src/nm-openvpn-service.c:400
+#: ../src/nm-openvpn-service.c:395
 #, c-format
 msgid "property '%s' invalid or not supported"
 msgstr "własność „%s” jest nieprawidłowa lub nieobsługiwana"
 
-#: ../src/nm-openvpn-service.c:416
+#: ../src/nm-openvpn-service.c:411
 msgid "No VPN configuration options."
 msgstr "Brak opcji konfiguracji VPN."
 
-#: ../src/nm-openvpn-service.c:585
+#: ../src/nm-openvpn-service.c:580
 msgid "A username is required."
 msgstr "Wymagana jest nazwa użytkownika."
 
-#: ../src/nm-openvpn-service.c:589
+#: ../src/nm-openvpn-service.c:584
 msgid "A password is required."
 msgstr "Wymagane jest hasło."
 
-#: ../src/nm-openvpn-service.c:592
+#: ../src/nm-openvpn-service.c:587
 msgid "A username and password are required."
 msgstr "Wymagana jest nazwa użytkownika i hasło."
 
-#: ../src/nm-openvpn-service.c:612
+#: ../src/nm-openvpn-service.c:607
 msgid "A private key password is required."
 msgstr "Wymagane jest hasło klucza prywatnego."
 
-#: ../src/nm-openvpn-service.c:625
+#: ../src/nm-openvpn-service.c:620
 msgid "An HTTP Proxy username is required."
 msgstr "Wymagana jest nazwa użytkownika pośrednika HTTP."
 
-#: ../src/nm-openvpn-service.c:629
+#: ../src/nm-openvpn-service.c:624
 msgid "An HTTP Proxy password is required."
 msgstr "Wymagane jest hasło pośrednika HTTP."
 
-#: ../src/nm-openvpn-service.c:632
+#: ../src/nm-openvpn-service.c:627
 msgid "An HTTP Proxy username and password are required."
 msgstr "Wymagana jest nazwa użytkownika i hasło pośrednika HTTP."
 
-#: ../src/nm-openvpn-service.c:1114
+#: ../src/nm-openvpn-service.c:1109
 msgid "Could not find the openvpn binary."
 msgstr "Nie można odnaleźć pliku binarnego openvpn."
 
-#: ../src/nm-openvpn-service.c:1124
+#: ../src/nm-openvpn-service.c:1119
 msgid "Invalid HMAC auth."
 msgstr "Nieprawidłowe uwierzytelnienie HMAC."
 
-#: ../src/nm-openvpn-service.c:1134 ../src/nm-openvpn-service.c:1834
+#: ../src/nm-openvpn-service.c:1129 ../src/nm-openvpn-service.c:1829
 msgid "Invalid connection type."
 msgstr "Nieprawidłowy typ połączenia."
 
-#: ../src/nm-openvpn-service.c:1169 ../src/nm-openvpn-service.c:1179
+#: ../src/nm-openvpn-service.c:1164 ../src/nm-openvpn-service.c:1174
 #, c-format
 msgid "Invalid port number '%s'."
 msgstr "Nieprawidłowy numer portu „%s”."
 
-#: ../src/nm-openvpn-service.c:1196
+#: ../src/nm-openvpn-service.c:1191
 #, c-format
 msgid "Invalid proto '%s'."
 msgstr "Nieprawidłowy protokół „%s”."
 
-#: ../src/nm-openvpn-service.c:1242
+#: ../src/nm-openvpn-service.c:1237
 #, c-format
 msgid "Invalid proxy type '%s'."
 msgstr "Nieprawidłowy typ pośrednika „%s”."
 
-#: ../src/nm-openvpn-service.c:1265
+#: ../src/nm-openvpn-service.c:1260
 #, c-format
 msgid "Invalid ping duration '%s'."
 msgstr "Nieprawidłowy czas trwania ping „%s”."
 
-#: ../src/nm-openvpn-service.c:1279
+#: ../src/nm-openvpn-service.c:1274
 #, c-format
 msgid "Invalid ping-exit duration '%s'."
 msgstr "Nieprawidłowy czas trwania ping-exit „%s”."
 
-#: ../src/nm-openvpn-service.c:1293
+#: ../src/nm-openvpn-service.c:1288
 #, c-format
 msgid "Invalid ping-restart duration '%s'."
 msgstr "Nieprawidłowy czas trwania ping-restart „%s”."
 
-#: ../src/nm-openvpn-service.c:1345
+#: ../src/nm-openvpn-service.c:1340
 #, c-format
 msgid "Invalid keysize '%s'."
 msgstr "Nieprawidłowy rozmiar klucza „%s”."
 
-#: ../src/nm-openvpn-service.c:1402
+#: ../src/nm-openvpn-service.c:1397
 #, c-format
 msgid "Invalid reneg seconds '%s'."
 msgstr "Nieprawidłowe sekundy renegocjacji „%s”."
 
-#: ../src/nm-openvpn-service.c:1434
+#: ../src/nm-openvpn-service.c:1429
 #, c-format
 msgid "Invalid TUN MTU size '%s'."
 msgstr "Nieprawidłowy rozmiar MTU TUN „%s”."
 
-#: ../src/nm-openvpn-service.c:1449
+#: ../src/nm-openvpn-service.c:1444
 #, c-format
 msgid "Invalid fragment size '%s'."
 msgstr "Nieprawidłowy rozmiar fragmentu „%s”."
 
-#: ../src/nm-openvpn-service.c:1525
+#: ../src/nm-openvpn-service.c:1520
 msgid "Missing required local IP address for static key mode."
 msgstr "Brak wymaganego lokalnego adresu IP dla trybu klucza statycznego."
 
-#: ../src/nm-openvpn-service.c:1537
+#: ../src/nm-openvpn-service.c:1532
 msgid "Missing required remote IP address for static key mode."
 msgstr "Brak wymaganego zdalnego adresu IP dla trybu klucza statycznego."
 
-#: ../src/nm-openvpn-service.c:1562
+#: ../src/nm-openvpn-service.c:1557
 #, c-format
 msgid "Unknown connection type '%s'."
 msgstr "Nieznany typ połączenia „%s”."
 
-#: ../src/nm-openvpn-service.c:1587
+#: ../src/nm-openvpn-service.c:1582
 #, c-format
 msgid "User '%s' not found, check NM_OPENVPN_USER."
 msgstr ""
 "Nie odnaleziono użytkownika „%s”. Proszę sprawdzić zmienną NM_OPENVPN_USER."
 
-#: ../src/nm-openvpn-service.c:1601
+#: ../src/nm-openvpn-service.c:1596
 #, c-format
 msgid "Group '%s' not found, check NM_OPENVPN_GROUP."
 msgstr "Nie odnaleziono grupy „%s”. Proszę sprawdzić zmienną NM_OPENVPN_GROUP."
 
-#: ../src/nm-openvpn-service.c:1748 ../src/nm-openvpn-service.c:1825
-#: ../src/nm-openvpn-service.c:1859
+#: ../src/nm-openvpn-service.c:1743 ../src/nm-openvpn-service.c:1820
+#: ../src/nm-openvpn-service.c:1854
 msgid ""
 "Could not process the request because the VPN connection settings were "
 "invalid."
@@ -609,7 +628,7 @@ msgstr ""
 "Nie można przetworzyć żądania, ponieważ ustawienia połączenia VPN są "
 "nieprawidłowe."
 
-#: ../src/nm-openvpn-service.c:1757
+#: ../src/nm-openvpn-service.c:1752
 msgid ""
 "Could not process the request because the openvpn connection type was "
 "invalid."
@@ -617,23 +636,23 @@ msgstr ""
 "Nie można przetworzyć żądania, ponieważ typ połączenia OpenVPN jest "
 "nieprawidłowy."
 
-#: ../src/nm-openvpn-service.c:1872
+#: ../src/nm-openvpn-service.c:1867
 msgid "Unhandled pending authentication."
 msgstr "Nieobsłużone oczekujące uwierzytelnienie."
 
-#: ../src/nm-openvpn-service.c:1990
+#: ../src/nm-openvpn-service.c:1986
 msgid "Don't quit when VPN connection terminates"
 msgstr "Nie kończy działania, kiedy połączenie VPN jest kończone"
 
-#: ../src/nm-openvpn-service.c:1991
+#: ../src/nm-openvpn-service.c:1987
 msgid "Enable verbose debug logging (may expose passwords)"
 msgstr "Włącza więcej komunikatów debugowania (może wyjawić hasła)"
 
-#: ../src/nm-openvpn-service.c:1992
+#: ../src/nm-openvpn-service.c:1988
 msgid "D-Bus name to use for this instance"
 msgstr "Nazwa D-Bus dla tego wystąpienia"
 
-#: ../src/nm-openvpn-service.c:2018
+#: ../src/nm-openvpn-service.c:2014
 msgid ""
 "nm-openvpn-service provides integrated OpenVPN capability to NetworkManager."
 msgstr ""
diff --git po/pt_BR.po po/pt_BR.po
index 402b564..8323d73 100644
--- po/pt_BR.po
+++ po/pt_BR.po
@@ -13,10 +13,10 @@
 msgid ""
 msgstr ""
 "Project-Id-Version: NetworkManager-OpenVPN\n"
-"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=Network"
-"Manager&keywords=I18N+L10N&component=VPN: openvpn\n"
-"POT-Creation-Date: 2016-04-14 10:38+0000\n"
-"PO-Revision-Date: 2016-04-16 07:07-0200\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=Networ"
+"kManager&keywords=I18N+L10N&component=VPN: openvpn\n"
+"POT-Creation-Date: 2016-05-06 13:09+0000\n"
+"PO-Revision-Date: 2016-05-09 10:17-0200\n"
 "Last-Translator: Rafael Fontenelle <rafaelff@gnome.org>\n"
 "Language-Team: Brazilian Portuguese <gnome-pt_br-list@gnome.org>\n"
 "Language: pt_BR\n"
@@ -27,397 +27,396 @@ msgstr ""
 "X-Generator: Virtaal 0.7.1\n"
 "X-Project-Style: gnome\n"
 
-#: ../appdata/network-manager-openvpn.appdata.xml.in.h:1
-#| msgid "OpenVPN"
+#: ../appdata/network-manager-openvpn.metainfo.xml.in.h:1
 msgid "OpenVPN client"
 msgstr "Cliente OpenVPN"
 
-#: ../appdata/network-manager-openvpn.appdata.xml.in.h:2
+#: ../appdata/network-manager-openvpn.metainfo.xml.in.h:2
 msgid "Client for OpenVPN virtual private networks"
 msgstr "Cliente para redes privadas virtuais OpenVPN"
 
-#: ../appdata/network-manager-openvpn.appdata.xml.in.h:3
+#: ../appdata/network-manager-openvpn.metainfo.xml.in.h:3
 msgid "Support for configuring OpenVPN virtual private network connections."
 msgstr "Suporte a configuração conexões de rede privada virtual OpenVPN."
 
-#: ../appdata/network-manager-openvpn.appdata.xml.in.h:4
+#: ../appdata/network-manager-openvpn.metainfo.xml.in.h:4
 msgid "OpenVPN is a popular and flexible free-software VPN solution."
 msgstr "OpenVPN é uma solução VPN popular e flexível de software livre."
 
-#: ../appdata/network-manager-openvpn.appdata.xml.in.h:5
+#: ../appdata/network-manager-openvpn.metainfo.xml.in.h:5
 msgid "The NetworkManager Developers"
 msgstr "Os desenvolvedores NetworkManager"
 
-#: ../auth-dialog/main.c:180
+#: ../auth-dialog/main.c:176
 #, c-format
 msgid "Authenticate VPN %s"
 msgstr "Autenticar na VPN %s"
 
-#: ../auth-dialog/main.c:187 ../properties/nm-openvpn-dialog.ui.h:21
+#: ../auth-dialog/main.c:183 ../properties/nm-openvpn-dialog.ui.h:21
 msgid "Password:"
 msgstr "Senha:"
 
-#: ../auth-dialog/main.c:194
+#: ../auth-dialog/main.c:190
 msgid "Certificate password:"
 msgstr "Senha do certificado:"
 
-#: ../auth-dialog/main.c:201
+#: ../auth-dialog/main.c:197
 msgid "HTTP proxy password:"
 msgstr "Senha do proxy HTTP:"
 
-#: ../auth-dialog/main.c:239
+#: ../auth-dialog/main.c:235
 msgid "Authenticate VPN"
 msgstr "Autenticar VPN"
 
-#: ../auth-dialog/main.c:248
+#: ../auth-dialog/main.c:244
 msgid "Certificate pass_word:"
 msgstr "Sen_ha do certificado:"
 
-#: ../auth-dialog/main.c:254
+#: ../auth-dialog/main.c:250
 msgid "_HTTP proxy password:"
 msgstr "Senha do proxy _HTTP:"
 
-#: ../auth-dialog/main.c:518
+#: ../auth-dialog/main.c:514
 #, c-format
 msgid "You need to authenticate to access the Virtual Private Network '%s'."
 msgstr "Você precisa se autenticar para acessar a Rede Privada Virtual \"%s\"."
 
-#: ../properties/auth-helpers.c:167
+#: ../properties/auth-helpers.c:164
 msgid "Choose your personal certificate..."
 msgstr "Escolha seu certificado pessoal..."
 
-#: ../properties/auth-helpers.c:185
+#: ../properties/auth-helpers.c:182
 msgid "Choose your private key..."
 msgstr "Escolha sua chave privada..."
 
-#: ../properties/auth-helpers.c:301
+#: ../properties/auth-helpers.c:298
 msgid "Choose a Certificate Authority certificate..."
 msgstr "Escolha um certificado de Autoridade Certificadora..."
 
-#: ../properties/auth-helpers.c:345
+#: ../properties/auth-helpers.c:342
 msgid "Choose an OpenVPN static key..."
 msgstr "Escolha uma chave estática do OpenVPN..."
 
-#: ../properties/auth-helpers.c:369 ../properties/auth-helpers.c:1111
-#: ../properties/auth-helpers.c:1800
+#: ../properties/auth-helpers.c:366 ../properties/auth-helpers.c:1108
+#: ../properties/auth-helpers.c:1797
 msgid "None"
 msgstr "Nenhum"
 
-#: ../properties/auth-helpers.c:811
+#: ../properties/auth-helpers.c:808
 msgid "PEM or PKCS#12 certificates (*.pem, *.crt, *.key, *.cer, *.p12)"
 msgstr "Certificados PEM ou PKCS#12 (*.pem, *.crt, *.key, *.cer, *.p12)"
 
-#: ../properties/auth-helpers.c:812
+#: ../properties/auth-helpers.c:809
 msgid "PEM certificates (*.pem, *.crt, *.key, *.cer)"
 msgstr "Certificados PEM (*.pem, *.crt, *.key, *.cer)"
 
-#: ../properties/auth-helpers.c:872
+#: ../properties/auth-helpers.c:869
 msgid "OpenVPN Static Keys (*.key)"
 msgstr "Chaves estáticas do OpenVPN (*.key)"
 
-#: ../properties/auth-helpers.c:1015 ../properties/auth-helpers.c:1103
+#: ../properties/auth-helpers.c:1012 ../properties/auth-helpers.c:1100
 msgid "Default"
 msgstr "Padrão"
 
-#: ../properties/auth-helpers.c:1113
+#: ../properties/auth-helpers.c:1110
 msgid "RSA MD-4"
 msgstr "RSA MD-4"
 
-#: ../properties/auth-helpers.c:1115
+#: ../properties/auth-helpers.c:1112
 msgid "MD-5"
 msgstr "MD-5"
 
-#: ../properties/auth-helpers.c:1117
+#: ../properties/auth-helpers.c:1114
 msgid "SHA-1"
 msgstr "SHA-1"
 
-#: ../properties/auth-helpers.c:1119
+#: ../properties/auth-helpers.c:1116
 msgid "SHA-224"
 msgstr "SHA-224"
 
-#: ../properties/auth-helpers.c:1121
+#: ../properties/auth-helpers.c:1118
 msgid "SHA-256"
 msgstr "SHA-256"
 
-#: ../properties/auth-helpers.c:1123
+#: ../properties/auth-helpers.c:1120
 msgid "SHA-384"
 msgstr "SHA-384"
 
-#: ../properties/auth-helpers.c:1125
+#: ../properties/auth-helpers.c:1122
 msgid "SHA-512"
 msgstr "SHA-512"
 
-#: ../properties/auth-helpers.c:1127
+#: ../properties/auth-helpers.c:1124
 msgid "RIPEMD-160"
 msgstr "RIPEMD-160"
 
-#: ../properties/auth-helpers.c:1178 ../properties/auth-helpers.c:1244
+#: ../properties/auth-helpers.c:1175 ../properties/auth-helpers.c:1241
 msgid "Server"
 msgstr "Servidor"
 
-#: ../properties/auth-helpers.c:1183 ../properties/auth-helpers.c:1249
+#: ../properties/auth-helpers.c:1180 ../properties/auth-helpers.c:1246
 msgid "Client"
 msgstr "Cliente"
 
-#: ../properties/auth-helpers.c:1498 ../properties/nm-openvpn-dialog.ui.h:41
+#: ../properties/auth-helpers.c:1495 ../properties/nm-openvpn-dialog.ui.h:41
 msgid "Not required"
 msgstr "Não requerido"
 
-#: ../properties/auth-helpers.c:1500
+#: ../properties/auth-helpers.c:1497
 msgid "HTTP"
 msgstr "HTTP"
 
-#: ../properties/auth-helpers.c:1502
+#: ../properties/auth-helpers.c:1499
 msgid "SOCKS"
 msgstr "SOCKS"
 
-#: ../properties/auth-helpers.c:1686
+#: ../properties/auth-helpers.c:1683
 msgid "TUN"
 msgstr "TUN"
 
-#: ../properties/auth-helpers.c:1688
+#: ../properties/auth-helpers.c:1685
 msgid "TAP"
 msgstr "TAP"
 
 #. interface name is max 15 chars
-#: ../properties/auth-helpers.c:1695
+#: ../properties/auth-helpers.c:1692
 msgid "(automatic)"
 msgstr "(automático)"
 
-#: ../properties/auth-helpers.c:1867
+#: ../properties/auth-helpers.c:1864
 msgid "ping-exit"
 msgstr "ping-exit"
 
-#: ../properties/auth-helpers.c:1869
+#: ../properties/auth-helpers.c:1866
 msgid "ping-restart"
 msgstr "ping-restart"
 
-#: ../properties/import-export.c:189
+#: ../properties/import-export.c:185
 #, c-format
 msgid "option %s expects between %u and %u argument"
 msgid_plural "option %s expects between %u and %u arguments"
 msgstr[0] "a opção %s espera entre %u e %u argumento"
 msgstr[1] "a opção %s espera entre %u e %u argumentos"
 
-#: ../properties/import-export.c:194
+#: ../properties/import-export.c:190
 #, c-format
 msgid "option %s expects no arguments"
 msgstr "a opção %s espera nenhum argumento"
 
-#: ../properties/import-export.c:196
+#: ../properties/import-export.c:192
 #, c-format
 msgid "option %s expects exactly one argument"
 msgid_plural "option %s expects exactly %u arguments"
 msgstr[0] "a opção %s espera exatamente um argumento"
 msgstr[1] "a opção %s espera exatamente %u argumentos"
 
-#: ../properties/import-export.c:225
+#: ../properties/import-export.c:221
 #, c-format
 msgid "argument %s of \"%s\" can not be empty"
 msgstr "argumento %s de \"%s\" não pode estar vazio"
 
-#: ../properties/import-export.c:227
+#: ../properties/import-export.c:223
 #, c-format
 msgid "argument of \"%s\" can not be empty"
 msgstr "argumento de \"%s\" não pode estar vazio"
 
-#: ../properties/import-export.c:243
+#: ../properties/import-export.c:239
 #, c-format
 msgid "argument %s of \"%s\" must be UTF-8 encoded"
 msgstr "argumento %s de \"%s\" deve estar codificado em UTF-8"
 
-#: ../properties/import-export.c:245
+#: ../properties/import-export.c:241
 #, c-format
 msgid "argument of \"%s\" must be UTF-8 encoded"
 msgstr "argumento de \"%s\" deve estar codificado em UTF-8"
 
-#: ../properties/import-export.c:269
+#: ../properties/import-export.c:265
 #, c-format
 msgid "invalid %uth argument to '%s' where number expected"
 msgstr "%uº argumento de \"%s\" inválido, no qual se esperava um número"
 
-#: ../properties/import-export.c:300
+#: ../properties/import-export.c:296
 #, c-format
 msgid "invalid %uth argument to '%s' where IPv4 address expected"
 msgstr "%uº argumento de \"%s\" inválido, no qual se esperava um endereço IPv4"
 
-#: ../properties/import-export.c:328
+#: ../properties/import-export.c:324
 #, c-format
 msgid "invalid %uth key-direction argument to '%s'"
 msgstr "argumento de direção chave %uº inválido para \"%s\""
 
-#: ../properties/import-export.c:342
+#: ../properties/import-export.c:338
 #, c-format
 msgid "invalid %uth argument to '%s'"
 msgstr "%uº argumento de \"%s\" inválido"
 
 # %s é substituído pela tradução de "double quote" ou "single quote".
-#: ../properties/import-export.c:458
+#: ../properties/import-export.c:454
 #, c-format
 msgid "unterminated %s at position %lld"
 msgstr "%s não terminadas na posição %lld"
 
-#: ../properties/import-export.c:459
+#: ../properties/import-export.c:455
 msgid "double quote"
 msgstr "aspas duplas"
 
-#: ../properties/import-export.c:459
+#: ../properties/import-export.c:455
 msgid "single quote"
 msgstr "aspas simples"
 
-#: ../properties/import-export.c:468
+#: ../properties/import-export.c:464
 #, c-format
 msgid "trailing escaping backslash at position %lld"
 msgstr "barra invertida de escape ao final na posição %lld"
 
-#: ../properties/import-export.c:589
+#: ../properties/import-export.c:585
 #, c-format
 msgid "unable to read HTTP proxy auth file"
 msgstr "não foi possível ler o arquivo auth de proxy HTTP"
 
-#: ../properties/import-export.c:607
+#: ../properties/import-export.c:603
 #, c-format
 msgid "cannot read user/password from HTTP proxy auth file"
 msgstr "não foi possível ler usuário/senha do arquivo auth de proxy HTTP"
 
-#: ../properties/import-export.c:615
+#: ../properties/import-export.c:611
 #, c-format
 msgid "user/password from HTTP proxy auth file must be UTF-8 encoded"
 msgstr ""
 "usuário/senha do arquivo auth de proxy HTTP deve estar codificado em UTF-8"
 
-#: ../properties/import-export.c:677
+#: ../properties/import-export.c:673
 #, c-format
 msgid "'%s' is not a directory"
 msgstr "\"%s\" não é um diretório"
 
-#: ../properties/import-export.c:685
+#: ../properties/import-export.c:681
 #, c-format
 msgid "cannot create '%s' directory"
 msgstr "não foi possível criar o diretório \"%s\""
 
-#: ../properties/import-export.c:705
+#: ../properties/import-export.c:701
 #, c-format
 msgid "cannot write <%s> blob from line %ld to file (%s)"
 msgstr ""
 "não foi possível escrever o blob <%s> a partir da linha %ld para o arquivo "
 "(%s)"
 
-#: ../properties/import-export.c:722
+#: ../properties/import-export.c:718
 #, c-format
 msgid "cannot write <%s> blob from line %ld to file '%s'"
 msgstr ""
-"não foi possível escrever o blob <%s> a partir da linha %ld para o arquivo \""
-"%s\""
+"não foi possível escrever o blob <%s> a partir da linha %ld para o arquivo "
+"\"%s\""
 
-#: ../properties/import-export.c:885 ../properties/import-export.c:1191
+#: ../properties/import-export.c:881 ../properties/import-export.c:1187
 #, c-format
 msgid "invalid option"
 msgstr "opção inválida"
 
-#: ../properties/import-export.c:917
+#: ../properties/import-export.c:913
 #, c-format
 msgid "unsupported comp-lzo argument"
 msgstr "argumento comp-lzo sem suporte"
 
-#: ../properties/import-export.c:1005
+#: ../properties/import-export.c:1001
 #, c-format
 msgid "remote cannot contain space"
 msgstr "remoto não pode conter espaço"
 
-#: ../properties/import-export.c:1009
+#: ../properties/import-export.c:1005
 #, c-format
 msgid "remote cannot contain comma"
 msgstr "remoto não pode conter vírgula"
 
-#: ../properties/import-export.c:1020
+#: ../properties/import-export.c:1016
 #, c-format
 msgid "remote expects protocol either udp or remote"
 msgstr "remoto espera que protocolo seja udp ou remoto"
 
-#: ../properties/import-export.c:1304
+#: ../properties/import-export.c:1300
 #, c-format
 msgid "unsupported blob/xml element"
 msgstr "elemento blob/xml sem suporte"
 
-#: ../properties/import-export.c:1333
+#: ../properties/import-export.c:1329
 #, c-format
 msgid "unterminated blob element <%s>"
 msgstr "elemento <%s> blob não terminado"
 
-#: ../properties/import-export.c:1383
+#: ../properties/import-export.c:1379
 #, c-format
 msgid "configuration error: %s (line %ld)"
 msgstr "erro de configuração: %s (linha %ld)"
 
-#: ../properties/import-export.c:1384
+#: ../properties/import-export.c:1380
 msgid "unknown or unsupported option"
 msgstr "opção sem suporte ou desconhecida"
 
-#: ../properties/import-export.c:1394
+#: ../properties/import-export.c:1390
 msgid "The file to import wasn't a valid OpenVPN client configuration"
 msgstr ""
 "O arquivo a ser importado não era uma configuração de cliente OpenVPN válida"
 
-#: ../properties/import-export.c:1402
+#: ../properties/import-export.c:1398
 msgid "The file to import wasn't a valid OpenVPN configure (no remote)"
 msgstr ""
 "O arquivo a ser importado não era uma configuração OpenVPN válida (nenhum "
 "remoto)"
 
-#: ../properties/import-export.c:1635
+#: ../properties/import-export.c:1631
 msgid "missing path argument"
 msgstr "faltando argumento de caminho"
 
-#: ../properties/import-export.c:1645
+#: ../properties/import-export.c:1641
 msgid "connection is not a valid OpenVPN connection"
 msgstr "a conexão não é uma conexão OpenVPN válida"
 
-#: ../properties/import-export.c:1654
+#: ../properties/import-export.c:1650
 msgid "connection was incomplete (missing gateway)"
 msgstr "conexão estava incompleta (faltando gateway)"
 
-#: ../properties/import-export.c:1955
+#: ../properties/import-export.c:1951
 #, c-format
 msgid "failed to write file: %s"
 msgstr "falha ao escrever o arquivo: %s"
 
-#: ../properties/nm-openvpn.c:44
+#: ../properties/nm-openvpn-editor-plugin.c:44
 msgid "OpenVPN"
 msgstr "OpenVPN"
 
-#: ../properties/nm-openvpn.c:45
+#: ../properties/nm-openvpn-editor-plugin.c:45
 msgid "Compatible with the OpenVPN server."
 msgstr "Compatível com o servidor OpenVPN."
 
-#: ../properties/nm-openvpn.c:329
+#: ../properties/nm-openvpn-editor-plugin.c:81
+msgid "unknown OpenVPN file extension"
+msgstr "extensão de arquivo OpenVPN desconhecido"
+
+#: ../properties/nm-openvpn-editor.c:309
 msgid "Certificates (TLS)"
 msgstr "Certificados (TLS)"
 
-#: ../properties/nm-openvpn.c:340
+#: ../properties/nm-openvpn-editor.c:320
 msgid "Password"
 msgstr "Senha"
 
-#: ../properties/nm-openvpn.c:353
+#: ../properties/nm-openvpn-editor.c:333
 msgid "Password with Certificates (TLS)"
 msgstr "Senha com certificados (TLS)"
 
-#: ../properties/nm-openvpn.c:365
+#: ../properties/nm-openvpn-editor.c:345
 msgid "Static Key"
 msgstr "Chave estática"
 
-#: ../properties/nm-openvpn.c:513
+#: ../properties/nm-openvpn-editor.c:500
 msgid "could not create openvpn object"
 msgstr "não foi possível criar objeto de openvpn"
 
-#: ../properties/nm-openvpn.c:539
+#: ../properties/nm-openvpn-editor.c:526
 msgid "could not load UI widget"
 msgstr "não foi possível carregar widget da UI"
 
-#: ../properties/nm-openvpn.c:630
-msgid "unknown OpenVPN file extension"
-msgstr "extensão de arquivo OpenVPN desconhecido"
-
 #: ../shared/nm-shared-utils.c:174
 #, c-format
 msgid "object class '%s' has no property named '%s'"
@@ -459,153 +458,172 @@ msgstr ""
 "o valor \"%s\" de tipo \"%s\" é inválido ou fora do intervalo da propriedade "
 "\"%s\" de tipo \"%s\""
 
-#: ../src/nm-openvpn-service.c:359
+#: ../shared/nm-vpn-plugin-utils.c:80
+#, c-format
+msgid "missing plugin file \"%s\""
+msgstr "faltando arquivo de plug-in \"%s\""
+
+#: ../shared/nm-vpn-plugin-utils.c:86
+#, c-format
+msgid "cannot load editor plugin: %s"
+msgstr "não foi possível carregar o plug-in do editor: %s"
+
+#: ../shared/nm-vpn-plugin-utils.c:95
+#, c-format
+msgid "cannot load factory %s from plugin: %s"
+msgstr "não foi possível carregar fábrica %s do plug-in: %s"
+
+#: ../shared/nm-vpn-plugin-utils.c:121
+msgid "unknown error creating editor instance"
+msgstr "erro desconhecido ao criar instância do editor"
+
+#: ../src/nm-openvpn-service.c:354
 #, c-format
 msgid "invalid address '%s'"
 msgstr "endereço inválido \"%s\""
 
-#: ../src/nm-openvpn-service.c:371
+#: ../src/nm-openvpn-service.c:366
 #, c-format
 msgid "invalid integer property '%s' or out of range [%d -> %d]"
 msgstr "propriedade inteira inválida \"%s\" ou fora do intervalo [%d -> %d]"
 
 #. Translators: keep "yes" and "no" untranslated!
-#: ../src/nm-openvpn-service.c:382
+#: ../src/nm-openvpn-service.c:377
 #, c-format
 msgid "invalid boolean property '%s' (not yes or no)"
 msgstr "propriedade booleana inválida \"%s\" (não é sim ou não)"
 
-#: ../src/nm-openvpn-service.c:389
+#: ../src/nm-openvpn-service.c:384
 #, c-format
 msgid "unhandled property '%s' type %s"
 msgstr "propriedade \"%s\" sem tratamento do tipo %s"
 
-#: ../src/nm-openvpn-service.c:400
+#: ../src/nm-openvpn-service.c:395
 #, c-format
 msgid "property '%s' invalid or not supported"
 msgstr "propriedade \"%s\" inválida ou sem suporte"
 
-#: ../src/nm-openvpn-service.c:416
+#: ../src/nm-openvpn-service.c:411
 msgid "No VPN configuration options."
 msgstr "Sem opções de configurações de VPN."
 
-#: ../src/nm-openvpn-service.c:585
+#: ../src/nm-openvpn-service.c:580
 msgid "A username is required."
 msgstr "É necessário um nome de usuário."
 
-#: ../src/nm-openvpn-service.c:589
+#: ../src/nm-openvpn-service.c:584
 msgid "A password is required."
 msgstr "Uma senha é necessária."
 
-#: ../src/nm-openvpn-service.c:592
+#: ../src/nm-openvpn-service.c:587
 msgid "A username and password are required."
 msgstr "São necessários um nome de usuário e senha."
 
-#: ../src/nm-openvpn-service.c:612
+#: ../src/nm-openvpn-service.c:607
 msgid "A private key password is required."
 msgstr "Uma senha da chave privada é necessária."
 
-#: ../src/nm-openvpn-service.c:625
+#: ../src/nm-openvpn-service.c:620
 msgid "An HTTP Proxy username is required."
 msgstr "É necessário um nome de usuário para o proxy HTTP."
 
-#: ../src/nm-openvpn-service.c:629
+#: ../src/nm-openvpn-service.c:624
 msgid "An HTTP Proxy password is required."
 msgstr "Uma senha de proxy HTTP é necessária."
 
-#: ../src/nm-openvpn-service.c:632
+#: ../src/nm-openvpn-service.c:627
 msgid "An HTTP Proxy username and password are required."
 msgstr "Um usuário e senha de proxy HTTP são necessários."
 
-#: ../src/nm-openvpn-service.c:1114
+#: ../src/nm-openvpn-service.c:1109
 msgid "Could not find the openvpn binary."
 msgstr "Não foi possível encontrar o executável do openvpn."
 
-#: ../src/nm-openvpn-service.c:1124
+#: ../src/nm-openvpn-service.c:1119
 msgid "Invalid HMAC auth."
 msgstr "Autenticação HMAC inválida."
 
-#: ../src/nm-openvpn-service.c:1134 ../src/nm-openvpn-service.c:1834
+#: ../src/nm-openvpn-service.c:1129 ../src/nm-openvpn-service.c:1829
 msgid "Invalid connection type."
 msgstr "Tipo de conexão inválida."
 
-#: ../src/nm-openvpn-service.c:1169 ../src/nm-openvpn-service.c:1179
+#: ../src/nm-openvpn-service.c:1164 ../src/nm-openvpn-service.c:1174
 #, c-format
 msgid "Invalid port number '%s'."
 msgstr "Número da porta inválida \"%s\"."
 
-#: ../src/nm-openvpn-service.c:1196
+#: ../src/nm-openvpn-service.c:1191
 #, c-format
 msgid "Invalid proto '%s'."
 msgstr "Protocolo inválido \"%s\"."
 
-#: ../src/nm-openvpn-service.c:1242
+#: ../src/nm-openvpn-service.c:1237
 #, c-format
 msgid "Invalid proxy type '%s'."
 msgstr "Tipo de proxy inválido \"%s\"."
 
-#: ../src/nm-openvpn-service.c:1265
+#: ../src/nm-openvpn-service.c:1260
 #, c-format
 msgid "Invalid ping duration '%s'."
 msgstr "Duração de ping %s inválida."
 
-#: ../src/nm-openvpn-service.c:1279
+#: ../src/nm-openvpn-service.c:1274
 #, c-format
 msgid "Invalid ping-exit duration '%s'."
 msgstr "Duração de ping-exit %s inválida."
 
-#: ../src/nm-openvpn-service.c:1293
+#: ../src/nm-openvpn-service.c:1288
 #, c-format
 msgid "Invalid ping-restart duration '%s'."
 msgstr "Duração de ping-restart %s inválida."
 
-#: ../src/nm-openvpn-service.c:1345
+#: ../src/nm-openvpn-service.c:1340
 #, c-format
 msgid "Invalid keysize '%s'."
 msgstr "Tamanho de chave inválido \"%s\"."
 
-#: ../src/nm-openvpn-service.c:1402
+#: ../src/nm-openvpn-service.c:1397
 #, c-format
 msgid "Invalid reneg seconds '%s'."
 msgstr "Segundos de renegociação inválidos \"%s\"."
 
-#: ../src/nm-openvpn-service.c:1434
+#: ../src/nm-openvpn-service.c:1429
 #, c-format
 msgid "Invalid TUN MTU size '%s'."
 msgstr "Tamanho TUN MTU inválido \"%s\"."
 
-#: ../src/nm-openvpn-service.c:1449
+#: ../src/nm-openvpn-service.c:1444
 #, c-format
 msgid "Invalid fragment size '%s'."
 msgstr "Tamanho do fragmento inválido \"%s\"."
 
-#: ../src/nm-openvpn-service.c:1525
+#: ../src/nm-openvpn-service.c:1520
 msgid "Missing required local IP address for static key mode."
 msgstr ""
 "Faltando o endereço de IP local necessário para o modo de chave estática."
 
-#: ../src/nm-openvpn-service.c:1537
+#: ../src/nm-openvpn-service.c:1532
 msgid "Missing required remote IP address for static key mode."
 msgstr ""
 "Faltando o endereço de IP remoto necessário para o modo de chave estática."
 
-#: ../src/nm-openvpn-service.c:1562
+#: ../src/nm-openvpn-service.c:1557
 #, c-format
 msgid "Unknown connection type '%s'."
 msgstr "Tipo de conexão desconhecida \"%s\"."
 
-#: ../src/nm-openvpn-service.c:1587
+#: ../src/nm-openvpn-service.c:1582
 #, c-format
 msgid "User '%s' not found, check NM_OPENVPN_USER."
 msgstr "Usuário \"%s\" não localizado, verifique NM_OPENVPN_USER."
 
-#: ../src/nm-openvpn-service.c:1601
+#: ../src/nm-openvpn-service.c:1596
 #, c-format
 msgid "Group '%s' not found, check NM_OPENVPN_GROUP."
 msgstr "Grupo \"%s\" não localizado, verifique NM_OPENVPN_GROUP."
 
-#: ../src/nm-openvpn-service.c:1748 ../src/nm-openvpn-service.c:1825
-#: ../src/nm-openvpn-service.c:1859
+#: ../src/nm-openvpn-service.c:1743 ../src/nm-openvpn-service.c:1820
+#: ../src/nm-openvpn-service.c:1854
 msgid ""
 "Could not process the request because the VPN connection settings were "
 "invalid."
@@ -613,7 +631,7 @@ msgstr ""
 "Não foi possível processar a requisição porque as configurações de conexão "
 "VPN eram inválidas."
 
-#: ../src/nm-openvpn-service.c:1757
+#: ../src/nm-openvpn-service.c:1752
 msgid ""
 "Could not process the request because the openvpn connection type was "
 "invalid."
@@ -621,23 +639,23 @@ msgstr ""
 "Não foi possível processar a requisição porque o tipo de conexão openvpn era "
 "inválido."
 
-#: ../src/nm-openvpn-service.c:1872
+#: ../src/nm-openvpn-service.c:1867
 msgid "Unhandled pending authentication."
 msgstr "Autenticação pendente sem tratamento."
 
-#: ../src/nm-openvpn-service.c:1990
+#: ../src/nm-openvpn-service.c:1986
 msgid "Don't quit when VPN connection terminates"
 msgstr "Não sair quando terminar a conexão VPN"
 
-#: ../src/nm-openvpn-service.c:1991
+#: ../src/nm-openvpn-service.c:1987
 msgid "Enable verbose debug logging (may expose passwords)"
 msgstr "Habilitar registros detalhados para depuração (pode expor senhas)"
 
-#: ../src/nm-openvpn-service.c:1992
+#: ../src/nm-openvpn-service.c:1988
 msgid "D-Bus name to use for this instance"
 msgstr "Nome D-Bus a ser usado para esta instância"
 
-#: ../src/nm-openvpn-service.c:2018
+#: ../src/nm-openvpn-service.c:2014
 msgid ""
 "nm-openvpn-service provides integrated OpenVPN capability to NetworkManager."
 msgstr ""
@@ -793,9 +811,9 @@ msgid ""
 msgstr ""
 "Direção do modo de criptografia da chave estática (não-TLS).\n"
 "Se direção da chave for utilizada, ela tem que ser oposta da usada no par da "
-"VPN. Por exemplo: se o par utiliza \"1\", esta conexão tem que utilizar \"0\""
-". Se você não tem certeza de qual valor utilizar, entre em contato com seu "
-"administrador de sistema.\n"
+"VPN. Por exemplo: se o par utiliza \"1\", esta conexão tem que utilizar "
+"\"0\". Se você não tem certeza de qual valor utilizar, entre em contato com "
+"seu administrador de sistema.\n"
 "config: static <arquivo> [direção]"
 
 #: ../properties/nm-openvpn-dialog.ui.h:38
@@ -993,8 +1011,8 @@ msgstr ""
 "como um usuário de conexão discada ou cliente DHCP.\n"
 "\n"
 "Essencialmente, --float diz para OpenVPN aceitar pacotes autenticados de "
-"qualquer endereço, não apenas o endereço que foi especificado na opção "
-"--remote.\n"
+"qualquer endereço, não apenas o endereço que foi especificado na opção --"
+"remote.\n"
 "\n"
 "config: float"
 
diff --git po/sr.po po/sr.po
index 149abf4..e3680d0 100644
--- po/sr.po
+++ po/sr.po
@@ -7,19 +7,41 @@
 msgid ""
 msgstr ""
 "Project-Id-Version: network-manager-openvpn master\n"
-"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=Network"
-"Manager&keywords=I18N+L10N&component=VPN: openvpn\n"
-"POT-Creation-Date: 2016-03-31 13:34+0000\n"
-"PO-Revision-Date: 2016-03-31 19:17+0200\n"
-"Last-Translator: Мирослав Николић <miroslavnikolic@rocketmail.com>\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
+"product=NetworkManager&keywords=I18N+L10N&component=VPN: openvpn\n"
+"POT-Creation-Date: 2016-04-14 10:36+0000\n"
+"PO-Revision-Date: 2016-04-14 18:06+0200\n"
+"Last-Translator: Марко М. Костић <marko.m.kostic@gmail.com>\n"
 "Language-Team: Serbian <gnom@prevod.org>\n"
 "Language: sr\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
-"Plural-Forms: nplurals=4; plural=n==1? 3 : n%10==1 && n%100!=11 ? 0 : "
-"n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"
+"Plural-Forms: nplurals=4; plural=n==1? 3 : n%10==1 && n%100!=11 ? 0 : n"
+"%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"
 "X-Project-Style: gnome\n"
+"X-Generator: Poedit 1.8.7.1\n"
+
+#: ../appdata/network-manager-openvpn.appdata.xml.in.h:1
+msgid "OpenVPN client"
+msgstr "ОпенВПН клијент"
+
+#: ../appdata/network-manager-openvpn.appdata.xml.in.h:2
+msgid "Client for OpenVPN virtual private networks"
+msgstr "Клијент за виртуелне приватне мреже кроз ОпенВПН"
+
+#: ../appdata/network-manager-openvpn.appdata.xml.in.h:3
+msgid "Support for configuring OpenVPN virtual private network connections."
+msgstr ""
+"Подршка за подешавање повезивања у виртуелним приватним мрежама кроз ОпенВПН."
+
+#: ../appdata/network-manager-openvpn.appdata.xml.in.h:4
+msgid "OpenVPN is a popular and flexible free-software VPN solution."
+msgstr "ОпенВПН је популаран, прилагодљив и слободан програм за ВПН."
+
+#: ../appdata/network-manager-openvpn.appdata.xml.in.h:5
+msgid "The NetworkManager Developers"
+msgstr "Развојни тим Управника мреже"
 
 #: ../auth-dialog/main.c:180
 #, c-format
@@ -73,8 +95,8 @@ msgstr "Изаберите уверење издавача овлашћења...
 msgid "Choose an OpenVPN static key..."
 msgstr "Изаберите ОпенВПН статички кључ..."
 
-#: ../properties/auth-helpers.c:369 ../properties/auth-helpers.c:1110
-#: ../properties/auth-helpers.c:1741
+#: ../properties/auth-helpers.c:369 ../properties/auth-helpers.c:1111
+#: ../properties/auth-helpers.c:1800
 msgid "None"
 msgstr "Ништа"
 
@@ -90,80 +112,80 @@ msgstr "ПЕМ уверења (*.pem, *.crt, *.key, *.cer)"
 msgid "OpenVPN Static Keys (*.key)"
 msgstr "ОпенВПН статички кључ (*.key)"
 
-#: ../properties/auth-helpers.c:1014 ../properties/auth-helpers.c:1102
+#: ../properties/auth-helpers.c:1015 ../properties/auth-helpers.c:1103
 msgid "Default"
 msgstr "Основно"
 
-#: ../properties/auth-helpers.c:1112
+#: ../properties/auth-helpers.c:1113
 msgid "RSA MD-4"
 msgstr "РСА-МД-4"
 
-#: ../properties/auth-helpers.c:1114
+#: ../properties/auth-helpers.c:1115
 msgid "MD-5"
 msgstr "МД-5"
 
-#: ../properties/auth-helpers.c:1116
+#: ../properties/auth-helpers.c:1117
 msgid "SHA-1"
 msgstr "СХА-1"
 
-#: ../properties/auth-helpers.c:1118
+#: ../properties/auth-helpers.c:1119
 msgid "SHA-224"
 msgstr "СХА‑224"
 
-#: ../properties/auth-helpers.c:1120
+#: ../properties/auth-helpers.c:1121
 msgid "SHA-256"
 msgstr "СХА‑256"
 
-#: ../properties/auth-helpers.c:1122
+#: ../properties/auth-helpers.c:1123
 msgid "SHA-384"
 msgstr "СХА‑384"
 
-#: ../properties/auth-helpers.c:1124
+#: ../properties/auth-helpers.c:1125
 msgid "SHA-512"
 msgstr "СХА‑512"
 
-#: ../properties/auth-helpers.c:1126
+#: ../properties/auth-helpers.c:1127
 msgid "RIPEMD-160"
 msgstr "РИПЕМД‑160"
 
-#: ../properties/auth-helpers.c:1177
+#: ../properties/auth-helpers.c:1178 ../properties/auth-helpers.c:1244
 msgid "Server"
 msgstr "Сервер"
 
-#: ../properties/auth-helpers.c:1182
+#: ../properties/auth-helpers.c:1183 ../properties/auth-helpers.c:1249
 msgid "Client"
 msgstr "Клијент"
 
-#: ../properties/auth-helpers.c:1450 ../properties/nm-openvpn-dialog.ui.h:41
+#: ../properties/auth-helpers.c:1498 ../properties/nm-openvpn-dialog.ui.h:41
 msgid "Not required"
 msgstr "Непотребно"
 
-#: ../properties/auth-helpers.c:1452
+#: ../properties/auth-helpers.c:1500
 msgid "HTTP"
 msgstr "ХТТП"
 
-#: ../properties/auth-helpers.c:1454
+#: ../properties/auth-helpers.c:1502
 msgid "SOCKS"
 msgstr "СОЦКС"
 
-#: ../properties/auth-helpers.c:1638
+#: ../properties/auth-helpers.c:1686
 msgid "TUN"
 msgstr "ТУН"
 
-#: ../properties/auth-helpers.c:1640
+#: ../properties/auth-helpers.c:1688
 msgid "TAP"
 msgstr "ТАП"
 
 #. interface name is max 15 chars
-#: ../properties/auth-helpers.c:1647
+#: ../properties/auth-helpers.c:1695
 msgid "(automatic)"
-msgstr "(аутоматски)"
+msgstr "(самостално)"
 
-#: ../properties/auth-helpers.c:1808
+#: ../properties/auth-helpers.c:1867
 msgid "ping-exit"
 msgstr "излаз пинга"
 
-#: ../properties/auth-helpers.c:1810
+#: ../properties/auth-helpers.c:1869
 msgid "ping-restart"
 msgstr "поновно покретање пинга"
 
@@ -241,7 +263,7 @@ msgstr "двоструки наводници"
 
 #: ../properties/import-export.c:459
 msgid "single quote"
-msgstr "полунаводник"
+msgstr "Једноструки наводник"
 
 #: ../properties/import-export.c:468
 #, c-format
@@ -286,71 +308,71 @@ msgstr "не могу да запишем <%s> блоб из %ld. реда у д
 msgid "cannot write <%s> blob from line %ld to file '%s'"
 msgstr "не могу да запишем <%s> блоб из %ld. реда у датотеку „%s“"
 
-#: ../properties/import-export.c:906
+#: ../properties/import-export.c:885 ../properties/import-export.c:1191
+#, c-format
+msgid "invalid option"
+msgstr "неисправна опција"
+
+#: ../properties/import-export.c:917
 #, c-format
 msgid "unsupported comp-lzo argument"
 msgstr "неподржан аргумент „comp-lzo“"
 
-#: ../properties/import-export.c:994
+#: ../properties/import-export.c:1005
 #, c-format
 msgid "remote cannot contain space"
 msgstr "удаљени не може да садржи размак"
 
-#: ../properties/import-export.c:998
+#: ../properties/import-export.c:1009
 #, c-format
 msgid "remote cannot contain comma"
 msgstr "удаљени не може да садржи зарез"
 
-#: ../properties/import-export.c:1009
+#: ../properties/import-export.c:1020
 #, c-format
 msgid "remote expects protocol either udp or remote"
 msgstr "удаљени очекује или протокол „udp“ или „remote“"
 
-#: ../properties/import-export.c:1180
-#, c-format
-msgid "invalid option"
-msgstr "неисправна опција"
-
-#: ../properties/import-export.c:1293
+#: ../properties/import-export.c:1304
 #, c-format
 msgid "unsupported blob/xml element"
 msgstr "неподржани елемент блоб/иксмл"
 
-#: ../properties/import-export.c:1322
+#: ../properties/import-export.c:1333
 #, c-format
 msgid "unterminated blob element <%s>"
 msgstr "неокончани елемент блоба <%s>"
 
-#: ../properties/import-export.c:1372
+#: ../properties/import-export.c:1383
 #, c-format
 msgid "configuration error: %s (line %ld)"
 msgstr "грешка подешавања: %s (%ld. ред)"
 
-#: ../properties/import-export.c:1373
+#: ../properties/import-export.c:1384
 msgid "unknown or unsupported option"
 msgstr "непозната или неподржана опција"
 
-#: ../properties/import-export.c:1383
+#: ../properties/import-export.c:1394
 msgid "The file to import wasn't a valid OpenVPN client configuration"
 msgstr "Датотека за увоз није исправно подешавање ОпенВПН клијента"
 
-#: ../properties/import-export.c:1391
+#: ../properties/import-export.c:1402
 msgid "The file to import wasn't a valid OpenVPN configure (no remote)"
 msgstr "Датотека за увоз није исправно ОпенВПН подешавање (нема удаљеног)"
 
-#: ../properties/import-export.c:1624
+#: ../properties/import-export.c:1635
 msgid "missing path argument"
 msgstr "недостаје аргумент са путањом"
 
-#: ../properties/import-export.c:1634
+#: ../properties/import-export.c:1645
 msgid "connection is not a valid OpenVPN connection"
 msgstr "веза није исправна ОпенВПН веза"
 
-#: ../properties/import-export.c:1643
+#: ../properties/import-export.c:1654
 msgid "connection was incomplete (missing gateway)"
 msgstr "веза беше непотпуна (недостаје мрежни пролаз)"
 
-#: ../properties/import-export.c:1943
+#: ../properties/import-export.c:1955
 #, c-format
 msgid "failed to write file: %s"
 msgstr "нисам успео да упишем датотеку: %s"
@@ -391,6 +413,222 @@ msgstr "не могу да учитам елемент сучеља"
 msgid "unknown OpenVPN file extension"
 msgstr "непознато проширење ОпенВПН датотеке"
 
+#: ../shared/nm-shared-utils.c:174
+#, c-format
+msgid "object class '%s' has no property named '%s'"
+msgstr "класа објекта „%s“ нема својство са називом „%s“"
+
+#: ../shared/nm-shared-utils.c:181
+#, c-format
+msgid "property '%s' of object class '%s' is not writable"
+msgstr "својство „%s“ класе објекта „%s“ није уписиво"
+
+#: ../shared/nm-shared-utils.c:188
+#, c-format
+msgid ""
+"construct property \"%s\" for object '%s' can't be set after construction"
+msgstr ""
+"својство конструкта „%s“ за објекат „%s“ се не може поставити након "
+"конструисања"
+
+#: ../shared/nm-shared-utils.c:196
+#, c-format
+msgid "'%s::%s' is not a valid property name; '%s' is not a GObject subtype"
+msgstr "„%s::%s“ није исправан назив својства; „%s“ није GObject подврста"
+
+#: ../shared/nm-shared-utils.c:205
+#, c-format
+msgid "unable to set property '%s' of type '%s' from value of type '%s'"
+msgstr "не могу да поставим својство „%s“ врсте „%s“ из вредности врсте „%s“"
+
+#: ../shared/nm-shared-utils.c:216
+#, c-format
+msgid ""
+"value \"%s\" of type '%s' is invalid or out of range for property '%s' of "
+"type '%s'"
+msgstr ""
+"вредност „%s“ врсте „%s“ је неисправна или ван опсега за својство „%s“ врсте "
+"„%s“"
+
+#: ../src/nm-openvpn-service.c:359
+#, c-format
+msgid "invalid address '%s'"
+msgstr "неисправна адреса „%s“"
+
+#: ../src/nm-openvpn-service.c:371
+#, c-format
+msgid "invalid integer property '%s' or out of range [%d -> %d]"
+msgstr "неисправно својство целог броја „%s“ или је ван опсега [%d —> %d]"
+
+#. Translators: keep "yes" and "no" untranslated!
+#: ../src/nm-openvpn-service.c:382
+#, c-format
+msgid "invalid boolean property '%s' (not yes or no)"
+msgstr "неисправно логичко својство „%s“ (није „yes“ (да) или „no“ (не))"
+
+#: ../src/nm-openvpn-service.c:389
+#, c-format
+msgid "unhandled property '%s' type %s"
+msgstr "неруковано својство „%s“ врсте %s"
+
+#: ../src/nm-openvpn-service.c:400
+#, c-format
+msgid "property '%s' invalid or not supported"
+msgstr "својство „%s“ је неисправно или није подржано"
+
+#: ../src/nm-openvpn-service.c:416
+msgid "No VPN configuration options."
+msgstr "Нема опција ВПН подешавања."
+
+#: ../src/nm-openvpn-service.c:585
+msgid "A username is required."
+msgstr "Потребно је корисничко име."
+
+#: ../src/nm-openvpn-service.c:589
+msgid "A password is required."
+msgstr "Потребна је лозинка."
+
+#: ../src/nm-openvpn-service.c:592
+msgid "A username and password are required."
+msgstr "Потребни су корисничко име и лозинка."
+
+#: ../src/nm-openvpn-service.c:612
+msgid "A private key password is required."
+msgstr "Потребна је лозинка приватног кључа."
+
+#: ../src/nm-openvpn-service.c:625
+msgid "An HTTP Proxy username is required."
+msgstr "Потребно је корисничко име ХТТП посредника."
+
+#: ../src/nm-openvpn-service.c:629
+msgid "An HTTP Proxy password is required."
+msgstr "Потребна је лозинка ХТТП посредника."
+
+#: ../src/nm-openvpn-service.c:632
+msgid "An HTTP Proxy username and password are required."
+msgstr "Потребни су корисничко име и лозинка ХТТП посредника."
+
+#: ../src/nm-openvpn-service.c:1114
+msgid "Could not find the openvpn binary."
+msgstr "Не могу да пронађем опенвпн извршни."
+
+#: ../src/nm-openvpn-service.c:1124
+msgid "Invalid HMAC auth."
+msgstr "Неисправно ХМАЦ потврђивање идентитета."
+
+#: ../src/nm-openvpn-service.c:1134 ../src/nm-openvpn-service.c:1834
+msgid "Invalid connection type."
+msgstr "Неисправна врста везе."
+
+#: ../src/nm-openvpn-service.c:1169 ../src/nm-openvpn-service.c:1179
+#, c-format
+msgid "Invalid port number '%s'."
+msgstr "Неисправан број прикључника „%s“."
+
+#: ../src/nm-openvpn-service.c:1196
+#, c-format
+msgid "Invalid proto '%s'."
+msgstr "Неисправан протокол „%s“."
+
+#: ../src/nm-openvpn-service.c:1242
+#, c-format
+msgid "Invalid proxy type '%s'."
+msgstr "Неисправна врста посредника „%s“."
+
+#: ../src/nm-openvpn-service.c:1265
+#, c-format
+msgid "Invalid ping duration '%s'."
+msgstr "Неисправно трајање пинга „%s“."
+
+#: ../src/nm-openvpn-service.c:1279
+#, c-format
+msgid "Invalid ping-exit duration '%s'."
+msgstr "Неисправно трајање изласка пинга „%s“."
+
+#: ../src/nm-openvpn-service.c:1293
+#, c-format
+msgid "Invalid ping-restart duration '%s'."
+msgstr "Неисправно трајање поновног покретања пинга „%s“."
+
+#: ../src/nm-openvpn-service.c:1345
+#, c-format
+msgid "Invalid keysize '%s'."
+msgstr "Неисправна величина кључа „%s“."
+
+#: ../src/nm-openvpn-service.c:1402
+#, c-format
+msgid "Invalid reneg seconds '%s'."
+msgstr "Неисправан број секунди поновног преговарања „%s“."
+
+#: ../src/nm-openvpn-service.c:1434
+#, c-format
+msgid "Invalid TUN MTU size '%s'."
+msgstr "Неисправна ТУН МТУ величина „%s“."
+
+#: ../src/nm-openvpn-service.c:1449
+#, c-format
+msgid "Invalid fragment size '%s'."
+msgstr "Неисправна величина одломка „%s“."
+
+#: ../src/nm-openvpn-service.c:1525
+msgid "Missing required local IP address for static key mode."
+msgstr "Недостаје захтевана месна ИП адреса за режим статичког кључа."
+
+#: ../src/nm-openvpn-service.c:1537
+msgid "Missing required remote IP address for static key mode."
+msgstr "Недостаје захтевана удаљена ИП адреса за режим статичког кључа."
+
+#: ../src/nm-openvpn-service.c:1562
+#, c-format
+msgid "Unknown connection type '%s'."
+msgstr "Непозната врста везе „%s“."
+
+#: ../src/nm-openvpn-service.c:1587
+#, c-format
+msgid "User '%s' not found, check NM_OPENVPN_USER."
+msgstr "Нисам нашао корисника „%s“, проверите „NM_OPENVPN_USER“."
+
+#: ../src/nm-openvpn-service.c:1601
+#, c-format
+msgid "Group '%s' not found, check NM_OPENVPN_GROUP."
+msgstr "Нисам нашао групу „%s“, проверите „NM_OPENVPN_GROUP“."
+
+#: ../src/nm-openvpn-service.c:1748 ../src/nm-openvpn-service.c:1825
+#: ../src/nm-openvpn-service.c:1859
+msgid ""
+"Could not process the request because the VPN connection settings were "
+"invalid."
+msgstr "Не могу да обрадим захтев због неисправних подешавања ВПН везе."
+
+#: ../src/nm-openvpn-service.c:1757
+msgid ""
+"Could not process the request because the openvpn connection type was "
+"invalid."
+msgstr "Не могу да обрадим захтев због неисправне врсте везе опенвпн-а."
+
+#: ../src/nm-openvpn-service.c:1872
+msgid "Unhandled pending authentication."
+msgstr "Непознато потврђивање идентитета на чекању."
+
+#: ../src/nm-openvpn-service.c:1990
+msgid "Don't quit when VPN connection terminates"
+msgstr "Не прекида када се завршава ВПН веза"
+
+#: ../src/nm-openvpn-service.c:1991
+msgid "Enable verbose debug logging (may expose passwords)"
+msgstr ""
+"Укључује опширно записивање зарад исправљања грешака (може да изложи лозинке)"
+
+#: ../src/nm-openvpn-service.c:1992
+msgid "D-Bus name to use for this instance"
+msgstr "Назив Д-сабирнице који ће се користити за овај примерак"
+
+#: ../src/nm-openvpn-service.c:2018
+msgid ""
+"nm-openvpn-service provides integrated OpenVPN capability to NetworkManager."
+msgstr ""
+"нм-опенвпн-услуга обезбеђује Управнику мреже обједињену ОпенВПН могућност."
+
 #: ../properties/nm-openvpn-dialog.ui.h:1
 msgid " "
 msgstr " "
@@ -410,9 +648,9 @@ msgid ""
 "delimiters).\n"
 "config: remote"
 msgstr ""
-"Удаљени мрежни пролаз(и), са изборним прикључником и протоколом (нпр. "
-"„ovpn.corp.com:1234:tcp“). Можете да наведете више ставки зарад изобиља ("
-"користите зарезе да раздвојите уносе).\n"
+"Удаљени мрежни пролаз(и), са изборним прикључником и протоколом (нпр. „ovpn."
+"corp.com:1234:tcp“). Можете да наведете више ставки зарад изобиља (користите "
+"зарезе да раздвојите уносе).\n"
 "подешавање: „remote“"
 
 #: ../properties/nm-openvpn-dialog.ui.h:6
@@ -479,7 +717,7 @@ msgstr ""
 
 #: ../properties/nm-openvpn-dialog.ui.h:22
 msgid "User name:"
-msgstr "Корисник:"
+msgstr "Корисничко име:"
 
 #: ../properties/nm-openvpn-dialog.ui.h:23
 msgid ""
@@ -540,7 +778,7 @@ msgstr ""
 "Усмерење за режим шифровања статичког кључа (не-ТЛС).\n"
 "Ако користите усмерење кључа, мора бити супротно од оног коришћеног на ВПН "
 "парњаку.  На пример, ако парњак користи „1“, ова веза мора да користи „0“.  "
-"Ако нисте сигурни коју вредност да користите, посаветујте се са "
+"Ако нисте сигурни коју вредност да користите, посавејтујте се са "
 "администратором система.\n"
 "подешавање: „static <датотека> [усмерење]“"
 
@@ -640,8 +878,8 @@ msgid ""
 "\"tap\").\n"
 "config: dev <name>"
 msgstr ""
-"Користите произвољан назив за ТУН/ТАП виртуелни уређај (уместо основног „tun“"
-" или „tap“).\n"
+"Користите произвољан назив за ТУН/ТАП виртуелни уређај (уместо основног "
+"„tun“ или „tap“).\n"
 "подешавање: dev „<назив>“"
 
 #: ../properties/nm-openvpn-dialog.ui.h:63
@@ -728,12 +966,13 @@ msgid ""
 "config: float"
 msgstr ""
 "Омогућава удаљеном парњаку да промени своју ИП адресу и/или број "
-"прикључника, као услед ДХЦП-а (ово је основно ако се не користи „--remote“)"
-".  „--float“ када је наведено са „--remote“ омогућава ОпенВПН сесији да се "
-"прво повеже са парњаком на познатој адреси, међутим ако пакети стижу са нове "
-"адресе и прођу све тестове потврђивања идентитета, нова адреса ће преузети "
-"контролу над сесијом.  Овоје корисно када се повезујете са парњаком који "
-"држи динамичку адресу као што је корисник двојне парице или ДХЦП клијент.\n"
+"прикључника, као услед ДХЦП-а (ово је основно ако се не користи „--"
+"remote“).  „--float“ када је наведено са „--remote“ омогућава ОпенВПН сесији "
+"да се прво повеже са парњаком на познатој адреси, међутим ако пакети стижу "
+"са нове адресе и прођу све тестове потврђивања идентитета, нова адреса ће "
+"преузети контролу над сесијом.  Овоје корисно када се повезујете са парњаком "
+"који држи динамичку адресу као што је корисник двојне парице или ДХЦП "
+"клијент.\n"
 "\n"
 "У основи, „--float“ говори ОпенВПН-у да прихвати проверене пакете са било "
 "које адресе, а не само са адресе која је наведена у опцији „--remote“.\n"
@@ -867,18 +1106,43 @@ msgstr ""
 "подешавање: „remote-cert-tls client|server“"
 
 #: ../properties/nm-openvpn-dialog.ui.h:111
+msgid "_Verify peer (server) certificate nsCertType designation"
+msgstr "_Провери ознаку nsCertType уверења парњака (сервера)"
+
+#: ../properties/nm-openvpn-dialog.ui.h:112
+msgid ""
+"Require that peer certificate was signed with an explicit nsCertType "
+"designation."
+msgstr ""
+"Захтевај да уверење парњака буде потписан са изричитом nsCertType ознаком."
+
+#: ../properties/nm-openvpn-dialog.ui.h:113
+msgid "_Remote peer certificate nsCert designation:"
+msgstr "Ознака nsCert уве_рења удаљеног парњака:"
+
+#: ../properties/nm-openvpn-dialog.ui.h:114
+msgid ""
+"Require that peer certificate was signed with an explicit nsCertType "
+"designation.\n"
+"config: ns-cert-type client|server"
+msgstr ""
+"Захтевајте да уверење парњака буде потписано са изричитом nsCertType "
+"ознаком.\n"
+"подешавање: „ns-cert-type client|server“"
+
+#: ../properties/nm-openvpn-dialog.ui.h:116
 msgid "Use additional _TLS authentication"
 msgstr "Користи допунско потврђивање идентитета _ТЛС-а"
 
-#: ../properties/nm-openvpn-dialog.ui.h:112
+#: ../properties/nm-openvpn-dialog.ui.h:117
 msgid "Add an additional layer of HMAC authentication."
 msgstr "Додајте допунски слој ХМАЦ потврде идентитета."
 
-#: ../properties/nm-openvpn-dialog.ui.h:113
+#: ../properties/nm-openvpn-dialog.ui.h:118
 msgid "Key _Direction:"
 msgstr "_Усмерење кључа:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:114
+#: ../properties/nm-openvpn-dialog.ui.h:119
 msgid ""
 "Add an additional layer of HMAC authentication on top of the TLS control "
 "channel to protect against DoS attacks.\n"
@@ -888,7 +1152,7 @@ msgstr ""
 "да се заштитите од ДоС напада.\n"
 "подешавање: „tls-auth <датотека> [усмерење]“"
 
-#: ../properties/nm-openvpn-dialog.ui.h:116
+#: ../properties/nm-openvpn-dialog.ui.h:121
 msgid ""
 "Direction parameter for static key mode.\n"
 "If key direction is used, it must be the opposite of that used on the VPN "
@@ -899,19 +1163,19 @@ msgstr ""
 "Параметри усмерења за режим статичког кључа.\n"
 "Ако користите усмерење кључа, мора бити супротно од оног коришћеног на ВПН "
 "парњаку.  На пример, ако парњак користи „1“, ова веза мора да користи „0“.  "
-"Ако нисте сигурни коју вредност да користите, посаветујте се са "
+"Ако нисте сигурни коју вредност да користите, посавејтујте се са "
 "администратором система.\n"
 "подешавање: „tls-auth <датотека> [усмерење]“"
 
-#: ../properties/nm-openvpn-dialog.ui.h:119
+#: ../properties/nm-openvpn-dialog.ui.h:124
 msgid "Key _File:"
 msgstr "_Датотека кључа:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:120
+#: ../properties/nm-openvpn-dialog.ui.h:125
 msgid "TLS Authentication"
 msgstr "ТЛС потврђивање идентитета"
 
-#: ../properties/nm-openvpn-dialog.ui.h:121
+#: ../properties/nm-openvpn-dialog.ui.h:126
 msgid ""
 "Proxy type: HTTP or Socks.\n"
 "config: http-proxy or socks-proxy"
@@ -919,11 +1183,11 @@ msgstr ""
 "Врста посредника: ХТТП или Соцкс.\n"
 "подешавање: „http-proxy“ или „socks-proxy“"
 
-#: ../properties/nm-openvpn-dialog.ui.h:123
+#: ../properties/nm-openvpn-dialog.ui.h:128
 msgid "Proxy _Type:"
 msgstr "Врста _посредника:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:124
+#: ../properties/nm-openvpn-dialog.ui.h:129
 msgid ""
 "<i>Select this option if your organization requires the use of a proxy "
 "server to access the Internet.</i>"
@@ -931,11 +1195,11 @@ msgstr ""
 "<i>Изаберите ову опцију ако ваше удружење захтева употребу посредничког "
 "сервера за приступање Интернету.</i>"
 
-#: ../properties/nm-openvpn-dialog.ui.h:125
+#: ../properties/nm-openvpn-dialog.ui.h:130
 msgid "Server _Address:"
 msgstr "_Адреса сервера:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:126
+#: ../properties/nm-openvpn-dialog.ui.h:131
 msgid ""
 "Connect to remote host through a proxy with this address.\n"
 "config: http-proxy or socks-proxy"
@@ -943,11 +1207,11 @@ msgstr ""
 "Повежите се на удаљеног домаћина путем посредника са овом адресом.\n"
 "подешавање: „http-proxy“ или „socks-proxy“"
 
-#: ../properties/nm-openvpn-dialog.ui.h:128
+#: ../properties/nm-openvpn-dialog.ui.h:133
 msgid "_Port:"
 msgstr "_Прикључник:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:129
+#: ../properties/nm-openvpn-dialog.ui.h:134
 msgid ""
 "Connect to remote host through a proxy with this port.\n"
 "config: http-proxy or socks-proxy"
@@ -955,11 +1219,11 @@ msgstr ""
 "Повежите се на удаљеног домаћина путем посредника са овим прикључником.\n"
 "подешавање: „http-proxy“ или „socks-proxy“"
 
-#: ../properties/nm-openvpn-dialog.ui.h:131
+#: ../properties/nm-openvpn-dialog.ui.h:136
 msgid "_Retry indefinitely when errors occur"
 msgstr "_Непрекидно покушавај кад дође до грешака"
 
-#: ../properties/nm-openvpn-dialog.ui.h:132
+#: ../properties/nm-openvpn-dialog.ui.h:137
 msgid ""
 "Retry indefinitely on proxy errors. It simulates a SIGUSR1 reset.\n"
 "config: http-proxy-retry or socks-proxy-retry"
@@ -968,247 +1232,31 @@ msgstr ""
 "постављање.\n"
 "подешавање: „http-proxy-retry“ или „socks-proxy-retry“"
 
-#: ../properties/nm-openvpn-dialog.ui.h:134
+#: ../properties/nm-openvpn-dialog.ui.h:139
 msgid "Proxy _Username:"
-msgstr "_Корисник посредника:"
+msgstr "Корисничко _име за посредника:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:135
+#: ../properties/nm-openvpn-dialog.ui.h:140
 msgid "Proxy Passwor_d:"
-msgstr "_Лозинка посредника:"
+msgstr "Лозинка _посредника:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:136
+#: ../properties/nm-openvpn-dialog.ui.h:141
 msgid "HTTP/Socks proxy username passed to OpenVPN when prompted for it."
 msgstr ""
 "Корисничко име ХТТП/Соцкс посредника прослеђено ОпенВПН-у када је затражено."
 
-#: ../properties/nm-openvpn-dialog.ui.h:137
+#: ../properties/nm-openvpn-dialog.ui.h:142
 msgid "HTTP/Socks proxy password passed to OpenVPN when prompted for it."
 msgstr "Лозинка ХТТП/Соцкс посредника прослеђена ОпенВПН-у када је затражено."
 
-#: ../properties/nm-openvpn-dialog.ui.h:138
+#: ../properties/nm-openvpn-dialog.ui.h:143
 msgid "_Show password"
 msgstr "_Прикажи лозинку"
 
-#: ../properties/nm-openvpn-dialog.ui.h:139
+#: ../properties/nm-openvpn-dialog.ui.h:144
 msgid "Proxies"
 msgstr "Посредници"
 
-#: ../shared/nm-shared-utils.c:174
-#, c-format
-msgid "object class '%s' has no property named '%s'"
-msgstr "класа објекта „%s“ нема својство са називом „%s“"
-
-#: ../shared/nm-shared-utils.c:181
-#, c-format
-msgid "property '%s' of object class '%s' is not writable"
-msgstr "својство „%s“ класе објекта „%s“ није уписиво"
-
-#: ../shared/nm-shared-utils.c:188
-#, c-format
-msgid ""
-"construct property \"%s\" for object '%s' can't be set after construction"
-msgstr ""
-"градивно својство „%s“ за објекат „%s“ не може бити постављено након "
-"конструкције"
-
-#: ../shared/nm-shared-utils.c:196
-#, c-format
-msgid "'%s::%s' is not a valid property name; '%s' is not a GObject subtype"
-msgstr "„%s::%s“ није исправан назив својства; „%s“ није подврста Гобјекта"
-
-#: ../shared/nm-shared-utils.c:205
-#, c-format
-msgid "unable to set property '%s' of type '%s' from value of type '%s'"
-msgstr "не могу да поставим својство „%s“ врсте „%s“ из вредности врсте „%s“"
-
-#: ../shared/nm-shared-utils.c:216
-#, c-format
-msgid ""
-"value \"%s\" of type '%s' is invalid or out of range for property '%s' of "
-"type '%s'"
-msgstr ""
-"вредност „%s“ врсте „%s“ је неисправна или је ван опсега за својство „%s“ "
-"врсте „%s“"
-
-#: ../src/nm-openvpn-service.c:358
-#, c-format
-msgid "invalid address '%s'"
-msgstr "неисправна адреса „%s“"
-
-#: ../src/nm-openvpn-service.c:370
-#, c-format
-msgid "invalid integer property '%s' or out of range [%d -> %d]"
-msgstr "неисправно својство целог броја „%s“ или је ван опсега [%d → %d]"
-
-#. Translators: keep "yes" and "no" untranslated!
-#: ../src/nm-openvpn-service.c:381
-#, c-format
-msgid "invalid boolean property '%s' (not yes or no)"
-msgstr "неисправно логичко својство „%s“ (није „да“ или „не“)"
-
-#: ../src/nm-openvpn-service.c:388
-#, c-format
-msgid "unhandled property '%s' type %s"
-msgstr "неруковано својство „%s“ врсте %s"
-
-#: ../src/nm-openvpn-service.c:399
-#, c-format
-msgid "property '%s' invalid or not supported"
-msgstr "својство „%s“ је неисправно или није подржано"
-
-#: ../src/nm-openvpn-service.c:415
-msgid "No VPN configuration options."
-msgstr "Нема опција ВПН подешавања."
-
-#: ../src/nm-openvpn-service.c:584
-msgid "A username is required."
-msgstr "Потребно је корисничко име."
-
-#: ../src/nm-openvpn-service.c:588
-msgid "A password is required."
-msgstr "Потребна је лозинка."
-
-#: ../src/nm-openvpn-service.c:591
-msgid "A username and password are required."
-msgstr "Потребни су корисничко име и лозинка."
-
-#: ../src/nm-openvpn-service.c:611
-msgid "A private key password is required."
-msgstr "Потребна је лозинка приватног кључа."
-
-#: ../src/nm-openvpn-service.c:624
-msgid "An HTTP Proxy username is required."
-msgstr "Потребно је корисничко име ХТТП посредника."
-
-#: ../src/nm-openvpn-service.c:628
-msgid "An HTTP Proxy password is required."
-msgstr "Потребна је лозинка ХТТП посредника."
-
-#: ../src/nm-openvpn-service.c:631
-msgid "An HTTP Proxy username and password are required."
-msgstr "Потребни су корисничко име и лозинка ХТТП посредника."
-
-#: ../src/nm-openvpn-service.c:1113
-msgid "Could not find the openvpn binary."
-msgstr "Не могу да пронађем опенвпн извршни."
-
-#: ../src/nm-openvpn-service.c:1123
-msgid "Invalid HMAC auth."
-msgstr "Неисправно ХМАЦ потврђивање идентитета."
-
-#: ../src/nm-openvpn-service.c:1133 ../src/nm-openvpn-service.c:1826
-msgid "Invalid connection type."
-msgstr "Неисправна врста везе."
-
-#: ../src/nm-openvpn-service.c:1168 ../src/nm-openvpn-service.c:1178
-#, c-format
-msgid "Invalid port number '%s'."
-msgstr "Неисправан број прикључника „%s“."
-
-#: ../src/nm-openvpn-service.c:1195
-#, c-format
-msgid "Invalid proto '%s'."
-msgstr "Неисправан протокол „%s“."
-
-#: ../src/nm-openvpn-service.c:1241
-#, c-format
-msgid "Invalid proxy type '%s'."
-msgstr "Неисправна врста посредника „%s“."
-
-#: ../src/nm-openvpn-service.c:1264
-#, c-format
-msgid "Invalid ping duration '%s'."
-msgstr "Неисправно трајање пинга „%s“."
-
-#: ../src/nm-openvpn-service.c:1278
-#, c-format
-msgid "Invalid ping-exit duration '%s'."
-msgstr "Неисправно трајање изласка пинга „%s“."
-
-#: ../src/nm-openvpn-service.c:1292
-#, c-format
-msgid "Invalid ping-restart duration '%s'."
-msgstr "Неисправно трајање поновног покретања пинга „%s“."
-
-#: ../src/nm-openvpn-service.c:1344
-#, c-format
-msgid "Invalid keysize '%s'."
-msgstr "Неисправна величина кључа „%s“."
-
-#: ../src/nm-openvpn-service.c:1394
-#, c-format
-msgid "Invalid reneg seconds '%s'."
-msgstr "Неисправан број секунди поновног преговарања „%s“."
-
-#: ../src/nm-openvpn-service.c:1426
-#, c-format
-msgid "Invalid TUN MTU size '%s'."
-msgstr "Неисправна ТУН МТУ величина „%s“."
-
-#: ../src/nm-openvpn-service.c:1441
-#, c-format
-msgid "Invalid fragment size '%s'."
-msgstr "Неисправна величина одломка „%s“."
-
-#: ../src/nm-openvpn-service.c:1517
-msgid "Missing required local IP address for static key mode."
-msgstr "Недостаје захтевана месна ИП адреса за режим статичког кључа."
-
-#: ../src/nm-openvpn-service.c:1529
-msgid "Missing required remote IP address for static key mode."
-msgstr "Недостаје захтевана удаљена ИП адреса за режим статичког кључа."
-
-#: ../src/nm-openvpn-service.c:1554
-#, c-format
-msgid "Unknown connection type '%s'."
-msgstr "Непозната врста везе „%s“."
-
-#: ../src/nm-openvpn-service.c:1579
-#, c-format
-msgid "User '%s' not found, check NM_OPENVPN_USER."
-msgstr "Нисам нашао корисника „%s“, проверите „NM_OPENVPN_USER“."
-
-#: ../src/nm-openvpn-service.c:1593
-#, c-format
-msgid "Group '%s' not found, check NM_OPENVPN_GROUP."
-msgstr "Нисам нашао групу „%s“, проверите „NM_OPENVPN_GROUP“."
-
-#: ../src/nm-openvpn-service.c:1740 ../src/nm-openvpn-service.c:1817
-#: ../src/nm-openvpn-service.c:1851
-msgid ""
-"Could not process the request because the VPN connection settings were "
-"invalid."
-msgstr "Не могу да обрадим захтев због неисправних подешавања ВПН везе."
-
-#: ../src/nm-openvpn-service.c:1749
-msgid ""
-"Could not process the request because the openvpn connection type was "
-"invalid."
-msgstr "Не могу да обрадим захтев због неисправне врсте везе опенвпн-а."
-
-#: ../src/nm-openvpn-service.c:1864
-msgid "Unhandled pending authentication."
-msgstr "Непознато потврђивање идентитета на чекању."
-
-#: ../src/nm-openvpn-service.c:1982
-msgid "Don't quit when VPN connection terminates"
-msgstr "Не прекида када се завршава ВПН веза"
-
-#: ../src/nm-openvpn-service.c:1983
-msgid "Enable verbose debug logging (may expose passwords)"
-msgstr ""
-"Укључује опширно записивање зарад исправљања грешака (може да изложи лозинке)"
-
-#: ../src/nm-openvpn-service.c:1984
-msgid "D-Bus name to use for this instance"
-msgstr "Назив Д-сабирнице који ће се користити за овај примерак"
-
-#: ../src/nm-openvpn-service.c:2010
-msgid ""
-"nm-openvpn-service provides integrated OpenVPN capability to NetworkManager."
-msgstr ""
-"нм-опенвпн-услуга обезбеђује Управнику мреже обједињену ОпенВПН могућност."
-
 #~ msgid "could not open file for writing"
 #~ msgstr "не могу да отворим датотеку за писање"
 
diff --git po/sr@latin.po po/sr@latin.po
index ff296bc..741308b 100644
--- po/sr@latin.po
+++ po/sr@latin.po
@@ -7,19 +7,41 @@
 msgid ""
 msgstr ""
 "Project-Id-Version: network-manager-openvpn master\n"
-"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=Network"
-"Manager&keywords=I18N+L10N&component=VPN: openvpn\n"
-"POT-Creation-Date: 2016-03-31 13:34+0000\n"
-"PO-Revision-Date: 2016-03-31 19:17+0200\n"
-"Last-Translator: Miroslav Nikolić <miroslavnikolic@rocketmail.com>\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
+"product=NetworkManager&keywords=I18N+L10N&component=VPN: openvpn\n"
+"POT-Creation-Date: 2016-04-14 10:36+0000\n"
+"PO-Revision-Date: 2016-04-14 18:06+0200\n"
+"Last-Translator: Marko M. Kostić <marko.m.kostic@gmail.com>\n"
 "Language-Team: Serbian <gnom@prevod.org>\n"
 "Language: sr\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
-"Plural-Forms: nplurals=4; plural=n==1? 3 : n%10==1 && n%100!=11 ? 0 : "
-"n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"
+"Plural-Forms: nplurals=4; plural=n==1? 3 : n%10==1 && n%100!=11 ? 0 : n"
+"%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"
 "X-Project-Style: gnome\n"
+"X-Generator: Poedit 1.8.7.1\n"
+
+#: ../appdata/network-manager-openvpn.appdata.xml.in.h:1
+msgid "OpenVPN client"
+msgstr "OpenVPN klijent"
+
+#: ../appdata/network-manager-openvpn.appdata.xml.in.h:2
+msgid "Client for OpenVPN virtual private networks"
+msgstr "Klijent za virtuelne privatne mreže kroz OpenVPN"
+
+#: ../appdata/network-manager-openvpn.appdata.xml.in.h:3
+msgid "Support for configuring OpenVPN virtual private network connections."
+msgstr ""
+"Podrška za podešavanje povezivanja u virtuelnim privatnim mrežama kroz OpenVPN."
+
+#: ../appdata/network-manager-openvpn.appdata.xml.in.h:4
+msgid "OpenVPN is a popular and flexible free-software VPN solution."
+msgstr "OpenVPN je popularan, prilagodljiv i slobodan program za VPN."
+
+#: ../appdata/network-manager-openvpn.appdata.xml.in.h:5
+msgid "The NetworkManager Developers"
+msgstr "Razvojni tim Upravnika mreže"
 
 #: ../auth-dialog/main.c:180
 #, c-format
@@ -73,8 +95,8 @@ msgstr "Izaberite uverenje izdavača ovlašćenja..."
 msgid "Choose an OpenVPN static key..."
 msgstr "Izaberite OpenVPN statički ključ..."
 
-#: ../properties/auth-helpers.c:369 ../properties/auth-helpers.c:1110
-#: ../properties/auth-helpers.c:1741
+#: ../properties/auth-helpers.c:369 ../properties/auth-helpers.c:1111
+#: ../properties/auth-helpers.c:1800
 msgid "None"
 msgstr "Ništa"
 
@@ -90,80 +112,80 @@ msgstr "PEM uverenja (*.pem, *.crt, *.key, *.cer)"
 msgid "OpenVPN Static Keys (*.key)"
 msgstr "OpenVPN statički ključ (*.key)"
 
-#: ../properties/auth-helpers.c:1014 ../properties/auth-helpers.c:1102
+#: ../properties/auth-helpers.c:1015 ../properties/auth-helpers.c:1103
 msgid "Default"
 msgstr "Osnovno"
 
-#: ../properties/auth-helpers.c:1112
+#: ../properties/auth-helpers.c:1113
 msgid "RSA MD-4"
 msgstr "RSA-MD-4"
 
-#: ../properties/auth-helpers.c:1114
+#: ../properties/auth-helpers.c:1115
 msgid "MD-5"
 msgstr "MD-5"
 
-#: ../properties/auth-helpers.c:1116
+#: ../properties/auth-helpers.c:1117
 msgid "SHA-1"
 msgstr "SHA-1"
 
-#: ../properties/auth-helpers.c:1118
+#: ../properties/auth-helpers.c:1119
 msgid "SHA-224"
 msgstr "SHA‑224"
 
-#: ../properties/auth-helpers.c:1120
+#: ../properties/auth-helpers.c:1121
 msgid "SHA-256"
 msgstr "SHA‑256"
 
-#: ../properties/auth-helpers.c:1122
+#: ../properties/auth-helpers.c:1123
 msgid "SHA-384"
 msgstr "SHA‑384"
 
-#: ../properties/auth-helpers.c:1124
+#: ../properties/auth-helpers.c:1125
 msgid "SHA-512"
 msgstr "SHA‑512"
 
-#: ../properties/auth-helpers.c:1126
+#: ../properties/auth-helpers.c:1127
 msgid "RIPEMD-160"
 msgstr "RIPEMD‑160"
 
-#: ../properties/auth-helpers.c:1177
+#: ../properties/auth-helpers.c:1178 ../properties/auth-helpers.c:1244
 msgid "Server"
 msgstr "Server"
 
-#: ../properties/auth-helpers.c:1182
+#: ../properties/auth-helpers.c:1183 ../properties/auth-helpers.c:1249
 msgid "Client"
 msgstr "Klijent"
 
-#: ../properties/auth-helpers.c:1450 ../properties/nm-openvpn-dialog.ui.h:41
+#: ../properties/auth-helpers.c:1498 ../properties/nm-openvpn-dialog.ui.h:41
 msgid "Not required"
 msgstr "Nepotrebno"
 
-#: ../properties/auth-helpers.c:1452
+#: ../properties/auth-helpers.c:1500
 msgid "HTTP"
 msgstr "HTTP"
 
-#: ../properties/auth-helpers.c:1454
+#: ../properties/auth-helpers.c:1502
 msgid "SOCKS"
 msgstr "SOCKS"
 
-#: ../properties/auth-helpers.c:1638
+#: ../properties/auth-helpers.c:1686
 msgid "TUN"
 msgstr "TUN"
 
-#: ../properties/auth-helpers.c:1640
+#: ../properties/auth-helpers.c:1688
 msgid "TAP"
 msgstr "TAP"
 
 #. interface name is max 15 chars
-#: ../properties/auth-helpers.c:1647
+#: ../properties/auth-helpers.c:1695
 msgid "(automatic)"
-msgstr "(automatski)"
+msgstr "(samostalno)"
 
-#: ../properties/auth-helpers.c:1808
+#: ../properties/auth-helpers.c:1867
 msgid "ping-exit"
 msgstr "izlaz pinga"
 
-#: ../properties/auth-helpers.c:1810
+#: ../properties/auth-helpers.c:1869
 msgid "ping-restart"
 msgstr "ponovno pokretanje pinga"
 
@@ -241,7 +263,7 @@ msgstr "dvostruki navodnici"
 
 #: ../properties/import-export.c:459
 msgid "single quote"
-msgstr "polunavodnik"
+msgstr "Jednostruki navodnik"
 
 #: ../properties/import-export.c:468
 #, c-format
@@ -286,71 +308,71 @@ msgstr "ne mogu da zapišem <%s> blob iz %ld. reda u datoteku (%s)"
 msgid "cannot write <%s> blob from line %ld to file '%s'"
 msgstr "ne mogu da zapišem <%s> blob iz %ld. reda u datoteku „%s“"
 
-#: ../properties/import-export.c:906
+#: ../properties/import-export.c:885 ../properties/import-export.c:1191
+#, c-format
+msgid "invalid option"
+msgstr "neispravna opcija"
+
+#: ../properties/import-export.c:917
 #, c-format
 msgid "unsupported comp-lzo argument"
 msgstr "nepodržan argument „comp-lzo“"
 
-#: ../properties/import-export.c:994
+#: ../properties/import-export.c:1005
 #, c-format
 msgid "remote cannot contain space"
 msgstr "udaljeni ne može da sadrži razmak"
 
-#: ../properties/import-export.c:998
+#: ../properties/import-export.c:1009
 #, c-format
 msgid "remote cannot contain comma"
 msgstr "udaljeni ne može da sadrži zarez"
 
-#: ../properties/import-export.c:1009
+#: ../properties/import-export.c:1020
 #, c-format
 msgid "remote expects protocol either udp or remote"
 msgstr "udaljeni očekuje ili protokol „udp“ ili „remote“"
 
-#: ../properties/import-export.c:1180
-#, c-format
-msgid "invalid option"
-msgstr "neispravna opcija"
-
-#: ../properties/import-export.c:1293
+#: ../properties/import-export.c:1304
 #, c-format
 msgid "unsupported blob/xml element"
 msgstr "nepodržani element blob/iksml"
 
-#: ../properties/import-export.c:1322
+#: ../properties/import-export.c:1333
 #, c-format
 msgid "unterminated blob element <%s>"
 msgstr "neokončani element bloba <%s>"
 
-#: ../properties/import-export.c:1372
+#: ../properties/import-export.c:1383
 #, c-format
 msgid "configuration error: %s (line %ld)"
 msgstr "greška podešavanja: %s (%ld. red)"
 
-#: ../properties/import-export.c:1373
+#: ../properties/import-export.c:1384
 msgid "unknown or unsupported option"
 msgstr "nepoznata ili nepodržana opcija"
 
-#: ../properties/import-export.c:1383
+#: ../properties/import-export.c:1394
 msgid "The file to import wasn't a valid OpenVPN client configuration"
 msgstr "Datoteka za uvoz nije ispravno podešavanje OpenVPN klijenta"
 
-#: ../properties/import-export.c:1391
+#: ../properties/import-export.c:1402
 msgid "The file to import wasn't a valid OpenVPN configure (no remote)"
 msgstr "Datoteka za uvoz nije ispravno OpenVPN podešavanje (nema udaljenog)"
 
-#: ../properties/import-export.c:1624
+#: ../properties/import-export.c:1635
 msgid "missing path argument"
 msgstr "nedostaje argument sa putanjom"
 
-#: ../properties/import-export.c:1634
+#: ../properties/import-export.c:1645
 msgid "connection is not a valid OpenVPN connection"
 msgstr "veza nije ispravna OpenVPN veza"
 
-#: ../properties/import-export.c:1643
+#: ../properties/import-export.c:1654
 msgid "connection was incomplete (missing gateway)"
 msgstr "veza beše nepotpuna (nedostaje mrežni prolaz)"
 
-#: ../properties/import-export.c:1943
+#: ../properties/import-export.c:1955
 #, c-format
 msgid "failed to write file: %s"
 msgstr "nisam uspeo da upišem datoteku: %s"
@@ -391,6 +413,222 @@ msgstr "ne mogu da učitam element sučelja"
 msgid "unknown OpenVPN file extension"
 msgstr "nepoznato proširenje OpenVPN datoteke"
 
+#: ../shared/nm-shared-utils.c:174
+#, c-format
+msgid "object class '%s' has no property named '%s'"
+msgstr "klasa objekta „%s“ nema svojstvo sa nazivom „%s“"
+
+#: ../shared/nm-shared-utils.c:181
+#, c-format
+msgid "property '%s' of object class '%s' is not writable"
+msgstr "svojstvo „%s“ klase objekta „%s“ nije upisivo"
+
+#: ../shared/nm-shared-utils.c:188
+#, c-format
+msgid ""
+"construct property \"%s\" for object '%s' can't be set after construction"
+msgstr ""
+"svojstvo konstrukta „%s“ za objekat „%s“ se ne može postaviti nakon "
+"konstruisanja"
+
+#: ../shared/nm-shared-utils.c:196
+#, c-format
+msgid "'%s::%s' is not a valid property name; '%s' is not a GObject subtype"
+msgstr "„%s::%s“ nije ispravan naziv svojstva; „%s“ nije GObject podvrsta"
+
+#: ../shared/nm-shared-utils.c:205
+#, c-format
+msgid "unable to set property '%s' of type '%s' from value of type '%s'"
+msgstr "ne mogu da postavim svojstvo „%s“ vrste „%s“ iz vrednosti vrste „%s“"
+
+#: ../shared/nm-shared-utils.c:216
+#, c-format
+msgid ""
+"value \"%s\" of type '%s' is invalid or out of range for property '%s' of "
+"type '%s'"
+msgstr ""
+"vrednost „%s“ vrste „%s“ je neispravna ili van opsega za svojstvo „%s“ vrste "
+"„%s“"
+
+#: ../src/nm-openvpn-service.c:359
+#, c-format
+msgid "invalid address '%s'"
+msgstr "neispravna adresa „%s“"
+
+#: ../src/nm-openvpn-service.c:371
+#, c-format
+msgid "invalid integer property '%s' or out of range [%d -> %d]"
+msgstr "neispravno svojstvo celog broja „%s“ ili je van opsega [%d —> %d]"
+
+#. Translators: keep "yes" and "no" untranslated!
+#: ../src/nm-openvpn-service.c:382
+#, c-format
+msgid "invalid boolean property '%s' (not yes or no)"
+msgstr "neispravno logičko svojstvo „%s“ (nije „yes“ (da) ili „no“ (ne))"
+
+#: ../src/nm-openvpn-service.c:389
+#, c-format
+msgid "unhandled property '%s' type %s"
+msgstr "nerukovano svojstvo „%s“ vrste %s"
+
+#: ../src/nm-openvpn-service.c:400
+#, c-format
+msgid "property '%s' invalid or not supported"
+msgstr "svojstvo „%s“ je neispravno ili nije podržano"
+
+#: ../src/nm-openvpn-service.c:416
+msgid "No VPN configuration options."
+msgstr "Nema opcija VPN podešavanja."
+
+#: ../src/nm-openvpn-service.c:585
+msgid "A username is required."
+msgstr "Potrebno je korisničko ime."
+
+#: ../src/nm-openvpn-service.c:589
+msgid "A password is required."
+msgstr "Potrebna je lozinka."
+
+#: ../src/nm-openvpn-service.c:592
+msgid "A username and password are required."
+msgstr "Potrebni su korisničko ime i lozinka."
+
+#: ../src/nm-openvpn-service.c:612
+msgid "A private key password is required."
+msgstr "Potrebna je lozinka privatnog ključa."
+
+#: ../src/nm-openvpn-service.c:625
+msgid "An HTTP Proxy username is required."
+msgstr "Potrebno je korisničko ime HTTP posrednika."
+
+#: ../src/nm-openvpn-service.c:629
+msgid "An HTTP Proxy password is required."
+msgstr "Potrebna je lozinka HTTP posrednika."
+
+#: ../src/nm-openvpn-service.c:632
+msgid "An HTTP Proxy username and password are required."
+msgstr "Potrebni su korisničko ime i lozinka HTTP posrednika."
+
+#: ../src/nm-openvpn-service.c:1114
+msgid "Could not find the openvpn binary."
+msgstr "Ne mogu da pronađem openvpn izvršni."
+
+#: ../src/nm-openvpn-service.c:1124
+msgid "Invalid HMAC auth."
+msgstr "Neispravno HMAC potvrđivanje identiteta."
+
+#: ../src/nm-openvpn-service.c:1134 ../src/nm-openvpn-service.c:1834
+msgid "Invalid connection type."
+msgstr "Neispravna vrsta veze."
+
+#: ../src/nm-openvpn-service.c:1169 ../src/nm-openvpn-service.c:1179
+#, c-format
+msgid "Invalid port number '%s'."
+msgstr "Neispravan broj priključnika „%s“."
+
+#: ../src/nm-openvpn-service.c:1196
+#, c-format
+msgid "Invalid proto '%s'."
+msgstr "Neispravan protokol „%s“."
+
+#: ../src/nm-openvpn-service.c:1242
+#, c-format
+msgid "Invalid proxy type '%s'."
+msgstr "Neispravna vrsta posrednika „%s“."
+
+#: ../src/nm-openvpn-service.c:1265
+#, c-format
+msgid "Invalid ping duration '%s'."
+msgstr "Neispravno trajanje pinga „%s“."
+
+#: ../src/nm-openvpn-service.c:1279
+#, c-format
+msgid "Invalid ping-exit duration '%s'."
+msgstr "Neispravno trajanje izlaska pinga „%s“."
+
+#: ../src/nm-openvpn-service.c:1293
+#, c-format
+msgid "Invalid ping-restart duration '%s'."
+msgstr "Neispravno trajanje ponovnog pokretanja pinga „%s“."
+
+#: ../src/nm-openvpn-service.c:1345
+#, c-format
+msgid "Invalid keysize '%s'."
+msgstr "Neispravna veličina ključa „%s“."
+
+#: ../src/nm-openvpn-service.c:1402
+#, c-format
+msgid "Invalid reneg seconds '%s'."
+msgstr "Neispravan broj sekundi ponovnog pregovaranja „%s“."
+
+#: ../src/nm-openvpn-service.c:1434
+#, c-format
+msgid "Invalid TUN MTU size '%s'."
+msgstr "Neispravna TUN MTU veličina „%s“."
+
+#: ../src/nm-openvpn-service.c:1449
+#, c-format
+msgid "Invalid fragment size '%s'."
+msgstr "Neispravna veličina odlomka „%s“."
+
+#: ../src/nm-openvpn-service.c:1525
+msgid "Missing required local IP address for static key mode."
+msgstr "Nedostaje zahtevana mesna IP adresa za režim statičkog ključa."
+
+#: ../src/nm-openvpn-service.c:1537
+msgid "Missing required remote IP address for static key mode."
+msgstr "Nedostaje zahtevana udaljena IP adresa za režim statičkog ključa."
+
+#: ../src/nm-openvpn-service.c:1562
+#, c-format
+msgid "Unknown connection type '%s'."
+msgstr "Nepoznata vrsta veze „%s“."
+
+#: ../src/nm-openvpn-service.c:1587
+#, c-format
+msgid "User '%s' not found, check NM_OPENVPN_USER."
+msgstr "Nisam našao korisnika „%s“, proverite „NM_OPENVPN_USER“."
+
+#: ../src/nm-openvpn-service.c:1601
+#, c-format
+msgid "Group '%s' not found, check NM_OPENVPN_GROUP."
+msgstr "Nisam našao grupu „%s“, proverite „NM_OPENVPN_GROUP“."
+
+#: ../src/nm-openvpn-service.c:1748 ../src/nm-openvpn-service.c:1825
+#: ../src/nm-openvpn-service.c:1859
+msgid ""
+"Could not process the request because the VPN connection settings were "
+"invalid."
+msgstr "Ne mogu da obradim zahtev zbog neispravnih podešavanja VPN veze."
+
+#: ../src/nm-openvpn-service.c:1757
+msgid ""
+"Could not process the request because the openvpn connection type was "
+"invalid."
+msgstr "Ne mogu da obradim zahtev zbog neispravne vrste veze openvpn-a."
+
+#: ../src/nm-openvpn-service.c:1872
+msgid "Unhandled pending authentication."
+msgstr "Nepoznato potvrđivanje identiteta na čekanju."
+
+#: ../src/nm-openvpn-service.c:1990
+msgid "Don't quit when VPN connection terminates"
+msgstr "Ne prekida kada se završava VPN veza"
+
+#: ../src/nm-openvpn-service.c:1991
+msgid "Enable verbose debug logging (may expose passwords)"
+msgstr ""
+"Uključuje opširno zapisivanje zarad ispravljanja grešaka (može da izloži lozinke)"
+
+#: ../src/nm-openvpn-service.c:1992
+msgid "D-Bus name to use for this instance"
+msgstr "Naziv D-sabirnice koji će se koristiti za ovaj primerak"
+
+#: ../src/nm-openvpn-service.c:2018
+msgid ""
+"nm-openvpn-service provides integrated OpenVPN capability to NetworkManager."
+msgstr ""
+"nm-openvpn-usluga obezbeđuje Upravniku mreže objedinjenu OpenVPN mogućnost."
+
 #: ../properties/nm-openvpn-dialog.ui.h:1
 msgid " "
 msgstr " "
@@ -410,9 +648,9 @@ msgid ""
 "delimiters).\n"
 "config: remote"
 msgstr ""
-"Udaljeni mrežni prolaz(i), sa izbornim priključnikom i protokolom (npr. "
-"„ovpn.corp.com:1234:tcp“). Možete da navedete više stavki zarad izobilja ("
-"koristite zareze da razdvojite unose).\n"
+"Udaljeni mrežni prolaz(i), sa izbornim priključnikom i protokolom (npr. „ovpn."
+"corp.com:1234:tcp“). Možete da navedete više stavki zarad izobilja (koristite "
+"zareze da razdvojite unose).\n"
 "podešavanje: „remote“"
 
 #: ../properties/nm-openvpn-dialog.ui.h:6
@@ -479,7 +717,7 @@ msgstr ""
 
 #: ../properties/nm-openvpn-dialog.ui.h:22
 msgid "User name:"
-msgstr "Korisnik:"
+msgstr "Korisničko ime:"
 
 #: ../properties/nm-openvpn-dialog.ui.h:23
 msgid ""
@@ -540,7 +778,7 @@ msgstr ""
 "Usmerenje za režim šifrovanja statičkog ključa (ne-TLS).\n"
 "Ako koristite usmerenje ključa, mora biti suprotno od onog korišćenog na VPN "
 "parnjaku.  Na primer, ako parnjak koristi „1“, ova veza mora da koristi „0“.  "
-"Ako niste sigurni koju vrednost da koristite, posavetujte se sa "
+"Ako niste sigurni koju vrednost da koristite, posavejtujte se sa "
 "administratorom sistema.\n"
 "podešavanje: „static <datoteka> [usmerenje]“"
 
@@ -640,8 +878,8 @@ msgid ""
 "\"tap\").\n"
 "config: dev <name>"
 msgstr ""
-"Koristite proizvoljan naziv za TUN/TAP virtuelni uređaj (umesto osnovnog „tun“"
-" ili „tap“).\n"
+"Koristite proizvoljan naziv za TUN/TAP virtuelni uređaj (umesto osnovnog "
+"„tun“ ili „tap“).\n"
 "podešavanje: dev „<naziv>“"
 
 #: ../properties/nm-openvpn-dialog.ui.h:63
@@ -728,12 +966,13 @@ msgid ""
 "config: float"
 msgstr ""
 "Omogućava udaljenom parnjaku da promeni svoju IP adresu i/ili broj "
-"priključnika, kao usled DHCP-a (ovo je osnovno ako se ne koristi „--remote“)"
-".  „--float“ kada je navedeno sa „--remote“ omogućava OpenVPN sesiji da se "
-"prvo poveže sa parnjakom na poznatoj adresi, međutim ako paketi stižu sa nove "
-"adrese i prođu sve testove potvrđivanja identiteta, nova adresa će preuzeti "
-"kontrolu nad sesijom.  Ovoje korisno kada se povezujete sa parnjakom koji "
-"drži dinamičku adresu kao što je korisnik dvojne parice ili DHCP klijent.\n"
+"priključnika, kao usled DHCP-a (ovo je osnovno ako se ne koristi „--"
+"remote“).  „--float“ kada je navedeno sa „--remote“ omogućava OpenVPN sesiji "
+"da se prvo poveže sa parnjakom na poznatoj adresi, međutim ako paketi stižu "
+"sa nove adrese i prođu sve testove potvrđivanja identiteta, nova adresa će "
+"preuzeti kontrolu nad sesijom.  Ovoje korisno kada se povezujete sa parnjakom "
+"koji drži dinamičku adresu kao što je korisnik dvojne parice ili DHCP "
+"klijent.\n"
 "\n"
 "U osnovi, „--float“ govori OpenVPN-u da prihvati proverene pakete sa bilo "
 "koje adrese, a ne samo sa adrese koja je navedena u opciji „--remote“.\n"
@@ -867,18 +1106,43 @@ msgstr ""
 "podešavanje: „remote-cert-tls client|server“"
 
 #: ../properties/nm-openvpn-dialog.ui.h:111
+msgid "_Verify peer (server) certificate nsCertType designation"
+msgstr "_Proveri oznaku nsCertType uverenja parnjaka (servera)"
+
+#: ../properties/nm-openvpn-dialog.ui.h:112
+msgid ""
+"Require that peer certificate was signed with an explicit nsCertType "
+"designation."
+msgstr ""
+"Zahtevaj da uverenje parnjaka bude potpisan sa izričitom nsCertType oznakom."
+
+#: ../properties/nm-openvpn-dialog.ui.h:113
+msgid "_Remote peer certificate nsCert designation:"
+msgstr "Oznaka nsCert uve_renja udaljenog parnjaka:"
+
+#: ../properties/nm-openvpn-dialog.ui.h:114
+msgid ""
+"Require that peer certificate was signed with an explicit nsCertType "
+"designation.\n"
+"config: ns-cert-type client|server"
+msgstr ""
+"Zahtevajte da uverenje parnjaka bude potpisano sa izričitom nsCertType "
+"oznakom.\n"
+"podešavanje: „ns-cert-type client|server“"
+
+#: ../properties/nm-openvpn-dialog.ui.h:116
 msgid "Use additional _TLS authentication"
 msgstr "Koristi dopunsko potvrđivanje identiteta _TLS-a"
 
-#: ../properties/nm-openvpn-dialog.ui.h:112
+#: ../properties/nm-openvpn-dialog.ui.h:117
 msgid "Add an additional layer of HMAC authentication."
 msgstr "Dodajte dopunski sloj HMAC potvrde identiteta."
 
-#: ../properties/nm-openvpn-dialog.ui.h:113
+#: ../properties/nm-openvpn-dialog.ui.h:118
 msgid "Key _Direction:"
 msgstr "_Usmerenje ključa:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:114
+#: ../properties/nm-openvpn-dialog.ui.h:119
 msgid ""
 "Add an additional layer of HMAC authentication on top of the TLS control "
 "channel to protect against DoS attacks.\n"
@@ -888,7 +1152,7 @@ msgstr ""
 "da se zaštitite od DoS napada.\n"
 "podešavanje: „tls-auth <datoteka> [usmerenje]“"
 
-#: ../properties/nm-openvpn-dialog.ui.h:116
+#: ../properties/nm-openvpn-dialog.ui.h:121
 msgid ""
 "Direction parameter for static key mode.\n"
 "If key direction is used, it must be the opposite of that used on the VPN "
@@ -899,19 +1163,19 @@ msgstr ""
 "Parametri usmerenja za režim statičkog ključa.\n"
 "Ako koristite usmerenje ključa, mora biti suprotno od onog korišćenog na VPN "
 "parnjaku.  Na primer, ako parnjak koristi „1“, ova veza mora da koristi „0“.  "
-"Ako niste sigurni koju vrednost da koristite, posavetujte se sa "
+"Ako niste sigurni koju vrednost da koristite, posavejtujte se sa "
 "administratorom sistema.\n"
 "podešavanje: „tls-auth <datoteka> [usmerenje]“"
 
-#: ../properties/nm-openvpn-dialog.ui.h:119
+#: ../properties/nm-openvpn-dialog.ui.h:124
 msgid "Key _File:"
 msgstr "_Datoteka ključa:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:120
+#: ../properties/nm-openvpn-dialog.ui.h:125
 msgid "TLS Authentication"
 msgstr "TLS potvrđivanje identiteta"
 
-#: ../properties/nm-openvpn-dialog.ui.h:121
+#: ../properties/nm-openvpn-dialog.ui.h:126
 msgid ""
 "Proxy type: HTTP or Socks.\n"
 "config: http-proxy or socks-proxy"
@@ -919,11 +1183,11 @@ msgstr ""
 "Vrsta posrednika: HTTP ili Socks.\n"
 "podešavanje: „http-proxy“ ili „socks-proxy“"
 
-#: ../properties/nm-openvpn-dialog.ui.h:123
+#: ../properties/nm-openvpn-dialog.ui.h:128
 msgid "Proxy _Type:"
 msgstr "Vrsta _posrednika:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:124
+#: ../properties/nm-openvpn-dialog.ui.h:129
 msgid ""
 "<i>Select this option if your organization requires the use of a proxy "
 "server to access the Internet.</i>"
@@ -931,11 +1195,11 @@ msgstr ""
 "<i>Izaberite ovu opciju ako vaše udruženje zahteva upotrebu posredničkog "
 "servera za pristupanje Internetu.</i>"
 
-#: ../properties/nm-openvpn-dialog.ui.h:125
+#: ../properties/nm-openvpn-dialog.ui.h:130
 msgid "Server _Address:"
 msgstr "_Adresa servera:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:126
+#: ../properties/nm-openvpn-dialog.ui.h:131
 msgid ""
 "Connect to remote host through a proxy with this address.\n"
 "config: http-proxy or socks-proxy"
@@ -943,11 +1207,11 @@ msgstr ""
 "Povežite se na udaljenog domaćina putem posrednika sa ovom adresom.\n"
 "podešavanje: „http-proxy“ ili „socks-proxy“"
 
-#: ../properties/nm-openvpn-dialog.ui.h:128
+#: ../properties/nm-openvpn-dialog.ui.h:133
 msgid "_Port:"
 msgstr "_Priključnik:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:129
+#: ../properties/nm-openvpn-dialog.ui.h:134
 msgid ""
 "Connect to remote host through a proxy with this port.\n"
 "config: http-proxy or socks-proxy"
@@ -955,11 +1219,11 @@ msgstr ""
 "Povežite se na udaljenog domaćina putem posrednika sa ovim priključnikom.\n"
 "podešavanje: „http-proxy“ ili „socks-proxy“"
 
-#: ../properties/nm-openvpn-dialog.ui.h:131
+#: ../properties/nm-openvpn-dialog.ui.h:136
 msgid "_Retry indefinitely when errors occur"
 msgstr "_Neprekidno pokušavaj kad dođe do grešaka"
 
-#: ../properties/nm-openvpn-dialog.ui.h:132
+#: ../properties/nm-openvpn-dialog.ui.h:137
 msgid ""
 "Retry indefinitely on proxy errors. It simulates a SIGUSR1 reset.\n"
 "config: http-proxy-retry or socks-proxy-retry"
@@ -968,247 +1232,31 @@ msgstr ""
 "postavljanje.\n"
 "podešavanje: „http-proxy-retry“ ili „socks-proxy-retry“"
 
-#: ../properties/nm-openvpn-dialog.ui.h:134
+#: ../properties/nm-openvpn-dialog.ui.h:139
 msgid "Proxy _Username:"
-msgstr "_Korisnik posrednika:"
+msgstr "Korisničko _ime za posrednika:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:135
+#: ../properties/nm-openvpn-dialog.ui.h:140
 msgid "Proxy Passwor_d:"
-msgstr "_Lozinka posrednika:"
+msgstr "Lozinka _posrednika:"
 
-#: ../properties/nm-openvpn-dialog.ui.h:136
+#: ../properties/nm-openvpn-dialog.ui.h:141
 msgid "HTTP/Socks proxy username passed to OpenVPN when prompted for it."
 msgstr ""
 "Korisničko ime HTTP/Socks posrednika prosleđeno OpenVPN-u kada je zatraženo."
 
-#: ../properties/nm-openvpn-dialog.ui.h:137
+#: ../properties/nm-openvpn-dialog.ui.h:142
 msgid "HTTP/Socks proxy password passed to OpenVPN when prompted for it."
 msgstr "Lozinka HTTP/Socks posrednika prosleđena OpenVPN-u kada je zatraženo."
 
-#: ../properties/nm-openvpn-dialog.ui.h:138
+#: ../properties/nm-openvpn-dialog.ui.h:143
 msgid "_Show password"
 msgstr "_Prikaži lozinku"
 
-#: ../properties/nm-openvpn-dialog.ui.h:139
+#: ../properties/nm-openvpn-dialog.ui.h:144
 msgid "Proxies"
 msgstr "Posrednici"
 
-#: ../shared/nm-shared-utils.c:174
-#, c-format
-msgid "object class '%s' has no property named '%s'"
-msgstr "klasa objekta „%s“ nema svojstvo sa nazivom „%s“"
-
-#: ../shared/nm-shared-utils.c:181
-#, c-format
-msgid "property '%s' of object class '%s' is not writable"
-msgstr "svojstvo „%s“ klase objekta „%s“ nije upisivo"
-
-#: ../shared/nm-shared-utils.c:188
-#, c-format
-msgid ""
-"construct property \"%s\" for object '%s' can't be set after construction"
-msgstr ""
-"gradivno svojstvo „%s“ za objekat „%s“ ne može biti postavljeno nakon "
-"konstrukcije"
-
-#: ../shared/nm-shared-utils.c:196
-#, c-format
-msgid "'%s::%s' is not a valid property name; '%s' is not a GObject subtype"
-msgstr "„%s::%s“ nije ispravan naziv svojstva; „%s“ nije podvrsta Gobjekta"
-
-#: ../shared/nm-shared-utils.c:205
-#, c-format
-msgid "unable to set property '%s' of type '%s' from value of type '%s'"
-msgstr "ne mogu da postavim svojstvo „%s“ vrste „%s“ iz vrednosti vrste „%s“"
-
-#: ../shared/nm-shared-utils.c:216
-#, c-format
-msgid ""
-"value \"%s\" of type '%s' is invalid or out of range for property '%s' of "
-"type '%s'"
-msgstr ""
-"vrednost „%s“ vrste „%s“ je neispravna ili je van opsega za svojstvo „%s“ "
-"vrste „%s“"
-
-#: ../src/nm-openvpn-service.c:358
-#, c-format
-msgid "invalid address '%s'"
-msgstr "neispravna adresa „%s“"
-
-#: ../src/nm-openvpn-service.c:370
-#, c-format
-msgid "invalid integer property '%s' or out of range [%d -> %d]"
-msgstr "neispravno svojstvo celog broja „%s“ ili je van opsega [%d → %d]"
-
-#. Translators: keep "yes" and "no" untranslated!
-#: ../src/nm-openvpn-service.c:381
-#, c-format
-msgid "invalid boolean property '%s' (not yes or no)"
-msgstr "neispravno logičko svojstvo „%s“ (nije „da“ ili „ne“)"
-
-#: ../src/nm-openvpn-service.c:388
-#, c-format
-msgid "unhandled property '%s' type %s"
-msgstr "nerukovano svojstvo „%s“ vrste %s"
-
-#: ../src/nm-openvpn-service.c:399
-#, c-format
-msgid "property '%s' invalid or not supported"
-msgstr "svojstvo „%s“ je neispravno ili nije podržano"
-
-#: ../src/nm-openvpn-service.c:415
-msgid "No VPN configuration options."
-msgstr "Nema opcija VPN podešavanja."
-
-#: ../src/nm-openvpn-service.c:584
-msgid "A username is required."
-msgstr "Potrebno je korisničko ime."
-
-#: ../src/nm-openvpn-service.c:588
-msgid "A password is required."
-msgstr "Potrebna je lozinka."
-
-#: ../src/nm-openvpn-service.c:591
-msgid "A username and password are required."
-msgstr "Potrebni su korisničko ime i lozinka."
-
-#: ../src/nm-openvpn-service.c:611
-msgid "A private key password is required."
-msgstr "Potrebna je lozinka privatnog ključa."
-
-#: ../src/nm-openvpn-service.c:624
-msgid "An HTTP Proxy username is required."
-msgstr "Potrebno je korisničko ime HTTP posrednika."
-
-#: ../src/nm-openvpn-service.c:628
-msgid "An HTTP Proxy password is required."
-msgstr "Potrebna je lozinka HTTP posrednika."
-
-#: ../src/nm-openvpn-service.c:631
-msgid "An HTTP Proxy username and password are required."
-msgstr "Potrebni su korisničko ime i lozinka HTTP posrednika."
-
-#: ../src/nm-openvpn-service.c:1113
-msgid "Could not find the openvpn binary."
-msgstr "Ne mogu da pronađem openvpn izvršni."
-
-#: ../src/nm-openvpn-service.c:1123
-msgid "Invalid HMAC auth."
-msgstr "Neispravno HMAC potvrđivanje identiteta."
-
-#: ../src/nm-openvpn-service.c:1133 ../src/nm-openvpn-service.c:1826
-msgid "Invalid connection type."
-msgstr "Neispravna vrsta veze."
-
-#: ../src/nm-openvpn-service.c:1168 ../src/nm-openvpn-service.c:1178
-#, c-format
-msgid "Invalid port number '%s'."
-msgstr "Neispravan broj priključnika „%s“."
-
-#: ../src/nm-openvpn-service.c:1195
-#, c-format
-msgid "Invalid proto '%s'."
-msgstr "Neispravan protokol „%s“."
-
-#: ../src/nm-openvpn-service.c:1241
-#, c-format
-msgid "Invalid proxy type '%s'."
-msgstr "Neispravna vrsta posrednika „%s“."
-
-#: ../src/nm-openvpn-service.c:1264
-#, c-format
-msgid "Invalid ping duration '%s'."
-msgstr "Neispravno trajanje pinga „%s“."
-
-#: ../src/nm-openvpn-service.c:1278
-#, c-format
-msgid "Invalid ping-exit duration '%s'."
-msgstr "Neispravno trajanje izlaska pinga „%s“."
-
-#: ../src/nm-openvpn-service.c:1292
-#, c-format
-msgid "Invalid ping-restart duration '%s'."
-msgstr "Neispravno trajanje ponovnog pokretanja pinga „%s“."
-
-#: ../src/nm-openvpn-service.c:1344
-#, c-format
-msgid "Invalid keysize '%s'."
-msgstr "Neispravna veličina ključa „%s“."
-
-#: ../src/nm-openvpn-service.c:1394
-#, c-format
-msgid "Invalid reneg seconds '%s'."
-msgstr "Neispravan broj sekundi ponovnog pregovaranja „%s“."
-
-#: ../src/nm-openvpn-service.c:1426
-#, c-format
-msgid "Invalid TUN MTU size '%s'."
-msgstr "Neispravna TUN MTU veličina „%s“."
-
-#: ../src/nm-openvpn-service.c:1441
-#, c-format
-msgid "Invalid fragment size '%s'."
-msgstr "Neispravna veličina odlomka „%s“."
-
-#: ../src/nm-openvpn-service.c:1517
-msgid "Missing required local IP address for static key mode."
-msgstr "Nedostaje zahtevana mesna IP adresa za režim statičkog ključa."
-
-#: ../src/nm-openvpn-service.c:1529
-msgid "Missing required remote IP address for static key mode."
-msgstr "Nedostaje zahtevana udaljena IP adresa za režim statičkog ključa."
-
-#: ../src/nm-openvpn-service.c:1554
-#, c-format
-msgid "Unknown connection type '%s'."
-msgstr "Nepoznata vrsta veze „%s“."
-
-#: ../src/nm-openvpn-service.c:1579
-#, c-format
-msgid "User '%s' not found, check NM_OPENVPN_USER."
-msgstr "Nisam našao korisnika „%s“, proverite „NM_OPENVPN_USER“."
-
-#: ../src/nm-openvpn-service.c:1593
-#, c-format
-msgid "Group '%s' not found, check NM_OPENVPN_GROUP."
-msgstr "Nisam našao grupu „%s“, proverite „NM_OPENVPN_GROUP“."
-
-#: ../src/nm-openvpn-service.c:1740 ../src/nm-openvpn-service.c:1817
-#: ../src/nm-openvpn-service.c:1851
-msgid ""
-"Could not process the request because the VPN connection settings were "
-"invalid."
-msgstr "Ne mogu da obradim zahtev zbog neispravnih podešavanja VPN veze."
-
-#: ../src/nm-openvpn-service.c:1749
-msgid ""
-"Could not process the request because the openvpn connection type was "
-"invalid."
-msgstr "Ne mogu da obradim zahtev zbog neispravne vrste veze openvpn-a."
-
-#: ../src/nm-openvpn-service.c:1864
-msgid "Unhandled pending authentication."
-msgstr "Nepoznato potvrđivanje identiteta na čekanju."
-
-#: ../src/nm-openvpn-service.c:1982
-msgid "Don't quit when VPN connection terminates"
-msgstr "Ne prekida kada se završava VPN veza"
-
-#: ../src/nm-openvpn-service.c:1983
-msgid "Enable verbose debug logging (may expose passwords)"
-msgstr ""
-"Uključuje opširno zapisivanje zarad ispravljanja grešaka (može da izloži lozinke)"
-
-#: ../src/nm-openvpn-service.c:1984
-msgid "D-Bus name to use for this instance"
-msgstr "Naziv D-sabirnice koji će se koristiti za ovaj primerak"
-
-#: ../src/nm-openvpn-service.c:2010
-msgid ""
-"nm-openvpn-service provides integrated OpenVPN capability to NetworkManager."
-msgstr ""
-"nm-openvpn-usluga obezbeđuje Upravniku mreže objedinjenu OpenVPN mogućnost."
-
 #~ msgid "could not open file for writing"
 #~ msgstr "ne mogu da otvorim datoteku za pisanje"
 
diff --git properties/Makefile.am properties/Makefile.am
index 726db2e..028709d 100644
--- properties/Makefile.am
+++ properties/Makefile.am
@@ -2,63 +2,130 @@ SUBDIRS = . tests
 
 plugindir = $(libdir)/NetworkManager
 plugin_LTLIBRARIES = libnm-vpn-plugin-openvpn.la
+if WITH_GNOME
+plugin_LTLIBRARIES += libnm-vpn-plugin-openvpn-editor.la
 if WITH_LIBNM_GLIB
 plugin_LTLIBRARIES += libnm-openvpn-properties.la
 endif
+endif
 
-libnm_vpn_plugin_openvpn_la_SOURCES =                   \
-        nm-openvpn.c                                    \
-        nm-openvpn.h                                    \
-        auth-helpers.c                                  \
-        auth-helpers.h                                  \
-        import-export.c                                 \
+plugin_sources = \
+        nm-openvpn-editor-plugin.c \
+        nm-openvpn-editor-plugin.h \
+        import-export.c \
         import-export.h
 
-libnm_openvpn_properties_la_SOURCES =               \
-        $(libnm_vpn_plugin_openvpn_la_SOURCES)
+editor_sources = \
+        nm-openvpn-editor.c \
+        nm-openvpn-editor.h \
+        auth-helpers.c \
+        auth-helpers.h
 
 uidir = $(datadir)/gnome-vpn-properties/openvpn
+if WITH_GNOME
 ui_DATA = nm-openvpn-dialog.ui
+endif
 
 common_CFLAGS =                                         \
         $(GLIB_CFLAGS)                                  \
-        $(GTK_CFLAGS)                                   \
         -I$(top_srcdir)/shared                          \
-        -DNETWORKMANAGER_COMPILATION=NM_NETWORKMANAGER_COMPILATION_LIB \
         -DICONDIR=\""$(datadir)/pixmaps"\"              \
         -DUIDIR=\""$(uidir)"\"                          \
         -DLOCALEDIR=\"$(datadir)/locale\"
 
+###############################################################################
+
+libnm_vpn_plugin_openvpn_la_SOURCES = \
+        $(plugin_sources)
+
 libnm_vpn_plugin_openvpn_la_CFLAGS =                    \
         $(common_CFLAGS)                                \
-        $(LIBNM_CFLAGS)                                 \
+        -DNETWORKMANAGER_COMPILATION=NM_NETWORKMANAGER_COMPILATION_LIB_BASE \
+        -DNM_PLUGIN_DIR=\"$(NM_PLUGIN_DIR)\" \
+        $(LIBNM_CFLAGS)
+
+libnm_vpn_plugin_openvpn_la_LIBADD = \
+        $(LIBNM_LIBS) \
+        $(top_builddir)/shared/libnm-vpn-editor-utils-shared.la \
+        $(top_builddir)/shared/libnm-vpn-plugin-openvpn-shared.la
+
+libnm_vpn_plugin_openvpn_la_LDFLAGS = \
+        -avoid-version \
+        -Wl,--version-script=$(srcdir)/libnm-vpn-plugin-openvpn.ver
+
+###############################################################################
+
+libnm_vpn_plugin_openvpn_editor_la_SOURCES = \
+        $(editor_sources)
+
+libnm_vpn_plugin_openvpn_editor_la_CFLAGS = \
+        $(common_CFLAGS) \
+        $(GTK_CFLAGS) \
+        -DNETWORKMANAGER_COMPILATION=NM_NETWORKMANAGER_COMPILATION_LIB_EDITOR \
+        $(LIBNM_CFLAGS) \
         $(LIBNMA_CFLAGS)
 
+libnm_vpn_plugin_openvpn_editor_la_LIBADD = \
+        $(GTK_LIBS) \
+        $(LIBNM_LIBS) \
+        $(LIBNMA_LIBS) \
+        $(top_builddir)/shared/libnm-vpn-plugin-openvpn-shared.la
+
+libnm_vpn_plugin_openvpn_editor_la_LDFLAGS = \
+        -avoid-version \
+        -Wl,--version-script=$(srcdir)/libnm-vpn-plugin-openvpn-editor.ver
+
+###############################################################################
+
+libnm_openvpn_properties_la_SOURCES = \
+        $(plugin_sources) \
+        $(editor_sources)
+
 libnm_openvpn_properties_la_CFLAGS =                \
-        -DNM_OPENVPN_OLD \
+        -DNM_VPN_OLD \
         $(common_CFLAGS)                                \
+        $(GTK_CFLAGS) \
+        -DNETWORKMANAGER_COMPILATION=NM_NETWORKMANAGER_COMPILATION_LIB \
         $(LIBNM_GLIB_CFLAGS)                            \
         $(LIBNM_GTK_CFLAGS)
 
-libnm_vpn_plugin_openvpn_la_LIBADD =                    \
-        $(GTK_LIBS)                                     \
-        $(LIBNM_LIBS)                                   \
-        $(LIBNMA_LIBS)                                  \
-        $(top_builddir)/shared/libnm-vpn-plugin-openvpn-shared.la
-
 libnm_openvpn_properties_la_LIBADD =                \
         $(GTK_LIBS)                                     \
         $(LIBNM_GLIB_LIBS)                              \
         $(LIBNM_GTK_LIBS)                               \
         $(top_builddir)/shared/libnm-openvpn-shared.la
 
-libnm_vpn_plugin_openvpn_la_LDFLAGS =                   \
-        -avoid-version
+libnm_openvpn_properties_la_LDFLAGS = \
+        -avoid-version \
+        -Wl,--version-script=$(srcdir)/libnm-openvpn-properties.ver
+
+###############################################################################
 
-libnm_openvpn_properties_la_LDFLAGS =               \
-        $(libnm_vpn_plugin_openvpn_la_LDFLAGS)
+libnm_vpn_plugin_openvpn_test_la_SOURCES = $(libnm_vpn_plugin_openvpn_la_SOURCES)
+libnm_vpn_plugin_openvpn_test_la_CFLAGS = $(libnm_vpn_plugin_openvpn_la_CFLAGS)
+libnm_vpn_plugin_openvpn_test_la_LIBADD = $(libnm_vpn_plugin_openvpn_la_LIBADD)
+libnm_vpn_plugin_openvpn_test_la_LDFLAGS = \
+    -avoid-version
+
+libnm_openvpn_properties_test_la_SOURCES = $(libnm_openvpn_properties_la_SOURCES)
+libnm_openvpn_properties_test_la_CFLAGS = $(libnm_openvpn_properties_la_CFLAGS)
+libnm_openvpn_properties_test_la_LIBADD = $(libnm_openvpn_properties_la_LIBADD)
+libnm_openvpn_properties_test_la_LDFLAGS = \
+    -avoid-version
+
+###############################################################################
+
+noinst_LTLIBRARIES = \
+    libnm-vpn-plugin-openvpn-test.la
+if WITH_LIBNM_GLIB
+noinst_LTLIBRARIES += libnm-openvpn-properties-test.la
+endif
 
 CLEANFILES = *.bak *~
 
-EXTRA_DIST =                            \
-        $(ui_DATA)
+EXTRA_DIST = \
+        libnm-vpn-plugin-openvpn.ver \
+        libnm-vpn-plugin-openvpn-editor.ver \
+        libnm-openvpn-properties.ver \
+        nm-openvpn-dialog.ui
+
diff --git properties/auth-helpers.c properties/auth-helpers.c
index d662199..d75c476 100644
--- properties/auth-helpers.c
+++ properties/auth-helpers.c
@@ -21,7 +21,9 @@
  *
  **************************************************************************/
 
-#include "config.h"
+#include "nm-default.h"
+
+#include "auth-helpers.h"
 
 #include <string.h>
 #include <sys/types.h>
@@ -31,11 +33,6 @@
 #include <unistd.h>
 #include <errno.h>
 
-#include "nm-default.h"
-
-#include "auth-helpers.h"
-#include "nm-openvpn.h"
-#include "nm-openvpn-service-defines.h"
 #include "utils.h"
 
 #define BLOCK_HANDLER_ID "block-handler-id"
@@ -433,8 +430,8 @@ validate_tls (GtkBuilder *builder, const char *prefix, GError **error)
 	g_free (tmp);
 	if (!valid) {
 		g_set_error (error,
-		             OPENVPN_EDITOR_PLUGIN_ERROR,
-		             OPENVPN_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
+		             NMV_EDITOR_PLUGIN_ERROR,
+		             NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
 		             NM_OPENVPN_KEY_CA);
 		return FALSE;
 	}
@@ -444,8 +441,8 @@ validate_tls (GtkBuilder *builder, const char *prefix, GError **error)
 	g_free (tmp);
 	if (!valid) {
 		g_set_error (error,
-		             OPENVPN_EDITOR_PLUGIN_ERROR,
-		             OPENVPN_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
+		             NMV_EDITOR_PLUGIN_ERROR,
+		             NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
 		             NM_OPENVPN_KEY_CERT);
 		return FALSE;
 	}
@@ -456,8 +453,8 @@ validate_tls (GtkBuilder *builder, const char *prefix, GError **error)
 	g_free (tmp);
 	if (!valid) {
 		g_set_error (error,
-		             OPENVPN_EDITOR_PLUGIN_ERROR,
-		             OPENVPN_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
+		             NMV_EDITOR_PLUGIN_ERROR,
+		             NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
 		             NM_OPENVPN_KEY_KEY);
 		return FALSE;
 	}
@@ -478,8 +475,8 @@ validate_tls (GtkBuilder *builder, const char *prefix, GError **error)
 	if (encrypted && secrets_required) {
 		if (!gtk_entry_get_text_length (GTK_ENTRY (widget))) {
 			g_set_error (error,
-			             OPENVPN_EDITOR_PLUGIN_ERROR,
-			             OPENVPN_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
+			             NMV_EDITOR_PLUGIN_ERROR,
+			             NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
 			             NM_OPENVPN_KEY_CERTPASS);
 			return FALSE;
 		}
@@ -505,16 +502,16 @@ auth_widget_check_validity (GtkBuilder *builder, const char *contype, GError **e
 		str = gtk_entry_get_text (GTK_ENTRY (widget));
 		if (!str || !strlen (str)) {
 			g_set_error (error,
-			             OPENVPN_EDITOR_PLUGIN_ERROR,
-			             OPENVPN_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
+			             NMV_EDITOR_PLUGIN_ERROR,
+			             NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
 			             NM_OPENVPN_KEY_USERNAME);
 			return FALSE;
 		}
 	} else if (!strcmp (contype, NM_OPENVPN_CONTYPE_PASSWORD)) {
 		if (!validate_file_chooser (builder, "pw_ca_cert_chooser")) {
 			g_set_error (error,
-			             OPENVPN_EDITOR_PLUGIN_ERROR,
-			             OPENVPN_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
+			             NMV_EDITOR_PLUGIN_ERROR,
+			             NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
 			             NM_OPENVPN_KEY_CA);
 			return FALSE;
 		}
@@ -522,16 +519,16 @@ auth_widget_check_validity (GtkBuilder *builder, const char *contype, GError **e
 		str = gtk_entry_get_text (GTK_ENTRY (widget));
 		if (!str || !strlen (str)) {
 			g_set_error (error,
-			             OPENVPN_EDITOR_PLUGIN_ERROR,
-			             OPENVPN_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
+			             NMV_EDITOR_PLUGIN_ERROR,
+			             NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
 			             NM_OPENVPN_KEY_USERNAME);
 			return FALSE;
 		}
 	} else if (!strcmp (contype, NM_OPENVPN_CONTYPE_STATIC_KEY)) {
 		if (!validate_file_chooser (builder, "sk_key_chooser")) {
 			g_set_error (error,
-			             OPENVPN_EDITOR_PLUGIN_ERROR,
-			             OPENVPN_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
+			             NMV_EDITOR_PLUGIN_ERROR,
+			             NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
 			             NM_OPENVPN_KEY_STATIC_KEY);
 			return FALSE;
 		}
@@ -540,8 +537,8 @@ auth_widget_check_validity (GtkBuilder *builder, const char *contype, GError **e
 		str = gtk_entry_get_text (GTK_ENTRY (widget));
 		if (!str || !strlen (str)) {
 			g_set_error (error,
-			             OPENVPN_EDITOR_PLUGIN_ERROR,
-			             OPENVPN_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
+			             NMV_EDITOR_PLUGIN_ERROR,
+			             NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
 			             NM_OPENVPN_KEY_LOCAL_IP);
 			return FALSE;
 		}
@@ -550,8 +547,8 @@ auth_widget_check_validity (GtkBuilder *builder, const char *contype, GError **e
 		str = gtk_entry_get_text (GTK_ENTRY (widget));
 		if (!str || !strlen (str)) {
 			g_set_error (error,
-			             OPENVPN_EDITOR_PLUGIN_ERROR,
-			             OPENVPN_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
+			             NMV_EDITOR_PLUGIN_ERROR,
+			             NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
 			             NM_OPENVPN_KEY_REMOTE_IP);
 			return FALSE;
 		}
@@ -1375,10 +1372,10 @@ device_name_changed_cb (GtkEntry *entry,
 	/* Change cell's background to red if the value is invalid */
 	if (entry_sensitive && entry_text[0] != '\0' && !nm_utils_iface_valid_name (entry_text)) {
 		gdk_rgba_parse (&rgba, "red");
-		gtk_widget_override_background_color (GTK_WIDGET (editable), GTK_STATE_NORMAL, &rgba);
+		gtk_widget_override_background_color (GTK_WIDGET (editable), GTK_STATE_FLAG_NORMAL, &rgba);
 		gtk_widget_set_sensitive (ok_button, FALSE);
 	} else {
-		gtk_widget_override_background_color (GTK_WIDGET (editable), GTK_STATE_NORMAL, NULL);
+		gtk_widget_override_background_color (GTK_WIDGET (editable), GTK_STATE_FLAG_NORMAL, NULL);
 		gtk_widget_set_sensitive (ok_button, TRUE);
 	}
 
@@ -1642,7 +1639,12 @@ advanced_dialog_new (GHashTable *hash, const char *contype)
 	}
 
 	value = g_hash_table_lookup (hash, NM_OPENVPN_KEY_COMP_LZO);
-	if (value && !strcmp (value, "yes")) {
+	if (NM_IN_STRSET (value, "yes", "adaptive")) {
+		/* the UI currently only supports "--comp-lzo yes" or omitting the "--comp-lzo"
+		 * flag.
+		 *
+		 * Internally, we also support "--comp-lzo [adaptive]" and "--comp-lzo no"
+		 * which have different meaning for openvpn. */
 		widget = GTK_WIDGET (gtk_builder_get_object (builder, "lzo_checkbutton"));
 		gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), TRUE);
 	}
@@ -2010,8 +2012,12 @@ advanced_dialog_new_hash_from_dialog (GtkWidget *dialog, GError **error)
 	}
 
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "lzo_checkbutton"));
-	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget)))
+	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget))) {
+		/* we only have a checkbox, which we either map to "--comp-lzo yes" or
+		 * no "--comp-lzo" flag. In the UI, we cannot express "--comp-lzo [adaptive]"
+		 * or "--comp-lzo no". */
 		g_hash_table_insert (hash, g_strdup (NM_OPENVPN_KEY_COMP_LZO), g_strdup ("yes"));
+	}
 
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "mssfix_checkbutton"));
 	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget)))
diff --git properties/auth-helpers.h properties/auth-helpers.h
index 88b1529..0e53ded 100644
--- properties/auth-helpers.h
+++ properties/auth-helpers.h
@@ -22,16 +22,8 @@
 #ifndef _AUTH_HELPERS_H_
 #define _AUTH_HELPERS_H_
 
-#include <glib.h>
 #include <gtk/gtk.h>
 
-#ifdef NM_OPENVPN_OLD
-#include <nm-connection.h>
-#include <nm-setting-vpn.h>
-#else /* !NM_OPENVPN_OLD */
-#include <NetworkManager.h>
-#endif
-
 typedef void (*ChangedCallback) (GtkWidget *widget, gpointer user_data);
 
 void tls_pw_init_auth_widget (GtkBuilder *builder,
diff --git properties/import-export.c properties/import-export.c
index 16a5925..f2b7440 100644
--- properties/import-export.c
+++ properties/import-export.c
@@ -19,7 +19,9 @@
  *
  **************************************************************************/
 
-#include "config.h"
+#include "nm-default.h"
+
+#include "import-export.h"
 
 #include <string.h>
 #include <sys/types.h>
@@ -32,14 +34,8 @@
 #include <ctype.h>
 #include <stdio.h>
 
-#include "nm-default.h"
-
-#include "import-export.h"
-#include "nm-openvpn.h"
-#include "nm-openvpn-service-defines.h"
 #include "utils.h"
-#include "nm-macros-internal.h"
-#include "nm-shared-utils.h"
+#include "nm-utils/nm-shared-utils.h"
 
 
 #define INLINE_BLOB_CA                  "ca"
@@ -700,8 +696,8 @@ inline_blob_write_out (const InlineBlobData *data, GError **error)
 		/* in test mode we don't create the certificate directory. */
 		if (!inline_blob_mkdir_parents (data, data->path, &err_msg)) {
 			g_set_error (error,
-			             OPENVPN_EDITOR_PLUGIN_ERROR,
-			             OPENVPN_EDITOR_PLUGIN_ERROR_FAILED,
+			             NMV_EDITOR_PLUGIN_ERROR,
+			             NMV_EDITOR_PLUGIN_ERROR_FAILED,
 			             _("cannot write <%s> blob from line %ld to file (%s)"),
 			             data->token,
 			             (long) data->token_start_line,
@@ -717,8 +713,8 @@ inline_blob_write_out (const InlineBlobData *data, GError **error)
 	 * access the file later on is left as exercise for the user. */
 	if (!g_file_set_contents (data->path, data->blob_data->str, data->blob_data->len, NULL)) {
 		g_set_error (error,
-		             OPENVPN_EDITOR_PLUGIN_ERROR,
-		             OPENVPN_EDITOR_PLUGIN_ERROR_FAILED,
+		             NMV_EDITOR_PLUGIN_ERROR,
+		             NMV_EDITOR_PLUGIN_ERROR_FAILED,
 		             _("cannot write <%s> blob from line %ld to file '%s'"),
 		             data->token,
 		             (long) data->token_start_line,
@@ -910,15 +906,11 @@ do_import (const char *path, const char *contents, gsize contents_len, GError **
 		if (NM_IN_STRSET (params[0], NMV_OVPN_TAG_COMP_LZO)) {
 			if (!args_params_check_nargs_minmax (params, 0, 1, &line_error))
 				goto handle_line_error;
-			if (params[1]) {
-				if (nm_streq (params[1], "no"))
-					continue;
-				if (!nm_streq (params[1], "yes")) {
-					line_error = g_strdup_printf (_("unsupported comp-lzo argument"));
-					goto handle_line_error;
-				}
+			if (!NM_IN_STRSET (params[1], NULL, "no", "yes", "adaptive")) {
+				line_error = g_strdup_printf (_("unsupported comp-lzo argument"));
+				goto handle_line_error;
 			}
-			setting_vpn_add_data_item (s_vpn, NM_OPENVPN_KEY_COMP_LZO, "yes");
+			setting_vpn_add_data_item (s_vpn, NM_OPENVPN_KEY_COMP_LZO, params[1] ?: "adaptive");
 			continue;
 		}
 
@@ -1152,6 +1144,15 @@ do_import (const char *path, const char *contents, gsize contents_len, GError **
 			continue;
 		}
 
+		if (NM_IN_STRSET (params[0], NMV_OVPN_TAG_TLS_CIPHER)) {
+			if (!args_params_check_nargs_n (params, 1, &line_error))
+				goto handle_line_error;
+			if (!args_params_check_arg_utf8 (params, 1, NULL, &line_error))
+				goto handle_line_error;
+			setting_vpn_add_data_item (s_vpn, NM_OPENVPN_KEY_TLS_CIPHER, params[1]);
+			continue;
+		}
+
 		if (NM_IN_STRSET (params[0], NMV_OVPN_TAG_KEEPALIVE)) {
 			gint64 v2;
 
@@ -1254,7 +1255,7 @@ do_import (const char *path, const char *contents, gsize contents_len, GError **
 			}
 
 			{
-#ifdef NM_OPENVPN_OLD
+#ifdef NM_VPN_OLD
 				NMIP4Route *route;
 
 				route = nm_ip4_route_new ();
@@ -1378,8 +1379,8 @@ do_import (const char *path, const char *contents, gsize contents_len, GError **
 
 handle_line_error:
 		g_set_error (error,
-		             OPENVPN_EDITOR_PLUGIN_ERROR,
-		             OPENVPN_EDITOR_PLUGIN_ERROR_FILE_INVALID,
+		             NMV_EDITOR_PLUGIN_ERROR,
+		             NMV_EDITOR_PLUGIN_ERROR_FILE_INVALID,
 		             _("configuration error: %s (line %ld)"),
 		             line_error ? : _("unknown or unsupported option"),
 		             (long) contents_cur_line);
@@ -1389,16 +1390,16 @@ handle_line_error:
 
 	if (!have_client && !have_sk) {
 		g_set_error_literal (error,
-		                     OPENVPN_EDITOR_PLUGIN_ERROR,
-		                     OPENVPN_EDITOR_PLUGIN_ERROR_FILE_NOT_OPENVPN,
+		                     NMV_EDITOR_PLUGIN_ERROR,
+		                     NMV_EDITOR_PLUGIN_ERROR_FILE_NOT_VPN,
 		                     _("The file to import wasn't a valid OpenVPN client configuration"));
 		goto out_error;
 	}
 
 	if (!have_remote) {
 		g_set_error_literal (error,
-		                     OPENVPN_EDITOR_PLUGIN_ERROR,
-		                     OPENVPN_EDITOR_PLUGIN_ERROR_FILE_NOT_OPENVPN,
+		                     NMV_EDITOR_PLUGIN_ERROR,
+		                     NMV_EDITOR_PLUGIN_ERROR_FILE_NOT_VPN,
 		                     _("The file to import wasn't a valid OpenVPN configure (no remote)"));
 		goto out_error;
 	}
@@ -1626,12 +1627,11 @@ do_export_create (NMConnection *connection, const char *path, GError **error)
 	const char *proxy_type = NULL;
 	guint i, num;
 	nm_auto(_auto_free_gstring_p) GString *f = NULL;
-	gs_free_error GError *local = NULL;
 
 	if (!path || !path[0]) {
 		g_set_error_literal (error,
-		                     OPENVPN_EDITOR_PLUGIN_ERROR,
-		                     OPENVPN_EDITOR_PLUGIN_ERROR_FILE_NOT_OPENVPN,
+		                     NMV_EDITOR_PLUGIN_ERROR,
+		                     NMV_EDITOR_PLUGIN_ERROR_FILE_NOT_VPN,
 		                     _("missing path argument"));
 		return NULL;
 	}
@@ -1640,8 +1640,8 @@ do_export_create (NMConnection *connection, const char *path, GError **error)
 	s_vpn = nm_connection_get_setting_vpn (connection);
 	if (!s_con || !s_vpn) {
 		g_set_error_literal (error,
-		                     OPENVPN_EDITOR_PLUGIN_ERROR,
-		                     OPENVPN_EDITOR_PLUGIN_ERROR_FILE_NOT_OPENVPN,
+		                     NMV_EDITOR_PLUGIN_ERROR,
+		                     NMV_EDITOR_PLUGIN_ERROR_FILE_NOT_VPN,
 		                     _("connection is not a valid OpenVPN connection"));
 		return NULL;
 	}
@@ -1649,8 +1649,8 @@ do_export_create (NMConnection *connection, const char *path, GError **error)
 	gateways = _arg_is_set (nm_setting_vpn_get_data_item (s_vpn, NM_OPENVPN_KEY_REMOTE));
 	if (!gateways) {
 		g_set_error_literal (error,
-		                     OPENVPN_EDITOR_PLUGIN_ERROR,
-		                     OPENVPN_EDITOR_PLUGIN_ERROR_FILE_NOT_OPENVPN,
+		                     NMV_EDITOR_PLUGIN_ERROR,
+		                     NMV_EDITOR_PLUGIN_ERROR_FILE_NOT_VPN,
 		                     _("connection was incomplete (missing gateway)"));
 		return NULL;
 	}
@@ -1754,10 +1754,13 @@ do_export_create (NMConnection *connection, const char *path, GError **error)
 
 	args_write_line_setting_value (f, NMV_OVPN_TAG_CIPHER, s_vpn, NM_OPENVPN_KEY_CIPHER);
 
+	args_write_line_setting_value (f, NMV_OVPN_TAG_TLS_CIPHER, s_vpn, NM_OPENVPN_KEY_TLS_CIPHER);
+
 	args_write_line_setting_value_int (f, NMV_OVPN_TAG_KEYSIZE, s_vpn, NM_OPENVPN_KEY_KEYSIZE);
 
-	if (nm_streq0 (nm_setting_vpn_get_data_item (s_vpn, NM_OPENVPN_KEY_COMP_LZO), "yes"))
-		args_write_line (f, NMV_OVPN_TAG_COMP_LZO, "yes");
+	value = nm_setting_vpn_get_data_item (s_vpn, NM_OPENVPN_KEY_COMP_LZO);
+	if (value)
+		args_write_line (f, NMV_OVPN_TAG_COMP_LZO, value);
 
 	if (nm_streq0 (nm_setting_vpn_get_data_item (s_vpn, NM_OPENVPN_KEY_FLOAT), "yes"))
 		args_write_line (f, NMV_OVPN_TAG_FLOAT);
@@ -1877,7 +1880,7 @@ do_export_create (NMConnection *connection, const char *path, GError **error)
 
 	s_ip4 = nm_connection_get_setting_ip4_config (connection);
 	if (s_ip4) {
-#ifdef NM_OPENVPN_OLD
+#ifdef NM_VPN_OLD
 		num = nm_setting_ip4_config_get_num_routes (s_ip4);
 #else
 		num = nm_setting_ip_config_get_num_routes (s_ip4);
@@ -1890,7 +1893,7 @@ do_export_create (NMConnection *connection, const char *path, GError **error)
 			guint64 metric;
 			char metric_buf[50];
 
-#ifdef NM_OPENVPN_OLD
+#ifdef NM_VPN_OLD
 			char next_hop_str_buf[INET_ADDRSTRLEN] = { 0 };
 			char dest_str_buf[INET_ADDRSTRLEN] = { 0 };
 			in_addr_t dest, next_hop;
@@ -1932,10 +1935,10 @@ do_export_create (NMConnection *connection, const char *path, GError **error)
 	args_write_line (f, NMV_OVPN_TAG_SCRIPT_SECURITY, "2");
 	args_write_line (f, NMV_OVPN_TAG_PERSIST_KEY);
 	args_write_line (f, NMV_OVPN_TAG_PERSIST_TUN);
-	args_write_line (f, NMV_OVPN_TAG_USER, "openvpn");
-	args_write_line (f, NMV_OVPN_TAG_GROUP, "openvpn");
+	args_write_line (f, NMV_OVPN_TAG_USER, NM_OPENVPN_USER);
+	args_write_line (f, NMV_OVPN_TAG_GROUP, NM_OPENVPN_GROUP);
 
-	return nm_unauto (&f);
+	return g_steal_pointer (&f);
 }
 
 gboolean
@@ -1950,8 +1953,8 @@ do_export (const char *path, NMConnection *connection, GError **error)
 
 	if (!g_file_set_contents (path, f->str, f->len, &local)) {
 		g_set_error (error,
-		             OPENVPN_EDITOR_PLUGIN_ERROR,
-		             OPENVPN_EDITOR_PLUGIN_ERROR_FILE_NOT_OPENVPN,
+		             NMV_EDITOR_PLUGIN_ERROR,
+		             NMV_EDITOR_PLUGIN_ERROR_FILE_NOT_VPN,
 		             _("failed to write file: %s"),
 		             local->message);
 		return FALSE;
diff --git properties/import-export.h properties/import-export.h
index 91e079f..06b92a8 100644
--- properties/import-export.h
+++ properties/import-export.h
@@ -22,14 +22,6 @@
 #ifndef _IMPORT_EXPORT_H_
 #define _IMPORT_EXPORT_H_
 
-#include <glib.h>
-
-#ifdef NM_OPENVPN_OLD
-#include <nm-connection.h>
-#else /* !NM_OPENVPN_OLD */
-#include <NetworkManager.h>
-#endif
-
 extern const char *_nmovpn_test_temp_path;
 
 gboolean _nmovpn_test_args_parse_line (const char *line,
diff --git properties/libnm-openvpn-properties.ver properties/libnm-openvpn-properties.ver
new file mode 100644
index 0000000..271c506
--- /dev/null
+++ properties/libnm-openvpn-properties.ver
@@ -0,0 +1,6 @@
+{
+global:
+	nm_vpn_plugin_ui_factory;
+local:
+	*;
+};
diff --git properties/libnm-vpn-plugin-openvpn-editor.ver properties/libnm-vpn-plugin-openvpn-editor.ver
new file mode 100644
index 0000000..542d577
--- /dev/null
+++ properties/libnm-vpn-plugin-openvpn-editor.ver
@@ -0,0 +1,6 @@
+{
+global:
+	nm_vpn_editor_factory_openvpn;
+local:
+	*;
+};
diff --git properties/libnm-vpn-plugin-openvpn.ver properties/libnm-vpn-plugin-openvpn.ver
new file mode 100644
index 0000000..92a7b14
--- /dev/null
+++ properties/libnm-vpn-plugin-openvpn.ver
@@ -0,0 +1,6 @@
+{
+global:
+	nm_vpn_editor_plugin_factory;
+local:
+	*;
+};
diff --git properties/nm-openvpn-editor-plugin.c properties/nm-openvpn-editor-plugin.c
new file mode 100644
index 0000000..7c1e59c
--- /dev/null
+++ properties/nm-openvpn-editor-plugin.c
@@ -0,0 +1,234 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/***************************************************************************
+ * nm-openvpn-editor-plugin.c : GNOME UI dialogs for configuring openvpn VPN connections
+ *
+ * Copyright (C) 2005 Tim Niemueller <tim@niemueller.de>
+ * Copyright (C) 2008 - 2010 Dan Williams, <dcbw@redhat.com>
+ * Copyright (C) 2008 - 2011 Red Hat, Inc.
+ * Based on work by David Zeuthen, <davidz@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ **************************************************************************/
+
+#include "nm-default.h"
+
+#include "nm-openvpn-editor-plugin.h"
+
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef NM_VPN_OLD
+#include "nm-openvpn-editor.h"
+#else
+#include "nm-vpn/nm-vpn-plugin-utils.h"
+#endif
+
+#include "import-export.h"
+
+#define OPENVPN_PLUGIN_NAME    _("OpenVPN")
+#define OPENVPN_PLUGIN_DESC    _("Compatible with the OpenVPN server.")
+
+/*****************************************************************************/
+
+enum {
+	PROP_0,
+	PROP_NAME,
+	PROP_DESC,
+	PROP_SERVICE
+};
+
+static void openvpn_editor_plugin_interface_init (NMVpnEditorPluginInterface *iface_class);
+
+G_DEFINE_TYPE_EXTENDED (OpenvpnEditorPlugin, openvpn_editor_plugin, G_TYPE_OBJECT, 0,
+                        G_IMPLEMENT_INTERFACE (NM_TYPE_VPN_EDITOR_PLUGIN,
+                                               openvpn_editor_plugin_interface_init))
+
+/*****************************************************************************/
+
+static NMConnection *
+import (NMVpnEditorPlugin *iface, const char *path, GError **error)
+{
+	NMConnection *connection = NULL;
+	char *contents = NULL;
+	char *ext;
+	gsize contents_len;
+
+	ext = strrchr (path, '.');
+
+	if (!ext || (   !g_str_has_suffix (ext, ".ovpn")
+	             && !g_str_has_suffix (ext, ".conf")
+	             && !g_str_has_suffix (ext, ".cnf")
+	             && !g_str_has_suffix (ext, ".ovpntest"))) {   /* Special extension for testcases */
+		g_set_error_literal (error,
+		                     NMV_EDITOR_PLUGIN_ERROR,
+		                     NMV_EDITOR_PLUGIN_ERROR_FILE_NOT_VPN,
+		                     _("unknown OpenVPN file extension"));
+		goto out;
+	}
+
+	if (!g_file_get_contents (path, &contents, &contents_len, error))
+		return NULL;
+
+	connection = do_import (path, contents, contents_len, error);
+
+out:
+	g_free (contents);
+	return connection;
+}
+
+static gboolean
+export (NMVpnEditorPlugin *iface,
+        const char *path,
+        NMConnection *connection,
+        GError **error)
+{
+	return do_export (path, connection, error);
+}
+
+static char *
+get_suggested_filename (NMVpnEditorPlugin *iface, NMConnection *connection)
+{
+	NMSettingConnection *s_con;
+	const char *id;
+
+	g_return_val_if_fail (connection != NULL, NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_return_val_if_fail (s_con != NULL, NULL);
+
+	id = nm_setting_connection_get_id (s_con);
+	g_return_val_if_fail (id != NULL, NULL);
+
+	return g_strdup_printf ("%s (openvpn).conf", id);
+}
+
+static guint32
+get_capabilities (NMVpnEditorPlugin *iface)
+{
+	return (NM_VPN_EDITOR_PLUGIN_CAPABILITY_IMPORT |
+	        NM_VPN_EDITOR_PLUGIN_CAPABILITY_EXPORT |
+	        NM_VPN_EDITOR_PLUGIN_CAPABILITY_IPV6);
+}
+
+#ifndef NM_VPN_OLD
+static NMVpnEditor *
+_call_editor_factory (gpointer factory,
+                      NMVpnEditorPlugin *editor_plugin,
+                      NMConnection *connection,
+                      gpointer user_data,
+                      GError **error)
+{
+	return ((NMVpnEditorFactory) factory) (editor_plugin,
+	                                       connection,
+	                                       error);
+}
+#endif
+
+static NMVpnEditor *
+get_editor (NMVpnEditorPlugin *iface, NMConnection *connection, GError **error)
+{
+	g_return_val_if_fail (OPENVPN_IS_EDITOR_PLUGIN (iface), NULL);
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+	g_return_val_if_fail (!error || !*error, NULL);
+
+	{
+#ifdef NM_VPN_OLD
+		return openvpn_editor_new (connection, error);
+#else
+		return nm_vpn_plugin_utils_load_editor (NM_PLUGIN_DIR"/libnm-vpn-plugin-openvpn-editor.so",
+		                                        "nm_vpn_editor_factory_openvpn",
+		                                        _call_editor_factory,
+		                                        iface,
+		                                        connection,
+		                                        NULL,
+		                                        error);
+#endif
+	}
+}
+
+/*****************************************************************************/
+
+static void
+get_property (GObject *object, guint prop_id,
+              GValue *value, GParamSpec *pspec)
+{
+	switch (prop_id) {
+	case PROP_NAME:
+		g_value_set_string (value, OPENVPN_PLUGIN_NAME);
+		break;
+	case PROP_DESC:
+		g_value_set_string (value, OPENVPN_PLUGIN_DESC);
+		break;
+	case PROP_SERVICE:
+		g_value_set_string (value, NM_VPN_SERVICE_TYPE_OPENVPN);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+openvpn_editor_plugin_init (OpenvpnEditorPlugin *plugin)
+{
+}
+
+static void
+openvpn_editor_plugin_interface_init (NMVpnEditorPluginInterface *iface_class)
+{
+	iface_class->get_editor = get_editor;
+	iface_class->get_capabilities = get_capabilities;
+	iface_class->import_from_file = import;
+	iface_class->export_to_file = export;
+	iface_class->get_suggested_filename = get_suggested_filename;
+}
+
+static void
+openvpn_editor_plugin_class_init (OpenvpnEditorPluginClass *req_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (req_class);
+
+	object_class->get_property = get_property;
+
+	g_object_class_override_property (object_class,
+	                                  PROP_NAME,
+	                                  NM_VPN_EDITOR_PLUGIN_NAME);
+
+	g_object_class_override_property (object_class,
+	                                  PROP_DESC,
+	                                  NM_VPN_EDITOR_PLUGIN_DESCRIPTION);
+
+	g_object_class_override_property (object_class,
+	                                  PROP_SERVICE,
+	                                  NM_VPN_EDITOR_PLUGIN_SERVICE);
+}
+
+/*****************************************************************************/
+
+G_MODULE_EXPORT NMVpnEditorPlugin *
+nm_vpn_editor_plugin_factory (GError **error)
+{
+	g_return_val_if_fail (!error || !*error, NULL);
+
+	bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
+	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
+
+	return g_object_new (OPENVPN_TYPE_EDITOR_PLUGIN, NULL);
+}
+
diff --git properties/nm-openvpn-editor-plugin.h properties/nm-openvpn-editor-plugin.h
new file mode 100644
index 0000000..df7808f
--- /dev/null
+++ properties/nm-openvpn-editor-plugin.h
@@ -0,0 +1,56 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/***************************************************************************
+ * nm-openvpn-editor.h : GNOME UI dialogs for configuring openvpn VPN connections
+ *
+ * Copyright (C) 2008 Dan Williams, <dcbw@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ **************************************************************************/
+
+#ifndef __NM_OPENVPN_EDITOR_PLUGIN_H__
+#define __NM_OPENVPN_EDITOR_PLUGIN_H__
+
+#define OPENVPN_TYPE_EDITOR_PLUGIN                (openvpn_editor_plugin_get_type ())
+#define OPENVPN_EDITOR_PLUGIN(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), OPENVPN_TYPE_EDITOR_PLUGIN, OpenvpnEditorPlugin))
+#define OPENVPN_EDITOR_PLUGIN_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), OPENVPN_TYPE_EDITOR_PLUGIN, OpenvpnEditorPluginClass))
+#define OPENVPN_IS_EDITOR_PLUGIN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OPENVPN_TYPE_EDITOR_PLUGIN))
+#define OPENVPN_IS_EDITOR_PLUGIN_CLASS(klass)     (G_TYPE_CHECK_CLASS_TYPE ((klass), OPENVPN_TYPE_EDITOR_PLUGIN))
+#define OPENVPN_EDITOR_PLUGIN_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), OPENVPN_TYPE_EDITOR_PLUGIN, OpenvpnEditorPluginClass))
+
+typedef struct _OpenvpnEditorPlugin OpenvpnEditorPlugin;
+typedef struct _OpenvpnEditorPluginClass OpenvpnEditorPluginClass;
+
+struct _OpenvpnEditorPlugin {
+	GObject parent;
+};
+
+struct _OpenvpnEditorPluginClass {
+	GObjectClass parent;
+};
+
+GType openvpn_editor_plugin_get_type (void);
+
+typedef NMVpnEditor *(*NMVpnEditorFactory) (NMVpnEditorPlugin *editor_plugin,
+                                            NMConnection *connection,
+                                            GError **error);
+
+NMVpnEditor *
+nm_vpn_editor_factory_openvpn (NMVpnEditorPlugin *editor_plugin,
+                               NMConnection *connection,
+                               GError **error);
+
+#endif /* __NM_OPENVPN_EDITOR_PLUGIN_H__ */
+
diff --git properties/nm-openvpn-editor.c properties/nm-openvpn-editor.c
new file mode 100644
index 0000000..f8acb9f
--- /dev/null
+++ properties/nm-openvpn-editor.c
@@ -0,0 +1,606 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/***************************************************************************
+ * CVSID: $Id: nm-openvpn.c 4232 2008-10-29 09:13:40Z tambeti $
+ *
+ * nm-openvpn.c : GNOME UI dialogs for configuring openvpn VPN connections
+ *
+ * Copyright (C) 2005 Tim Niemueller <tim@niemueller.de>
+ * Copyright (C) 2008 - 2010 Dan Williams, <dcbw@redhat.com>
+ * Copyright (C) 2008 - 2011 Red Hat, Inc.
+ * Based on work by David Zeuthen, <davidz@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ **************************************************************************/
+
+#include "nm-default.h"
+
+#include "nm-openvpn-editor.h"
+
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <gtk/gtk.h>
+
+#include "auth-helpers.h"
+
+/*****************************************************************************/
+
+static void openvpn_editor_plugin_widget_interface_init (NMVpnEditorInterface *iface_class);
+
+G_DEFINE_TYPE_EXTENDED (OpenvpnEditor, openvpn_editor_plugin_widget, G_TYPE_OBJECT, 0,
+                        G_IMPLEMENT_INTERFACE (NM_TYPE_VPN_EDITOR,
+                                               openvpn_editor_plugin_widget_interface_init))
+
+#define OPENVPN_EDITOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), OPENVPN_TYPE_EDITOR, OpenvpnEditorPrivate))
+
+typedef struct {
+	GtkBuilder *builder;
+	GtkWidget *widget;
+	GtkSizeGroup *group;
+	GtkWindowGroup *window_group;
+	gboolean window_added;
+	GHashTable *advanced;
+	gboolean new_connection;
+} OpenvpnEditorPrivate;
+
+/*****************************************************************************/
+
+#define COL_AUTH_NAME 0
+#define COL_AUTH_PAGE 1
+#define COL_AUTH_TYPE 2
+
+/* Example: abc.com:1234:udp, ovpnserver.company.com:443, vpn.example.com::tcp */
+static gboolean
+check_gateway_entry (const char *str)
+{
+	char **list, **iter;
+	char *host, *port, *proto;
+	long int port_int;
+	gboolean success = FALSE;
+
+	if (!str || !*str)
+		return FALSE;
+
+	list = g_strsplit_set (str, " \t,", -1);
+	for (iter = list; iter && *iter; iter++) {
+		if (!**iter)
+			continue;
+		host = g_strstrip (*iter);
+		port = strchr (host, ':');
+		proto = port ? strchr (port + 1, ':') : NULL;
+		if (port)
+			*port++ = '\0';
+		if (proto)
+			*proto++ = '\0';
+
+		/* check hostname */
+		if (!*host)
+			goto out;
+		/* check port */
+		if (port && *port) {
+			char *end;
+			errno = 0;
+			port_int = strtol (port, &end, 10);
+			if (errno != 0 || *end != '\0' || port_int < 1 || port_int > 65535)
+				goto out;
+		}
+		/* check proto */
+		if (proto && strcmp (proto, "udp") && strcmp (proto, "tcp"))
+			goto out;
+	}
+	success = TRUE;
+out:
+	g_strfreev (list);
+	return success;
+}
+
+static gboolean
+check_validity (OpenvpnEditor *self, GError **error)
+{
+	OpenvpnEditorPrivate *priv = OPENVPN_EDITOR_GET_PRIVATE (self);
+	GtkWidget *widget;
+	const char *str;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+	const char *contype = NULL;
+	GdkRGBA rgba;
+	gboolean gateway_valid;
+	gboolean success;
+
+	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "gateway_entry"));
+	str = gtk_entry_get_text (GTK_ENTRY (widget));
+	gateway_valid = check_gateway_entry (str);
+	/* Change entry background colour while editing */
+	if (!gateway_valid)
+		gdk_rgba_parse (&rgba, "red3");
+	gtk_widget_override_background_color (widget, GTK_STATE_FLAG_NORMAL, !gateway_valid ? &rgba : NULL);
+	if (!gateway_valid) {
+		g_set_error (error,
+		             NMV_EDITOR_PLUGIN_ERROR,
+		             NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
+		             NM_OPENVPN_KEY_REMOTE);
+		return FALSE;
+	}
+
+	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "auth_combo"));
+	model = gtk_combo_box_get_model (GTK_COMBO_BOX (widget));
+	g_return_val_if_fail (model, FALSE);
+	success = gtk_combo_box_get_active_iter (GTK_COMBO_BOX (widget), &iter);
+	g_return_val_if_fail (success == TRUE, FALSE);
+	gtk_tree_model_get (model, &iter, COL_AUTH_TYPE, &contype, -1);
+	if (!auth_widget_check_validity (priv->builder, contype, error))
+		return FALSE;
+
+	return TRUE;
+}
+
+static void
+stuff_changed_cb (GtkWidget *widget, gpointer user_data)
+{
+	g_signal_emit_by_name (OPENVPN_EDITOR (user_data), "changed");
+}
+
+static void
+auth_combo_changed_cb (GtkWidget *combo, gpointer user_data)
+{
+	OpenvpnEditor *self = OPENVPN_EDITOR (user_data);
+	OpenvpnEditorPrivate *priv = OPENVPN_EDITOR_GET_PRIVATE (self);
+	GtkWidget *auth_notebook;
+	GtkWidget *show_passwords;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+	gint new_page = 0;
+
+	auth_notebook = GTK_WIDGET (gtk_builder_get_object (priv->builder, "auth_notebook"));
+	g_assert (auth_notebook);
+	show_passwords = GTK_WIDGET (gtk_builder_get_object (priv->builder, "show_passwords"));
+	g_assert (auth_notebook);
+
+	model = gtk_combo_box_get_model (GTK_COMBO_BOX (combo));
+	g_assert (model);
+	g_assert (gtk_combo_box_get_active_iter (GTK_COMBO_BOX (combo), &iter));
+
+	gtk_tree_model_get (model, &iter, COL_AUTH_PAGE, &new_page, -1);
+
+	/* Static key page doesn't have any passwords */
+	gtk_widget_set_sensitive (show_passwords, new_page != 3);
+
+	gtk_notebook_set_current_page (GTK_NOTEBOOK (auth_notebook), new_page);
+
+	stuff_changed_cb (combo, self);
+}
+
+static void
+advanced_dialog_close_cb (GtkWidget *dialog, gpointer user_data)
+{
+	gtk_widget_hide (dialog);
+	/* gtk_widget_destroy() will remove the window from the window group */
+	gtk_widget_destroy (dialog);
+}
+
+static void
+advanced_dialog_response_cb (GtkWidget *dialog, gint response, gpointer user_data)
+{
+	OpenvpnEditor *self = OPENVPN_EDITOR (user_data);
+	OpenvpnEditorPrivate *priv = OPENVPN_EDITOR_GET_PRIVATE (self);
+	GError *error = NULL;
+
+	if (response != GTK_RESPONSE_OK) {
+		advanced_dialog_close_cb (dialog, self);
+		return;
+	}
+
+	if (priv->advanced)
+		g_hash_table_destroy (priv->advanced);
+	priv->advanced = advanced_dialog_new_hash_from_dialog (dialog, &error);
+	if (!priv->advanced) {
+		g_message ("%s: error reading advanced settings: %s", __func__, error->message);
+		g_error_free (error);
+	}
+	advanced_dialog_close_cb (dialog, self);
+
+	stuff_changed_cb (NULL, self);
+}
+
+static void
+advanced_button_clicked_cb (GtkWidget *button, gpointer user_data)
+{
+	OpenvpnEditor *self = OPENVPN_EDITOR (user_data);
+	OpenvpnEditorPrivate *priv = OPENVPN_EDITOR_GET_PRIVATE (self);
+	GtkWidget *dialog, *toplevel, *widget;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+	const char *contype = NULL;
+	gboolean success;
+
+	toplevel = gtk_widget_get_toplevel (priv->widget);
+	g_return_if_fail (gtk_widget_is_toplevel (toplevel));
+
+	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "auth_combo"));
+	model = gtk_combo_box_get_model (GTK_COMBO_BOX (widget));
+	success = gtk_combo_box_get_active_iter (GTK_COMBO_BOX (widget), &iter);
+	g_return_if_fail (success == TRUE);
+	gtk_tree_model_get (model, &iter, COL_AUTH_TYPE, &contype, -1);
+
+	dialog = advanced_dialog_new (priv->advanced, contype);
+	if (!dialog) {
+		g_warning ("%s: failed to create the Advanced dialog!", __func__);
+		return;
+	}
+
+	gtk_window_group_add_window (priv->window_group, GTK_WINDOW (dialog));
+	if (!priv->window_added) {
+		gtk_window_group_add_window (priv->window_group, GTK_WINDOW (toplevel));
+		priv->window_added = TRUE;
+	}
+
+	gtk_window_set_transient_for (GTK_WINDOW (dialog), GTK_WINDOW (toplevel));
+	g_signal_connect (G_OBJECT (dialog), "response", G_CALLBACK (advanced_dialog_response_cb), self);
+	g_signal_connect (G_OBJECT (dialog), "close", G_CALLBACK (advanced_dialog_close_cb), self);
+
+	gtk_widget_show_all (dialog);
+}
+
+static gboolean
+init_editor_plugin (OpenvpnEditor *self, NMConnection *connection, GError **error)
+{
+	OpenvpnEditorPrivate *priv = OPENVPN_EDITOR_GET_PRIVATE (self);
+	NMSettingVpn *s_vpn;
+	GtkWidget *widget;
+	GtkListStore *store;
+	GtkTreeIter iter;
+	int active = -1;
+	const char *value;
+	const char *contype = NM_OPENVPN_CONTYPE_TLS;
+
+	s_vpn = nm_connection_get_setting_vpn (connection);
+
+	priv->group = gtk_size_group_new (GTK_SIZE_GROUP_HORIZONTAL);
+
+	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "gateway_entry"));
+	g_return_val_if_fail (widget != NULL, FALSE);
+	gtk_size_group_add_widget (priv->group, widget);
+	if (s_vpn) {
+		value = nm_setting_vpn_get_data_item (s_vpn, NM_OPENVPN_KEY_REMOTE);
+		if (value)
+			gtk_entry_set_text (GTK_ENTRY (widget), value);
+	}
+	g_signal_connect (G_OBJECT (widget), "changed", G_CALLBACK (stuff_changed_cb), self);
+
+	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "auth_combo"));
+	g_return_val_if_fail (widget != NULL, FALSE);
+	gtk_size_group_add_widget (priv->group, widget);
+
+	store = gtk_list_store_new (3, G_TYPE_STRING, G_TYPE_INT, G_TYPE_STRING);
+
+	if (s_vpn) {
+		contype = nm_setting_vpn_get_data_item (s_vpn, NM_OPENVPN_KEY_CONNECTION_TYPE);
+		if (contype) {
+			if (   strcmp (contype, NM_OPENVPN_CONTYPE_TLS)
+			    && strcmp (contype, NM_OPENVPN_CONTYPE_STATIC_KEY)
+			    && strcmp (contype, NM_OPENVPN_CONTYPE_PASSWORD)
+			    && strcmp (contype, NM_OPENVPN_CONTYPE_PASSWORD_TLS))
+				contype = NM_OPENVPN_CONTYPE_TLS;
+		} else
+			contype = NM_OPENVPN_CONTYPE_TLS;
+	}
+
+	/* TLS auth widget */
+	tls_pw_init_auth_widget (priv->builder, priv->group, s_vpn,
+	                         NM_OPENVPN_CONTYPE_TLS, "tls",
+	                         stuff_changed_cb, self);
+	gtk_list_store_append (store, &iter);
+	gtk_list_store_set (store, &iter,
+	                    COL_AUTH_NAME, _("Certificates (TLS)"),
+	                    COL_AUTH_PAGE, 0,
+	                    COL_AUTH_TYPE, NM_OPENVPN_CONTYPE_TLS,
+	                    -1);
+
+	/* Password auth widget */
+	tls_pw_init_auth_widget (priv->builder, priv->group, s_vpn,
+	                         NM_OPENVPN_CONTYPE_PASSWORD, "pw",
+	                         stuff_changed_cb, self);
+	gtk_list_store_append (store, &iter);
+	gtk_list_store_set (store, &iter,
+	                    COL_AUTH_NAME, _("Password"),
+	                    COL_AUTH_PAGE, 1,
+	                    COL_AUTH_TYPE, NM_OPENVPN_CONTYPE_PASSWORD,
+	                    -1);
+	if ((active < 0) && !strcmp (contype, NM_OPENVPN_CONTYPE_PASSWORD))
+		active = 1;
+
+	/* Password+TLS auth widget */
+	tls_pw_init_auth_widget (priv->builder, priv->group, s_vpn,
+	                         NM_OPENVPN_CONTYPE_PASSWORD_TLS, "pw_tls",
+	                         stuff_changed_cb, self);
+	gtk_list_store_append (store, &iter);
+	gtk_list_store_set (store, &iter,
+	                    COL_AUTH_NAME, _("Password with Certificates (TLS)"),
+	                    COL_AUTH_PAGE, 2,
+	                    COL_AUTH_TYPE, NM_OPENVPN_CONTYPE_PASSWORD_TLS,
+	                    -1);
+	if ((active < 0) && !strcmp (contype, NM_OPENVPN_CONTYPE_PASSWORD_TLS))
+		active = 2;
+
+	/* Static key auth widget */
+	sk_init_auth_widget (priv->builder, priv->group, s_vpn, stuff_changed_cb, self);
+
+	gtk_list_store_append (store, &iter);
+	gtk_list_store_set (store, &iter,
+	                    COL_AUTH_NAME, _("Static Key"),
+	                    COL_AUTH_PAGE, 3,
+	                    COL_AUTH_TYPE, NM_OPENVPN_CONTYPE_STATIC_KEY,
+	                    -1);
+	if ((active < 0) && !strcmp (contype, NM_OPENVPN_CONTYPE_STATIC_KEY))
+		active = 3;
+
+	gtk_combo_box_set_model (GTK_COMBO_BOX (widget), GTK_TREE_MODEL (store));
+	g_object_unref (store);
+	g_signal_connect (widget, "changed", G_CALLBACK (auth_combo_changed_cb), self);
+	gtk_combo_box_set_active (GTK_COMBO_BOX (widget), active < 0 ? 0 : active);
+
+	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "advanced_button"));
+	g_signal_connect (G_OBJECT (widget), "clicked", G_CALLBACK (advanced_button_clicked_cb), self);
+
+	return TRUE;
+}
+
+static GObject *
+get_widget (NMVpnEditor *iface)
+{
+	OpenvpnEditor *self = OPENVPN_EDITOR (iface);
+	OpenvpnEditorPrivate *priv = OPENVPN_EDITOR_GET_PRIVATE (self);
+
+	return G_OBJECT (priv->widget);
+}
+
+static void
+hash_copy_advanced (gpointer key, gpointer data, gpointer user_data)
+{
+	NMSettingVpn *s_vpn = NM_SETTING_VPN (user_data);
+	const char *value = (const char *) data;
+
+	g_return_if_fail (value && strlen (value));
+
+	/* HTTP Proxy password is a secret, not a data item */
+	if (!strcmp (key, NM_OPENVPN_KEY_HTTP_PROXY_PASSWORD))
+		nm_setting_vpn_add_secret (s_vpn, (const char *) key, value);
+	else
+		nm_setting_vpn_add_data_item (s_vpn, (const char *) key, value);
+}
+
+static char *
+get_auth_type (GtkBuilder *builder)
+{
+	GtkComboBox *combo;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+	char *auth_type = NULL;
+	gboolean success;
+
+	combo = GTK_COMBO_BOX (GTK_WIDGET (gtk_builder_get_object (builder, "auth_combo")));
+	model = gtk_combo_box_get_model (combo);
+
+	success = gtk_combo_box_get_active_iter (combo, &iter);
+	g_return_val_if_fail (success == TRUE, NULL);
+	gtk_tree_model_get (model, &iter, COL_AUTH_TYPE, &auth_type, -1);
+
+	return auth_type;
+}
+
+static gboolean
+update_connection (NMVpnEditor *iface,
+                   NMConnection *connection,
+                   GError **error)
+{
+	OpenvpnEditor *self = OPENVPN_EDITOR (iface);
+	OpenvpnEditorPrivate *priv = OPENVPN_EDITOR_GET_PRIVATE (self);
+	NMSettingVpn *s_vpn;
+	GtkWidget *widget;
+	char *str, *auth_type;
+	gboolean valid = FALSE;
+
+	if (!check_validity (self, error))
+		return FALSE;
+
+	s_vpn = NM_SETTING_VPN (nm_setting_vpn_new ());
+	g_object_set (s_vpn, NM_SETTING_VPN_SERVICE_TYPE, NM_VPN_SERVICE_TYPE_OPENVPN, NULL);
+
+	/* Gateway */
+	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "gateway_entry"));
+	str = (char *) gtk_entry_get_text (GTK_ENTRY (widget));
+	if (str && strlen (str))
+		nm_setting_vpn_add_data_item (s_vpn, NM_OPENVPN_KEY_REMOTE, str);
+
+	auth_type = get_auth_type (priv->builder);
+	if (auth_type) {
+		nm_setting_vpn_add_data_item (s_vpn, NM_OPENVPN_KEY_CONNECTION_TYPE, auth_type);
+		auth_widget_update_connection (priv->builder, auth_type, s_vpn);
+		g_free (auth_type);
+	}
+
+	if (priv->advanced)
+		g_hash_table_foreach (priv->advanced, hash_copy_advanced, s_vpn);
+
+	/* Default to agent-owned secrets for new connections */
+	if (priv->new_connection) {
+		if (nm_setting_vpn_get_secret (s_vpn, NM_OPENVPN_KEY_HTTP_PROXY_PASSWORD)) {
+			nm_setting_set_secret_flags (NM_SETTING (s_vpn),
+			                             NM_OPENVPN_KEY_HTTP_PROXY_PASSWORD,
+			                             NM_SETTING_SECRET_FLAG_AGENT_OWNED,
+			                             NULL);
+		}
+
+		if (nm_setting_vpn_get_secret (s_vpn, NM_OPENVPN_KEY_PASSWORD)) {
+			nm_setting_set_secret_flags (NM_SETTING (s_vpn),
+			                             NM_OPENVPN_KEY_PASSWORD,
+			                             NM_SETTING_SECRET_FLAG_AGENT_OWNED,
+			                             NULL);
+		}
+
+		if (nm_setting_vpn_get_secret (s_vpn, NM_OPENVPN_KEY_CERTPASS)) {
+			nm_setting_set_secret_flags (NM_SETTING (s_vpn),
+			                             NM_OPENVPN_KEY_CERTPASS,
+			                             NM_SETTING_SECRET_FLAG_AGENT_OWNED,
+			                             NULL);
+		}
+	}
+
+	nm_connection_add_setting (connection, NM_SETTING (s_vpn));
+	valid = TRUE;
+
+	return valid;
+}
+
+static void
+is_new_func (const char *key, const char *value, gpointer user_data)
+{
+	gboolean *is_new = user_data;
+
+	/* If there are any VPN data items the connection isn't new */
+	*is_new = FALSE;
+}
+
+/*****************************************************************************/
+
+static void
+openvpn_editor_plugin_widget_init (OpenvpnEditor *plugin)
+{
+}
+
+NMVpnEditor *
+openvpn_editor_new (NMConnection *connection, GError **error)
+{
+	NMVpnEditor *object;
+	OpenvpnEditorPrivate *priv;
+	char *ui_file;
+	gboolean new = TRUE;
+	NMSettingVpn *s_vpn;
+
+	if (error)
+		g_return_val_if_fail (*error == NULL, NULL);
+
+	object = g_object_new (OPENVPN_TYPE_EDITOR, NULL);
+	if (!object) {
+		g_set_error_literal (error, NMV_EDITOR_PLUGIN_ERROR, 0, _("could not create openvpn object"));
+		return NULL;
+	}
+
+	priv = OPENVPN_EDITOR_GET_PRIVATE (object);
+
+	ui_file = g_strdup_printf ("%s/%s", UIDIR, "nm-openvpn-dialog.ui");
+	priv->builder = gtk_builder_new ();
+
+	gtk_builder_set_translation_domain (priv->builder, GETTEXT_PACKAGE);
+
+	if (!gtk_builder_add_from_file (priv->builder, ui_file, error)) {
+		g_warning ("Couldn't load builder file: %s",
+		           error && *error ? (*error)->message : "(unknown)");
+		g_clear_error (error);
+		g_set_error (error, NMV_EDITOR_PLUGIN_ERROR, 0,
+		             "could not load required resources from %s", ui_file);
+		g_free (ui_file);
+		g_object_unref (object);
+		return NULL;
+	}
+
+	g_free (ui_file);
+
+	priv->widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "openvpn-vbox"));
+	if (!priv->widget) {
+		g_set_error_literal (error, NMV_EDITOR_PLUGIN_ERROR, 0, _("could not load UI widget"));
+		g_object_unref (object);
+		return NULL;
+	}
+	g_object_ref_sink (priv->widget);
+
+	priv->window_group = gtk_window_group_new ();
+
+	s_vpn = nm_connection_get_setting_vpn (connection);
+	if (s_vpn)
+		nm_setting_vpn_foreach_data_item (s_vpn, is_new_func, &new);
+	priv->new_connection = new;
+
+	if (!init_editor_plugin (OPENVPN_EDITOR (object), connection, error)) {
+		g_object_unref (object);
+		return NULL;
+	}
+
+	priv->advanced = advanced_dialog_new_hash_from_connection (connection, error);
+	if (!priv->advanced) {
+		g_object_unref (object);
+		return NULL;
+	}
+
+	return object;
+}
+
+static void
+dispose (GObject *object)
+{
+	OpenvpnEditor *plugin = OPENVPN_EDITOR (object);
+	OpenvpnEditorPrivate *priv = OPENVPN_EDITOR_GET_PRIVATE (plugin);
+
+	g_clear_object (&priv->group);
+
+	g_clear_object (&priv->window_group);
+
+	g_clear_object (&priv->widget);
+
+	g_clear_object (&priv->builder);
+
+	g_clear_pointer (&priv->advanced, g_hash_table_destroy);
+
+	G_OBJECT_CLASS (openvpn_editor_plugin_widget_parent_class)->dispose (object);
+}
+
+static void
+openvpn_editor_plugin_widget_interface_init (NMVpnEditorInterface *iface_class)
+{
+	/* interface implementation */
+	iface_class->get_widget = get_widget;
+	iface_class->update_connection = update_connection;
+}
+
+static void
+openvpn_editor_plugin_widget_class_init (OpenvpnEditorClass *req_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (req_class);
+
+	g_type_class_add_private (req_class, sizeof (OpenvpnEditorPrivate));
+
+	object_class->dispose = dispose;
+}
+
+/*****************************************************************************/
+
+#ifndef NM_VPN_OLD
+
+#include "nm-openvpn-editor-plugin.h"
+
+G_MODULE_EXPORT NMVpnEditor *
+nm_vpn_editor_factory_openvpn (NMVpnEditorPlugin *editor_plugin,
+                               NMConnection *connection,
+                               GError **error)
+{
+	g_return_val_if_fail (!error || !*error, NULL);
+
+	return openvpn_editor_new (connection, error);
+}
+#endif
+
diff --git properties/nm-openvpn-editor.h properties/nm-openvpn-editor.h
new file mode 100644
index 0000000..6940068
--- /dev/null
+++ properties/nm-openvpn-editor.h
@@ -0,0 +1,49 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/***************************************************************************
+ * nm-openvpn-editor.h : GNOME UI dialogs for configuring openvpn VPN connections
+ *
+ * Copyright (C) 2008 Dan Williams, <dcbw@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ **************************************************************************/
+
+#ifndef __NM_OPENVPN_EDITOR_H__
+#define __NM_OPENVPN_EDITOR_H__
+
+#define OPENVPN_TYPE_EDITOR            (openvpn_editor_plugin_widget_get_type ())
+#define OPENVPN_EDITOR(obj)                      (G_TYPE_CHECK_INSTANCE_CAST ((obj), OPENVPN_TYPE_EDITOR, OpenvpnEditor))
+#define OPENVPN_EDITOR_CLASS(klass)              (G_TYPE_CHECK_CLASS_CAST ((klass), OPENVPN_TYPE_EDITOR, OpenvpnEditorClass))
+#define OPENVPN_IS_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OPENVPN_TYPE_EDITOR))
+#define OPENVPN_IS_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OPENVPN_TYPE_EDITOR))
+#define OPENVPN_EDITOR_GET_CLASS(obj)            (G_TYPE_INSTANCE_GET_CLASS ((obj), OPENVPN_TYPE_EDITOR, OpenvpnEditorClass))
+
+typedef struct _OpenvpnEditor OpenvpnEditor;
+typedef struct _OpenvpnEditorClass OpenvpnEditorClass;
+
+struct _OpenvpnEditor {
+	GObject parent;
+};
+
+struct _OpenvpnEditorClass {
+	GObjectClass parent;
+};
+
+GType openvpn_editor_plugin_widget_get_type (void);
+
+NMVpnEditor *openvpn_editor_new (NMConnection *connection, GError **error);
+
+#endif	/* __NM_OPENVPN_EDITOR_H__ */
+
diff --git properties/nm-openvpn.c properties/nm-openvpn.c
deleted file mode 100644
index b98f036..0000000
--- properties/nm-openvpn.c
+++ /dev/null
@@ -1,747 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/***************************************************************************
- * CVSID: $Id: nm-openvpn.c 4232 2008-10-29 09:13:40Z tambeti $
- *
- * nm-openvpn.c : GNOME UI dialogs for configuring openvpn VPN connections
- *
- * Copyright (C) 2005 Tim Niemueller <tim@niemueller.de>
- * Copyright (C) 2008 - 2010 Dan Williams, <dcbw@redhat.com>
- * Copyright (C) 2008 - 2011 Red Hat, Inc.
- * Based on work by David Zeuthen, <davidz@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- **************************************************************************/
-
-#include "config.h"
-
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <errno.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gtk/gtk.h>
-
-#include "nm-default.h"
-
-#include "nm-openvpn-service-defines.h"
-#include "nm-openvpn.h"
-#include "auth-helpers.h"
-#include "import-export.h"
-
-#define OPENVPN_PLUGIN_NAME    _("OpenVPN")
-#define OPENVPN_PLUGIN_DESC    _("Compatible with the OpenVPN server.")
-
-/************** plugin class **************/
-
-enum {
-	PROP_0,
-	PROP_NAME,
-	PROP_DESC,
-	PROP_SERVICE
-};
-
-static void openvpn_editor_plugin_interface_init (NMVpnEditorPluginInterface *iface_class);
-
-G_DEFINE_TYPE_EXTENDED (OpenvpnEditorPlugin, openvpn_editor_plugin, G_TYPE_OBJECT, 0,
-                        G_IMPLEMENT_INTERFACE (NM_TYPE_VPN_EDITOR_PLUGIN,
-                                               openvpn_editor_plugin_interface_init))
-
-/************** UI widget class **************/
-
-static void openvpn_editor_plugin_widget_interface_init (NMVpnEditorInterface *iface_class);
-
-G_DEFINE_TYPE_EXTENDED (OpenvpnEditor, openvpn_editor_plugin_widget, G_TYPE_OBJECT, 0,
-                        G_IMPLEMENT_INTERFACE (NM_TYPE_VPN_EDITOR,
-                                               openvpn_editor_plugin_widget_interface_init))
-
-#define OPENVPN_EDITOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), OPENVPN_TYPE_EDITOR, OpenvpnEditorPrivate))
-
-typedef struct {
-	GtkBuilder *builder;
-	GtkWidget *widget;
-	GtkSizeGroup *group;
-	GtkWindowGroup *window_group;
-	gboolean window_added;
-	GHashTable *advanced;
-	gboolean new_connection;
-} OpenvpnEditorPrivate;
-
-
-#define COL_AUTH_NAME 0
-#define COL_AUTH_PAGE 1
-#define COL_AUTH_TYPE 2
-
-/* Example: abc.com:1234:udp, ovpnserver.company.com:443, vpn.example.com::tcp */
-static gboolean
-check_gateway_entry (const char *str)
-{
-	char **list, **iter;
-	char *host, *port, *proto;
-	long int port_int;
-	gboolean success = FALSE;
-
-	if (!str || !*str)
-		return FALSE;
-
-	list = g_strsplit_set (str, " \t,", -1);
-	for (iter = list; iter && *iter; iter++) {
-		if (!**iter)
-			continue;
-		host = g_strstrip (*iter);
-		port = strchr (host, ':');
-		proto = port ? strchr (port + 1, ':') : NULL;
-		if (port)
-			*port++ = '\0';
-		if (proto)
-			*proto++ = '\0';
-
-		/* check hostname */
-		if (!*host)
-			goto out;
-		/* check port */
-		if (port && *port) {
-			char *end;
-			errno = 0;
-			port_int = strtol (port, &end, 10);
-			if (errno != 0 || *end != '\0' || port_int < 1 || port_int > 65535)
-				goto out;
-		}
-		/* check proto */
-		if (proto && strcmp (proto, "udp") && strcmp (proto, "tcp"))
-			goto out;
-	}
-	success = TRUE;
-out:
-	g_strfreev (list);
-	return success;
-}
-
-static gboolean
-check_validity (OpenvpnEditor *self, GError **error)
-{
-	OpenvpnEditorPrivate *priv = OPENVPN_EDITOR_GET_PRIVATE (self);
-	GtkWidget *widget;
-	const char *str;
-	GtkTreeModel *model;
-	GtkTreeIter iter;
-	const char *contype = NULL;
-	GdkRGBA rgba;
-	gboolean gateway_valid;
-	gboolean success;
-
-	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "gateway_entry"));
-	str = gtk_entry_get_text (GTK_ENTRY (widget));
-	gateway_valid = check_gateway_entry (str);
-	/* Change entry background colour while editing */
-	if (!gateway_valid)
-		gdk_rgba_parse (&rgba, "red3");
-	gtk_widget_override_background_color (widget, GTK_STATE_NORMAL, !gateway_valid ? &rgba : NULL);
-	if (!gateway_valid) {
-		g_set_error (error,
-		             OPENVPN_EDITOR_PLUGIN_ERROR,
-		             OPENVPN_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
-		             NM_OPENVPN_KEY_REMOTE);
-		return FALSE;
-	}
-
-	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "auth_combo"));
-	model = gtk_combo_box_get_model (GTK_COMBO_BOX (widget));
-	g_return_val_if_fail (model, FALSE);
-	success = gtk_combo_box_get_active_iter (GTK_COMBO_BOX (widget), &iter);
-	g_return_val_if_fail (success == TRUE, FALSE);
-	gtk_tree_model_get (model, &iter, COL_AUTH_TYPE, &contype, -1);
-	if (!auth_widget_check_validity (priv->builder, contype, error))
-		return FALSE;
-
-	return TRUE;
-}
-
-static void
-stuff_changed_cb (GtkWidget *widget, gpointer user_data)
-{
-	g_signal_emit_by_name (OPENVPN_EDITOR (user_data), "changed");
-}
-
-static void
-auth_combo_changed_cb (GtkWidget *combo, gpointer user_data)
-{
-	OpenvpnEditor *self = OPENVPN_EDITOR (user_data);
-	OpenvpnEditorPrivate *priv = OPENVPN_EDITOR_GET_PRIVATE (self);
-	GtkWidget *auth_notebook;
-	GtkWidget *show_passwords;
-	GtkTreeModel *model;
-	GtkTreeIter iter;
-	gint new_page = 0;
-
-	auth_notebook = GTK_WIDGET (gtk_builder_get_object (priv->builder, "auth_notebook"));
-	g_assert (auth_notebook);
-	show_passwords = GTK_WIDGET (gtk_builder_get_object (priv->builder, "show_passwords"));
-	g_assert (auth_notebook);
-
-	model = gtk_combo_box_get_model (GTK_COMBO_BOX (combo));
-	g_assert (model);
-	g_assert (gtk_combo_box_get_active_iter (GTK_COMBO_BOX (combo), &iter));
-
-	gtk_tree_model_get (model, &iter, COL_AUTH_PAGE, &new_page, -1);
-
-	/* Static key page doesn't have any passwords */
-	gtk_widget_set_sensitive (show_passwords, new_page != 3);
-
-	gtk_notebook_set_current_page (GTK_NOTEBOOK (auth_notebook), new_page);
-
-	stuff_changed_cb (combo, self);
-}
-
-static void
-advanced_dialog_close_cb (GtkWidget *dialog, gpointer user_data)
-{
-	gtk_widget_hide (dialog);
-	/* gtk_widget_destroy() will remove the window from the window group */
-	gtk_widget_destroy (dialog);
-}
-
-static void
-advanced_dialog_response_cb (GtkWidget *dialog, gint response, gpointer user_data)
-{
-	OpenvpnEditor *self = OPENVPN_EDITOR (user_data);
-	OpenvpnEditorPrivate *priv = OPENVPN_EDITOR_GET_PRIVATE (self);
-	GError *error = NULL;
-
-	if (response != GTK_RESPONSE_OK) {
-		advanced_dialog_close_cb (dialog, self);
-		return;
-	}
-
-	if (priv->advanced)
-		g_hash_table_destroy (priv->advanced);
-	priv->advanced = advanced_dialog_new_hash_from_dialog (dialog, &error);
-	if (!priv->advanced) {
-		g_message ("%s: error reading advanced settings: %s", __func__, error->message);
-		g_error_free (error);
-	}
-	advanced_dialog_close_cb (dialog, self);
-
-	stuff_changed_cb (NULL, self);
-}
-
-static void
-advanced_button_clicked_cb (GtkWidget *button, gpointer user_data)
-{
-	OpenvpnEditor *self = OPENVPN_EDITOR (user_data);
-	OpenvpnEditorPrivate *priv = OPENVPN_EDITOR_GET_PRIVATE (self);
-	GtkWidget *dialog, *toplevel, *widget;
-	GtkTreeModel *model;
-	GtkTreeIter iter;
-	const char *contype = NULL;
-	gboolean success;
-
-	toplevel = gtk_widget_get_toplevel (priv->widget);
-	g_return_if_fail (gtk_widget_is_toplevel (toplevel));
-
-	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "auth_combo"));
-	model = gtk_combo_box_get_model (GTK_COMBO_BOX (widget));
-	success = gtk_combo_box_get_active_iter (GTK_COMBO_BOX (widget), &iter);
-	g_return_if_fail (success == TRUE);
-	gtk_tree_model_get (model, &iter, COL_AUTH_TYPE, &contype, -1);
-
-	dialog = advanced_dialog_new (priv->advanced, contype);
-	if (!dialog) {
-		g_warning ("%s: failed to create the Advanced dialog!", __func__);
-		return;
-	}
-
-	gtk_window_group_add_window (priv->window_group, GTK_WINDOW (dialog));
-	if (!priv->window_added) {
-		gtk_window_group_add_window (priv->window_group, GTK_WINDOW (toplevel));
-		priv->window_added = TRUE;
-	}
-
-	gtk_window_set_transient_for (GTK_WINDOW (dialog), GTK_WINDOW (toplevel));
-	g_signal_connect (G_OBJECT (dialog), "response", G_CALLBACK (advanced_dialog_response_cb), self);
-	g_signal_connect (G_OBJECT (dialog), "close", G_CALLBACK (advanced_dialog_close_cb), self);
-
-	gtk_widget_show_all (dialog);
-}
-
-static gboolean
-init_editor_plugin (OpenvpnEditor *self, NMConnection *connection, GError **error)
-{
-	OpenvpnEditorPrivate *priv = OPENVPN_EDITOR_GET_PRIVATE (self);
-	NMSettingVpn *s_vpn;
-	GtkWidget *widget;
-	GtkListStore *store;
-	GtkTreeIter iter;
-	int active = -1;
-	const char *value;
-	const char *contype = NM_OPENVPN_CONTYPE_TLS;
-
-	s_vpn = nm_connection_get_setting_vpn (connection);
-
-	priv->group = gtk_size_group_new (GTK_SIZE_GROUP_HORIZONTAL);
-
-	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "gateway_entry"));
-	g_return_val_if_fail (widget != NULL, FALSE);
-	gtk_size_group_add_widget (priv->group, widget);
-	if (s_vpn) {
-		value = nm_setting_vpn_get_data_item (s_vpn, NM_OPENVPN_KEY_REMOTE);
-		if (value)
-			gtk_entry_set_text (GTK_ENTRY (widget), value);
-	}
-	g_signal_connect (G_OBJECT (widget), "changed", G_CALLBACK (stuff_changed_cb), self);
-
-	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "auth_combo"));
-	g_return_val_if_fail (widget != NULL, FALSE);
-	gtk_size_group_add_widget (priv->group, widget);
-
-	store = gtk_list_store_new (3, G_TYPE_STRING, G_TYPE_INT, G_TYPE_STRING);
-
-	if (s_vpn) {
-		contype = nm_setting_vpn_get_data_item (s_vpn, NM_OPENVPN_KEY_CONNECTION_TYPE);
-		if (contype) {
-			if (   strcmp (contype, NM_OPENVPN_CONTYPE_TLS)
-			    && strcmp (contype, NM_OPENVPN_CONTYPE_STATIC_KEY)
-			    && strcmp (contype, NM_OPENVPN_CONTYPE_PASSWORD)
-			    && strcmp (contype, NM_OPENVPN_CONTYPE_PASSWORD_TLS))
-				contype = NM_OPENVPN_CONTYPE_TLS;
-		} else
-			contype = NM_OPENVPN_CONTYPE_TLS;
-	}
-
-	/* TLS auth widget */
-	tls_pw_init_auth_widget (priv->builder, priv->group, s_vpn,
-	                         NM_OPENVPN_CONTYPE_TLS, "tls",
-	                         stuff_changed_cb, self);
-	gtk_list_store_append (store, &iter);
-	gtk_list_store_set (store, &iter,
-	                    COL_AUTH_NAME, _("Certificates (TLS)"),
-	                    COL_AUTH_PAGE, 0,
-	                    COL_AUTH_TYPE, NM_OPENVPN_CONTYPE_TLS,
-	                    -1);
-
-	/* Password auth widget */
-	tls_pw_init_auth_widget (priv->builder, priv->group, s_vpn,
-	                         NM_OPENVPN_CONTYPE_PASSWORD, "pw",
-	                         stuff_changed_cb, self);
-	gtk_list_store_append (store, &iter);
-	gtk_list_store_set (store, &iter,
-	                    COL_AUTH_NAME, _("Password"),
-	                    COL_AUTH_PAGE, 1,
-	                    COL_AUTH_TYPE, NM_OPENVPN_CONTYPE_PASSWORD,
-	                    -1);
-	if ((active < 0) && !strcmp (contype, NM_OPENVPN_CONTYPE_PASSWORD))
-		active = 1;
-
-	/* Password+TLS auth widget */
-	tls_pw_init_auth_widget (priv->builder, priv->group, s_vpn,
-	                         NM_OPENVPN_CONTYPE_PASSWORD_TLS, "pw_tls",
-	                         stuff_changed_cb, self);
-	gtk_list_store_append (store, &iter);
-	gtk_list_store_set (store, &iter,
-	                    COL_AUTH_NAME, _("Password with Certificates (TLS)"),
-	                    COL_AUTH_PAGE, 2,
-	                    COL_AUTH_TYPE, NM_OPENVPN_CONTYPE_PASSWORD_TLS,
-	                    -1);
-	if ((active < 0) && !strcmp (contype, NM_OPENVPN_CONTYPE_PASSWORD_TLS))
-		active = 2;
-
-	/* Static key auth widget */
-	sk_init_auth_widget (priv->builder, priv->group, s_vpn, stuff_changed_cb, self);
-
-	gtk_list_store_append (store, &iter);
-	gtk_list_store_set (store, &iter,
-	                    COL_AUTH_NAME, _("Static Key"),
-	                    COL_AUTH_PAGE, 3,
-	                    COL_AUTH_TYPE, NM_OPENVPN_CONTYPE_STATIC_KEY,
-	                    -1);
-	if ((active < 0) && !strcmp (contype, NM_OPENVPN_CONTYPE_STATIC_KEY))
-		active = 3;
-
-	gtk_combo_box_set_model (GTK_COMBO_BOX (widget), GTK_TREE_MODEL (store));
-	g_object_unref (store);
-	g_signal_connect (widget, "changed", G_CALLBACK (auth_combo_changed_cb), self);
-	gtk_combo_box_set_active (GTK_COMBO_BOX (widget), active < 0 ? 0 : active);
-
-	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "advanced_button"));
-	g_signal_connect (G_OBJECT (widget), "clicked", G_CALLBACK (advanced_button_clicked_cb), self);
-
-	return TRUE;
-}
-
-static GObject *
-get_widget (NMVpnEditor *iface)
-{
-	OpenvpnEditor *self = OPENVPN_EDITOR (iface);
-	OpenvpnEditorPrivate *priv = OPENVPN_EDITOR_GET_PRIVATE (self);
-
-	return G_OBJECT (priv->widget);
-}
-
-static void
-hash_copy_advanced (gpointer key, gpointer data, gpointer user_data)
-{
-	NMSettingVpn *s_vpn = NM_SETTING_VPN (user_data);
-	const char *value = (const char *) data;
-
-	g_return_if_fail (value && strlen (value));
-
-	/* HTTP Proxy password is a secret, not a data item */
-	if (!strcmp (key, NM_OPENVPN_KEY_HTTP_PROXY_PASSWORD))
-		nm_setting_vpn_add_secret (s_vpn, (const char *) key, value);
-	else
-		nm_setting_vpn_add_data_item (s_vpn, (const char *) key, value);
-}
-
-static char *
-get_auth_type (GtkBuilder *builder)
-{
-	GtkComboBox *combo;
-	GtkTreeModel *model;
-	GtkTreeIter iter;
-	char *auth_type = NULL;
-	gboolean success;
-
-	combo = GTK_COMBO_BOX (GTK_WIDGET (gtk_builder_get_object (builder, "auth_combo")));
-	model = gtk_combo_box_get_model (combo);
-
-	success = gtk_combo_box_get_active_iter (combo, &iter);
-	g_return_val_if_fail (success == TRUE, NULL);
-	gtk_tree_model_get (model, &iter, COL_AUTH_TYPE, &auth_type, -1);
-
-	return auth_type;
-}
-
-static gboolean
-update_connection (NMVpnEditor *iface,
-                   NMConnection *connection,
-                   GError **error)
-{
-	OpenvpnEditor *self = OPENVPN_EDITOR (iface);
-	OpenvpnEditorPrivate *priv = OPENVPN_EDITOR_GET_PRIVATE (self);
-	NMSettingVpn *s_vpn;
-	GtkWidget *widget;
-	char *str, *auth_type;
-	gboolean valid = FALSE;
-
-	if (!check_validity (self, error))
-		return FALSE;
-
-	s_vpn = NM_SETTING_VPN (nm_setting_vpn_new ());
-	g_object_set (s_vpn, NM_SETTING_VPN_SERVICE_TYPE, NM_VPN_SERVICE_TYPE_OPENVPN, NULL);
-
-	/* Gateway */
-	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "gateway_entry"));
-	str = (char *) gtk_entry_get_text (GTK_ENTRY (widget));
-	if (str && strlen (str))
-		nm_setting_vpn_add_data_item (s_vpn, NM_OPENVPN_KEY_REMOTE, str);
-
-	auth_type = get_auth_type (priv->builder);
-	if (auth_type) {
-		nm_setting_vpn_add_data_item (s_vpn, NM_OPENVPN_KEY_CONNECTION_TYPE, auth_type);
-		auth_widget_update_connection (priv->builder, auth_type, s_vpn);
-		g_free (auth_type);
-	}
-
-	if (priv->advanced)
-		g_hash_table_foreach (priv->advanced, hash_copy_advanced, s_vpn);
-
-	/* Default to agent-owned secrets for new connections */
-	if (priv->new_connection) {
-		if (nm_setting_vpn_get_secret (s_vpn, NM_OPENVPN_KEY_HTTP_PROXY_PASSWORD)) {
-			nm_setting_set_secret_flags (NM_SETTING (s_vpn),
-			                             NM_OPENVPN_KEY_HTTP_PROXY_PASSWORD,
-			                             NM_SETTING_SECRET_FLAG_AGENT_OWNED,
-			                             NULL);
-		}
-
-		if (nm_setting_vpn_get_secret (s_vpn, NM_OPENVPN_KEY_PASSWORD)) {
-			nm_setting_set_secret_flags (NM_SETTING (s_vpn),
-			                             NM_OPENVPN_KEY_PASSWORD,
-			                             NM_SETTING_SECRET_FLAG_AGENT_OWNED,
-			                             NULL);
-		}
-
-		if (nm_setting_vpn_get_secret (s_vpn, NM_OPENVPN_KEY_CERTPASS)) {
-			nm_setting_set_secret_flags (NM_SETTING (s_vpn),
-			                             NM_OPENVPN_KEY_CERTPASS,
-			                             NM_SETTING_SECRET_FLAG_AGENT_OWNED,
-			                             NULL);
-		}
-	}
-
-	nm_connection_add_setting (connection, NM_SETTING (s_vpn));
-	valid = TRUE;
-
-	return valid;
-}
-
-static void
-is_new_func (const char *key, const char *value, gpointer user_data)
-{
-	gboolean *is_new = user_data;
-
-	/* If there are any VPN data items the connection isn't new */
-	*is_new = FALSE;
-}
-
-static NMVpnEditor *
-nm_vpn_editor_interface_new (NMConnection *connection, GError **error)
-{
-	NMVpnEditor *object;
-	OpenvpnEditorPrivate *priv;
-	char *ui_file;
-	gboolean new = TRUE;
-	NMSettingVpn *s_vpn;
-
-	if (error)
-		g_return_val_if_fail (*error == NULL, NULL);
-
-	object = g_object_new (OPENVPN_TYPE_EDITOR, NULL);
-	if (!object) {
-		g_set_error_literal (error, OPENVPN_EDITOR_PLUGIN_ERROR, 0, _("could not create openvpn object"));
-		return NULL;
-	}
-
-	priv = OPENVPN_EDITOR_GET_PRIVATE (object);
-
-	ui_file = g_strdup_printf ("%s/%s", UIDIR, "nm-openvpn-dialog.ui");
-	priv->builder = gtk_builder_new ();
-
-	gtk_builder_set_translation_domain (priv->builder, GETTEXT_PACKAGE);
-
-	if (!gtk_builder_add_from_file (priv->builder, ui_file, error)) {
-		g_warning ("Couldn't load builder file: %s",
-		           error && *error ? (*error)->message : "(unknown)");
-		g_clear_error (error);
-		g_set_error (error, OPENVPN_EDITOR_PLUGIN_ERROR, 0,
-		             "could not load required resources from %s", ui_file);
-		g_free (ui_file);
-		g_object_unref (object);
-		return NULL;
-	}
-
-	g_free (ui_file);
-
-	priv->widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "openvpn-vbox"));
-	if (!priv->widget) {
-		g_set_error_literal (error, OPENVPN_EDITOR_PLUGIN_ERROR, 0, _("could not load UI widget"));
-		g_object_unref (object);
-		return NULL;
-	}
-	g_object_ref_sink (priv->widget);
-
-	priv->window_group = gtk_window_group_new ();
-
-	s_vpn = nm_connection_get_setting_vpn (connection);
-	if (s_vpn)
-		nm_setting_vpn_foreach_data_item (s_vpn, is_new_func, &new);
-	priv->new_connection = new;
-
-	if (!init_editor_plugin (OPENVPN_EDITOR (object), connection, error)) {
-		g_object_unref (object);
-		return NULL;
-	}
-
-	priv->advanced = advanced_dialog_new_hash_from_connection (connection, error);
-	if (!priv->advanced) {
-		g_object_unref (object);
-		return NULL;
-	}
-
-	return object;
-}
-
-static void
-dispose (GObject *object)
-{
-	OpenvpnEditor *plugin = OPENVPN_EDITOR (object);
-	OpenvpnEditorPrivate *priv = OPENVPN_EDITOR_GET_PRIVATE (plugin);
-
-	g_clear_object (&priv->group);
-
-	g_clear_object (&priv->window_group);
-
-	g_clear_object (&priv->widget);
-
-	g_clear_object (&priv->builder);
-
-	g_clear_pointer (&priv->advanced, g_hash_table_destroy);
-
-	G_OBJECT_CLASS (openvpn_editor_plugin_widget_parent_class)->dispose (object);
-}
-
-static void
-openvpn_editor_plugin_widget_class_init (OpenvpnEditorClass *req_class)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (req_class);
-
-	g_type_class_add_private (req_class, sizeof (OpenvpnEditorPrivate));
-
-	object_class->dispose = dispose;
-}
-
-static void
-openvpn_editor_plugin_widget_init (OpenvpnEditor *plugin)
-{
-}
-
-static void
-openvpn_editor_plugin_widget_interface_init (NMVpnEditorInterface *iface_class)
-{
-	/* interface implementation */
-	iface_class->get_widget = get_widget;
-	iface_class->update_connection = update_connection;
-}
-
-static NMConnection *
-import (NMVpnEditorPlugin *iface, const char *path, GError **error)
-{
-	NMConnection *connection = NULL;
-	char *contents = NULL;
-	char *ext;
-	gsize contents_len;
-
-	ext = strrchr (path, '.');
-
-	if (!ext || (   !g_str_has_suffix (ext, ".ovpn")
-	             && !g_str_has_suffix (ext, ".conf")
-	             && !g_str_has_suffix (ext, ".cnf")
-	             && !g_str_has_suffix (ext, ".ovpntest"))) {   /* Special extension for testcases */
-		g_set_error_literal (error,
-		                     OPENVPN_EDITOR_PLUGIN_ERROR,
-		                     OPENVPN_EDITOR_PLUGIN_ERROR_FILE_NOT_OPENVPN,
-		                     _("unknown OpenVPN file extension"));
-		goto out;
-	}
-
-	if (!g_file_get_contents (path, &contents, &contents_len, error))
-		return NULL;
-
-	connection = do_import (path, contents, contents_len, error);
-
-out:
-	g_free (contents);
-	return connection;
-}
-
-static gboolean
-export (NMVpnEditorPlugin *iface,
-        const char *path,
-        NMConnection *connection,
-        GError **error)
-{
-	return do_export (path, connection, error);
-}
-
-static char *
-get_suggested_filename (NMVpnEditorPlugin *iface, NMConnection *connection)
-{
-	NMSettingConnection *s_con;
-	const char *id;
-
-	g_return_val_if_fail (connection != NULL, NULL);
-
-	s_con = nm_connection_get_setting_connection (connection);
-	g_return_val_if_fail (s_con != NULL, NULL);
-
-	id = nm_setting_connection_get_id (s_con);
-	g_return_val_if_fail (id != NULL, NULL);
-
-	return g_strdup_printf ("%s (openvpn).conf", id);
-}
-
-static guint32
-get_capabilities (NMVpnEditorPlugin *iface)
-{
-	return (NM_VPN_EDITOR_PLUGIN_CAPABILITY_IMPORT |
-	        NM_VPN_EDITOR_PLUGIN_CAPABILITY_EXPORT |
-	        NM_VPN_EDITOR_PLUGIN_CAPABILITY_IPV6);
-}
-
-static NMVpnEditor *
-get_editor (NMVpnEditorPlugin *iface, NMConnection *connection, GError **error)
-{
-	return nm_vpn_editor_interface_new (connection, error);
-}
-
-static void
-get_property (GObject *object, guint prop_id,
-			  GValue *value, GParamSpec *pspec)
-{
-	switch (prop_id) {
-	case PROP_NAME:
-		g_value_set_string (value, OPENVPN_PLUGIN_NAME);
-		break;
-	case PROP_DESC:
-		g_value_set_string (value, OPENVPN_PLUGIN_DESC);
-		break;
-	case PROP_SERVICE:
-		g_value_set_string (value, NM_VPN_SERVICE_TYPE_OPENVPN);
-		break;
-	default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-		break;
-	}
-}
-
-static void
-openvpn_editor_plugin_class_init (OpenvpnEditorPluginClass *req_class)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (req_class);
-
-	object_class->get_property = get_property;
-
-	g_object_class_override_property (object_class,
-	                                  PROP_NAME,
-	                                  NM_VPN_EDITOR_PLUGIN_NAME);
-
-	g_object_class_override_property (object_class,
-	                                  PROP_DESC,
-	                                  NM_VPN_EDITOR_PLUGIN_DESCRIPTION);
-
-	g_object_class_override_property (object_class,
-	                                  PROP_SERVICE,
-	                                  NM_VPN_EDITOR_PLUGIN_SERVICE);
-}
-
-static void
-openvpn_editor_plugin_init (OpenvpnEditorPlugin *plugin)
-{
-}
-
-static void
-openvpn_editor_plugin_interface_init (NMVpnEditorPluginInterface *iface_class)
-{
-	/* interface implementation */
-	iface_class->get_editor = get_editor;
-	iface_class->get_capabilities = get_capabilities;
-	iface_class->import_from_file = import;
-	iface_class->export_to_file = export;
-	iface_class->get_suggested_filename = get_suggested_filename;
-}
-
-
-G_MODULE_EXPORT NMVpnEditorPlugin *
-nm_vpn_editor_plugin_factory (GError **error)
-{
-	if (error)
-		g_return_val_if_fail (*error == NULL, NULL);
-
-	bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
-	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
-
-	return g_object_new (OPENVPN_TYPE_EDITOR_PLUGIN, NULL);
-}
-
diff --git properties/nm-openvpn.h properties/nm-openvpn.h
deleted file mode 100644
index bda4888..0000000
--- properties/nm-openvpn.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/***************************************************************************
- * nm-openvpn.h : GNOME UI dialogs for configuring openvpn VPN connections
- *
- * Copyright (C) 2008 Dan Williams, <dcbw@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- **************************************************************************/
-
-#ifndef _NM_OPENVPN_H_
-#define _NM_OPENVPN_H_
-
-#include <glib-object.h>
-
-#define OPENVPN_TYPE_EDITOR_PLUGIN                (openvpn_editor_plugin_get_type ())
-#define OPENVPN_EDITOR_PLUGIN(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), OPENVPN_TYPE_EDITOR_PLUGIN, OpenvpnEditorPlugin))
-#define OPENVPN_EDITOR_PLUGIN_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), OPENVPN_TYPE_EDITOR_PLUGIN, OpenvpnEditorPluginClass))
-#define OPENVPN_IS_EDITOR_PLUGIN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OPENVPN_TYPE_EDITOR_PLUGIN))
-#define OPENVPN_IS_EDITOR_PLUGIN_CLASS(klass)     (G_TYPE_CHECK_CLASS_TYPE ((klass), OPENVPN_TYPE_EDITOR_PLUGIN))
-#define OPENVPN_EDITOR_PLUGIN_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), OPENVPN_TYPE_EDITOR_PLUGIN, OpenvpnEditorPluginClass))
-
-typedef struct _OpenvpnEditorPlugin OpenvpnEditorPlugin;
-typedef struct _OpenvpnEditorPluginClass OpenvpnEditorPluginClass;
-
-struct _OpenvpnEditorPlugin {
-	GObject parent;
-};
-
-struct _OpenvpnEditorPluginClass {
-	GObjectClass parent;
-};
-
-GType openvpn_editor_plugin_get_type (void);
-
-
-#define OPENVPN_TYPE_EDITOR            (openvpn_editor_plugin_widget_get_type ())
-#define OPENVPN_EDITOR(obj)                      (G_TYPE_CHECK_INSTANCE_CAST ((obj), OPENVPN_TYPE_EDITOR, OpenvpnEditor))
-#define OPENVPN_EDITOR_CLASS(klass)              (G_TYPE_CHECK_CLASS_CAST ((klass), OPENVPN_TYPE_EDITOR, OpenvpnEditorClass))
-#define OPENVPN_IS_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OPENVPN_TYPE_EDITOR))
-#define OPENVPN_IS_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OPENVPN_TYPE_EDITOR))
-#define OPENVPN_EDITOR_GET_CLASS(obj)            (G_TYPE_INSTANCE_GET_CLASS ((obj), OPENVPN_TYPE_EDITOR, OpenvpnEditorClass))
-
-typedef struct _OpenvpnEditor OpenvpnEditor;
-typedef struct _OpenvpnEditorClass OpenvpnEditorClass;
-
-struct _OpenvpnEditor {
-	GObject parent;
-};
-
-struct _OpenvpnEditorClass {
-	GObjectClass parent;
-};
-
-GType openvpn_editor_plugin_widget_get_type (void);
-
-#endif	/* _NM_OPENVPN_H_ */
-
diff --git properties/tests/Makefile.am properties/tests/Makefile.am
index 7eecb26..c3eef5b 100644
--- properties/tests/Makefile.am
+++ properties/tests/Makefile.am
@@ -27,14 +27,14 @@ test_import_export_LDADD = \
 	$(GTK_LIBS) \
 	$(LIBNM_LIBS) \
 	$(LIBNMA_LIBS) \
-	$(top_builddir)/properties/libnm-vpn-plugin-openvpn.la
+	$(top_builddir)/properties/libnm-vpn-plugin-openvpn-test.la
 
 
 test_import_export_glib_SOURCES = \
 	test-import-export.c
 
 test_import_export_glib_CPPFLAGS = \
-	-DNM_OPENVPN_OLD \
+	-DNM_VPN_OLD \
 	$(GLIB_CFLAGS) \
 	$(GTK_CFLAGS) \
 	$(LIBNM_GLIB_CFLAGS) \
@@ -45,7 +45,7 @@ test_import_export_glib_LDADD = \
 	$(GTK_LIBS) \
 	$(LIBNM_GLIB_LIBS) \
 	$(LIBNM_GTK_LIBS) \
-	$(top_builddir)/properties/libnm-openvpn-properties.la
+	$(top_builddir)/properties/libnm-openvpn-properties-test.la
 
 
 TESTS = \
diff --git properties/tests/test-import-export.c properties/tests/test-import-export.c
index 5c8b7a0..936662c 100644
--- properties/tests/test-import-export.c
+++ properties/tests/test-import-export.c
@@ -18,7 +18,7 @@
  *
  */
 
-#include "config.h"
+#include "nm-default.h"
 
 #include <string.h>
 #include <netinet/in.h>
@@ -26,14 +26,12 @@
 #include <locale.h>
 #include <sys/stat.h>
 
-#include "nm-default.h"
-
-#include "nm-openvpn.h"
-#include "nm-openvpn-service-defines.h"
+#include "nm-openvpn-editor-plugin.h"
+#include "nm-openvpn-editor.h"
 #include "import-export.h"
 #include "utils.h"
 
-#include "nm-test-utils.h"
+#include "nm-utils/nm-test-utils.h"
 
 #define SRCDIR TEST_SRCDIR"/conf"
 #define TMPDIR TEST_BUILDDIR"/conf-tmp"
@@ -76,23 +74,21 @@ get_basic_connection (NMVpnEditorPlugin *plugin,
 	return connection;
 }
 
-static void
-_check_item (NMSettingVpn *s_vpn,
-             const char *item,
-             const char *expected)
-{
-	g_assert (s_vpn);
-	g_assert_cmpstr (nm_setting_vpn_get_data_item (s_vpn, item), ==, expected);
-}
-
-static void
-_check_secret (NMSettingVpn *s_vpn,
-               const char *item,
-               const char *expected)
-{
-	g_assert (s_vpn);
-	g_assert_cmpstr (nm_setting_vpn_get_secret (s_vpn, item), ==, expected);
-}
+#define _check_item(s_vpn, item, expected) \
+	G_STMT_START { \
+		NMSettingVpn *_s_vpn = (s_vpn); \
+		\
+		g_assert (_s_vpn); \
+		g_assert_cmpstr (nm_setting_vpn_get_data_item (_s_vpn, (item)), ==, (expected)); \
+	} G_STMT_END
+
+#define _check_secret(s_vpn, item, expected) \
+	G_STMT_START { \
+		NMSettingVpn *_s_vpn = (s_vpn); \
+		\
+		g_assert (_s_vpn); \
+		g_assert_cmpstr (nm_setting_vpn_get_secret (_s_vpn, (item)), ==, (expected)); \
+	} G_STMT_END
 
 /*****************************************************************************/
 
@@ -236,7 +232,7 @@ test_tls_import (void)
 	_check_item (s_vpn, NM_OPENVPN_KEY_CONNECTION_TYPE, NM_OPENVPN_CONTYPE_TLS);
 	_check_item (s_vpn, NM_OPENVPN_KEY_DEV, "tun");
 	_check_item (s_vpn, NM_OPENVPN_KEY_PROTO_TCP, NULL);
-	_check_item (s_vpn, NM_OPENVPN_KEY_COMP_LZO, "yes");
+	_check_item (s_vpn, NM_OPENVPN_KEY_COMP_LZO, "adaptive");
 	_check_item (s_vpn, NM_OPENVPN_KEY_FLOAT, "yes");
 	_check_item (s_vpn, NM_OPENVPN_KEY_RENEG_SECONDS, NULL);
 	_check_item (s_vpn, NM_OPENVPN_KEY_REMOTE, "173.8.149.245:1194");
@@ -329,7 +325,7 @@ test_tls_inline_import (void)
 	_check_item (s_vpn, NM_OPENVPN_KEY_CONNECTION_TYPE, NM_OPENVPN_CONTYPE_TLS);
 	_check_item (s_vpn, NM_OPENVPN_KEY_DEV, "tun");
 	_check_item (s_vpn, NM_OPENVPN_KEY_PROTO_TCP, NULL);
-	_check_item (s_vpn, NM_OPENVPN_KEY_COMP_LZO, "yes");
+	_check_item (s_vpn, NM_OPENVPN_KEY_COMP_LZO, "adaptive");
 	_check_item (s_vpn, NM_OPENVPN_KEY_FLOAT, "yes");
 	_check_item (s_vpn, NM_OPENVPN_KEY_RENEG_SECONDS, NULL);
 	_check_item (s_vpn, NM_OPENVPN_KEY_REMOTE, "173.8.149.245:1194");
@@ -423,7 +419,7 @@ test_pkcs12_import (void)
 	_check_item (s_vpn, NM_OPENVPN_KEY_CONNECTION_TYPE, NM_OPENVPN_CONTYPE_TLS);
 	_check_item (s_vpn, NM_OPENVPN_KEY_DEV, "tun");
 	_check_item (s_vpn, NM_OPENVPN_KEY_PROTO_TCP, NULL);
-	_check_item (s_vpn, NM_OPENVPN_KEY_COMP_LZO, "yes");
+	_check_item (s_vpn, NM_OPENVPN_KEY_COMP_LZO, "adaptive");
 	_check_item (s_vpn, NM_OPENVPN_KEY_FLOAT, NULL);
 	_check_item (s_vpn, NM_OPENVPN_KEY_RENEG_SECONDS, NULL);
 	_check_item (s_vpn, NM_OPENVPN_KEY_REMOTE, "173.8.149.245:1194");
@@ -1115,7 +1111,7 @@ test_route_import (void)
 	/* IP4 setting */
 	s_ip4 = nm_connection_get_setting_ip4_config (connection);
 	g_assert (s_ip4);
-#ifdef NM_OPENVPN_OLD
+#ifdef NM_VPN_OLD
 	{
 		NMIP4Route *route;
 		const char *expected_nh2   = "0.0.0.0";
diff --git shared/Makefile.am shared/Makefile.am
index f9a7a5e..22d36c4 100644
--- shared/Makefile.am
+++ shared/Makefile.am
@@ -1,38 +1,62 @@
-noinst_LTLIBRARIES=libnm-vpn-plugin-openvpn-shared.la
+noinst_LTLIBRARIES = \
+	libnm-vpn-plugin-openvpn-shared.la \
+	libnm-vpn-editor-utils-shared.la
 if WITH_LIBNM_GLIB
 noinst_LTLIBRARIES += libnm-openvpn-shared.la
 endif
 
+shared_sources = \
+    nm-utils/nm-shared-utils.c \
+    nm-utils/nm-shared-utils.h \
+    utils.c \
+    utils.h \
+    nm-service-defines.h
+
+###############################################################################
+
 libnm_vpn_plugin_openvpn_shared_la_CPPFLAGS = \
     $(LIBNM_CFLAGS) \
     -I$(top_srcdir)/shared
 
-libnm_openvpn_shared_la_CPPFLAGS = \
-    -DNM_OPENVPN_OLD \
-    $(LIBNM_GLIB_CFLAGS) \
-    -I$(top_srcdir)/shared
-
 libnm_vpn_plugin_openvpn_shared_la_SOURCES= \
-    nm-shared-utils.c \
-    nm-shared-utils.h \
-    utils.c \
-    utils.h \
-    nm-openvpn-service-defines.h
-
-libnm_openvpn_shared_la_SOURCES = \
-    $(libnm_vpn_plugin_openvpn_shared_la_SOURCES)
+    $(shared_sources)
 
 libnm_vpn_plugin_openvpn_shared_la_LIBADD = \
     $(LIBNM_LIBS)
 
+###############################################################################
+
+libnm_openvpn_shared_la_SOURCES = \
+    $(shared_sources)
+
+libnm_openvpn_shared_la_CPPFLAGS = \
+    -DNM_VPN_OLD \
+    $(LIBNM_GLIB_CFLAGS) \
+    -I$(top_srcdir)/shared
+
 libnm_openvpn_shared_la_LIBADD = \
     $(LIBNM_GLIB_LIBS)
 
+###############################################################################
+
+libnm_vpn_editor_utils_shared_la_CPPFLAGS = \
+    $(LIBNM_CFLAGS) \
+    -I$(top_srcdir)/shared
+
+libnm_vpn_editor_utils_shared_la_SOURCES = \
+    nm-vpn/nm-vpn-plugin-utils.c \
+    nm-vpn/nm-vpn-plugin-utils.h
+
+libnm_vpn_editor_utils_shared_la_LIBADD = \
+    $(LIBNM_LIBS) \
+    -ldl
+
+###############################################################################
+
 EXTRA_DIST = \
-     gsystem-local-alloc.h \
-     nm-dbus-compat.h \
-     nm-default.h \
-     nm-glib.h \
-     nm-macros-internal.h \
-     nm-test-utils.h
+     nm-utils/gsystem-local-alloc.h \
+     nm-utils/nm-glib.h \
+     nm-utils/nm-macros-internal.h \
+     nm-utils/nm-test-utils.h \
+     nm-default.h
 
diff --git shared/README shared/README
new file mode 100644
index 0000000..e7a2dff
--- /dev/null
+++ shared/README
@@ -0,0 +1,24 @@
+The files in the "shared/" directory are supposed to be shared
+across NetworkManager related projects (reuse-by-copying).
+
+(1) the files
+    shared/nm-utils/gsystem-local-alloc.h
+    shared/nm-utils/nm-glib.h
+    shared/nm-utils/nm-macros-internal.h
+    shared/nm-utils/nm-shared-utils.c
+    shared/nm-utils/nm-shared-utils.h
+    shared/nm-utils/nm-test-utils.h
+are copied as-is from NetworkManager
+  https://cgit.freedesktop.org/NetworkManager/NetworkManager/tree/shared?id=9770024f63b85da604f1134a8bc8dc968278dcd1
+
+2) the files
+    shared/nm-vpn/nm-vpn-plugin-utils.c
+    shared/nm-vpn/nm-vpn-plugin-utils.h
+are copied as-is from nm-openvpn
+  https://git.gnome.org/browse/network-manager-openvpn/tree/shared?id=3d0ac3ca94b4bf24f77306cef5a95172ddaf5fc4
+
+
+Do *not* modify these files locally so that they don't diverge.
+Fix/extend them in their respective origin first, and re-import
+the files as a whole.
+
diff --git shared/gsystem-local-alloc.h shared/gsystem-local-alloc.h
deleted file mode 100644
index 51b6251..0000000
--- shared/gsystem-local-alloc.h
+++ /dev/null
@@ -1,208 +0,0 @@
-/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*-
- *
- * Copyright (C) 2012 Colin Walters <walters@verbum.org>.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef __GSYSTEM_LOCAL_ALLOC_H__
-#define __GSYSTEM_LOCAL_ALLOC_H__
-
-#include <gio/gio.h>
-
-G_BEGIN_DECLS
-
-#define GS_DEFINE_CLEANUP_FUNCTION(Type, name, func) \
-  static inline void name (void *v) \
-  { \
-    func (*(Type*)v); \
-  }
-
-#define GS_DEFINE_CLEANUP_FUNCTION0(Type, name, func) \
-  static inline void name (void *v) \
-  { \
-    if (*(Type*)v) \
-      func (*(Type*)v); \
-  }
-
-/* These functions shouldn't be invoked directly;
- * they are stubs that:
- * 1) Take a pointer to the location (typically itself a pointer).
- * 2) Provide %NULL-safety where it doesn't exist already (e.g. g_object_unref)
- */
-
-/**
- * gs_free:
- *
- * Call g_free() on a variable location when it goes out of scope.
- */
-#define gs_free __attribute__ ((cleanup(gs_local_free)))
-GS_DEFINE_CLEANUP_FUNCTION(void*, gs_local_free, g_free)
-
-/**
- * gs_unref_object:
- *
- * Call g_object_unref() on a variable location when it goes out of
- * scope.  Note that unlike g_object_unref(), the variable may be
- * %NULL.
- */
-#define gs_unref_object __attribute__ ((cleanup(gs_local_obj_unref)))
-GS_DEFINE_CLEANUP_FUNCTION0(GObject*, gs_local_obj_unref, g_object_unref)
-
-/**
- * gs_unref_variant:
- *
- * Call g_variant_unref() on a variable location when it goes out of
- * scope.  Note that unlike g_variant_unref(), the variable may be
- * %NULL.
- */
-#define gs_unref_variant __attribute__ ((cleanup(gs_local_variant_unref)))
-GS_DEFINE_CLEANUP_FUNCTION0(GVariant*, gs_local_variant_unref, g_variant_unref)
-
-/**
- * gs_free_variant_iter:
- *
- * Call g_variant_iter_free() on a variable location when it goes out of
- * scope.
- */
-#define gs_free_variant_iter __attribute__ ((cleanup(gs_local_variant_iter_free)))
-GS_DEFINE_CLEANUP_FUNCTION0(GVariantIter*, gs_local_variant_iter_free, g_variant_iter_free)
-
-/**
- * gs_free_variant_builder:
- *
- * Call g_variant_builder_unref() on a variable location when it goes out of
- * scope.
- */
-#define gs_unref_variant_builder __attribute__ ((cleanup(gs_local_variant_builder_unref)))
-GS_DEFINE_CLEANUP_FUNCTION0(GVariantBuilder*, gs_local_variant_builder_unref, g_variant_builder_unref)
-
-/**
- * gs_unref_array:
- *
- * Call g_array_unref() on a variable location when it goes out of
- * scope.  Note that unlike g_array_unref(), the variable may be
- * %NULL.
-
- */
-#define gs_unref_array __attribute__ ((cleanup(gs_local_array_unref)))
-GS_DEFINE_CLEANUP_FUNCTION0(GArray*, gs_local_array_unref, g_array_unref)
-
-/**
- * gs_unref_ptrarray:
- *
- * Call g_ptr_array_unref() on a variable location when it goes out of
- * scope.  Note that unlike g_ptr_array_unref(), the variable may be
- * %NULL.
-
- */
-#define gs_unref_ptrarray __attribute__ ((cleanup(gs_local_ptrarray_unref)))
-GS_DEFINE_CLEANUP_FUNCTION0(GPtrArray*, gs_local_ptrarray_unref, g_ptr_array_unref)
-
-/**
- * gs_unref_hashtable:
- *
- * Call g_hash_table_unref() on a variable location when it goes out
- * of scope.  Note that unlike g_hash_table_unref(), the variable may
- * be %NULL.
- */
-#define gs_unref_hashtable __attribute__ ((cleanup(gs_local_hashtable_unref)))
-GS_DEFINE_CLEANUP_FUNCTION0(GHashTable*, gs_local_hashtable_unref, g_hash_table_unref)
-
-/**
- * gs_free_list:
- *
- * Call g_list_free() on a variable location when it goes out
- * of scope.
- */
-#define gs_free_list __attribute__ ((cleanup(gs_local_free_list)))
-GS_DEFINE_CLEANUP_FUNCTION(GList*, gs_local_free_list, g_list_free)
-
-/**
- * gs_free_slist:
- *
- * Call g_slist_free() on a variable location when it goes out
- * of scope.
- */
-#define gs_free_slist __attribute__ ((cleanup(gs_local_free_slist)))
-GS_DEFINE_CLEANUP_FUNCTION(GSList*, gs_local_free_slist, g_slist_free)
-
-/**
- * gs_free_checksum:
- *
- * Call g_checksum_free() on a variable location when it goes out
- * of scope.  Note that unlike g_checksum_free(), the variable may
- * be %NULL.
- */
-#define gs_free_checksum __attribute__ ((cleanup(gs_local_checksum_free)))
-GS_DEFINE_CLEANUP_FUNCTION0(GChecksum*, gs_local_checksum_free, g_checksum_free)
-
-/**
- * gs_unref_bytes:
- *
- * Call g_bytes_unref() on a variable location when it goes out
- * of scope.  Note that unlike g_bytes_unref(), the variable may
- * be %NULL.
- */
-#define gs_unref_bytes __attribute__ ((cleanup(gs_local_bytes_unref)))
-GS_DEFINE_CLEANUP_FUNCTION0(GBytes*, gs_local_bytes_unref, g_bytes_unref)
-
-/**
- * gs_strfreev:
- *
- * Call g_strfreev() on a variable location when it goes out of scope.
- */
-#define gs_strfreev __attribute__ ((cleanup(gs_local_strfreev)))
-GS_DEFINE_CLEANUP_FUNCTION(char**, gs_local_strfreev, g_strfreev)
-
-/**
- * gs_free_error:
- *
- * Call g_error_free() on a variable location when it goes out of scope.
- */
-#define gs_free_error __attribute__ ((cleanup(gs_local_free_error)))
-GS_DEFINE_CLEANUP_FUNCTION0(GError*, gs_local_free_error, g_error_free)
-
-/**
- * gs_unref_keyfile:
- *
- * Call g_key_file_unref() on a variable location when it goes out of scope.
- */
-#define gs_unref_keyfile __attribute__ ((cleanup(gs_local_keyfile_unref)))
-GS_DEFINE_CLEANUP_FUNCTION0(GKeyFile*, gs_local_keyfile_unref, g_key_file_unref)
-
-static inline void
-gs_cleanup_close_fdp (int *fdp)
-{
-  int fd;
-
-  g_assert (fdp);
-  
-  fd = *fdp;
-  if (fd != -1)
-    (void) close (fd);
-}
-
-/**
- * gs_fd_close:
- *
- * Call close() on a variable location when it goes out of scope.
- */
-#define gs_fd_close __attribute__((cleanup(gs_cleanup_close_fdp)))
-
-G_END_DECLS
-
-#endif
diff --git shared/nm-dbus-compat.h shared/nm-dbus-compat.h
deleted file mode 100644
index dd97b5f..0000000
--- shared/nm-dbus-compat.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright 2015 Red Hat, Inc.
- */
-
-#ifndef __NM_DBUS_COMPAT_H__
-#define __NM_DBUS_COMPAT_H__
-
-/* Copied from <dbus/dbus-shared.h> */
-
-/* Bus names */
-
-/** The bus name used to talk to the bus itself. */
-#define DBUS_SERVICE_DBUS      "org.freedesktop.DBus"
-
-/* Paths */
-/** The object path used to talk to the bus itself. */
-#define DBUS_PATH_DBUS  "/org/freedesktop/DBus"
-/** The object path used in local/in-process-generated messages. */
-#define DBUS_PATH_LOCAL "/org/freedesktop/DBus/Local"
-
-/* Interfaces, these #define don't do much other than
- * catch typos at compile time
- */
-/** The interface exported by the object with #DBUS_SERVICE_DBUS and #DBUS_PATH_DBUS */
-#define DBUS_INTERFACE_DBUS           "org.freedesktop.DBus"
-/** The interface supported by introspectable objects */
-#define DBUS_INTERFACE_INTROSPECTABLE "org.freedesktop.DBus.Introspectable"
-/** The interface supported by objects with properties */
-#define DBUS_INTERFACE_PROPERTIES     "org.freedesktop.DBus.Properties"
-/** The interface supported by most dbus peers */
-#define DBUS_INTERFACE_PEER           "org.freedesktop.DBus.Peer"
-
-/** This is a special interface whose methods can only be invoked
- * by the local implementation (messages from remote apps aren't
- * allowed to specify this interface).
- */
-#define DBUS_INTERFACE_LOCAL "org.freedesktop.DBus.Local"
-
-/* Owner flags */
-#define DBUS_NAME_FLAG_ALLOW_REPLACEMENT 0x1 /**< Allow another service to become the primary owner if requested */
-#define DBUS_NAME_FLAG_REPLACE_EXISTING  0x2 /**< Request to replace the current primary owner */
-#define DBUS_NAME_FLAG_DO_NOT_QUEUE      0x4 /**< If we can not become the primary owner do not place us in the queue */
-
-/* Replies to request for a name */
-#define DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER  1 /**< Service has become the primary owner of the requested name */
-#define DBUS_REQUEST_NAME_REPLY_IN_QUEUE       2 /**< Service could not become the primary owner and has been placed in the queue */
-#define DBUS_REQUEST_NAME_REPLY_EXISTS         3 /**< Service is already in the queue */
-#define DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER  4 /**< Service is already the primary owner */
-
-/* Replies to releasing a name */
-#define DBUS_RELEASE_NAME_REPLY_RELEASED        1 /**< Service was released from the given name */
-#define DBUS_RELEASE_NAME_REPLY_NON_EXISTENT    2 /**< The given name does not exist on the bus */
-#define DBUS_RELEASE_NAME_REPLY_NOT_OWNER       3 /**< Service is not an owner of the given name */
-
-/* Replies to service starts */
-#define DBUS_START_REPLY_SUCCESS         1 /**< Service was auto started */
-#define DBUS_START_REPLY_ALREADY_RUNNING 2 /**< Service was already running */
-
-#endif  /* __NM_DBUS_COMPAT_H__ */
diff --git shared/nm-default.h shared/nm-default.h
index 0567727..139dc74 100644
--- shared/nm-default.h
+++ shared/nm-default.h
@@ -25,7 +25,9 @@
 /* makefiles define NETWORKMANAGER_COMPILATION for compiling NetworkManager.
  * Depending on which parts are compiled, different values are set. */
 #define NM_NETWORKMANAGER_COMPILATION_DEFAULT             0x0001
-#define NM_NETWORKMANAGER_COMPILATION_LIB                 0x0002
+#define NM_NETWORKMANAGER_COMPILATION_LIB_BASE            0x0002
+#define NM_NETWORKMANAGER_COMPILATION_LIB_EDITOR          0x0004
+#define NM_NETWORKMANAGER_COMPILATION_LIB                 (0x0002 | 0x0004)
 
 #ifndef NETWORKMANAGER_COMPILATION
 /* For convenience, we don't require our Makefile.am to define
@@ -36,16 +38,20 @@
 
 /*****************************************************************************/
 
+#include <config.h>
+
 /* always include these headers for our internal source files. */
 
-#include "nm-glib.h"
+#include "nm-utils/nm-glib.h"
+#include "nm-utils/gsystem-local-alloc.h"
+#include "nm-utils/nm-macros-internal.h"
+
 #include "nm-version.h"
-#include "gsystem-local-alloc.h"
-#include "nm-macros-internal.h"
+#include "nm-service-defines.h"
 
 /*****************************************************************************/
 
-#if (NETWORKMANAGER_COMPILATION) == NM_NETWORKMANAGER_COMPILATION_LIB
+#if ((NETWORKMANAGER_COMPILATION) & NM_NETWORKMANAGER_COMPILATION_LIB)
 
 #include <glib/gi18n-lib.h>
 
@@ -57,9 +63,10 @@
 
 /*****************************************************************************/
 
-#ifdef NM_OPENVPN_OLD
+#ifdef NM_VPN_OLD
 
 #define NM_VPN_LIBNM_COMPAT
+#include <nm-connection.h>
 #include <nm-setting-connection.h>
 #include <nm-setting-8021x.h>
 #include <nm-setting-ip4-config.h>
@@ -72,86 +79,39 @@
 #define NM_SETTING_IP_CONFIG_METHOD NM_SETTING_IP4_CONFIG_METHOD
 #define NMSettingIPConfig NMSettingIP4Config
 
-#define OPENVPN_EDITOR_PLUGIN_ERROR                     NM_SETTING_VPN_ERROR
-#define OPENVPN_EDITOR_PLUGIN_ERROR_FAILED              NM_SETTING_VPN_ERROR_UNKNOWN
-#define OPENVPN_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY    NM_SETTING_VPN_ERROR_INVALID_PROPERTY
-#define OPENVPN_EDITOR_PLUGIN_ERROR_MISSING_PROPERTY    NM_SETTING_VPN_ERROR_MISSING_PROPERTY
-#define OPENVPN_EDITOR_PLUGIN_ERROR_FILE_NOT_OPENVPN    NM_SETTING_VPN_ERROR_UNKNOWN
-#define OPENVPN_EDITOR_PLUGIN_ERROR_FILE_NOT_READABLE   NM_SETTING_VPN_ERROR_UNKNOWN
-#define OPENVPN_EDITOR_PLUGIN_ERROR_FILE_INVALID        NM_SETTING_VPN_ERROR_UNKNOWN
+#define NMV_EDITOR_PLUGIN_ERROR                     NM_SETTING_VPN_ERROR
+#define NMV_EDITOR_PLUGIN_ERROR_FAILED              NM_SETTING_VPN_ERROR_UNKNOWN
+#define NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY    NM_SETTING_VPN_ERROR_INVALID_PROPERTY
+#define NMV_EDITOR_PLUGIN_ERROR_MISSING_PROPERTY    NM_SETTING_VPN_ERROR_MISSING_PROPERTY
+#define NMV_EDITOR_PLUGIN_ERROR_FILE_NOT_VPN        NM_SETTING_VPN_ERROR_UNKNOWN
+#define NMV_EDITOR_PLUGIN_ERROR_FILE_NOT_READABLE   NM_SETTING_VPN_ERROR_UNKNOWN
+#define NMV_EDITOR_PLUGIN_ERROR_FILE_INVALID        NM_SETTING_VPN_ERROR_UNKNOWN
 
-#else /* !NM_OPENVPN_OLD */
+#else /* !NM_VPN_OLD */
 
 #include <NetworkManager.h>
 
-#define OPENVPN_EDITOR_PLUGIN_ERROR                     NM_CONNECTION_ERROR
-#define OPENVPN_EDITOR_PLUGIN_ERROR_FAILED              NM_CONNECTION_ERROR_FAILED
-#define OPENVPN_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY    NM_CONNECTION_ERROR_INVALID_PROPERTY
-#define OPENVPN_EDITOR_PLUGIN_ERROR_MISSING_PROPERTY    NM_CONNECTION_ERROR_MISSING_PROPERTY
-#define OPENVPN_EDITOR_PLUGIN_ERROR_FILE_NOT_OPENVPN    NM_CONNECTION_ERROR_FAILED
-#define OPENVPN_EDITOR_PLUGIN_ERROR_FILE_NOT_READABLE   NM_CONNECTION_ERROR_FAILED
-#define OPENVPN_EDITOR_PLUGIN_ERROR_FILE_INVALID        NM_CONNECTION_ERROR_FAILED
+#define NMV_EDITOR_PLUGIN_ERROR                     NM_CONNECTION_ERROR
+#define NMV_EDITOR_PLUGIN_ERROR_FAILED              NM_CONNECTION_ERROR_FAILED
+#define NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY    NM_CONNECTION_ERROR_INVALID_PROPERTY
+#define NMV_EDITOR_PLUGIN_ERROR_MISSING_PROPERTY    NM_CONNECTION_ERROR_MISSING_PROPERTY
+#define NMV_EDITOR_PLUGIN_ERROR_FILE_NOT_VPN        NM_CONNECTION_ERROR_FAILED
+#define NMV_EDITOR_PLUGIN_ERROR_FILE_NOT_READABLE   NM_CONNECTION_ERROR_FAILED
+#define NMV_EDITOR_PLUGIN_ERROR_FILE_INVALID        NM_CONNECTION_ERROR_FAILED
 
-#endif /* NM_OPENVPN_OLD */
+#endif /* NM_VPN_OLD */
 
 /*****************************************************************************/
 
-#if (NETWORKMANAGER_COMPILATION) == NM_NETWORKMANAGER_COMPILATION_LIB
+#if (NETWORKMANAGER_COMPILATION) & NM_NETWORKMANAGER_COMPILATION_LIB_EDITOR
 
-#ifdef NM_OPENVPN_OLD
+#ifdef NM_VPN_OLD
 #include <nm-ui-utils.h>
-#else /* NM_OPENVPN_OLD */
+#else /* NM_VPN_OLD */
 #include <nma-ui-utils.h>
-#endif /* NM_OPENVPN_OLD */
-
-#endif /* NM_NETWORKMANAGER_COMPILATION_LIB */
+#endif /* NM_VPN_OLD */
 
-/*****************************************************************************/
-
-/**
- * The boolean type _Bool is C99 while we mostly stick to C89. However, _Bool is too
- * convinient to miss and is effectively available in gcc and clang. So, just use it.
- *
- * Usually, one would include "stdbool.h" to get the "bool" define which aliases
- * _Bool. We provide this define here, because we want to make use of it anywhere.
- * (also, stdbool.h is again C99).
- *
- * Using _Bool has advantages over gboolean:
- *
- * - commonly _Bool is one byte large, instead of gboolean's 4 bytes (because gboolean
- *   is a typedef for gint). Especially when having boolean fields in a struct, we can
- *   thereby easily save some space.
- *
- * - _Bool type guarantees that two "true" expressions compare equal. E.g. the follwing
- *   will not work:
- *        gboolean v1 = 1;
- *        gboolean v2 = 2;
- *        g_assert_cmpint (v1, ==, v2); // will fail
- *   For that, we often to use !! to coerce gboolean values to 0 or 1:
- *        g_assert_cmpint (!!v2, ==, TRUE);
- *   With _Bool type, this will be handled properly by the compiler.
- *
- * - For structs, we might want to safe even more space and use bitfields:
- *       struct s1 {
- *           gboolean v1:1;
- *       };
- *   But the problem here is that gboolean is signed, so that
- *   v1 will be either 0 or -1 (not 1, TRUE). Thus, the following
- *   fails:
- *      struct s1 s = { .v1 = TRUE, };
- *      g_assert_cmpint (s1.v1, ==, TRUE);
- *   It will however work just fine with bool/_Bool while retaining the
- *   notion of having a boolean value.
- *
- * Also, add the defines for "true" and "false". Those are nicely highlighted by the editor
- * as special types, contrary to glib's "TRUE"/"FALSE".
- */
-
-#ifndef bool
-#define bool _Bool
-#define true    1
-#define false   0
-#endif
+#endif /* NM_NETWORKMANAGER_COMPILATION_LIB_EDITOR */
 
 /*****************************************************************************/
 
diff --git shared/nm-glib.h shared/nm-glib.h
deleted file mode 100644
index c92d6f0..0000000
--- shared/nm-glib.h
+++ /dev/null
@@ -1,377 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright 2008 - 2011 Red Hat, Inc.
- */
-
-#ifndef __NM_GLIB_H__
-#define __NM_GLIB_H__
-
-
-#include <gio/gio.h>
-#include <string.h>
-
-#ifdef __clang__
-
-#undef G_GNUC_BEGIN_IGNORE_DEPRECATIONS
-#undef G_GNUC_END_IGNORE_DEPRECATIONS
-
-#define G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
-    _Pragma("clang diagnostic push") \
-    _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
-
-#define G_GNUC_END_IGNORE_DEPRECATIONS \
-    _Pragma("clang diagnostic pop")
-
-#endif
-
-static inline void
-__g_type_ensure (GType type)
-{
-#if !GLIB_CHECK_VERSION(2,34,0)
-	if (G_UNLIKELY (type == (GType)-1))
-		g_error ("can't happen");
-#else
-	G_GNUC_BEGIN_IGNORE_DEPRECATIONS;
-	g_type_ensure (type);
-	G_GNUC_END_IGNORE_DEPRECATIONS;
-#endif
-}
-#define g_type_ensure __g_type_ensure
-
-#if !GLIB_CHECK_VERSION(2,34,0)
-
-#define g_clear_pointer(pp, destroy) \
-    G_STMT_START {                                                                 \
-        G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));                       \
-        /* Only one access, please */                                              \
-        gpointer *_pp = (gpointer *) (pp);                                         \
-        gpointer _p;                                                               \
-        /* This assignment is needed to avoid a gcc warning */                     \
-        GDestroyNotify _destroy = (GDestroyNotify) (destroy);                      \
-                                                                                   \
-        _p = *_pp;                                                                 \
-        if (_p)                                                                    \
-        {                                                                          \
-            *_pp = NULL;                                                           \
-            _destroy (_p);                                                         \
-        }                                                                          \
-    } G_STMT_END
-
-/* These are used to clean up the output of test programs; we can just let
- * them no-op in older glib.
- */
-#define g_test_expect_message(log_domain, log_level, pattern)
-#define g_test_assert_expected_messages()
-
-#else
-
-/* We build with -DGLIB_MAX_ALLOWED_VERSION set to 2.32 to make sure we don't
- * accidentally use new API that we shouldn't. But we don't want warnings for
- * the APIs that we emulate above.
- */
-
-#define g_test_expect_message(domain, level, format...) \
-	G_STMT_START { \
-		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
-		g_test_expect_message (domain, level, format); \
-		G_GNUC_END_IGNORE_DEPRECATIONS \
-	} G_STMT_END
-
-#define g_test_assert_expected_messages_internal(domain, file, line, func) \
-	G_STMT_START { \
-		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
-		g_test_assert_expected_messages_internal (domain, file, line, func); \
-		G_GNUC_END_IGNORE_DEPRECATIONS \
-	} G_STMT_END
-
-#endif
-
-
-#if GLIB_CHECK_VERSION (2, 35, 0)
-/* For glib >= 2.36, g_type_init() is deprecated.
- * But since 2.35.1 (7c42ab23b55c43ab96d0ac2124b550bf1f49c1ec) this function
- * does nothing. Replace the call with empty statement. */
-#define nm_g_type_init()     G_STMT_START { (void) 0; } G_STMT_END
-#else
-#define nm_g_type_init()     G_STMT_START { g_type_init (); } G_STMT_END
-#endif
-
-
-/* g_test_initialized() is only available since glib 2.36. */
-#if !GLIB_CHECK_VERSION (2, 36, 0)
-#define g_test_initialized() (g_test_config_vars->test_initialized)
-#endif
-
-/* g_assert_cmpmem() is only available since glib 2.46. */
-#if !GLIB_CHECK_VERSION (2, 45, 7)
-#define g_assert_cmpmem(m1, l1, m2, l2) G_STMT_START {\
-                                             gconstpointer __m1 = m1, __m2 = m2; \
-                                             int __l1 = l1, __l2 = l2; \
-                                             if (__l1 != __l2) \
-                                               g_assertion_message_cmpnum (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
-                                                                           #l1 " (len(" #m1 ")) == " #l2 " (len(" #m2 "))", __l1, "==", __l2, 'i'); \
-                                             else if (memcmp (__m1, __m2, __l1) != 0) \
-                                               g_assertion_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
-                                                                    "assertion failed (" #m1 " == " #m2 ")"); \
-                                        } G_STMT_END
-#endif
-
-/* Rumtime check for glib version. First do a compile time check which
- * (if satisfied) shortcuts the runtime check. */
-#define nm_glib_check_version(major, minor, micro) \
-    (   GLIB_CHECK_VERSION ((major), (minor), (micro)) \
-     || (   (   glib_major_version > (major)) \
-         || (   glib_major_version == (major) \
-             && glib_minor_version > (minor)) \
-         || (   glib_major_version == (major) \
-             && glib_minor_version == (minor) \
-             && glib_micro_version >= (micro))))
-
-/* g_test_skip() is only available since glib 2.38. Add a compatibility wrapper. */
-inline static void
-__nmtst_g_test_skip (const gchar *msg)
-{
-#if GLIB_CHECK_VERSION (2, 38, 0)
-	G_GNUC_BEGIN_IGNORE_DEPRECATIONS
-	g_test_skip (msg);
-	G_GNUC_END_IGNORE_DEPRECATIONS
-#else
-	g_debug ("%s", msg);
-#endif
-}
-#define g_test_skip __nmtst_g_test_skip
-
-
-/* g_test_add_data_func_full() is only available since glib 2.34. Add a compatibility wrapper. */
-inline static void
-__g_test_add_data_func_full (const char     *testpath,
-                             gpointer        test_data,
-                             GTestDataFunc   test_func,
-                             GDestroyNotify  data_free_func)
-{
-#if GLIB_CHECK_VERSION (2, 34, 0)
-	G_GNUC_BEGIN_IGNORE_DEPRECATIONS
-	g_test_add_data_func_full (testpath, test_data, test_func, data_free_func);
-	G_GNUC_END_IGNORE_DEPRECATIONS
-#else
-	g_return_if_fail (testpath != NULL);
-	g_return_if_fail (testpath[0] == '/');
-	g_return_if_fail (test_func != NULL);
-
-	g_test_add_vtable (testpath, 0, test_data, NULL,
-	                   (GTestFixtureFunc) test_func,
-	                   (GTestFixtureFunc) data_free_func);
-#endif
-}
-#define g_test_add_data_func_full __g_test_add_data_func_full
-
-
-#if !GLIB_CHECK_VERSION (2, 34, 0)
-#define G_DEFINE_QUARK(QN, q_n)               \
-GQuark                                        \
-q_n##_quark (void)                            \
-{                                             \
-	static GQuark q;                          \
-                                              \
-	if G_UNLIKELY (q == 0)                    \
-		q = g_quark_from_static_string (#QN); \
-                                              \
-	return q;                                 \
-}
-#endif
-
-
-static inline gboolean
-nm_g_hash_table_replace (GHashTable *hash, gpointer key, gpointer value)
-{
-	/* glib 2.40 added a return value indicating whether the key already existed
-	 * (910191597a6c2e5d5d460e9ce9efb4f47d9cc63c). */
-#if GLIB_CHECK_VERSION(2, 40, 0)
-	return g_hash_table_replace (hash, key, value);
-#else
-	gboolean contained = g_hash_table_contains (hash, key);
-
-	g_hash_table_replace (hash, key, value);
-	return !contained;
-#endif
-}
-
-static inline gboolean
-nm_g_hash_table_insert (GHashTable *hash, gpointer key, gpointer value)
-{
-	/* glib 2.40 added a return value indicating whether the key already existed
-	 * (910191597a6c2e5d5d460e9ce9efb4f47d9cc63c). */
-#if GLIB_CHECK_VERSION(2, 40, 0)
-	return g_hash_table_insert (hash, key, value);
-#else
-	gboolean contained = g_hash_table_contains (hash, key);
-
-	g_hash_table_insert (hash, key, value);
-	return !contained;
-#endif
-}
-
-static inline gboolean
-nm_g_hash_table_add (GHashTable *hash, gpointer key)
-{
-	/* glib 2.40 added a return value indicating whether the key already existed
-	 * (910191597a6c2e5d5d460e9ce9efb4f47d9cc63c). */
-#if GLIB_CHECK_VERSION(2, 40, 0)
-	return g_hash_table_add (hash, key);
-#else
-	gboolean contained = g_hash_table_contains (hash, key);
-
-	g_hash_table_add (hash, key);
-	return !contained;
-#endif
-}
-
-#if !GLIB_CHECK_VERSION(2, 40, 0) || defined (NM_GLIB_COMPAT_H_TEST)
-static inline void
-_nm_g_ptr_array_insert (GPtrArray *array,
-                        gint       index_,
-                        gpointer   data)
-{
-	g_return_if_fail (array);
-	g_return_if_fail (index_ >= -1);
-	g_return_if_fail (index_ <= (gint) array->len);
-
-	g_ptr_array_add (array, data);
-
-	if (index_ != -1 && index_ != (gint) (array->len - 1)) {
-		memmove (&(array->pdata[index_ + 1]),
-		         &(array->pdata[index_]),
-		         (array->len - index_ - 1) * sizeof (gpointer));
-		array->pdata[index_] = data;
-	}
-}
-#endif
-#if !GLIB_CHECK_VERSION(2, 40, 0)
-#define g_ptr_array_insert(array, index, data) G_STMT_START { _nm_g_ptr_array_insert (array, index, data); } G_STMT_END
-#else
-#define g_ptr_array_insert(array, index, data) \
-	G_STMT_START { \
-		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
-		g_ptr_array_insert (array, index, data); \
-		G_GNUC_END_IGNORE_DEPRECATIONS \
-	} G_STMT_END
-#endif
-
-
-#if !GLIB_CHECK_VERSION (2, 40, 0)
-inline static gboolean
-_g_key_file_save_to_file (GKeyFile     *key_file,
-                          const gchar  *filename,
-                          GError      **error)
-{
-	gchar *contents;
-	gboolean success;
-	gsize length;
-
-	g_return_val_if_fail (key_file != NULL, FALSE);
-	g_return_val_if_fail (filename != NULL, FALSE);
-	g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
-
-	contents = g_key_file_to_data (key_file, &length, NULL);
-	g_assert (contents != NULL);
-
-	success = g_file_set_contents (filename, contents, length, error);
-	g_free (contents);
-
-	return success;
-}
-#define g_key_file_save_to_file(key_file, filename, error) \
-	_g_key_file_save_to_file (key_file, filename, error)
-#else
-#define g_key_file_save_to_file(key_file, filename, error) \
-	({ \
-		gboolean _success; \
-		\
-		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
-		_success = g_key_file_save_to_file (key_file, filename, error); \
-		G_GNUC_END_IGNORE_DEPRECATIONS \
-		_success; \
-	})
-#endif
-
-
-#if GLIB_CHECK_VERSION (2, 36, 0)
-#define g_credentials_get_unix_pid(creds, error) \
-	G_GNUC_EXTENSION ({ \
-		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
-			(g_credentials_get_unix_pid) ((creds), (error)); \
-		G_GNUC_END_IGNORE_DEPRECATIONS \
-	})
-#else
-#define g_credentials_get_unix_pid(creds, error) \
-	G_GNUC_EXTENSION ({ \
-		struct ucred *native_creds; \
-		 \
-		native_creds = g_credentials_get_native ((creds), G_CREDENTIALS_TYPE_LINUX_UCRED); \
-		g_assert (native_creds); \
-		native_creds->pid; \
-	})
-#endif
-
-
-#if !GLIB_CHECK_VERSION(2, 40, 0) || defined (NM_GLIB_COMPAT_H_TEST)
-static inline gpointer *
-_nm_g_hash_table_get_keys_as_array (GHashTable *hash_table,
-                                    guint      *length)
-{
-	GHashTableIter iter;
-	gpointer key, *ret;
-	guint i = 0;
-
-	g_return_val_if_fail (hash_table, NULL);
-
-	ret = g_new0 (gpointer, g_hash_table_size (hash_table) + 1);
-	g_hash_table_iter_init (&iter, hash_table);
-
-	while (g_hash_table_iter_next (&iter, &key, NULL))
-		ret[i++] = key;
-
-	ret[i] = NULL;
-
-	if (length)
-		*length = i;
-
-	return ret;
-}
-#endif
-#if !GLIB_CHECK_VERSION(2, 40, 0)
-#define g_hash_table_get_keys_as_array(hash_table, length) \
-	G_GNUC_EXTENSION ({ \
-		_nm_g_hash_table_get_keys_as_array (hash_table, length); \
-	})
-#else
-#define g_hash_table_get_keys_as_array(hash_table, length) \
-	G_GNUC_EXTENSION ({ \
-		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
-			(g_hash_table_get_keys_as_array) ((hash_table), (length)); \
-		G_GNUC_END_IGNORE_DEPRECATIONS \
-	})
-#endif
-
-#ifndef g_info
-/* g_info was only added with 2.39.2 */
-#define g_info(...)     g_log (G_LOG_DOMAIN,         \
-                               G_LOG_LEVEL_INFO,     \
-                               __VA_ARGS__)
-#endif
-
-#endif  /* __NM_GLIB_H__ */
diff --git shared/nm-macros-internal.h shared/nm-macros-internal.h
deleted file mode 100644
index 4176231..0000000
--- shared/nm-macros-internal.h
+++ /dev/null
@@ -1,564 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301 USA.
- *
- * (C) Copyright 2014 Red Hat, Inc.
- */
-
-#ifndef __NM_MACROS_INTERNAL_H__
-#define __NM_MACROS_INTERNAL_H__
-
-#include <stdlib.h>
-
-/********************************************************/
-
-#define nm_auto(fcn) __attribute ((cleanup(fcn)))
-
-/**
- * nm_auto_free:
- *
- * Call free() on a variable location when it goes out of scope.
- */
-#define nm_auto_free nm_auto(_nm_auto_free_impl)
-GS_DEFINE_CLEANUP_FUNCTION(void*, _nm_auto_free_impl, free)
-
-static inline void
-_nm_auto_unset_gvalue_impl (GValue *v)
-{
-	g_value_unset (v);
-}
-#define nm_auto_unset_gvalue nm_auto(_nm_auto_unset_gvalue_impl)
-
-/********************************************************/
-
-/* http://stackoverflow.com/a/11172679 */
-#define  _NM_UTILS_MACRO_FIRST(...)                           __NM_UTILS_MACRO_FIRST_HELPER(__VA_ARGS__, throwaway)
-#define __NM_UTILS_MACRO_FIRST_HELPER(first, ...)             first
-
-#define  _NM_UTILS_MACRO_REST(...)                            __NM_UTILS_MACRO_REST_HELPER(__NM_UTILS_MACRO_REST_NUM(__VA_ARGS__), __VA_ARGS__)
-#define __NM_UTILS_MACRO_REST_HELPER(qty, ...)                __NM_UTILS_MACRO_REST_HELPER2(qty, __VA_ARGS__)
-#define __NM_UTILS_MACRO_REST_HELPER2(qty, ...)               __NM_UTILS_MACRO_REST_HELPER_##qty(__VA_ARGS__)
-#define __NM_UTILS_MACRO_REST_HELPER_ONE(first)
-#define __NM_UTILS_MACRO_REST_HELPER_TWOORMORE(first, ...)    , __VA_ARGS__
-#define __NM_UTILS_MACRO_REST_NUM(...) \
-    __NM_UTILS_MACRO_REST_SELECT_20TH(__VA_ARGS__, \
-                TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE,\
-                TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE,\
-                TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE,\
-                TWOORMORE, TWOORMORE, TWOORMORE, ONE, throwaway)
-#define __NM_UTILS_MACRO_REST_SELECT_20TH(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, ...) a20
-
-/********************************************************/
-
-/* http://stackoverflow.com/a/2124385/354393 */
-
-#define NM_NARG(...) \
-         _NM_NARG(__VA_ARGS__,_NM_NARG_RSEQ_N())
-#define _NM_NARG(...) \
-         _NM_NARG_ARG_N(__VA_ARGS__)
-#define _NM_NARG_ARG_N( \
-          _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \
-         _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \
-         _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \
-         _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \
-         _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \
-         _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \
-         _61,_62,_63,N,...) N
-#define _NM_NARG_RSEQ_N() \
-         63,62,61,60,                   \
-         59,58,57,56,55,54,53,52,51,50, \
-         49,48,47,46,45,44,43,42,41,40, \
-         39,38,37,36,35,34,33,32,31,30, \
-         29,28,27,26,25,24,23,22,21,20, \
-         19,18,17,16,15,14,13,12,11,10, \
-         9,8,7,6,5,4,3,2,1,0
-
-/********************************************************/
-
-#if defined (__GNUC__)
-#define _NM_PRAGMA_WARNING_DO(warning)       G_STRINGIFY(GCC diagnostic ignored warning)
-#elif defined (__clang__)
-#define _NM_PRAGMA_WARNING_DO(warning)       G_STRINGIFY(clang diagnostic ignored warning)
-#endif
-
-/* you can only suppress a specific warning that the compiler
- * understands. Otherwise you will get another compiler warning
- * about invalid pragma option.
- * It's not that bad however, because gcc and clang often have the
- * same name for the same warning. */
-
-#if defined (__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
-#define NM_PRAGMA_WARNING_DISABLE(warning) \
-        _Pragma("GCC diagnostic push") \
-        _Pragma(_NM_PRAGMA_WARNING_DO(warning))
-#elif defined (__clang__)
-#define NM_PRAGMA_WARNING_DISABLE(warning) \
-        _Pragma("clang diagnostic push") \
-        _Pragma(_NM_PRAGMA_WARNING_DO(warning))
-#else
-#define NM_PRAGMA_WARNING_DISABLE(warning)
-#endif
-
-#if defined (__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
-#define NM_PRAGMA_WARNING_REENABLE \
-    _Pragma("GCC diagnostic pop")
-#elif defined (__clang__)
-#define NM_PRAGMA_WARNING_REENABLE \
-    _Pragma("clang diagnostic pop")
-#else
-#define NM_PRAGMA_WARNING_REENABLE
-#endif
-
-/********************************************************/
-
-/**
- * NM_G_ERROR_MSG:
- * @error: (allow none): the #GError instance
- *
- * All functions must follow the convention that when they
- * return a failure, they must also set the GError to a valid
- * message. For external API however, we want to be extra
- * careful before accessing the error instance. Use NM_G_ERROR_MSG()
- * which is safe to use on NULL.
- *
- * Returns: the error message.
- **/
-static inline const char *
-NM_G_ERROR_MSG (GError *error)
-{
-	return error ? (error->message ? : "(null)") : "(no-error)"; \
-}
-
-/********************************************************/
-
-/* macro to return strlen() of a compile time string. */
-#define NM_STRLEN(str)     ( sizeof ("" str) - 1 )
-
-#define NM_SET_OUT(out_val, value) \
-	G_STMT_START { \
-		typeof(*(out_val)) *_out_val = (out_val); \
-		\
-		if (_out_val) { \
-			*_out_val = (value); \
-		} \
-	} G_STMT_END
-
-/********************************************************/
-
-#define _NM_IN_SET_EVAL_1(op, _x, y1)                               \
-    (_x == (y1))
-
-#define _NM_IN_SET_EVAL_2(op, _x, y1, y2)                           \
-    (   (_x == (y1))                                                \
-     op (_x == (y2))                                                \
-    )
-
-#define _NM_IN_SET_EVAL_3(op, _x, y1, y2, y3)                       \
-    (   (_x == (y1))                                                \
-     op (_x == (y2))                                                \
-     op (_x == (y3))                                                \
-    )
-
-#define _NM_IN_SET_EVAL_4(op, _x, y1, y2, y3, y4)                   \
-    (   (_x == (y1))                                                \
-     op (_x == (y2))                                                \
-     op (_x == (y3))                                                \
-     op (_x == (y4))                                                \
-    )
-
-#define _NM_IN_SET_EVAL_5(op, _x, y1, y2, y3, y4, y5)               \
-    (   (_x == (y1))                                                \
-     op (_x == (y2))                                                \
-     op (_x == (y3))                                                \
-     op (_x == (y4))                                                \
-     op (_x == (y5))                                                \
-    )
-
-#define _NM_IN_SET_EVAL_6(op, _x, y1, y2, y3, y4, y5, y6)           \
-    (   (_x == (y1))                                                \
-     op (_x == (y2))                                                \
-     op (_x == (y3))                                                \
-     op (_x == (y4))                                                \
-     op (_x == (y5))                                                \
-     op (_x == (y6))                                                \
-    )
-
-#define _NM_IN_SET_EVAL_N2(op, _x, n, ...)        _NM_IN_SET_EVAL_##n(op, _x, __VA_ARGS__)
-#define _NM_IN_SET_EVAL_N(op, x, n, ...)                            \
-    ({                                                              \
-        typeof(x) _x = (x);                                         \
-        !!_NM_IN_SET_EVAL_N2(op, _x, n, __VA_ARGS__);               \
-    })
-
-/* Beware that this does short-circuit evaluation (use "||" instead of "|")
- * which has a possibly unexpected non-function-like behavior.
- * Use NM_IN_SET_SE if you need all arguments to be evaluted. */
-#define NM_IN_SET(x, ...)               _NM_IN_SET_EVAL_N(||, x, NM_NARG (__VA_ARGS__), __VA_ARGS__)
-
-/* "SE" stands for "side-effect". Contrary to NM_IN_SET(), this does not do
- * short-circuit evaluation, which can make a difference if the arguments have
- * side-effects. */
-#define NM_IN_SET_SE(x, ...)            _NM_IN_SET_EVAL_N(|, x, NM_NARG (__VA_ARGS__), __VA_ARGS__)
-
-/********************************************************/
-
-static inline gboolean
-_NM_IN_STRSET_streq (const char *x, const char *s)
-{
-	return s && strcmp (x, s) == 0;
-}
-
-#define _NM_IN_STRSET_EVAL_1(op, _x, y1)                            \
-    _NM_IN_STRSET_streq (_x, y1)
-
-#define _NM_IN_STRSET_EVAL_2(op, _x, y1, y2)                        \
-    (   _NM_IN_STRSET_streq (_x, y1)                                \
-     op _NM_IN_STRSET_streq (_x, y2)                                \
-    )
-
-#define _NM_IN_STRSET_EVAL_3(op, _x, y1, y2, y3)                    \
-    (   _NM_IN_STRSET_streq (_x, y1)                                \
-     op _NM_IN_STRSET_streq (_x, y2)                                \
-     op _NM_IN_STRSET_streq (_x, y3)                                \
-    )
-
-#define _NM_IN_STRSET_EVAL_4(op, _x, y1, y2, y3, y4)                \
-    (   _NM_IN_STRSET_streq (_x, y1)                                \
-     op _NM_IN_STRSET_streq (_x, y2)                                \
-     op _NM_IN_STRSET_streq (_x, y3)                                \
-     op _NM_IN_STRSET_streq (_x, y4)                                \
-    )
-
-#define _NM_IN_STRSET_EVAL_5(op, _x, y1, y2, y3, y4, y5)            \
-    (   _NM_IN_STRSET_streq (_x, y1)                                \
-     op _NM_IN_STRSET_streq (_x, y2)                                \
-     op _NM_IN_STRSET_streq (_x, y3)                                \
-     op _NM_IN_STRSET_streq (_x, y4)                                \
-     op _NM_IN_STRSET_streq (_x, y5)                                \
-    )
-
-#define _NM_IN_STRSET_EVAL_6(op, _x, y1, y2, y3, y4, y5, y6)        \
-    (   _NM_IN_STRSET_streq (_x, y1)                                \
-     op _NM_IN_STRSET_streq (_x, y2)                                \
-     op _NM_IN_STRSET_streq (_x, y3)                                \
-     op _NM_IN_STRSET_streq (_x, y4)                                \
-     op _NM_IN_STRSET_streq (_x, y5)                                \
-     op _NM_IN_STRSET_streq (_x, y6)                                \
-    )
-
-#define _NM_IN_STRSET_EVAL_N2(op, _x, n, ...) _NM_IN_STRSET_EVAL_##n(op, _x, __VA_ARGS__)
-#define _NM_IN_STRSET_EVAL_N(op, x, n, ...)                       \
-    ({                                                            \
-        const char *_x = (x);                                     \
-        (   ((_x == NULL) && _NM_IN_SET_EVAL_N2    (op, (const char *) NULL, n, __VA_ARGS__)) \
-         || ((_x != NULL) && _NM_IN_STRSET_EVAL_N2 (op, _x,                  n, __VA_ARGS__)) \
-        ); \
-    })
-
-/* Beware that this does short-circuit evaluation (use "||" instead of "|")
- * which has a possibly unexpected non-function-like behavior.
- * Use NM_IN_STRSET_SE if you need all arguments to be evaluted. */
-#define NM_IN_STRSET(x, ...)               _NM_IN_STRSET_EVAL_N(||, x, NM_NARG (__VA_ARGS__), __VA_ARGS__)
-
-/* "SE" stands for "side-effect". Contrary to NM_IN_STRSET(), this does not do
- * short-circuit evaluation, which can make a difference if the arguments have
- * side-effects. */
-#define NM_IN_STRSET_SE(x, ...)            _NM_IN_STRSET_EVAL_N(|, x, NM_NARG (__VA_ARGS__), __VA_ARGS__)
-
-/*****************************************************************************/
-
-#define nm_streq(s1, s2)  (strcmp (s1, s2) == 0)
-#define nm_streq0(s1, s2) (g_strcmp0 (s1, s2) == 0)
-
-/*****************************************************************************/
-
-#define NM_PRINT_FMT_QUOTED(cond, prefix, str, suffix, str_else) \
-	(cond) ? (prefix) : "", \
-	(cond) ? (str) : (str_else), \
-	(cond) ? (suffix) : ""
-#define NM_PRINT_FMT_QUOTE_STRING(arg) NM_PRINT_FMT_QUOTED((arg), "\"", (arg), "\"", "(null)")
-
-/*****************************************************************************/
-
-#if NM_MORE_ASSERTS
-#define nm_assert(cond) G_STMT_START { g_assert (cond); } G_STMT_END
-#define nm_assert_not_reached() G_STMT_START { g_assert_not_reached (); } G_STMT_END
-#else
-#define nm_assert(cond) G_STMT_START { if (FALSE) { if (cond) { } } } G_STMT_END
-#define nm_assert_not_reached() G_STMT_START { ; } G_STMT_END
-#endif
-
-/*****************************************************************************/
-
-#define NM_GOBJECT_PROPERTIES_DEFINE_BASE(...) \
-typedef enum { \
-	_PROPERTY_ENUMS_0, \
-	__VA_ARGS__ \
-	_PROPERTY_ENUMS_LAST, \
-} _PropertyEnums; \
-static GParamSpec *obj_properties[_PROPERTY_ENUMS_LAST] = { NULL, }
-
-#define NM_GOBJECT_PROPERTIES_DEFINE(obj_type, ...) \
-NM_GOBJECT_PROPERTIES_DEFINE_BASE (__VA_ARGS__); \
-static inline void \
-_notify (obj_type *obj, _PropertyEnums prop) \
-{ \
-	nm_assert (G_IS_OBJECT (obj)); \
-	nm_assert ((gsize) prop < G_N_ELEMENTS (obj_properties)); \
-	g_object_notify_by_pspec ((GObject *) obj, obj_properties[prop]); \
-}
-
-/*****************************************************************************/
-
-#define nm_unauto(pp)                                               \
-    ({                                                              \
-        G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));        \
-        gpointer *_pp = (gpointer *) (pp);                          \
-        gpointer _p = *_pp;                                         \
-                                                                    \
-        *_pp = NULL;                                                \
-        _p;                                                         \
-    })
-
-/*****************************************************************************/
-
-static inline gpointer
-nm_g_object_ref (gpointer obj)
-{
-	/* g_object_ref() doesn't accept NULL. */
-	if (obj)
-		g_object_ref (obj);
-	return obj;
-}
-
-static inline void
-nm_g_object_unref (gpointer obj)
-{
-	/* g_object_unref() doesn't accept NULL. Usully, we workaround that
-	 * by using g_clear_object(), but sometimes that is not convinient
-	 * (for example as as destroy function for a hash table that can contain
-	 * NULL values). */
-	if (obj)
-		g_object_unref (obj);
-}
-
-static inline gboolean
-nm_clear_g_source (guint *id)
-{
-	if (id && *id) {
-		g_source_remove (*id);
-		*id = 0;
-		return TRUE;
-	}
-	return FALSE;
-}
-
-static inline gboolean
-nm_clear_g_signal_handler (gpointer self, gulong *id)
-{
-	if (id && *id) {
-		g_signal_handler_disconnect (self, *id);
-		*id = 0;
-		return TRUE;
-	}
-	return FALSE;
-}
-
-static inline gboolean
-nm_clear_g_variant (GVariant **variant)
-{
-	if (variant && *variant) {
-		g_variant_unref (*variant);
-		*variant = NULL;
-		return TRUE;
-	}
-	return FALSE;
-}
-
-static inline gboolean
-nm_clear_g_cancellable (GCancellable **cancellable)
-{
-	if (cancellable && *cancellable) {
-		g_cancellable_cancel (*cancellable);
-		g_object_unref (*cancellable);
-		*cancellable = NULL;
-		return TRUE;
-	}
-	return FALSE;
-}
-
-/*****************************************************************************/
-
-/* Determine whether @x is a power of two (@x being an integer type).
- * For the special cases @x equals zero or one, it also returns true.
- * For negative @x, always returns FALSE. That only applies, if the data
- * type of @x is signed. */
-#define nm_utils_is_power_of_two(x) ({ \
-		typeof(x) __x = (x); \
-		\
-		/* Check if the value is negative. In that case, return FALSE.
-		 * The first expression is a compile time constant, depending on whether
-		 * the type is signed. The second expression is a clumsy way for (__x >= 0),
-		 * which causes a compiler warning for unsigned types. */ \
-		    ( ( ((typeof(__x)) -1) > ((typeof(__x)) 0) ) || (__x > 0) || (__x == 0) ) \
-		 && ((__x & (__x - 1)) == 0); \
-	})
-
-/*****************************************************************************/
-
-/* check if @flags has exactly one flag (@check) set. You should call this
- * only with @check being a compile time constant and a power of two. */
-#define NM_FLAGS_HAS(flags, check)  \
-    ( (G_STATIC_ASSERT_EXPR ( ((check) != 0) && ((check) & ((check)-1)) == 0 )), (NM_FLAGS_ANY ((flags), (check))) )
-
-#define NM_FLAGS_ANY(flags, check)  ( ( ((flags) & (check)) != 0       ) ? TRUE : FALSE )
-#define NM_FLAGS_ALL(flags, check)  ( ( ((flags) & (check)) == (check) ) ? TRUE : FALSE )
-
-#define NM_FLAGS_SET(flags, val)  ({ \
-		const typeof(flags) _flags = (flags); \
-		const typeof(flags) _val = (val); \
-		\
-		_flags | _val; \
-	})
-
-#define NM_FLAGS_UNSET(flags, val)  ({ \
-		const typeof(flags) _flags = (flags); \
-		const typeof(flags) _val = (val); \
-		\
-		_flags & (~_val); \
-	})
-
-#define NM_FLAGS_ASSIGN(flags, val, assign)  ({ \
-		const typeof(flags) _flags = (flags); \
-		const typeof(flags) _val = (val); \
-		\
-		(assign) \
-			? _flags | (_val) \
-			: _flags & (~_val); \
-	})
-
-/*****************************************************************************/
-
-#define _NM_BACKPORT_SYMBOL_IMPL(VERSION, RETURN_TYPE, ORIG_FUNC, VERSIONED_FUNC, ARGS_TYPED, ARGS) \
-RETURN_TYPE VERSIONED_FUNC ARGS_TYPED; \
-RETURN_TYPE VERSIONED_FUNC ARGS_TYPED \
-{ \
-    return ORIG_FUNC ARGS; \
-} \
-RETURN_TYPE ORIG_FUNC ARGS_TYPED; \
-__asm__(".symver "G_STRINGIFY(VERSIONED_FUNC)", "G_STRINGIFY(ORIG_FUNC)"@"G_STRINGIFY(VERSION))
-
-#define NM_BACKPORT_SYMBOL(VERSION, RETURN_TYPE, FUNC, ARGS_TYPED, ARGS) \
-_NM_BACKPORT_SYMBOL_IMPL(VERSION, RETURN_TYPE, FUNC, _##FUNC##_##VERSION, ARGS_TYPED, ARGS)
-
-/*****************************************************************************/
-
-static inline char *
-nm_strstrip (char *str)
-{
-	/* g_strstrip doesn't like NULL. */
-	return str ? g_strstrip (str) : NULL;
-}
-
-/*****************************************************************************/
-
-static inline guint
-nm_encode_version (guint major, guint minor, guint micro) {
-	/* analog to the preprocessor macro NM_ENCODE_VERSION(). */
-	return (major << 16) | (minor << 8) | micro;
-}
-
-static inline void
-nm_decode_version (guint version, guint *major, guint *minor, guint *micro) {
-	*major = (version & 0xFFFF0000u) >> 16;
-	*minor = (version & 0x0000FF00u) >>  8;
-	*micro = (version & 0x000000FFu);
-}
-/*****************************************************************************/
-
-#define nm_sprintf_buf(buf, format, ...) ({ \
-		char * _buf = (buf); \
-		\
-		/* some static assert trying to ensure that the buffer is statically allocated.
-		 * It disallows a buffer size of sizeof(gpointer) to catch that. */ \
-		G_STATIC_ASSERT (G_N_ELEMENTS (buf) == sizeof (buf) && sizeof (buf) != sizeof (char *)); \
-		g_snprintf (_buf, sizeof (buf), \
-		            ""format"", ##__VA_ARGS__); \
-		_buf; \
-	})
-
-#define nm_sprintf_bufa(n_elements, format, ...) \
-	({ \
-		char *_buf; \
-		\
-		G_STATIC_ASSERT (sizeof (char[MAX ((n_elements), 1)]) == (n_elements)); \
-		_buf = g_alloca (n_elements); \
-		g_snprintf (_buf, n_elements, \
-		            ""format"", ##__VA_ARGS__); \
-		_buf; \
-	})
-
-/*****************************************************************************/
-
-/**
- * The boolean type _Bool is C99 while we mostly stick to C89. However, _Bool is too
- * convinient to miss and is effectively available in gcc and clang. So, just use it.
- *
- * Usually, one would include "stdbool.h" to get the "bool" define which aliases
- * _Bool. We provide this define here, because we want to make use of it anywhere.
- * (also, stdbool.h is again C99).
- *
- * Using _Bool has advantages over gboolean:
- *
- * - commonly _Bool is one byte large, instead of gboolean's 4 bytes (because gboolean
- *   is a typedef for gint). Especially when having boolean fields in a struct, we can
- *   thereby easily save some space.
- *
- * - _Bool type guarantees that two "true" expressions compare equal. E.g. the follwing
- *   will not work:
- *        gboolean v1 = 1;
- *        gboolean v2 = 2;
- *        g_assert_cmpint (v1, ==, v2); // will fail
- *   For that, we often to use !! to coerce gboolean values to 0 or 1:
- *        g_assert_cmpint (!!v2, ==, TRUE);
- *   With _Bool type, this will be handled properly by the compiler.
- *
- * - For structs, we might want to safe even more space and use bitfields:
- *       struct s1 {
- *           gboolean v1:1;
- *       };
- *   But the problem here is that gboolean is signed, so that
- *   v1 will be either 0 or -1 (not 1, TRUE). Thus, the following
- *   fails:
- *      struct s1 s = { .v1 = TRUE, };
- *      g_assert_cmpint (s1.v1, ==, TRUE);
- *   It will however work just fine with bool/_Bool while retaining the
- *   notion of having a boolean value.
- *
- * Also, add the defines for "true" and "false". Those are nicely highlighted by the editor
- * as special types, contrary to glib's "TRUE"/"FALSE".
- */
-
-#ifndef bool
-#define bool _Bool
-#define true    1
-#define false   0
-#endif
-
-/*****************************************************************************/
-
-#endif /* __NM_MACROS_INTERNAL_H__ */
diff --git shared/nm-openvpn-service-defines.h shared/nm-openvpn-service-defines.h
deleted file mode 100644
index 825e3c7..0000000
--- shared/nm-openvpn-service-defines.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* nm-openvpn-service - openvpn integration with NetworkManager
- *
- * Copyright (C) 2005 - 2008 Tim Niemueller <tim@niemueller.de>
- * Copyright (C) 2005 - 2008 Dan Williams <dcbw@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- */
-
-#ifndef NM_OPENVPN_SERVICE_DEFINES_H
-#define NM_OPENVPN_SERVICE_DEFINES_H
-
-#define NM_VPN_SERVICE_TYPE_OPENVPN "org.freedesktop.NetworkManager.openvpn"
-
-#define NM_DBUS_SERVICE_OPENVPN    "org.freedesktop.NetworkManager.openvpn"
-#define NM_DBUS_INTERFACE_OPENVPN  "org.freedesktop.NetworkManager.openvpn"
-#define NM_DBUS_PATH_OPENVPN       "/org/freedesktop/NetworkManager/openvpn"
-
-#define NM_OPENVPN_KEY_AUTH "auth"
-#define NM_OPENVPN_KEY_CA "ca"
-#define NM_OPENVPN_KEY_CERT "cert"
-#define NM_OPENVPN_KEY_CIPHER "cipher"
-#define NM_OPENVPN_KEY_KEYSIZE "keysize"
-#define NM_OPENVPN_KEY_COMP_LZO "comp-lzo"
-#define NM_OPENVPN_KEY_CONNECTION_TYPE "connection-type"
-#define NM_OPENVPN_KEY_FLOAT "float"
-#define NM_OPENVPN_KEY_FRAGMENT_SIZE "fragment-size"
-#define NM_OPENVPN_KEY_KEY "key"
-#define NM_OPENVPN_KEY_LOCAL_IP "local-ip" /* ??? */
-#define NM_OPENVPN_KEY_MSSFIX "mssfix"
-#define NM_OPENVPN_KEY_NS_CERT_TYPE "ns-cert-type"
-#define NM_OPENVPN_KEY_PING "ping"
-#define NM_OPENVPN_KEY_PING_EXIT "ping-exit"
-#define NM_OPENVPN_KEY_PING_RESTART "ping-restart"
-#define NM_OPENVPN_KEY_PORT "port"
-#define NM_OPENVPN_KEY_PROTO_TCP "proto-tcp"
-#define NM_OPENVPN_KEY_PROXY_TYPE "proxy-type"
-#define NM_OPENVPN_KEY_PROXY_SERVER "proxy-server"
-#define NM_OPENVPN_KEY_PROXY_PORT "proxy-port"
-#define NM_OPENVPN_KEY_PROXY_RETRY "proxy-retry"
-#define NM_OPENVPN_KEY_HTTP_PROXY_USERNAME "http-proxy-username"
-#define NM_OPENVPN_KEY_REMOTE "remote"
-#define NM_OPENVPN_KEY_REMOTE_RANDOM "remote-random"
-#define NM_OPENVPN_KEY_REMOTE_IP "remote-ip"
-#define NM_OPENVPN_KEY_STATIC_KEY "static-key"
-#define NM_OPENVPN_KEY_STATIC_KEY_DIRECTION "static-key-direction"
-#define NM_OPENVPN_KEY_TA "ta"
-#define NM_OPENVPN_KEY_TA_DIR "ta-dir"
-#define NM_OPENVPN_KEY_TUNNEL_MTU "tunnel-mtu"
-#define NM_OPENVPN_KEY_USERNAME "username"
-#define NM_OPENVPN_KEY_TAP_DEV "tap-dev"
-#define NM_OPENVPN_KEY_DEV "dev"
-#define NM_OPENVPN_KEY_DEV_TYPE "dev-type"
-#define NM_OPENVPN_KEY_TUN_IPV6 "tun-ipv6"
-#define NM_OPENVPN_KEY_TLS_REMOTE "tls-remote"
-#define NM_OPENVPN_KEY_REMOTE_CERT_TLS "remote-cert-tls"
-
-#define NM_OPENVPN_KEY_PASSWORD "password"
-#define NM_OPENVPN_KEY_CERTPASS "cert-pass"
-#define NM_OPENVPN_KEY_HTTP_PROXY_PASSWORD "http-proxy-password"
-/* Internal auth-dialog -> service token indicating that no secrets are
- * required for the connection.
- */
-#define NM_OPENVPN_KEY_NOSECRET "no-secret"
-
-#define NM_OPENVPN_KEY_RENEG_SECONDS "reneg-seconds"
-
-#define NM_OPENVPN_AUTH_NONE "none"
-#define NM_OPENVPN_AUTH_RSA_MD4 "RSA-MD4"
-#define NM_OPENVPN_AUTH_MD5  "MD5"
-#define NM_OPENVPN_AUTH_SHA1 "SHA1"
-#define NM_OPENVPN_AUTH_SHA224 "SHA224"
-#define NM_OPENVPN_AUTH_SHA256 "SHA256"
-#define NM_OPENVPN_AUTH_SHA384 "SHA384"
-#define NM_OPENVPN_AUTH_SHA512 "SHA512"
-#define NM_OPENVPN_AUTH_RIPEMD160 "RIPEMD160"
-
-#define NM_OPENVPN_CONTYPE_TLS          "tls"
-#define NM_OPENVPN_CONTYPE_STATIC_KEY   "static-key"
-#define NM_OPENVPN_CONTYPE_PASSWORD     "password"
-#define NM_OPENVPN_CONTYPE_PASSWORD_TLS "password-tls"
-
-/* arguments of "--remote-cert-tls" */
-#define NM_OPENVPN_REM_CERT_TLS_CLIENT "client"
-#define NM_OPENVPN_REM_CERT_TLS_SERVER "server"
-
-/* arguments of "--ns-cert-type" */
-#define NM_OPENVPN_NS_CERT_TYPE_CLIENT "client"
-#define NM_OPENVPN_NS_CERT_TYPE_SERVER "server"
-
-/* User name and group to run nm-openvpn-service under */
-#define NM_OPENVPN_USER   "nm-openvpn"
-#define NM_OPENVPN_GROUP  "nm-openvpn"
-#define NM_OPENVPN_CHROOT LOCALSTATEDIR "/lib/openvpn/chroot"
-
-#endif /* NM_OPENVPN_SERVICE_DEFINES_H */
diff --git shared/nm-service-defines.h shared/nm-service-defines.h
new file mode 100644
index 0000000..b204bdb
--- /dev/null
+++ shared/nm-service-defines.h
@@ -0,0 +1,109 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/*
+ * Copyright (C) 2005 - 2008 Tim Niemueller <tim@niemueller.de>
+ * Copyright (C) 2005 - 2008 Dan Williams <dcbw@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef __NM_SERVICE_DEFINES_H__
+#define __NM_SERVICE_DEFINES_H__
+
+#define NM_VPN_SERVICE_TYPE_OPENVPN "org.freedesktop.NetworkManager.openvpn"
+
+#define NM_DBUS_SERVICE_OPENVPN    "org.freedesktop.NetworkManager.openvpn"
+#define NM_DBUS_INTERFACE_OPENVPN  "org.freedesktop.NetworkManager.openvpn"
+#define NM_DBUS_PATH_OPENVPN       "/org/freedesktop/NetworkManager/openvpn"
+
+#define NM_OPENVPN_KEY_AUTH "auth"
+#define NM_OPENVPN_KEY_CA "ca"
+#define NM_OPENVPN_KEY_CERT "cert"
+#define NM_OPENVPN_KEY_CIPHER "cipher"
+#define NM_OPENVPN_KEY_KEYSIZE "keysize"
+#define NM_OPENVPN_KEY_COMP_LZO "comp-lzo"
+#define NM_OPENVPN_KEY_CONNECTION_TYPE "connection-type"
+#define NM_OPENVPN_KEY_FLOAT "float"
+#define NM_OPENVPN_KEY_FRAGMENT_SIZE "fragment-size"
+#define NM_OPENVPN_KEY_KEY "key"
+#define NM_OPENVPN_KEY_LOCAL_IP "local-ip" /* ??? */
+#define NM_OPENVPN_KEY_MSSFIX "mssfix"
+#define NM_OPENVPN_KEY_NS_CERT_TYPE "ns-cert-type"
+#define NM_OPENVPN_KEY_PING "ping"
+#define NM_OPENVPN_KEY_PING_EXIT "ping-exit"
+#define NM_OPENVPN_KEY_PING_RESTART "ping-restart"
+#define NM_OPENVPN_KEY_PORT "port"
+#define NM_OPENVPN_KEY_PROTO_TCP "proto-tcp"
+#define NM_OPENVPN_KEY_PROXY_TYPE "proxy-type"
+#define NM_OPENVPN_KEY_PROXY_SERVER "proxy-server"
+#define NM_OPENVPN_KEY_PROXY_PORT "proxy-port"
+#define NM_OPENVPN_KEY_PROXY_RETRY "proxy-retry"
+#define NM_OPENVPN_KEY_HTTP_PROXY_USERNAME "http-proxy-username"
+#define NM_OPENVPN_KEY_REMOTE "remote"
+#define NM_OPENVPN_KEY_REMOTE_RANDOM "remote-random"
+#define NM_OPENVPN_KEY_REMOTE_IP "remote-ip"
+#define NM_OPENVPN_KEY_STATIC_KEY "static-key"
+#define NM_OPENVPN_KEY_STATIC_KEY_DIRECTION "static-key-direction"
+#define NM_OPENVPN_KEY_TA "ta"
+#define NM_OPENVPN_KEY_TA_DIR "ta-dir"
+#define NM_OPENVPN_KEY_TUNNEL_MTU "tunnel-mtu"
+#define NM_OPENVPN_KEY_USERNAME "username"
+#define NM_OPENVPN_KEY_TAP_DEV "tap-dev"
+#define NM_OPENVPN_KEY_DEV "dev"
+#define NM_OPENVPN_KEY_DEV_TYPE "dev-type"
+#define NM_OPENVPN_KEY_TUN_IPV6 "tun-ipv6"
+#define NM_OPENVPN_KEY_TLS_CIPHER "tls-cipher"
+#define NM_OPENVPN_KEY_TLS_REMOTE "tls-remote"
+#define NM_OPENVPN_KEY_REMOTE_CERT_TLS "remote-cert-tls"
+
+#define NM_OPENVPN_KEY_PASSWORD "password"
+#define NM_OPENVPN_KEY_CERTPASS "cert-pass"
+#define NM_OPENVPN_KEY_HTTP_PROXY_PASSWORD "http-proxy-password"
+/* Internal auth-dialog -> service token indicating that no secrets are
+ * required for the connection.
+ */
+#define NM_OPENVPN_KEY_NOSECRET "no-secret"
+
+#define NM_OPENVPN_KEY_RENEG_SECONDS "reneg-seconds"
+
+#define NM_OPENVPN_AUTH_NONE "none"
+#define NM_OPENVPN_AUTH_RSA_MD4 "RSA-MD4"
+#define NM_OPENVPN_AUTH_MD5  "MD5"
+#define NM_OPENVPN_AUTH_SHA1 "SHA1"
+#define NM_OPENVPN_AUTH_SHA224 "SHA224"
+#define NM_OPENVPN_AUTH_SHA256 "SHA256"
+#define NM_OPENVPN_AUTH_SHA384 "SHA384"
+#define NM_OPENVPN_AUTH_SHA512 "SHA512"
+#define NM_OPENVPN_AUTH_RIPEMD160 "RIPEMD160"
+
+#define NM_OPENVPN_CONTYPE_TLS          "tls"
+#define NM_OPENVPN_CONTYPE_STATIC_KEY   "static-key"
+#define NM_OPENVPN_CONTYPE_PASSWORD     "password"
+#define NM_OPENVPN_CONTYPE_PASSWORD_TLS "password-tls"
+
+/* arguments of "--remote-cert-tls" */
+#define NM_OPENVPN_REM_CERT_TLS_CLIENT "client"
+#define NM_OPENVPN_REM_CERT_TLS_SERVER "server"
+
+/* arguments of "--ns-cert-type" */
+#define NM_OPENVPN_NS_CERT_TYPE_CLIENT "client"
+#define NM_OPENVPN_NS_CERT_TYPE_SERVER "server"
+
+/* User name and group to run nm-openvpn-service under */
+#define NM_OPENVPN_USER   "nm-openvpn"
+#define NM_OPENVPN_GROUP  "nm-openvpn"
+#define NM_OPENVPN_CHROOT LOCALSTATEDIR "/lib/openvpn/chroot"
+
+#endif /* __NM_SERVICE_DEFINES_H__ */
diff --git shared/nm-shared-utils.c shared/nm-shared-utils.c
deleted file mode 100644
index 0ae54bd..0000000
--- shared/nm-shared-utils.c
+++ /dev/null
@@ -1,228 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301 USA.
- *
- * (C) Copyright 2016 Red Hat, Inc.
- */
-
-#include "nm-default.h"
-
-#include "nm-shared-utils.h"
-
-#include <errno.h>
-
-/*****************************************************************************/
-
-/* _nm_utils_ascii_str_to_int64:
- *
- * A wrapper for g_ascii_strtoll, that checks whether the whole string
- * can be successfully converted to a number and is within a given
- * range. On any error, @fallback will be returned and %errno will be set
- * to a non-zero value. On success, %errno will be set to zero, check %errno
- * for errors. Any trailing or leading (ascii) white space is ignored and the
- * functions is locale independent.
- *
- * The function is guaranteed to return a value between @min and @max
- * (inclusive) or @fallback. Also, the parsing is rather strict, it does
- * not allow for any unrecognized characters, except leading and trailing
- * white space.
- **/
-gint64
-_nm_utils_ascii_str_to_int64 (const char *str, guint base, gint64 min, gint64 max, gint64 fallback)
-{
-	gint64 v;
-	size_t len;
-	char buf[64], *s, *str_free = NULL;
-
-	if (str) {
-		while (g_ascii_isspace (str[0]))
-			str++;
-	}
-	if (!str || !str[0]) {
-		errno = EINVAL;
-		return fallback;
-	}
-
-	len = strlen (str);
-	if (g_ascii_isspace (str[--len])) {
-		/* backward search the first non-ws character.
-		 * We already know that str[0] is non-ws. */
-		while (g_ascii_isspace (str[--len]))
-			;
-
-		/* str[len] is now the last non-ws character... */
-		len++;
-
-		if (len >= sizeof (buf))
-			s = str_free = g_malloc (len + 1);
-		else
-			s = buf;
-
-		memcpy (s, str, len);
-		s[len] = 0;
-
-		nm_assert (len > 0 && len < strlen (str) && len == strlen (s));
-		nm_assert (!g_ascii_isspace (str[len-1]) && g_ascii_isspace (str[len]));
-		nm_assert (strncmp (str, s, len) == 0);
-
-		str = s;
-	}
-
-	errno = 0;
-	v = g_ascii_strtoll (str, &s, base);
-
-	if (errno != 0)
-		v = fallback;
-	else if (s[0] != 0) {
-		errno = EINVAL;
-		v = fallback;
-	} else if (v > max || v < min) {
-		errno = ERANGE;
-		v = fallback;
-	}
-
-	if (G_UNLIKELY (str_free))
-		g_free (str_free);
-	return v;
-}
-
-/*****************************************************************************/
-
-G_DEFINE_QUARK (nm-utils-error-quark, nm_utils_error)
-
-void
-nm_utils_error_set_cancelled (GError **error,
-                              gboolean is_disposing,
-                              const char *instance_name)
-{
-	if (is_disposing) {
-		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_CANCELLED_DISPOSING,
-		             "Disposing %s instance",
-		             instance_name && *instance_name ? instance_name : "source");
-	} else {
-		g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_CANCELLED,
-		                     "Request cancelled");
-	}
-}
-
-gboolean
-nm_utils_error_is_cancelled (GError *error,
-                             gboolean consider_is_disposing)
-{
-	if (error) {
-		if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
-			return TRUE;
-		if (   consider_is_disposing
-		    && g_error_matches (error, NM_UTILS_ERROR, NM_UTILS_ERROR_CANCELLED_DISPOSING))
-			return TRUE;
-	}
-	return FALSE;
-}
-
-/*****************************************************************************/
-
-/**
- * nm_g_object_set_property:
- * @object: the target object
- * @property_name: the property name
- * @value: the #GValue to set
- * @error: (allow-none): optional error argument
- *
- * A reimplementation of g_object_set_property(), but instead
- * returning an error instead of logging a warning. All g_object_set*()
- * versions in glib require you to not pass invalid types or they will
- * log a g_warning() -- without reporting an error. We don't want that,
- * so we need to hack error checking around it.
- *
- * Returns: whether the value was successfully set.
- */
-gboolean
-nm_g_object_set_property (GObject *object,
-                          const gchar  *property_name,
-                          const GValue *value,
-                          GError **error)
-{
-	GParamSpec *pspec;
-	nm_auto_unset_gvalue GValue tmp_value = G_VALUE_INIT;
-	GObjectClass *klass;
-
-	g_return_val_if_fail (G_IS_OBJECT (object), FALSE);
-	g_return_val_if_fail (property_name != NULL, FALSE);
-	g_return_val_if_fail (G_IS_VALUE (value), FALSE);
-	g_return_val_if_fail (!error || !*error, FALSE);
-
-	/* g_object_class_find_property() does g_param_spec_get_redirect_target(),
-	 * where we differ from a plain g_object_set_property(). */
-	pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (object), property_name);
-
-	if (!pspec) {
-		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
-		             _("object class '%s' has no property named '%s'"),
-		             G_OBJECT_TYPE_NAME (object),
-		             property_name);
-		return FALSE;
-	}
-	if (!(pspec->flags & G_PARAM_WRITABLE)) {
-		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
-		             _("property '%s' of object class '%s' is not writable"),
-		             pspec->name,
-		             G_OBJECT_TYPE_NAME (object));
-		return FALSE;
-	}
-	if ((pspec->flags & G_PARAM_CONSTRUCT_ONLY)) {
-		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
-		             _("construct property \"%s\" for object '%s' can't be set after construction"),
-		             pspec->name, G_OBJECT_TYPE_NAME (object));
-		return FALSE;
-	}
-
-	klass = g_type_class_peek (pspec->owner_type);
-	if (klass == NULL) {
-		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
-		             _("'%s::%s' is not a valid property name; '%s' is not a GObject subtype"),
-		            g_type_name (pspec->owner_type), pspec->name, g_type_name (pspec->owner_type));
-		return FALSE;
-	}
-
-	/* provide a copy to work from, convert (if necessary) and validate */
-	g_value_init (&tmp_value, pspec->value_type);
-	if (!g_value_transform (value, &tmp_value)) {
-		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
-		             _("unable to set property '%s' of type '%s' from value of type '%s'"),
-		             pspec->name,
-		             g_type_name (pspec->value_type),
-		             G_VALUE_TYPE_NAME (value));
-		return FALSE;
-	}
-	if (   g_param_value_validate (pspec, &tmp_value)
-	    && !(pspec->flags & G_PARAM_LAX_VALIDATION)) {
-		gs_free char *contents = g_strdup_value_contents (value);
-
-		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
-		             _("value \"%s\" of type '%s' is invalid or out of range for property '%s' of type '%s'"),
-		             contents,
-		             G_VALUE_TYPE_NAME (value),
-		             pspec->name,
-		             g_type_name (pspec->value_type));
-		return FALSE;
-	}
-
-	g_object_set_property (object, property_name, &tmp_value);
-	return TRUE;
-}
-
-/*****************************************************************************/
diff --git shared/nm-shared-utils.h shared/nm-shared-utils.h
deleted file mode 100644
index f80c850..0000000
--- shared/nm-shared-utils.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301 USA.
- *
- * (C) Copyright 2016 Red Hat, Inc.
- */
-
-#ifndef __NM_SHARED_UTILS_H__
-#define __NM_SHARED_UTILS_H__
-
-/******************************************************************************/
-
-gint64 _nm_utils_ascii_str_to_int64 (const char *str, guint base, gint64 min, gint64 max, gint64 fallback);
-
-/******************************************************************************/
-
-/**
- * NMUtilsError:
- * @NM_UTILS_ERROR_UNKNOWN: unknown or unclassified error
- * @NM_UTILS_ERROR_CANCELLED_DISPOSING: when disposing an object that has
- *   pending aynchronous operations, the operation is cancelled with this
- *   error reason. Depending on the usage, this might indicate a bug because
- *   usually the target object should stay alive as long as there are pending
- *   operations.
- */
-typedef enum {
-	NM_UTILS_ERROR_UNKNOWN = 0,                 /*< nick=Unknown >*/
-	NM_UTILS_ERROR_CANCELLED_DISPOSING,         /*< nick=CancelledDisposing >*/
-} NMUtilsError;
-
-#define NM_UTILS_ERROR (nm_utils_error_quark ())
-GQuark nm_utils_error_quark (void);
-
-void nm_utils_error_set_cancelled (GError **error,
-                                   gboolean is_disposing,
-                                   const char *instance_name);
-gboolean nm_utils_error_is_cancelled (GError *error,
-                                      gboolean consider_is_disposing);
-
-/******************************************************************************/
-
-gboolean nm_g_object_set_property (GObject *object,
-                                   const gchar  *property_name,
-                                   const GValue *value,
-                                   GError **error);
-
-/******************************************************************************/
-
-#endif /* __NM_SHARED_UTILS_H__ */
diff --git shared/nm-test-utils.h shared/nm-test-utils.h
deleted file mode 100644
index 2503245..0000000
--- shared/nm-test-utils.h
+++ /dev/null
@@ -1,1938 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/*
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301 USA.
- *
- * Copyright 2014 Red Hat, Inc.
- */
-
-#ifndef __NM_TEST_UTILS_H__
-#define __NM_TEST_UTILS_H__
-
-/*******************************************************************************
- * HOWTO run tests.
- *
- * Our tests (make check) include this header-only file nm-test-utils.h.
- *
- * Logging:
- *   In tests, nm-logging redirects to glib logging. By default, glib suppresses all debug
- *   messages unless you set G_MESSAGES_DEBUG. To enable debug logging, you can explicitly set
- *   G_MESSAGES_DEBUG. Otherwise, nm-test will set G_MESSAGES_DEBUG=all in debug mode (see below).
- *   For nm-logging, you can configure the log-level and domains via NMTST_DEBUG environment
- *   variable.
- *
- * Assert-logging:
- *   Some tests assert against logged messages (g_test_expect_message()).
- *   By specifying no-expect-message in NMTST_DEBUG, you can disable assert logging
- *   and g_test_assert_expected_messages() will not fail.
- *
- * NMTST_SEED_RAND environment variable:
- *   Tests that use random numbers from nmtst_get_rand() get seeded randomly at each start.
- *   You can specify the seed by setting NMTST_SEED_RAND. Also, tests will print the seed
- *   to stdout, so that you know the choosen seed.
- *
- *
- * NMTST_DEBUG environment variable:
- *
- * "debug", "no-debug": when at test is run in debug mode, it might behave differently,
- *   depending on the test. See nmtst_is_debug().
- *   Known differences:
- *    - a test might leave the logging level unspecified. In this case, running in
- *      debug mode, will turn on DEBUG logging, otherwise WARN logging only.
- *    - if G_MESSAGES_DEBUG is unset, nm-test will set G_MESSAGES_DEBUG=all
- *      for tests that don't do assert-logging.
- *   Debug mode is determined as follows (highest priority first):
- *    - command line option --debug/--no-debug
- *    - NMTST_DEBUG=debug/no-debug
- *    - setting NMTST_DEBUG implies debugging turned on
- *    - g_test_verbose()
- *
- * "no-expect-message": for tests that would assert against log messages, disable
- *   those asserts.
- *
- * "log-level=LEVEL", "log-domains=DOMAIN": reset the log level and domain for tests.
- *    It only has an effect for nm-logging messages.
- *    This has no effect if the test asserts against logging (unless no-expect-message),
- *    otherwise, changing the logging would break tests.
- *    If you set the level to DEBUG or TRACE, it also sets G_MESSAGES_DEBUG=all (unless
- *    in assert-logging mode and unless G_MESSAGES_DEBUG is already defined).
- *
- * "TRACE", this is shorthand for "log-level=TRACE".
- *
- * "D", this is shorthand for "log-level=TRACE,no-expect-message".
- *
- * "sudo-cmd=PATH": when running root tests as normal user, the test will execute
- *   itself by invoking sudo at PATH.
- *   For example
- *     NMTST_DEBUG="sudo-cmd=$PWD/tools/test-sudo-wrapper.sh" make -C src/platform/tests/ check
- *
- * "slow|quick|thorough": enable/disable long-running tests. This sets nmtst_test_quick().
- *   Whether long-running tests are enabled is determined as follows (highest priority first):
- *     - specifying the value in NMTST_DEBUG has highest priority
- *     - respect g_test_quick(), if the command line contains '-mslow', '-mquick', '-mthorough'.
- *     - use compile time default
- *
- * "p=PATH"|"s=PATH": passes the path to g_test_init() as "-p" and "-s", respectively.
- *   Unfortunately, these options conflict with "--tap" which our makefile passes to the
- *   tests, thus it's only useful outside of `make check`.
- *
- *******************************************************************************/
-
-#include "nm-default.h"
-
-#include <arpa/inet.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-
-#include "nm-utils.h"
-
-#ifdef __NETWORKMANAGER_LOGGING_H__
-/* We are running tests under src/. Let's include some files by default.
- * They are useful, and affect how nm-test-utils.h itself behaves. */
-#include "NetworkManagerUtils.h"
-#include "nm-keyfile-internal.h"
-#endif
-
-/*******************************************************************************/
-
-/* general purpose functions that have no dependency on other nmtst functions */
-
-#define nmtst_assert_error(error, expect_error_domain, expect_error_code, expect_error_pattern) \
-	G_STMT_START { \
-		GError *_error = (error); \
-		GQuark _expect_error_domain = (expect_error_domain); \
-		const char *_expect_error_pattern = (expect_error_pattern); \
-		\
-		if (_expect_error_domain) \
-			g_assert_error (_error, _expect_error_domain, (expect_error_code)); \
-		else \
-			g_assert (_error); \
-		g_assert (_error->message); \
-		if (   _expect_error_pattern \
-		    && !g_pattern_match_simple (_expect_error_pattern, _error->message)) { \
-			g_error ("%s:%d: error message does not have expected pattern '%s'. Instead it is '%s' (%s, %d)", \
-			         __FILE__, __LINE__, \
-			         _expect_error_pattern, _error->message, g_quark_to_string (_error->domain), _error->code); \
-		} \
-	} G_STMT_END
-
-#define NMTST_WAIT(max_wait_ms, wait) \
-	({ \
-		gboolean _not_expired = TRUE; \
-		gint64 _nmtst_end, _nmtst_max_wait_us = (max_wait_ms) * 1000L; \
-		\
-		_nmtst_end = g_get_monotonic_time () + _nmtst_max_wait_us; \
-		while (TRUE) { \
-			{ wait }; \
-			if (g_get_monotonic_time () > _nmtst_end) { \
-				_not_expired = FALSE; \
-				break; \
-			} \
-		} \
-		_not_expired; \
-	})
-
-#define NMTST_WAIT_ASSERT(max_wait_ms, wait) \
-	G_STMT_START { \
-		if (!(NMTST_WAIT (max_wait_ms, wait))) \
-			g_assert_not_reached (); \
-	} G_STMT_END
-
-inline static void
-_nmtst_assert_success (gboolean success, GError *error, const char *file, int line)
-{
-	if (!success || error)
-		g_error ("(%s:%d) FAILURE success=%d, error=%s", file, line, success, error ? error->message : "(no error)");
-}
-#define nmtst_assert_success(success, error) _nmtst_assert_success ((success), (error), __FILE__, __LINE__)
-
-#define nmtst_assert_no_success(success, error) \
-	G_STMT_START { \
-		g_assert (error); \
-		g_assert (!(success)); \
-	} G_STMT_END
-
-/*******************************************************************************/
-
-struct __nmtst_internal
-{
-	GRand *rand0;
-	guint32 rand_seed;
-	GRand *rand;
-	gboolean is_debug;
-	gboolean assert_logging;
-	gboolean no_expect_message;
-	gboolean test_quick;
-	gboolean test_tap_log;
-	char *sudo_cmd;
-	char **orig_argv;
-};
-
-extern struct __nmtst_internal __nmtst_internal;
-
-#define NMTST_DEFINE() \
-struct __nmtst_internal __nmtst_internal = { 0 }; \
-\
-__attribute__ ((destructor)) static void \
-_nmtst_exit (void) \
-{ \
-	__nmtst_internal.assert_logging = FALSE; \
-	g_test_assert_expected_messages (); \
-	nmtst_free (); \
-}
-
-
-inline static gboolean
-nmtst_initialized (void)
-{
-	return !!__nmtst_internal.rand0;
-}
-
-#define __NMTST_LOG(cmd, ...) \
-	G_STMT_START { \
-		g_assert (nmtst_initialized ()); \
-		if (!__nmtst_internal.assert_logging || __nmtst_internal.no_expect_message) { \
-			cmd (__VA_ARGS__); \
-		} else { \
-			printf (_NM_UTILS_MACRO_FIRST (__VA_ARGS__) "\n" _NM_UTILS_MACRO_REST (__VA_ARGS__)); \
-		} \
-	} G_STMT_END
-
-/* split the string inplace at specific delimiters, allowing escaping with '\\'.
- * Returns a zero terminated array of pointers into @str.
- *
- * The caller must g_free() the returned argv array.
- **/
-inline static char **
-nmtst_str_split (char *str, const char *delimiters)
-{
-	const char *d;
-	GArray *result = g_array_sized_new (TRUE, FALSE, sizeof (char *), 3);
-
-	g_assert (str);
-	g_assert (delimiters && !strchr (delimiters, '\\'));
-
-	while (*str) {
-		gsize i = 0, j = 0;
-
-		while (TRUE) {
-			char c = str[i];
-
-			if (c == '\0') {
-				str[j++] = 0;
-				break;
-			} else if (c == '\\') {
-				str[j++] = str[++i];
-				if (!str[i])
-					break;
-			} else {
-				for (d = delimiters; *d; d++) {
-					if (c == *d) {
-						str[j++] = 0;
-						i++;
-						goto BREAK_INNER_LOOPS;
-					}
-				}
-				str[j++] = c;
-			}
-			i++;
-		}
-
-BREAK_INNER_LOOPS:
-		g_array_append_val (result, str);
-		str = &str[i];
-	}
-
-	return (char **) g_array_free (result, FALSE);
-}
-
-
-/* free instances allocated by nmtst (especially nmtst_init()) on shutdown
- * to release memory. After nmtst_free(), the test is uninitialized again. */
-inline static void
-nmtst_free (void)
-{
-	if (!nmtst_initialized ())
-		return;
-
-	g_rand_free (__nmtst_internal.rand0);
-	if (__nmtst_internal.rand)
-		g_rand_free (__nmtst_internal.rand);
-	g_free (__nmtst_internal.sudo_cmd);
-	g_strfreev (__nmtst_internal.orig_argv);
-
-	memset (&__nmtst_internal, 0, sizeof (__nmtst_internal));
-}
-
-inline static void
-__nmtst_init (int *argc, char ***argv, gboolean assert_logging, const char *log_level, const char *log_domains, gboolean *out_set_logging)
-{
-	const char *nmtst_debug;
-	gboolean is_debug = FALSE;
-	char *c_log_level = NULL, *c_log_domains = NULL;
-	char *sudo_cmd = NULL;
-	GArray *debug_messages = g_array_new (TRUE, FALSE, sizeof (char *));
-	int i;
-	gboolean no_expect_message = FALSE;
-	gboolean _out_set_logging;
-	gboolean test_quick = FALSE;
-	gboolean test_quick_set = FALSE;
-	gboolean test_quick_argv = FALSE;
-	gs_unref_ptrarray GPtrArray *p_tests = NULL;
-	gs_unref_ptrarray GPtrArray *s_tests = NULL;
-
-	if (!out_set_logging)
-		out_set_logging = &_out_set_logging;
-	*out_set_logging = FALSE;
-
-	g_assert (!nmtst_initialized ());
-
-	g_assert (!((!!argc) ^ (!!argv)));
-	g_assert (!argc || (g_strv_length (*argv) == *argc));
-	g_assert (!assert_logging || (!log_level && !log_domains));
-
-#ifdef __NETWORKMANAGER_UTILS_H__
-	if (!nm_utils_get_testing_initialized ())
-		_nm_utils_set_testing (_NM_UTILS_TEST_GENERAL);
-#endif
-
-	if (argc)
-		__nmtst_internal.orig_argv = g_strdupv (*argv);
-
-	__nmtst_internal.assert_logging = !!assert_logging;
-
-	nm_g_type_init ();
-
-	is_debug = g_test_verbose ();
-
-	nmtst_debug = g_getenv ("NMTST_DEBUG");
-	if (nmtst_debug) {
-		char **d_argv, **i_argv, *nmtst_debug_copy;
-
-		/* By setting then NMTST_DEBUG variable, @is_debug is set automatically.
-		 * This can be reverted with no-debug (on command line or environment variable). */
-		is_debug = TRUE;
-
-		nmtst_debug_copy = g_strdup (nmtst_debug);
-		d_argv = nmtst_str_split (nmtst_debug_copy, ",; \t\r\n");
-
-		for (i_argv = d_argv; *i_argv; i_argv++) {
-			const char *debug = *i_argv;
-
-			if (!g_ascii_strcasecmp (debug, "debug"))
-				is_debug = TRUE;
-			else if (!g_ascii_strcasecmp (debug, "no-debug")) {
-				/* when specifying the NMTST_DEBUG variable, we set is_debug to true. Use this flag to disable this
-				 * (e.g. for only setting the log-level, but not is_debug). */
-				is_debug = FALSE;
-			} else if (!g_ascii_strncasecmp (debug, "log-level=", strlen ("log-level="))) {
-				g_free (c_log_level);
-				log_level = c_log_level = g_strdup (&debug[strlen ("log-level=")]);
-			} else if (!g_ascii_strcasecmp (debug, "D")) {
-				/* shorthand for "log-level=TRACE,no-expect-message" */
-				g_free (c_log_level);
-				log_level = c_log_level = g_strdup ("TRACE");
-				no_expect_message = TRUE;
-			} else if (!g_ascii_strcasecmp (debug, "TRACE")) {
-				g_free (c_log_level);
-				log_level = c_log_level = g_strdup ("TRACE");
-			} else if (!g_ascii_strncasecmp (debug, "log-domains=", strlen ("log-domains="))) {
-				g_free (c_log_domains);
-				log_domains = c_log_domains = g_strdup (&debug[strlen ("log-domains=")]);
-			} else if (!g_ascii_strncasecmp (debug, "sudo-cmd=", strlen ("sudo-cmd="))) {
-				g_free (sudo_cmd);
-				sudo_cmd = g_strdup (&debug[strlen ("sudo-cmd=")]);
-			} else if (!g_ascii_strcasecmp (debug, "no-expect-message")) {
-				no_expect_message = TRUE;
-			} else if (!g_ascii_strncasecmp (debug, "p=", strlen ("p="))) {
-				if (!p_tests)
-					p_tests = g_ptr_array_new_with_free_func (g_free);
-				g_ptr_array_add (p_tests, g_strdup (&debug[strlen ("p=")]));
-			} else if (!g_ascii_strncasecmp (debug, "s=", strlen ("s="))) {
-				if (!s_tests)
-					s_tests = g_ptr_array_new_with_free_func (g_free);
-				g_ptr_array_add (s_tests, g_strdup (&debug[strlen ("s=")]));
-			} else if (!g_ascii_strcasecmp (debug, "slow") || !g_ascii_strcasecmp (debug, "thorough")) {
-				test_quick = FALSE;
-				test_quick_set = TRUE;
-			} else if (!g_ascii_strcasecmp (debug, "quick")) {
-				test_quick = TRUE;
-				test_quick_set = TRUE;
-			} else {
-				char *msg = g_strdup_printf (">>> nmtst: ignore unrecognized NMTST_DEBUG option \"%s\"", debug);
-
-				g_array_append_val (debug_messages, msg);
-			}
-		}
-
-		g_free (d_argv);
-		g_free (nmtst_debug_copy);
-	}
-
-	if (__nmtst_internal.orig_argv) {
-		char **a = __nmtst_internal.orig_argv;
-
-		for (; *a; a++) {
-			if (!g_ascii_strcasecmp (*a, "--debug"))
-				is_debug = TRUE;
-			else if (!g_ascii_strcasecmp (*a, "--no-debug"))
-				is_debug = FALSE;
-			else if (   !strcmp (*a, "-m=slow")
-			         || !strcmp (*a, "-m=thorough")
-			         || !strcmp (*a, "-m=quick")
-			         || (!strcmp (*a, "-m") && *(a+1)
-			                                && (   !strcmp (*(a+1), "quick")
-			                                    || !strcmp (*(a+1), "slow")
-			                                    || !strcmp (*(a+1), "thorough"))))
-				test_quick_argv = TRUE;
-			else if (strcmp (*a, "--tap") == 0)
-				__nmtst_internal.test_tap_log = TRUE;
-		}
-	}
-
-	if (!argc || g_test_initialized ()) {
-		if (p_tests || s_tests) {
-			char *msg = g_strdup_printf (">>> nmtst: ignore -p and -s options for test which calls g_test_init() itself");
-
-			g_array_append_val (debug_messages, msg);
-		}
-	} else {
-		/* g_test_init() is a variadic function, so we cannot pass it
-		 * (variadic) arguments. If you need to pass additional parameters,
-		 * call nmtst_init() with argc==NULL and call g_test_init() yourself. */
-
-		/* g_test_init() sets g_log_set_always_fatal() for G_LOG_LEVEL_WARNING
-		 * and G_LOG_LEVEL_CRITICAL. So, beware that the test will fail if you
-		 * have any WARN or ERR log messages -- unless you g_test_expect_message(). */
-		GPtrArray *arg_array = g_ptr_array_new ();
-		gs_free char **arg_array_c = NULL;
-		int arg_array_n, j;
-		static char **s_tests_x, **p_tests_x;
-
-		if (*argc) {
-			for (i = 0; i < *argc; i++)
-				g_ptr_array_add (arg_array, (*argv)[i]);
-		} else
-			g_ptr_array_add (arg_array, "./test");
-
-		if (test_quick_set && !test_quick_argv)
-			g_ptr_array_add (arg_array, "-m=quick");
-
-		if (!__nmtst_internal.test_tap_log) {
-			for (i = 0; p_tests && i < p_tests->len; i++) {
-				g_ptr_array_add (arg_array, "-p");
-				g_ptr_array_add (arg_array, p_tests->pdata[i]);
-			}
-			for (i = 0; s_tests && i < s_tests->len; i++) {
-				g_ptr_array_add (arg_array, "-s");
-				g_ptr_array_add (arg_array, s_tests->pdata[i]);
-			}
-		} else if (p_tests || s_tests) {
-			char *msg = g_strdup_printf (">>> nmtst: ignore -p and -s options for tap-tests");
-
-			g_array_append_val (debug_messages, msg);
-		}
-
-		g_ptr_array_add (arg_array, NULL);
-
-		arg_array_n = arg_array->len - 1;
-		arg_array_c = (char **) g_ptr_array_free (arg_array, FALSE);
-
-		g_test_init (&arg_array_n, &arg_array_c, NULL);
-
-		if (*argc > 1) {
-			/* collaps argc/argv by removing the arguments detected
-			 * by g_test_init(). */
-			for (i = 1, j = 1; i < *argc; i++) {
-				if ((*argv)[i] == arg_array_c[j])
-					j++;
-				else
-					(*argv)[i] = NULL;
-			}
-			for (i = 1, j = 1; i < *argc; i++) {
-				if ((*argv)[i]) {
-					(*argv)[j++] = (*argv)[i];
-					if (i >= j)
-						(*argv)[i] = NULL;
-				}
-			}
-			*argc = j;
-		}
-
-		/* we must "leak" the test paths because they are not cloned by g_test_init(). */
-		if (!__nmtst_internal.test_tap_log) {
-			if (p_tests) {
-				p_tests_x = (char **) g_ptr_array_free (p_tests, FALSE);
-				p_tests = NULL;
-			}
-			if (s_tests) {
-				s_tests_x = (char **) g_ptr_array_free (s_tests, FALSE);
-				s_tests = NULL;
-			}
-		}
-	}
-
-	if (test_quick_set)
-		__nmtst_internal.test_quick = test_quick;
-	else if (test_quick_argv)
-		__nmtst_internal.test_quick = g_test_quick ();
-	else {
-#ifdef NMTST_TEST_QUICK
-		__nmtst_internal.test_quick = NMTST_TEST_QUICK;
-#else
-		__nmtst_internal.test_quick = FALSE;
-#endif
-	}
-
-	__nmtst_internal.is_debug = is_debug;
-	__nmtst_internal.rand0 = g_rand_new_with_seed (0);
-	__nmtst_internal.sudo_cmd = sudo_cmd;
-	__nmtst_internal.no_expect_message = no_expect_message;
-
-	if (!log_level && log_domains) {
-		/* if the log level is not specified (but the domain is), we assume
-		 * the caller wants to set it depending on is_debug */
-		log_level = is_debug ? "DEBUG" : "WARN";
-	}
-
-	if (!__nmtst_internal.assert_logging) {
-		gboolean success = TRUE;
-#ifdef __NETWORKMANAGER_LOGGING_H__
-		success = nm_logging_setup (log_level, log_domains, NULL, NULL);
-		*out_set_logging = TRUE;
-#endif
-		g_assert (success);
-#if GLIB_CHECK_VERSION(2,34,0)
-		if (__nmtst_internal.no_expect_message)
-			g_log_set_always_fatal (G_LOG_FATAL_MASK);
-#else
-		/* g_test_expect_message() is a NOP, so allow any messages */
-		g_log_set_always_fatal (G_LOG_FATAL_MASK);
-#endif
-	} else if (__nmtst_internal.no_expect_message) {
-		/* We have a test that would be assert_logging, but the user specified no_expect_message.
-		 * This transforms g_test_expect_message() into a NOP, but we also have to relax
-		 * g_log_set_always_fatal(), which was set by g_test_init(). */
-		g_log_set_always_fatal (G_LOG_FATAL_MASK);
-#ifdef __NETWORKMANAGER_LOGGING_H__
-		if (c_log_domains || c_log_level) {
-			/* Normally, tests with assert_logging do not overwrite the logging level/domains because
-			 * the logging statements are part of the assertions. But if the test is run with
-			 * no-expect-message *and* the logging is set explicitly via environment variables,
-			 * we still reset the logging. */
-			gboolean success;
-
-			success = nm_logging_setup (log_level, log_domains, NULL, NULL);
-			*out_set_logging = TRUE;
-			g_assert (success);
-		}
-#endif
-	} else {
-#if GLIB_CHECK_VERSION(2,34,0)
-		/* We were called not to set logging levels. This means, that the user
-		 * expects to assert against (all) messages. Any uncought message is fatal. */
-		g_log_set_always_fatal (G_LOG_LEVEL_MASK);
-#else
-		/* g_test_expect_message() is a NOP, so allow any messages */
-		g_log_set_always_fatal (G_LOG_FATAL_MASK);
-#endif
-	}
-
-	if ((!__nmtst_internal.assert_logging || (__nmtst_internal.assert_logging && __nmtst_internal.no_expect_message)) &&
-	    (is_debug || (c_log_level && (!g_ascii_strcasecmp (c_log_level, "DEBUG") || !g_ascii_strcasecmp (c_log_level, "TRACE")))) &&
-	    !g_getenv ("G_MESSAGES_DEBUG"))
-	{
-		/* if we are @is_debug or @log_level=="DEBUG" and
-		 * G_MESSAGES_DEBUG is unset, we set G_MESSAGES_DEBUG=all.
-		 * To disable this default behaviour, set G_MESSAGES_DEBUG='' */
-
-		/* Note that g_setenv is not thread safe, but you should anyway call
-		 * nmtst_init() at the very start. */
-		g_setenv ("G_MESSAGES_DEBUG", "all", TRUE);
-	}
-
-	/* Delay messages until we setup logging. */
-	for (i = 0; i < debug_messages->len; i++)
-		__NMTST_LOG (g_message, "%s", g_array_index (debug_messages, const char *, i));
-
-	g_strfreev ((char **) g_array_free (debug_messages, FALSE));
-	g_free (c_log_level);
-	g_free (c_log_domains);
-
-#ifdef __NETWORKMANAGER_UTILS_H__
-	/* ensure that monotonic timestamp is called (because it initially logs a line) */
-	nm_utils_get_monotonic_timestamp_s ();
-#endif
-
-#ifdef NM_UTILS_H
-	{
-		gs_free_error GError *error = NULL;
-
-		if (!nm_utils_init (&error))
-			g_assert_not_reached ();
-		g_assert_no_error (error);
-	}
-#endif
-}
-
-#ifdef __NETWORKMANAGER_LOGGING_H__
-inline static void
-nmtst_init_with_logging (int *argc, char ***argv, const char *log_level, const char *log_domains)
-{
-	__nmtst_init (argc, argv, FALSE, log_level, log_domains, NULL);
-}
-inline static void
-nmtst_init_assert_logging (int *argc, char ***argv, const char *log_level, const char *log_domains)
-{
-	gboolean set_logging;
-
-	__nmtst_init (argc, argv, TRUE, NULL, NULL, &set_logging);
-
-	if (!set_logging) {
-		gboolean success;
-
-		success = nm_logging_setup (log_level, log_domains, NULL, NULL);
-		g_assert (success);
-	}
-}
-#else
-inline static void
-nmtst_init (int *argc, char ***argv, gboolean assert_logging)
-{
-	__nmtst_init (argc, argv, assert_logging, NULL, NULL, NULL);
-}
-#endif
-
-inline static gboolean
-nmtst_is_debug (void)
-{
-	g_assert (nmtst_initialized ());
-	return __nmtst_internal.is_debug;
-}
-
-inline static gboolean
-nmtst_test_quick (void)
-{
-	g_assert (nmtst_initialized ());
-	return __nmtst_internal.test_quick;
-}
-
-#if GLIB_CHECK_VERSION(2,34,0)
-#undef g_test_expect_message
-#define g_test_expect_message(...) \
-	G_STMT_START { \
-		g_assert (nmtst_initialized ()); \
-		if (__nmtst_internal.assert_logging && __nmtst_internal.no_expect_message) { \
-			g_debug ("nmtst: assert-logging: g_test_expect_message %s", G_STRINGIFY ((__VA_ARGS__))); \
-		} else { \
-			G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
-			g_test_expect_message (__VA_ARGS__); \
-			G_GNUC_END_IGNORE_DEPRECATIONS \
-		} \
-	} G_STMT_END
-#undef g_test_assert_expected_messages_internal
-#define g_test_assert_expected_messages_internal(domain, file, line, func) \
-	G_STMT_START { \
-		const char *_domain = (domain); \
-		const char *_file = (file); \
-		const char *_func = (func); \
-		int _line = (line); \
-		\
-		if (__nmtst_internal.assert_logging && __nmtst_internal.no_expect_message) \
-			g_debug ("nmtst: assert-logging: g_test_assert_expected_messages(%s, %s:%d, %s)", _domain?:"", _file?:"", _line, _func?:""); \
-		\
-		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
-		g_test_assert_expected_messages_internal (_domain, _file, _line, _func); \
-		G_GNUC_END_IGNORE_DEPRECATIONS \
-	} G_STMT_END
-#endif
-
-/*****************************************************************************/
-
-typedef struct _NmtstTestData NmtstTestData;
-
-typedef void (*NmtstTestDataRelease) (const NmtstTestData *test_data);
-
-struct _NmtstTestData {
-	const char *testpath;
-	NmtstTestDataRelease fcn_release;
-	gsize n_args;
-	gpointer args[1];
-};
-
-inline static void
-_nmtst_test_data_unpack (const NmtstTestData *test_data, gsize n_args, ...)
-{
-	gsize i;
-	va_list ap;
-	gpointer *p;
-
-	g_assert (test_data);
-	g_assert_cmpint (n_args, ==, test_data->n_args);
-
-	va_start (ap, n_args);
-	for (i = 0; i < n_args; i++) {
-		p = va_arg (ap, gpointer *);
-
-		g_assert (p);
-		*p = test_data->args[i];
-	}
-	va_end (ap);
-}
-#define nmtst_test_data_unpack(test_data, ...) _nmtst_test_data_unpack(test_data, NM_NARG (__VA_ARGS__), ##__VA_ARGS__)
-
-inline static void
-_nmtst_test_data_free (gpointer data)
-{
-	NmtstTestData *test_data = data;
-
-	g_assert (test_data);
-
-	if (test_data->fcn_release)
-		test_data->fcn_release (test_data);
-
-	g_free ((gpointer) test_data->testpath);
-	g_free (test_data);
-}
-
-inline static void
-_nmtst_add_test_func_full (const char *testpath, GTestDataFunc test_func, NmtstTestDataRelease fcn_release, gsize n_args, ...)
-{
-	gsize i;
-	NmtstTestData *data;
-	va_list ap;
-
-	data = g_malloc (G_STRUCT_OFFSET (NmtstTestData, args) + sizeof (gpointer) * (n_args + 1));
-
-	data->testpath = g_strdup (testpath);
-	data->fcn_release = fcn_release;
-	data->n_args = n_args;
-	va_start (ap, n_args);
-	for (i = 0; i < n_args; i++)
-		data->args[i] = va_arg (ap, gpointer);
-	data->args[i] = NULL;
-	va_end (ap);
-
-	g_test_add_data_func_full (testpath,
-	                           data,
-	                           test_func,
-	                           _nmtst_test_data_free);
-}
-#define nmtst_add_test_func_full(testpath, test_func, fcn_release, ...) _nmtst_add_test_func_full(testpath, test_func, fcn_release, NM_NARG (__VA_ARGS__), ##__VA_ARGS__)
-#define nmtst_add_test_func(testpath, test_func, ...) nmtst_add_test_func_full(testpath, test_func, NULL, ##__VA_ARGS__)
-
-/*****************************************************************************/
-
-inline static GRand *
-nmtst_get_rand0 (void)
-{
-	g_assert (nmtst_initialized ());
-	return __nmtst_internal.rand0;
-}
-
-inline static GRand *
-nmtst_get_rand (void)
-{
-	g_assert (nmtst_initialized ());
-
-	if (G_UNLIKELY (!__nmtst_internal.rand)) {
-		guint32 seed;
-		const char *str;
-
-		if ((str = g_getenv ("NMTST_SEED_RAND"))) {
-			gchar *s;
-			gint64 i;
-
-			i = g_ascii_strtoll (str, &s, 0);
-			g_assert (s[0] == '\0' && i >= 0 && i < G_MAXUINT32);
-
-			seed = i;
-			__nmtst_internal.rand = g_rand_new_with_seed (seed);
-		} else {
-			__nmtst_internal.rand = g_rand_new ();
-
-			seed = g_rand_int (__nmtst_internal.rand);
-			g_rand_set_seed (__nmtst_internal.rand, seed);
-		}
-		__nmtst_internal.rand_seed = seed;
-
-		g_print ("\nnmtst: initialize nmtst_get_rand() with NMTST_SEED_RAND=%u\n", seed);
-	}
-	return __nmtst_internal.rand;
-}
-
-inline static guint32
-nmtst_get_rand_int (void)
-{
-	return g_rand_int (nmtst_get_rand ());
-}
-
-inline static void *
-nmtst_rand_perm (GRand *rand, void *dst, const void *src, gsize elmt_size, gsize n_elmt)
-{
-	gsize i, j;
-	char *p_, *pj;
-	char *bu;
-
-	g_assert (dst);
-	g_assert (elmt_size > 0);
-	g_assert (n_elmt < G_MAXINT32);
-
-	if (n_elmt == 0)
-		return dst;
-
-	if (src && dst != src)
-		memcpy (dst, src, elmt_size * n_elmt);
-
-	if (!rand)
-		rand = nmtst_get_rand ();
-
-	bu = g_slice_alloc (elmt_size);
-
-	p_ = dst;
-	for (i = n_elmt; i > 1; i--) {
-		j = g_rand_int_range (rand, 0, i);
-
-		if (j != 0) {
-			pj = &p_[j * elmt_size];
-
-			/* swap */
-			memcpy (bu, p_, elmt_size);
-			memcpy (p_, pj, elmt_size);
-			memcpy (pj, bu, elmt_size);
-		}
-		p_ += elmt_size;
-	}
-
-	g_slice_free1 (elmt_size, bu);
-	return dst;
-}
-
-/*****************************************************************************/
-
-inline static gboolean
-_nmtst_main_loop_run_timeout (gpointer user_data)
-{
-	GMainLoop **p_loop = user_data;
-
-	g_assert (p_loop);
-	g_assert (*p_loop);
-
-	g_main_loop_quit (*p_loop);
-	*p_loop = NULL;
-
-	return G_SOURCE_REMOVE;
-}
-
-inline static gboolean
-nmtst_main_loop_run (GMainLoop *loop, int timeout_ms)
-{
-	GSource *source = NULL;
-	guint id = 0;
-	GMainLoop *loopx = loop;
-
-	if (timeout_ms > 0) {
-		source = g_timeout_source_new (timeout_ms);
-		g_source_set_callback (source, _nmtst_main_loop_run_timeout, &loopx, NULL);
-		id = g_source_attach (source, g_main_loop_get_context (loop));
-		g_assert (id);
-		g_source_unref (source);
-	}
-
-	g_main_loop_run (loop);
-
-	/* if the timeout was reached, return FALSE. */
-	return loopx != NULL;
-}
-
-inline static void
-_nmtst_main_loop_quit_on_notify (GObject *object, GParamSpec *pspec, gpointer user_data)
-{
-	GMainLoop *loop = user_data;
-
-	g_assert (G_IS_OBJECT (object));
-	g_assert (loop);
-
-	g_main_loop_quit (loop);
-}
-#define nmtst_main_loop_quit_on_notify ((GCallback) _nmtst_main_loop_quit_on_notify)
-
-/*****************************************************************************/
-
-inline static const char *
-nmtst_get_sudo_cmd (void)
-{
-	g_assert (nmtst_initialized ());
-	return __nmtst_internal.sudo_cmd;
-}
-
-inline static void
-nmtst_reexec_sudo (void)
-{
-	char *str;
-	char **argv;
-	int i;
-	int errsv;
-
-	g_assert (nmtst_initialized ());
-	g_assert (__nmtst_internal.orig_argv);
-
-	if (!__nmtst_internal.sudo_cmd)
-		return;
-
-	str = g_strjoinv (" ", __nmtst_internal.orig_argv);
-	__NMTST_LOG (g_message, ">> exec %s %s", __nmtst_internal.sudo_cmd, str);
-
-	argv = g_new0 (char *, 1 + g_strv_length (__nmtst_internal.orig_argv) + 1);
-	argv[0] = __nmtst_internal.sudo_cmd;
-	for (i = 0; __nmtst_internal.orig_argv[i]; i++)
-		argv[i+1] = __nmtst_internal.orig_argv[i];
-
-	execvp (__nmtst_internal.sudo_cmd, argv);
-
-	errsv = errno;
-	g_error (">> exec %s failed: %d - %s", __nmtst_internal.sudo_cmd, errsv, strerror (errsv));
-}
-
-/*****************************************************************************/
-
-inline static gsize
-nmtst_find_all_indexes (gpointer *elements,
-                        gsize n_elements,
-                        gpointer *needles,
-                        gsize n_needles,
-                        gboolean (*equal_fcn) (gpointer element, gpointer needle, gpointer user_data),
-                        gpointer user_data,
-                        gssize *out_idx)
-{
-	gsize i, j, k;
-	gsize found = 0;
-
-	for (i = 0; i < n_needles; i++) {
-		gssize idx = -1;
-
-		for (j = 0; j < n_elements; j++) {
-
-			/* no duplicates */
-			for (k = 0; k < i; k++) {
-				if (out_idx[k] == j)
-					goto next;
-			}
-
-			if (equal_fcn (elements[j], needles[i], user_data)) {
-				idx = j;
-				break;
-			}
-next:
-			;
-		}
-
-		out_idx[i] = idx;
-		if (idx >= 0)
-			found++;
-	}
-
-	return found;
-}
-
-/*****************************************************************************/
-
-#define __define_nmtst_static(NUM,SIZE) \
-inline static const char * \
-nmtst_static_##SIZE##_##NUM (const char *str) \
-{ \
-	gsize l; \
-	static char buf[SIZE]; \
-\
-	if (!str) \
-		return NULL; \
-	l = g_strlcpy (buf, str, sizeof (buf)); \
-	g_assert (l < sizeof (buf)); \
-	return buf; \
-}
-__define_nmtst_static(01, 1024)
-__define_nmtst_static(02, 1024)
-__define_nmtst_static(03, 1024)
-#undef __define_nmtst_static
-
-inline static const char *
-nmtst_uuid_generate (void)
-{
-	static char u[37];
-	gs_free char *m = NULL;
-
-	m = nm_utils_uuid_generate ();
-	g_assert (m && strlen (m) == sizeof (u) - 1);
-	memcpy (u, m, sizeof (u));
-	return u;
-}
-
-#define NMTST_SWAP(x,y) \
-	G_STMT_START { \
-		char __nmtst_swap_temp[sizeof(x) == sizeof(y) ? (signed) sizeof(x) : -1]; \
-		memcpy(__nmtst_swap_temp, &y, sizeof(x)); \
-		memcpy(&y,                &x, sizeof(x)); \
-		memcpy(&x, __nmtst_swap_temp, sizeof(x)); \
-	} G_STMT_END
-
-#define nmtst_assert_str_has_substr(str, substr) \
-	G_STMT_START { \
-		const char *__str = (str); \
-		const char *__substr = (substr); \
-		\
-		g_assert (__str); \
-		g_assert (__substr); \
-		if (strstr (__str, __substr) == NULL) \
-			g_error ("%s:%d: Expects \"%s\" but got \"%s\"", __FILE__, __LINE__, __substr, __str); \
-	} G_STMT_END
-
-inline static guint32
-nmtst_inet4_from_string (const char *str)
-{
-	guint32 addr;
-	int success;
-
-	if (!str)
-		return 0;
-
-	success = inet_pton (AF_INET, str, &addr);
-
-	g_assert (success == 1);
-
-	return addr;
-}
-
-inline static const struct in6_addr *
-nmtst_inet6_from_string (const char *str)
-{
-	static struct in6_addr addr;
-	int success;
-
-	if (!str)
-		addr = in6addr_any;
-	else {
-		success = inet_pton (AF_INET6, str, &addr);
-		g_assert (success == 1);
-	}
-
-	return &addr;
-}
-
-inline static void
-_nmtst_assert_ip4_address (const char *file, int line, in_addr_t addr, const char *str_expected)
-{
-	if (nmtst_inet4_from_string (str_expected) != addr) {
-		char buf[100];
-
-		g_error ("%s:%d: Unexpected IPv4 address: expected %s, got %s",
-		         file, line, str_expected ? str_expected : "0.0.0.0",
-		         inet_ntop (AF_INET, &addr, buf, sizeof (buf)));
-	}
-}
-#define nmtst_assert_ip4_address(addr, str_expected) _nmtst_assert_ip4_address (__FILE__, __LINE__, addr, str_expected)
-
-inline static void
-_nmtst_assert_ip6_address (const char *file, int line, const struct in6_addr *addr, const char *str_expected)
-{
-	struct in6_addr any = in6addr_any;
-
-	if (!addr)
-		addr = &any;
-
-	if (memcmp (nmtst_inet6_from_string (str_expected), addr, sizeof (*addr)) != 0) {
-		char buf[100];
-
-		g_error ("%s:%d: Unexpected IPv6 address: expected %s, got %s",
-		         file, line, str_expected ? str_expected : "::",
-		         inet_ntop (AF_INET6, addr, buf, sizeof (buf)));
-	}
-}
-#define nmtst_assert_ip6_address(addr, str_expected) _nmtst_assert_ip6_address (__FILE__, __LINE__, addr, str_expected)
-
-#define nmtst_spawn_sync(working_directory, standard_out, standard_err, assert_exit_status, ...) \
-	__nmtst_spawn_sync (working_directory, standard_out, standard_err, assert_exit_status, ##__VA_ARGS__, NULL)
-inline static gint
-__nmtst_spawn_sync (const char *working_directory, char **standard_out, char **standard_err, int assert_exit_status, ...) G_GNUC_NULL_TERMINATED;
-inline static gint
-__nmtst_spawn_sync (const char *working_directory, char **standard_out, char **standard_err, int assert_exit_status, ...)
-{
-	gint exit_status = 0;
-	GError *error = NULL;
-	char *arg;
-	va_list va_args;
-	GPtrArray *argv = g_ptr_array_new ();
-	gboolean success;
-
-	va_start (va_args, assert_exit_status);
-	while ((arg = va_arg (va_args, char *)))
-		g_ptr_array_add (argv, arg);
-	va_end (va_args);
-
-	g_assert (argv->len >= 1);
-	g_ptr_array_add (argv, NULL);
-
-	success = g_spawn_sync (working_directory,
-	                        (char**) argv->pdata,
-	                        NULL,
-	                        0 /*G_SPAWN_DEFAULT*/,
-	                        NULL,
-	                        NULL,
-	                        standard_out,
-	                        standard_err,
-	                        &exit_status,
-	                        &error);
-	if (!success)
-		g_error ("nmtst_spawn_sync(%s): %s", ((char **) argv->pdata)[0], error->message);
-	g_assert (!error);
-
-	g_assert (!standard_out || *standard_out);
-	g_assert (!standard_err || *standard_err);
-
-	if (assert_exit_status != -1) {
-		/* exit status is a guint8 on success. Set @assert_exit_status to -1
-		 * not to check for the exit status. */
-		g_assert (WIFEXITED (exit_status));
-		g_assert_cmpint (WEXITSTATUS (exit_status), ==, assert_exit_status);
-	}
-
-	g_ptr_array_free (argv, TRUE);
-	return exit_status;
-}
-
-/*******************************************************************************/
-
-inline static char *
-nmtst_file_resolve_relative_path (const char *rel, const char *cwd)
-{
-	gs_free char *cwd_free = NULL;
-
-	g_assert (rel && *rel);
-
-	if (g_path_is_absolute (rel))
-		return g_strdup (rel);
-
-	if (!cwd)
-		cwd = cwd_free = g_get_current_dir ();
-	return g_build_filename (cwd, rel, NULL);
-}
-
-inline static void
-_nmtst_assert_resolve_relative_path_equals (const char *f1, const char *f2, const char *file, int line)
-{
-	gs_free char *p1 = NULL, *p2 = NULL;
-
-	p1 = nmtst_file_resolve_relative_path (f1, NULL);
-	p2 = nmtst_file_resolve_relative_path (f2, NULL);
-	g_assert (p1 && *p1);
-
-	/* Fixme: later we might need to coalesce repeated '/', "./", and "../".
-	 * For now, it's good enough. */
-	if (g_strcmp0 (p1, p2) != 0)
-		g_error ("%s:%d : filenames don't match \"%s\" vs. \"%s\" // \"%s\" - \"%s\"", file, line, f1, f2, p1, p2);
-}
-#define nmtst_assert_resolve_relative_path_equals(f1, f2) _nmtst_assert_resolve_relative_path_equals (f1, f2, __FILE__, __LINE__);
-
-/*******************************************************************************/
-
-#ifdef __NETWORKMANAGER_PLATFORM_H__
-
-inline static NMPlatformIP6Address *
-nmtst_platform_ip6_address (const char *address, const char *peer_address, guint plen)
-{
-	static NMPlatformIP6Address addr;
-
-	memset (&addr, 0, sizeof (addr));
-	addr.address = *nmtst_inet6_from_string (address);
-	addr.peer_address = *nmtst_inet6_from_string (peer_address);
-	addr.plen = plen;
-
-	return &addr;
-}
-
-inline static NMPlatformIP6Address *
-nmtst_platform_ip6_address_full (const char *address, const char *peer_address, guint plen,
-                                 int ifindex, NMIPConfigSource source, guint32 timestamp,
-                                 guint32 lifetime, guint32 preferred, guint32 flags)
-{
-	NMPlatformIP6Address *addr = nmtst_platform_ip6_address (address, peer_address, plen);
-
-	addr->ifindex = ifindex;
-	addr->source = source;
-	addr->timestamp = timestamp;
-	addr->lifetime = lifetime;
-	addr->preferred = preferred;
-	addr->n_ifa_flags = flags;
-
-	return addr;
-}
-
-inline static NMPlatformIP4Route *
-nmtst_platform_ip4_route (const char *network, guint plen, const char *gateway)
-{
-	static NMPlatformIP4Route route;
-
-	memset (&route, 0, sizeof (route));
-	route.network = nmtst_inet4_from_string (network);
-	route.plen = plen;
-	route.gateway = nmtst_inet4_from_string (gateway);
-
-	return &route;
-}
-
-inline static NMPlatformIP4Route *
-nmtst_platform_ip4_route_full (const char *network, guint plen, const char *gateway,
-                               int ifindex, NMIPConfigSource source,
-                               guint metric, guint mss,
-                               guint8 scope,
-                               const char *pref_src)
-{
-	NMPlatformIP4Route *route = nmtst_platform_ip4_route (network, plen, gateway);
-
-	route->ifindex = ifindex;
-	route->source = source;
-	route->metric = metric;
-	route->mss = mss;
-	route->scope_inv = nm_platform_route_scope_inv (scope);
-	route->pref_src = nmtst_inet4_from_string (pref_src);
-
-	return route;
-}
-
-inline static NMPlatformIP6Route *
-nmtst_platform_ip6_route (const char *network, guint plen, const char *gateway)
-{
-	static NMPlatformIP6Route route;
-
-	memset (&route, 0, sizeof (route));
-	route.network = *nmtst_inet6_from_string (network);
-	route.plen = plen;
-	route.gateway = *nmtst_inet6_from_string (gateway);
-
-	return &route;
-}
-
-inline static NMPlatformIP6Route *
-nmtst_platform_ip6_route_full (const char *network, guint plen, const char *gateway,
-                               int ifindex, NMIPConfigSource source,
-                               guint metric, guint mss)
-{
-	NMPlatformIP6Route *route = nmtst_platform_ip6_route (network, plen, gateway);
-
-	route->ifindex = ifindex;
-	route->source = source;
-	route->metric = metric;
-	route->mss = mss;
-
-	return route;
-}
-
-inline static int
-_nmtst_platform_ip4_routes_equal_sort (gconstpointer a, gconstpointer b, gpointer user_data)
-{
-	return nm_platform_ip4_route_cmp ((const NMPlatformIP4Route *) a, (const NMPlatformIP4Route *) b);
-}
-
-inline static void
-nmtst_platform_ip4_routes_equal (const NMPlatformIP4Route *a, const NMPlatformIP4Route *b, gsize len, gboolean ignore_order)
-{
-	gsize i;
-	gs_free const NMPlatformIP4Route *c_a = NULL, *c_b = NULL;
-
-	g_assert (a);
-	g_assert (b);
-
-	if (ignore_order) {
-		a = c_a = g_memdup (a, sizeof (NMPlatformIP4Route) * len);
-		b = c_b = g_memdup (b, sizeof (NMPlatformIP4Route) * len);
-		g_qsort_with_data (c_a, len, sizeof (NMPlatformIP4Route), _nmtst_platform_ip4_routes_equal_sort, NULL);
-		g_qsort_with_data (c_b, len, sizeof (NMPlatformIP4Route), _nmtst_platform_ip4_routes_equal_sort, NULL);
-	}
-
-	for (i = 0; i < len; i++) {
-		if (nm_platform_ip4_route_cmp (&a[i], &b[i]) != 0) {
-			char buf[sizeof (_nm_utils_to_string_buffer)];
-
-			g_error ("Error comparing IPv4 route[%lu]: %s vs %s", (long unsigned) i,
-			         nm_platform_ip4_route_to_string (&a[i], NULL, 0),
-			         nm_platform_ip4_route_to_string (&b[i], buf, sizeof (buf)));
-			g_assert_not_reached ();
-		}
-	}
-}
-
-inline static int
-_nmtst_platform_ip6_routes_equal_sort (gconstpointer a, gconstpointer b, gpointer user_data)
-{
-	return nm_platform_ip6_route_cmp ((const NMPlatformIP6Route *) a, (const NMPlatformIP6Route *) b);
-}
-
-inline static void
-nmtst_platform_ip6_routes_equal (const NMPlatformIP6Route *a, const NMPlatformIP6Route *b, gsize len, gboolean ignore_order)
-{
-	gsize i;
-	gs_free const NMPlatformIP6Route *c_a = NULL, *c_b = NULL;
-
-	g_assert (a);
-	g_assert (b);
-
-	if (ignore_order) {
-		a = c_a = g_memdup (a, sizeof (NMPlatformIP6Route) * len);
-		b = c_b = g_memdup (b, sizeof (NMPlatformIP6Route) * len);
-		g_qsort_with_data (c_a, len, sizeof (NMPlatformIP6Route), _nmtst_platform_ip6_routes_equal_sort, NULL);
-		g_qsort_with_data (c_b, len, sizeof (NMPlatformIP6Route), _nmtst_platform_ip6_routes_equal_sort, NULL);
-	}
-
-	for (i = 0; i < len; i++) {
-		if (nm_platform_ip6_route_cmp (&a[i], &b[i]) != 0) {
-			char buf[sizeof (_nm_utils_to_string_buffer)];
-
-			g_error ("Error comparing IPv6 route[%lu]: %s vs %s", (long unsigned) i,
-			         nm_platform_ip6_route_to_string (&a[i], NULL, 0),
-			         nm_platform_ip6_route_to_string (&b[i], buf, sizeof (buf)));
-			g_assert_not_reached ();
-		}
-	}
-}
-
-#endif
-
-
-#ifdef __NETWORKMANAGER_IP4_CONFIG_H__
-
-inline static NMIP4Config *
-nmtst_ip4_config_clone (NMIP4Config *config)
-{
-	NMIP4Config *copy = nm_ip4_config_new (-1);
-
-	g_assert (copy);
-	g_assert (config);
-	nm_ip4_config_replace (copy, config, NULL);
-	return copy;
-}
-
-#endif
-
-
-#ifdef __NETWORKMANAGER_IP6_CONFIG_H__
-
-inline static NMIP6Config *
-nmtst_ip6_config_clone (NMIP6Config *config)
-{
-	NMIP6Config *copy = nm_ip6_config_new (-1);
-
-	g_assert (copy);
-	g_assert (config);
-	nm_ip6_config_replace (copy, config, NULL);
-	return copy;
-}
-
-#endif
-
-#ifdef NM_SETTING_IP_CONFIG_H
-inline static void
-nmtst_setting_ip_config_add_address (NMSettingIPConfig *s_ip,
-                                     const char *address,
-                                     guint prefix)
-{
-	NMIPAddress *addr;
-	int family;
-
-	g_assert (s_ip);
-
-	if (nm_utils_ipaddr_valid (AF_INET, address))
-		family = AF_INET;
-	else if (nm_utils_ipaddr_valid (AF_INET6, address))
-		family = AF_INET6;
-	else
-		g_assert_not_reached ();
-
-	addr = nm_ip_address_new (family, address, prefix, NULL);
-	g_assert (addr);
-	g_assert (nm_setting_ip_config_add_address (s_ip, addr));
-	nm_ip_address_unref (addr);
-}
-
-inline static void
-nmtst_setting_ip_config_add_route (NMSettingIPConfig *s_ip,
-                                   const char *dest,
-                                   guint prefix,
-                                   const char *next_hop,
-                                   gint64 metric)
-{
-	NMIPRoute *route;
-	int family;
-
-	g_assert (s_ip);
-
-	if (nm_utils_ipaddr_valid (AF_INET, dest))
-		family = AF_INET;
-	else if (nm_utils_ipaddr_valid (AF_INET6, dest))
-		family = AF_INET6;
-	else
-		g_assert_not_reached ();
-
-	route = nm_ip_route_new (family, dest, prefix, next_hop, metric, NULL);
-	g_assert (route);
-	g_assert (nm_setting_ip_config_add_route (s_ip, route));
-	nm_ip_route_unref (route);
-}
-#endif /* NM_SETTING_IP_CONFIG_H */
-
-#if (defined(__NM_SIMPLE_CONNECTION_H__) && defined(__NM_SETTING_CONNECTION_H__)) || (defined(NM_CONNECTION_H))
-
-inline static NMConnection *
-nmtst_clone_connection (NMConnection *connection)
-{
-	g_assert (NM_IS_CONNECTION (connection));
-
-#if defined(__NM_SIMPLE_CONNECTION_H__)
-	return nm_simple_connection_new_clone (connection);
-#else
-	return nm_connection_duplicate (connection);
-#endif
-}
-
-inline static NMConnection *
-nmtst_create_minimal_connection (const char *id, const char *uuid, const char *type, NMSettingConnection **out_s_con)
-{
-	NMConnection *con;
-	NMSetting *s_base = NULL;
-	NMSettingConnection *s_con;
-	gs_free char *uuid_free = NULL;
-
-	g_assert (id);
-
-	if (uuid)
-		g_assert (nm_utils_is_uuid (uuid));
-	else
-		uuid = uuid_free = nm_utils_uuid_generate ();
-
-	if (type) {
-		GType type_g;
-
-#if defined(__NM_SIMPLE_CONNECTION_H__)
-		type_g = nm_setting_lookup_type (type);
-#else
-		type_g = nm_connection_lookup_setting_type (type);
-#endif
-
-		g_assert (type_g != G_TYPE_INVALID);
-
-		s_base = g_object_new (type_g, NULL);
-		g_assert (NM_IS_SETTING (s_base));
-	}
-
-#if defined(__NM_SIMPLE_CONNECTION_H__)
-	con = nm_simple_connection_new ();
-#else
-	con = nm_connection_new ();
-#endif
-
-	s_con = NM_SETTING_CONNECTION (nm_setting_connection_new ());
-
-	g_object_set (s_con,
-	              NM_SETTING_CONNECTION_ID, id,
-	              NM_SETTING_CONNECTION_UUID, uuid,
-	              NM_SETTING_CONNECTION_TYPE, type,
-	              NULL);
-	nm_connection_add_setting (con, NM_SETTING (s_con));
-
-	if (s_base)
-		nm_connection_add_setting (con, s_base);
-
-	if (out_s_con)
-		*out_s_con = s_con;
-	return con;
-}
-
-inline static gboolean
-_nmtst_connection_normalize_v (NMConnection *connection, va_list args)
-{
-	GError *error = NULL;
-	gboolean success;
-	gboolean was_modified = FALSE;
-	GHashTable *parameters = NULL;
-	const char *p_name;
-
-	g_assert (NM_IS_CONNECTION (connection));
-
-	while ((p_name = va_arg (args, const char *))) {
-		if (!parameters)
-			parameters =  g_hash_table_new (g_str_hash, g_str_equal);
-		g_hash_table_insert (parameters, (gpointer *) p_name, va_arg (args, gpointer));
-	}
-
-	success = nm_connection_normalize (connection,
-	                                   parameters,
-	                                   &was_modified,
-	                                   &error);
-	g_assert_no_error (error);
-	g_assert (success);
-
-	if (parameters)
-		g_hash_table_destroy (parameters);
-
-	return was_modified;
-}
-
-inline static gboolean
-_nmtst_connection_normalize (NMConnection *connection, ...)
-{
-	gboolean was_modified;
-	va_list args;
-
-	va_start (args, connection);
-	was_modified = _nmtst_connection_normalize_v (connection, args);
-	va_end (args);
-
-	return was_modified;
-}
-#define nmtst_connection_normalize(connection, ...) \
-    _nmtst_connection_normalize(connection, ##__VA_ARGS__, NULL)
-
-inline static NMConnection *
-_nmtst_connection_duplicate_and_normalize (NMConnection *connection, ...)
-{
-	gboolean was_modified;
-	va_list args;
-
-	connection = nmtst_clone_connection (connection);
-
-	va_start (args, connection);
-	was_modified = _nmtst_connection_normalize_v (connection, args);
-	va_end (args);
-
-	return connection;
-}
-#define nmtst_connection_duplicate_and_normalize(connection, ...) \
-    _nmtst_connection_duplicate_and_normalize(connection, ##__VA_ARGS__, NULL)
-
-inline static void
-nmtst_assert_connection_equals (NMConnection *a, gboolean normalize_a, NMConnection *b, gboolean normalize_b)
-{
-	gboolean compare;
-	gs_unref_object NMConnection *a2 = NULL;
-	gs_unref_object NMConnection *b2 = NULL;
-	GHashTable *out_settings = NULL;
-
-	g_assert (NM_IS_CONNECTION (a));
-	g_assert (NM_IS_CONNECTION (b));
-
-	if (normalize_a)
-		a = a2 = nmtst_connection_duplicate_and_normalize (a);
-	if (normalize_b)
-		b = b2 = nmtst_connection_duplicate_and_normalize (b);
-
-	compare = nm_connection_diff (a, b, NM_SETTING_COMPARE_FLAG_EXACT, &out_settings);
-	if (!compare || out_settings) {
-		const char *name, *pname;
-		GHashTable *setting;
-		GHashTableIter iter, iter2;
-
-		__NMTST_LOG (g_message, ">>> ASSERTION nmtst_assert_connection_equals() fails");
-		if (out_settings) {
-			g_hash_table_iter_init (&iter, out_settings);
-			while (g_hash_table_iter_next (&iter, (gpointer *) &name, (gpointer *) &setting)) {
-				__NMTST_LOG (g_message, ">>> differences in setting '%s':", name);
-
-				g_hash_table_iter_init (&iter2, setting);
-				while (g_hash_table_iter_next (&iter2, (gpointer *) &pname, NULL))
-					__NMTST_LOG (g_message, ">>> differences in setting '%s.%s'", name, pname);
-			}
-		}
-
-#ifdef __NM_KEYFILE_INTERNAL_H__
-		{
-			gs_unref_keyfile GKeyFile *kf_a = NULL, *kf_b = NULL;
-			gs_free char *str_a = NULL, *str_b = NULL;
-
-			kf_a = nm_keyfile_write (a, NULL, NULL, NULL);
-			kf_b = nm_keyfile_write (b, NULL, NULL, NULL);
-
-			if (kf_a)
-				str_a = g_key_file_to_data (kf_a, NULL, NULL);
-			if (kf_b)
-				str_b = g_key_file_to_data (kf_b, NULL, NULL);
-
-			__NMTST_LOG (g_message, ">>> Connection A as kf (*WARNING: keyfile representation might not show the difference*):\n%s", str_a);
-			__NMTST_LOG (g_message, ">>> Connection B as kf (*WARNING: keyfile representation might not show the difference*):\n%s", str_b);
-		}
-#endif
-	}
-	g_assert (compare);
-	g_assert (!out_settings);
-
-	compare = nm_connection_compare (a, b, NM_SETTING_COMPARE_FLAG_EXACT);
-	g_assert (compare);
-}
-
-inline static void
-nmtst_assert_connection_verifies (NMConnection *con)
-{
-	/* assert that the connection does verify, it might be normaliziable or not */
-	GError *error = NULL;
-	gboolean success;
-
-	g_assert (NM_IS_CONNECTION (con));
-
-	success = nm_connection_verify (con, &error);
-	g_assert_no_error (error);
-	g_assert (success);
-}
-
-inline static void
-nmtst_assert_connection_verifies_without_normalization (NMConnection *con)
-{
-	/* assert that the connection verifies and does not need any normalization */
-	GError *error = NULL;
-	gboolean success;
-	gboolean was_modified = FALSE;
-	gs_unref_object NMConnection *clone = NULL;
-
-	clone = nmtst_clone_connection (con);
-
-	nmtst_assert_connection_verifies (con);
-
-	success = nm_connection_normalize (clone, NULL, &was_modified, &error);
-	g_assert_no_error (error);
-	g_assert (success);
-	nmtst_assert_connection_equals (con, FALSE, clone, FALSE);
-	g_assert (!was_modified);
-}
-
-inline static void
-nmtst_assert_connection_verifies_and_normalizable (NMConnection *con)
-{
-	/* assert that the connection does verify, but normalization still modifies it */
-	GError *error = NULL;
-	gboolean success;
-	gboolean was_modified = FALSE;
-	gs_unref_object NMConnection *clone = NULL;
-
-	clone = nmtst_clone_connection (con);
-
-	nmtst_assert_connection_verifies (con);
-
-	success = nm_connection_normalize (clone, NULL, &was_modified, &error);
-	g_assert_no_error (error);
-	g_assert (success);
-	g_assert (was_modified);
-
-	/* again! */
-	nmtst_assert_connection_verifies_without_normalization (clone);
-}
-
-inline static void
-nmtst_assert_connection_verifies_after_normalization (NMConnection *con,
-                                                      GQuark expect_error_domain,
-                                                      gint expect_error_code)
-{
-	/* assert that the connection does not verify, but normalization does fix it */
-	GError *error = NULL;
-	gboolean success;
-	gboolean was_modified = FALSE;
-	gs_unref_object NMConnection *clone = NULL;
-
-	clone = nmtst_clone_connection (con);
-
-	success = nm_connection_verify (con, &error);
-	nmtst_assert_error (error, expect_error_domain, expect_error_code, NULL);
-	g_assert (!success);
-	g_clear_error (&error);
-
-	success = nm_connection_normalize (clone, NULL, &was_modified, &error);
-	g_assert_no_error (error);
-	g_assert (success);
-	g_assert (was_modified);
-
-	/* again! */
-	nmtst_assert_connection_verifies_without_normalization (clone);
-}
-
-inline static void
-nmtst_assert_connection_unnormalizable (NMConnection *con,
-                                        GQuark expect_error_domain,
-                                        gint expect_error_code)
-{
-	/* assert that the connection does not verify, and it cannot be fixed by normalization */
-
-	GError *error = NULL;
-	gboolean success;
-	gboolean was_modified = FALSE;
-	gs_unref_object NMConnection *clone = NULL;
-
-	clone = nmtst_clone_connection (con);
-
-	success = nm_connection_verify (con, &error);
-	nmtst_assert_error (error, expect_error_domain, expect_error_code, NULL);
-	g_assert (!success);
-	g_clear_error (&error);
-
-	success = nm_connection_normalize (clone, NULL, &was_modified, &error);
-	nmtst_assert_error (error, expect_error_domain, expect_error_code, NULL);
-	g_assert (!success);
-	g_assert (!was_modified);
-	nmtst_assert_connection_equals (con, FALSE, clone, FALSE);
-	g_clear_error (&error);
-}
-
-inline static void
-nmtst_assert_setting_verifies (NMSetting *setting)
-{
-	/* assert that the setting verifies without an error */
-
-	GError *error = NULL;
-	gboolean success;
-
-	g_assert (NM_IS_SETTING (setting));
-
-	success = nm_setting_verify (setting, NULL, &error);
-	g_assert_no_error (error);
-	g_assert (success);
-}
-
-inline static void
-nmtst_assert_setting_verify_fails (NMSetting *setting,
-                                   GQuark expect_error_domain,
-                                   gint expect_error_code)
-{
-	/* assert that the setting verification fails */
-
-	GError *error = NULL;
-	gboolean success;
-
-	g_assert (NM_IS_SETTING (setting));
-
-	success = nm_setting_verify (setting, NULL, &error);
-	nmtst_assert_error (error, expect_error_domain, expect_error_code, NULL);
-	g_assert (!success);
-	g_clear_error (&error);
-}
-
-#endif
-
-#ifdef __NM_UTILS_H__
-static inline void
-nmtst_assert_hwaddr_equals (gconstpointer hwaddr1, gssize hwaddr1_len, const char *expected, const char *file, int line)
-{
-	guint8 buf2[NM_UTILS_HWADDR_LEN_MAX];
-	gsize hwaddr2_len = 1;
-	const char *p;
-	gboolean success;
-
-	g_assert (hwaddr1_len > 0 && hwaddr1_len <= NM_UTILS_HWADDR_LEN_MAX);
-
-	g_assert (expected);
-	for (p = expected; *p; p++) {
-		if (*p == ':' || *p == '-')
-			hwaddr2_len++;
-	}
-	g_assert (hwaddr2_len <= NM_UTILS_HWADDR_LEN_MAX);
-	g_assert (nm_utils_hwaddr_aton (expected, buf2, hwaddr2_len));
-
-	/* Manually check the entire hardware address instead of using
-	 * nm_utils_hwaddr_matches() because that function doesn't compare
-	 * entire InfiniBand addresses for various (legitimate) reasons.
-	 */
-	success = (hwaddr1_len == hwaddr2_len);
-	if (success)
-		success = !memcmp (hwaddr1, buf2, hwaddr1_len);
-	if (!success) {
-		g_error ("assert: %s:%d: hwaddr '%s' (%zd) expected, but got %s (%zd)",
-		         file, line, expected, hwaddr2_len, nm_utils_hwaddr_ntoa (hwaddr1, hwaddr1_len), hwaddr1_len);
-	}
-}
-#define nmtst_assert_hwaddr_equals(hwaddr1, hwaddr1_len, expected) \
-    nmtst_assert_hwaddr_equals (hwaddr1, hwaddr1_len, expected, __FILE__, __LINE__)
-#endif
-
-#if defined(__NM_SIMPLE_CONNECTION_H__) && defined(__NM_SETTING_CONNECTION_H__) && defined(__NM_KEYFILE_INTERNAL_H__)
-
-inline static NMConnection *
-nmtst_create_connection_from_keyfile (const char *keyfile_str, const char *keyfile_name, const char *base_dir)
-{
-	GKeyFile *keyfile;
-	GError *error = NULL;
-	gboolean success;
-	NMConnection *con;
-
-	g_assert (keyfile_str);
-
-	keyfile =  g_key_file_new ();
-	success = g_key_file_load_from_data (keyfile, keyfile_str, strlen (keyfile_str), G_KEY_FILE_NONE, &error);
-	g_assert_no_error (error);
-	g_assert (success);
-
-	con = nm_keyfile_read (keyfile, keyfile_name, base_dir, NULL, NULL, &error);
-	g_assert_no_error (error);
-	g_assert (NM_IS_CONNECTION (con));
-
-	g_key_file_unref (keyfile);
-
-	nmtst_connection_normalize (con);
-
-	return con;
-}
-
-#endif
-
-#ifdef __NM_CONNECTION_H__
-
-inline static GVariant *
-_nmtst_variant_new_vardict (int dummy, ...)
-{
-	GVariantBuilder builder;
-	va_list ap;
-	const char *name;
-	GVariant *variant;
-
-	g_variant_builder_init (&builder, G_VARIANT_TYPE_VARDICT);
-
-	va_start (ap, dummy);
-	while ((name = va_arg (ap, const char *))) {
-		variant = va_arg (ap, GVariant *);
-		g_variant_builder_add (&builder, "{sv}", name, variant);
-	}
-	va_end (ap);
-
-	return g_variant_builder_end (&builder);
-}
-#define nmtst_variant_new_vardict(...) _nmtst_variant_new_vardict (0, __VA_ARGS__, NULL)
-
-#define nmtst_assert_variant_is_of_type(variant, type) \
-	G_STMT_START { \
-		GVariant *_variantx = (variant); \
-		\
-		g_assert (_variantx); \
-		g_assert (g_variant_is_of_type (_variantx, (type))); \
-	} G_STMT_END
-
-#define nmtst_assert_variant_uint32(variant, val) \
-	G_STMT_START { \
-		GVariant *_variant = (variant); \
-		\
-		nmtst_assert_variant_is_of_type (_variant, G_VARIANT_TYPE_UINT32); \
-		g_assert_cmpint (g_variant_get_uint32 (_variant), ==, (val)); \
-	} G_STMT_END
-
-#define nmtst_assert_variant_string(variant, str) \
-	G_STMT_START { \
-		gsize _l; \
-		GVariant *_variant = (variant); \
-		const char *_str = (str); \
-		\
-		nmtst_assert_variant_is_of_type (_variant, G_VARIANT_TYPE_STRING); \
-		g_assert (_str); \
-		g_assert_cmpstr (g_variant_get_string (_variant, &_l), ==, _str); \
-		g_assert_cmpint (_l, ==, strlen (_str)); \
-	} G_STMT_END
-
-typedef enum {
-	NMTST_VARIANT_EDITOR_CONNECTION,
-	NMTST_VARIANT_EDITOR_SETTING,
-	NMTST_VARIANT_EDITOR_PROPERTY
-} NmtstVariantEditorPhase;
-
-#define NMTST_VARIANT_EDITOR(__connection_variant, __code) \
-	G_STMT_START { \
-		GVariantIter __connection_iter, *__setting_iter; \
-		GVariantBuilder __connection_builder, __setting_builder; \
-		const char *__cur_setting_name, *__cur_property_name; \
-		GVariant *__property_val; \
-		NmtstVariantEditorPhase __phase; \
-                                                                        \
-		g_variant_builder_init (&__connection_builder, NM_VARIANT_TYPE_CONNECTION); \
-		g_variant_iter_init (&__connection_iter, __connection_variant); \
-		 \
-		__phase = NMTST_VARIANT_EDITOR_CONNECTION; \
-		__cur_setting_name = NULL; \
-		__cur_property_name = NULL; \
-		__code; \
-		while (g_variant_iter_next (&__connection_iter, "{&sa{sv}}", &__cur_setting_name, &__setting_iter)) { \
-			g_variant_builder_init (&__setting_builder, NM_VARIANT_TYPE_SETTING); \
-			__phase = NMTST_VARIANT_EDITOR_SETTING; \
-			__cur_property_name = NULL; \
-			__code; \
-			 \
-			while (   __cur_setting_name \
-			       && g_variant_iter_next (__setting_iter, "{&sv}", &__cur_property_name, &__property_val)) { \
-				__phase = NMTST_VARIANT_EDITOR_PROPERTY; \
-				__code; \
-				 \
-				if (__cur_property_name) { \
-					g_variant_builder_add (&__setting_builder, "{sv}", \
-					                       __cur_property_name, \
-					                       __property_val); \
-				} \
-				g_variant_unref (__property_val); \
-			} \
-			 \
-			if (__cur_setting_name) \
-				g_variant_builder_add (&__connection_builder, "{sa{sv}}", __cur_setting_name, &__setting_builder); \
-			else \
-				g_variant_builder_clear (&__setting_builder); \
-			g_variant_iter_free (__setting_iter); \
-		} \
-		 \
-		g_variant_unref (__connection_variant); \
-		 \
-		__connection_variant = g_variant_builder_end (&__connection_builder); \
-	} G_STMT_END;
-
-#define NMTST_VARIANT_ADD_SETTING(__setting_name, __setting_variant) \
-	G_STMT_START { \
-		if (__phase == NMTST_VARIANT_EDITOR_CONNECTION) \
-			g_variant_builder_add (&__connection_builder, "{s@a{sv}}", __setting_name, __setting_variant); \
-	} G_STMT_END
-
-#define NMTST_VARIANT_DROP_SETTING(__setting_name) \
-	G_STMT_START { \
-		if (__phase == NMTST_VARIANT_EDITOR_SETTING && __cur_setting_name) { \
-			if (!strcmp (__cur_setting_name, __setting_name)) \
-				__cur_setting_name = NULL; \
-		} \
-	} G_STMT_END
-
-#define NMTST_VARIANT_ADD_PROPERTY(__setting_name, __property_name, __format_string, __value) \
-	G_STMT_START { \
-		if (__phase == NMTST_VARIANT_EDITOR_SETTING) { \
-			if (!strcmp (__cur_setting_name, __setting_name)) { \
-				g_variant_builder_add (&__setting_builder, "{sv}", __property_name, \
-				                       g_variant_new (__format_string, __value)); \
-			} \
-		} \
-	} G_STMT_END
-
-#define NMTST_VARIANT_DROP_PROPERTY(__setting_name, __property_name) \
-	G_STMT_START { \
-		if (__phase == NMTST_VARIANT_EDITOR_PROPERTY && __cur_property_name) { \
-			if (   !strcmp (__cur_setting_name, __setting_name) \
-			    && !strcmp (__cur_property_name, __property_name)) \
-				__cur_property_name = NULL; \
-		} \
-	} G_STMT_END
-
-#define NMTST_VARIANT_CHANGE_PROPERTY(__setting_name, __property_name, __format_string, __value) \
-	G_STMT_START { \
-		NMTST_VARIANT_DROP_PROPERTY (__setting_name, __property_name); \
-		NMTST_VARIANT_ADD_PROPERTY (__setting_name, __property_name, __format_string, __value); \
-	} G_STMT_END
-
-#endif /* __NM_CONNECTION_H__ */
-
-#endif /* __NM_TEST_UTILS_H__ */
diff --git shared/nm-utils/gsystem-local-alloc.h shared/nm-utils/gsystem-local-alloc.h
new file mode 100644
index 0000000..51b6251
--- /dev/null
+++ shared/nm-utils/gsystem-local-alloc.h
@@ -0,0 +1,208 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*-
+ *
+ * Copyright (C) 2012 Colin Walters <walters@verbum.org>.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GSYSTEM_LOCAL_ALLOC_H__
+#define __GSYSTEM_LOCAL_ALLOC_H__
+
+#include <gio/gio.h>
+
+G_BEGIN_DECLS
+
+#define GS_DEFINE_CLEANUP_FUNCTION(Type, name, func) \
+  static inline void name (void *v) \
+  { \
+    func (*(Type*)v); \
+  }
+
+#define GS_DEFINE_CLEANUP_FUNCTION0(Type, name, func) \
+  static inline void name (void *v) \
+  { \
+    if (*(Type*)v) \
+      func (*(Type*)v); \
+  }
+
+/* These functions shouldn't be invoked directly;
+ * they are stubs that:
+ * 1) Take a pointer to the location (typically itself a pointer).
+ * 2) Provide %NULL-safety where it doesn't exist already (e.g. g_object_unref)
+ */
+
+/**
+ * gs_free:
+ *
+ * Call g_free() on a variable location when it goes out of scope.
+ */
+#define gs_free __attribute__ ((cleanup(gs_local_free)))
+GS_DEFINE_CLEANUP_FUNCTION(void*, gs_local_free, g_free)
+
+/**
+ * gs_unref_object:
+ *
+ * Call g_object_unref() on a variable location when it goes out of
+ * scope.  Note that unlike g_object_unref(), the variable may be
+ * %NULL.
+ */
+#define gs_unref_object __attribute__ ((cleanup(gs_local_obj_unref)))
+GS_DEFINE_CLEANUP_FUNCTION0(GObject*, gs_local_obj_unref, g_object_unref)
+
+/**
+ * gs_unref_variant:
+ *
+ * Call g_variant_unref() on a variable location when it goes out of
+ * scope.  Note that unlike g_variant_unref(), the variable may be
+ * %NULL.
+ */
+#define gs_unref_variant __attribute__ ((cleanup(gs_local_variant_unref)))
+GS_DEFINE_CLEANUP_FUNCTION0(GVariant*, gs_local_variant_unref, g_variant_unref)
+
+/**
+ * gs_free_variant_iter:
+ *
+ * Call g_variant_iter_free() on a variable location when it goes out of
+ * scope.
+ */
+#define gs_free_variant_iter __attribute__ ((cleanup(gs_local_variant_iter_free)))
+GS_DEFINE_CLEANUP_FUNCTION0(GVariantIter*, gs_local_variant_iter_free, g_variant_iter_free)
+
+/**
+ * gs_free_variant_builder:
+ *
+ * Call g_variant_builder_unref() on a variable location when it goes out of
+ * scope.
+ */
+#define gs_unref_variant_builder __attribute__ ((cleanup(gs_local_variant_builder_unref)))
+GS_DEFINE_CLEANUP_FUNCTION0(GVariantBuilder*, gs_local_variant_builder_unref, g_variant_builder_unref)
+
+/**
+ * gs_unref_array:
+ *
+ * Call g_array_unref() on a variable location when it goes out of
+ * scope.  Note that unlike g_array_unref(), the variable may be
+ * %NULL.
+
+ */
+#define gs_unref_array __attribute__ ((cleanup(gs_local_array_unref)))
+GS_DEFINE_CLEANUP_FUNCTION0(GArray*, gs_local_array_unref, g_array_unref)
+
+/**
+ * gs_unref_ptrarray:
+ *
+ * Call g_ptr_array_unref() on a variable location when it goes out of
+ * scope.  Note that unlike g_ptr_array_unref(), the variable may be
+ * %NULL.
+
+ */
+#define gs_unref_ptrarray __attribute__ ((cleanup(gs_local_ptrarray_unref)))
+GS_DEFINE_CLEANUP_FUNCTION0(GPtrArray*, gs_local_ptrarray_unref, g_ptr_array_unref)
+
+/**
+ * gs_unref_hashtable:
+ *
+ * Call g_hash_table_unref() on a variable location when it goes out
+ * of scope.  Note that unlike g_hash_table_unref(), the variable may
+ * be %NULL.
+ */
+#define gs_unref_hashtable __attribute__ ((cleanup(gs_local_hashtable_unref)))
+GS_DEFINE_CLEANUP_FUNCTION0(GHashTable*, gs_local_hashtable_unref, g_hash_table_unref)
+
+/**
+ * gs_free_list:
+ *
+ * Call g_list_free() on a variable location when it goes out
+ * of scope.
+ */
+#define gs_free_list __attribute__ ((cleanup(gs_local_free_list)))
+GS_DEFINE_CLEANUP_FUNCTION(GList*, gs_local_free_list, g_list_free)
+
+/**
+ * gs_free_slist:
+ *
+ * Call g_slist_free() on a variable location when it goes out
+ * of scope.
+ */
+#define gs_free_slist __attribute__ ((cleanup(gs_local_free_slist)))
+GS_DEFINE_CLEANUP_FUNCTION(GSList*, gs_local_free_slist, g_slist_free)
+
+/**
+ * gs_free_checksum:
+ *
+ * Call g_checksum_free() on a variable location when it goes out
+ * of scope.  Note that unlike g_checksum_free(), the variable may
+ * be %NULL.
+ */
+#define gs_free_checksum __attribute__ ((cleanup(gs_local_checksum_free)))
+GS_DEFINE_CLEANUP_FUNCTION0(GChecksum*, gs_local_checksum_free, g_checksum_free)
+
+/**
+ * gs_unref_bytes:
+ *
+ * Call g_bytes_unref() on a variable location when it goes out
+ * of scope.  Note that unlike g_bytes_unref(), the variable may
+ * be %NULL.
+ */
+#define gs_unref_bytes __attribute__ ((cleanup(gs_local_bytes_unref)))
+GS_DEFINE_CLEANUP_FUNCTION0(GBytes*, gs_local_bytes_unref, g_bytes_unref)
+
+/**
+ * gs_strfreev:
+ *
+ * Call g_strfreev() on a variable location when it goes out of scope.
+ */
+#define gs_strfreev __attribute__ ((cleanup(gs_local_strfreev)))
+GS_DEFINE_CLEANUP_FUNCTION(char**, gs_local_strfreev, g_strfreev)
+
+/**
+ * gs_free_error:
+ *
+ * Call g_error_free() on a variable location when it goes out of scope.
+ */
+#define gs_free_error __attribute__ ((cleanup(gs_local_free_error)))
+GS_DEFINE_CLEANUP_FUNCTION0(GError*, gs_local_free_error, g_error_free)
+
+/**
+ * gs_unref_keyfile:
+ *
+ * Call g_key_file_unref() on a variable location when it goes out of scope.
+ */
+#define gs_unref_keyfile __attribute__ ((cleanup(gs_local_keyfile_unref)))
+GS_DEFINE_CLEANUP_FUNCTION0(GKeyFile*, gs_local_keyfile_unref, g_key_file_unref)
+
+static inline void
+gs_cleanup_close_fdp (int *fdp)
+{
+  int fd;
+
+  g_assert (fdp);
+  
+  fd = *fdp;
+  if (fd != -1)
+    (void) close (fd);
+}
+
+/**
+ * gs_fd_close:
+ *
+ * Call close() on a variable location when it goes out of scope.
+ */
+#define gs_fd_close __attribute__((cleanup(gs_cleanup_close_fdp)))
+
+G_END_DECLS
+
+#endif
diff --git shared/nm-utils/nm-glib.h shared/nm-utils/nm-glib.h
new file mode 100644
index 0000000..5f8ebc7
--- /dev/null
+++ shared/nm-utils/nm-glib.h
@@ -0,0 +1,395 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2008 - 2011 Red Hat, Inc.
+ */
+
+#ifndef __NM_GLIB_H__
+#define __NM_GLIB_H__
+
+
+#include <gio/gio.h>
+#include <string.h>
+
+#ifdef __clang__
+
+#undef G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+#undef G_GNUC_END_IGNORE_DEPRECATIONS
+
+#define G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+    _Pragma("clang diagnostic push") \
+    _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
+
+#define G_GNUC_END_IGNORE_DEPRECATIONS \
+    _Pragma("clang diagnostic pop")
+
+#endif
+
+static inline void
+__g_type_ensure (GType type)
+{
+#if !GLIB_CHECK_VERSION(2,34,0)
+	if (G_UNLIKELY (type == (GType)-1))
+		g_error ("can't happen");
+#else
+	G_GNUC_BEGIN_IGNORE_DEPRECATIONS;
+	g_type_ensure (type);
+	G_GNUC_END_IGNORE_DEPRECATIONS;
+#endif
+}
+#define g_type_ensure __g_type_ensure
+
+#if !GLIB_CHECK_VERSION(2,34,0)
+
+#define g_clear_pointer(pp, destroy) \
+    G_STMT_START {                                                                 \
+        G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));                       \
+        /* Only one access, please */                                              \
+        gpointer *_pp = (gpointer *) (pp);                                         \
+        gpointer _p;                                                               \
+        /* This assignment is needed to avoid a gcc warning */                     \
+        GDestroyNotify _destroy = (GDestroyNotify) (destroy);                      \
+                                                                                   \
+        _p = *_pp;                                                                 \
+        if (_p)                                                                    \
+        {                                                                          \
+            *_pp = NULL;                                                           \
+            _destroy (_p);                                                         \
+        }                                                                          \
+    } G_STMT_END
+
+/* These are used to clean up the output of test programs; we can just let
+ * them no-op in older glib.
+ */
+#define g_test_expect_message(log_domain, log_level, pattern)
+#define g_test_assert_expected_messages()
+
+#else
+
+/* We build with -DGLIB_MAX_ALLOWED_VERSION set to 2.32 to make sure we don't
+ * accidentally use new API that we shouldn't. But we don't want warnings for
+ * the APIs that we emulate above.
+ */
+
+#define g_test_expect_message(domain, level, format...) \
+	G_STMT_START { \
+		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+		g_test_expect_message (domain, level, format); \
+		G_GNUC_END_IGNORE_DEPRECATIONS \
+	} G_STMT_END
+
+#define g_test_assert_expected_messages_internal(domain, file, line, func) \
+	G_STMT_START { \
+		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+		g_test_assert_expected_messages_internal (domain, file, line, func); \
+		G_GNUC_END_IGNORE_DEPRECATIONS \
+	} G_STMT_END
+
+#endif
+
+
+#if GLIB_CHECK_VERSION (2, 35, 0)
+/* For glib >= 2.36, g_type_init() is deprecated.
+ * But since 2.35.1 (7c42ab23b55c43ab96d0ac2124b550bf1f49c1ec) this function
+ * does nothing. Replace the call with empty statement. */
+#define nm_g_type_init()     G_STMT_START { (void) 0; } G_STMT_END
+#else
+#define nm_g_type_init()     G_STMT_START { g_type_init (); } G_STMT_END
+#endif
+
+
+/* g_test_initialized() is only available since glib 2.36. */
+#if !GLIB_CHECK_VERSION (2, 36, 0)
+#define g_test_initialized() (g_test_config_vars->test_initialized)
+#endif
+
+/* g_assert_cmpmem() is only available since glib 2.46. */
+#if !GLIB_CHECK_VERSION (2, 45, 7)
+#define g_assert_cmpmem(m1, l1, m2, l2) G_STMT_START {\
+                                             gconstpointer __m1 = m1, __m2 = m2; \
+                                             int __l1 = l1, __l2 = l2; \
+                                             if (__l1 != __l2) \
+                                               g_assertion_message_cmpnum (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
+                                                                           #l1 " (len(" #m1 ")) == " #l2 " (len(" #m2 "))", __l1, "==", __l2, 'i'); \
+                                             else if (memcmp (__m1, __m2, __l1) != 0) \
+                                               g_assertion_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
+                                                                    "assertion failed (" #m1 " == " #m2 ")"); \
+                                        } G_STMT_END
+#endif
+
+/* Rumtime check for glib version. First do a compile time check which
+ * (if satisfied) shortcuts the runtime check. */
+#define nm_glib_check_version(major, minor, micro) \
+    (   GLIB_CHECK_VERSION ((major), (minor), (micro)) \
+     || (   (   glib_major_version > (major)) \
+         || (   glib_major_version == (major) \
+             && glib_minor_version > (minor)) \
+         || (   glib_major_version == (major) \
+             && glib_minor_version == (minor) \
+             && glib_micro_version >= (micro))))
+
+/* g_test_skip() is only available since glib 2.38. Add a compatibility wrapper. */
+inline static void
+__nmtst_g_test_skip (const gchar *msg)
+{
+#if GLIB_CHECK_VERSION (2, 38, 0)
+	G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+	g_test_skip (msg);
+	G_GNUC_END_IGNORE_DEPRECATIONS
+#else
+	g_debug ("%s", msg);
+#endif
+}
+#define g_test_skip __nmtst_g_test_skip
+
+
+/* g_test_add_data_func_full() is only available since glib 2.34. Add a compatibility wrapper. */
+inline static void
+__g_test_add_data_func_full (const char     *testpath,
+                             gpointer        test_data,
+                             GTestDataFunc   test_func,
+                             GDestroyNotify  data_free_func)
+{
+#if GLIB_CHECK_VERSION (2, 34, 0)
+	G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+	g_test_add_data_func_full (testpath, test_data, test_func, data_free_func);
+	G_GNUC_END_IGNORE_DEPRECATIONS
+#else
+	g_return_if_fail (testpath != NULL);
+	g_return_if_fail (testpath[0] == '/');
+	g_return_if_fail (test_func != NULL);
+
+	g_test_add_vtable (testpath, 0, test_data, NULL,
+	                   (GTestFixtureFunc) test_func,
+	                   (GTestFixtureFunc) data_free_func);
+#endif
+}
+#define g_test_add_data_func_full __g_test_add_data_func_full
+
+
+#if !GLIB_CHECK_VERSION (2, 34, 0)
+#define G_DEFINE_QUARK(QN, q_n)               \
+GQuark                                        \
+q_n##_quark (void)                            \
+{                                             \
+	static GQuark q;                          \
+                                              \
+	if G_UNLIKELY (q == 0)                    \
+		q = g_quark_from_static_string (#QN); \
+                                              \
+	return q;                                 \
+}
+#endif
+
+
+static inline gboolean
+nm_g_hash_table_replace (GHashTable *hash, gpointer key, gpointer value)
+{
+	/* glib 2.40 added a return value indicating whether the key already existed
+	 * (910191597a6c2e5d5d460e9ce9efb4f47d9cc63c). */
+#if GLIB_CHECK_VERSION(2, 40, 0)
+	return g_hash_table_replace (hash, key, value);
+#else
+	gboolean contained = g_hash_table_contains (hash, key);
+
+	g_hash_table_replace (hash, key, value);
+	return !contained;
+#endif
+}
+
+static inline gboolean
+nm_g_hash_table_insert (GHashTable *hash, gpointer key, gpointer value)
+{
+	/* glib 2.40 added a return value indicating whether the key already existed
+	 * (910191597a6c2e5d5d460e9ce9efb4f47d9cc63c). */
+#if GLIB_CHECK_VERSION(2, 40, 0)
+	return g_hash_table_insert (hash, key, value);
+#else
+	gboolean contained = g_hash_table_contains (hash, key);
+
+	g_hash_table_insert (hash, key, value);
+	return !contained;
+#endif
+}
+
+static inline gboolean
+nm_g_hash_table_add (GHashTable *hash, gpointer key)
+{
+	/* glib 2.40 added a return value indicating whether the key already existed
+	 * (910191597a6c2e5d5d460e9ce9efb4f47d9cc63c). */
+#if GLIB_CHECK_VERSION(2, 40, 0)
+	return g_hash_table_add (hash, key);
+#else
+	gboolean contained = g_hash_table_contains (hash, key);
+
+	g_hash_table_add (hash, key);
+	return !contained;
+#endif
+}
+
+#if !GLIB_CHECK_VERSION(2, 40, 0) || defined (NM_GLIB_COMPAT_H_TEST)
+static inline void
+_nm_g_ptr_array_insert (GPtrArray *array,
+                        gint       index_,
+                        gpointer   data)
+{
+	g_return_if_fail (array);
+	g_return_if_fail (index_ >= -1);
+	g_return_if_fail (index_ <= (gint) array->len);
+
+	g_ptr_array_add (array, data);
+
+	if (index_ != -1 && index_ != (gint) (array->len - 1)) {
+		memmove (&(array->pdata[index_ + 1]),
+		         &(array->pdata[index_]),
+		         (array->len - index_ - 1) * sizeof (gpointer));
+		array->pdata[index_] = data;
+	}
+}
+#endif
+#if !GLIB_CHECK_VERSION(2, 40, 0)
+#define g_ptr_array_insert(array, index, data) G_STMT_START { _nm_g_ptr_array_insert (array, index, data); } G_STMT_END
+#else
+#define g_ptr_array_insert(array, index, data) \
+	G_STMT_START { \
+		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+		g_ptr_array_insert (array, index, data); \
+		G_GNUC_END_IGNORE_DEPRECATIONS \
+	} G_STMT_END
+#endif
+
+
+#if !GLIB_CHECK_VERSION (2, 40, 0)
+inline static gboolean
+_g_key_file_save_to_file (GKeyFile     *key_file,
+                          const gchar  *filename,
+                          GError      **error)
+{
+	gchar *contents;
+	gboolean success;
+	gsize length;
+
+	g_return_val_if_fail (key_file != NULL, FALSE);
+	g_return_val_if_fail (filename != NULL, FALSE);
+	g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
+
+	contents = g_key_file_to_data (key_file, &length, NULL);
+	g_assert (contents != NULL);
+
+	success = g_file_set_contents (filename, contents, length, error);
+	g_free (contents);
+
+	return success;
+}
+#define g_key_file_save_to_file(key_file, filename, error) \
+	_g_key_file_save_to_file (key_file, filename, error)
+#else
+#define g_key_file_save_to_file(key_file, filename, error) \
+	({ \
+		gboolean _success; \
+		\
+		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+		_success = g_key_file_save_to_file (key_file, filename, error); \
+		G_GNUC_END_IGNORE_DEPRECATIONS \
+		_success; \
+	})
+#endif
+
+
+#if GLIB_CHECK_VERSION (2, 36, 0)
+#define g_credentials_get_unix_pid(creds, error) \
+	G_GNUC_EXTENSION ({ \
+		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+			(g_credentials_get_unix_pid) ((creds), (error)); \
+		G_GNUC_END_IGNORE_DEPRECATIONS \
+	})
+#else
+#define g_credentials_get_unix_pid(creds, error) \
+	G_GNUC_EXTENSION ({ \
+		struct ucred *native_creds; \
+		 \
+		native_creds = g_credentials_get_native ((creds), G_CREDENTIALS_TYPE_LINUX_UCRED); \
+		g_assert (native_creds); \
+		native_creds->pid; \
+	})
+#endif
+
+
+#if !GLIB_CHECK_VERSION(2, 40, 0) || defined (NM_GLIB_COMPAT_H_TEST)
+static inline gpointer *
+_nm_g_hash_table_get_keys_as_array (GHashTable *hash_table,
+                                    guint      *length)
+{
+	GHashTableIter iter;
+	gpointer key, *ret;
+	guint i = 0;
+
+	g_return_val_if_fail (hash_table, NULL);
+
+	ret = g_new0 (gpointer, g_hash_table_size (hash_table) + 1);
+	g_hash_table_iter_init (&iter, hash_table);
+
+	while (g_hash_table_iter_next (&iter, &key, NULL))
+		ret[i++] = key;
+
+	ret[i] = NULL;
+
+	if (length)
+		*length = i;
+
+	return ret;
+}
+#endif
+#if !GLIB_CHECK_VERSION(2, 40, 0)
+#define g_hash_table_get_keys_as_array(hash_table, length) \
+	G_GNUC_EXTENSION ({ \
+		_nm_g_hash_table_get_keys_as_array (hash_table, length); \
+	})
+#else
+#define g_hash_table_get_keys_as_array(hash_table, length) \
+	G_GNUC_EXTENSION ({ \
+		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+			(g_hash_table_get_keys_as_array) ((hash_table), (length)); \
+		G_GNUC_END_IGNORE_DEPRECATIONS \
+	})
+#endif
+
+#ifndef g_info
+/* g_info was only added with 2.39.2 */
+#define g_info(...)     g_log (G_LOG_DOMAIN,         \
+                               G_LOG_LEVEL_INFO,     \
+                               __VA_ARGS__)
+#endif
+
+#if !GLIB_CHECK_VERSION(2, 44, 0)
+static inline gpointer
+g_steal_pointer (gpointer pp)
+{
+	gpointer *ptr = (gpointer *) pp;
+	gpointer ref;
+
+	ref = *ptr;
+	*ptr = NULL;
+
+	return ref;
+}
+
+/* type safety */
+#define g_steal_pointer(pp) \
+  (0 ? (*(pp)) : (g_steal_pointer) (pp))
+#endif
+
+#endif  /* __NM_GLIB_H__ */
diff --git shared/nm-utils/nm-macros-internal.h shared/nm-utils/nm-macros-internal.h
new file mode 100644
index 0000000..7a5c90f
--- /dev/null
+++ shared/nm-utils/nm-macros-internal.h
@@ -0,0 +1,573 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2014 Red Hat, Inc.
+ */
+
+#ifndef __NM_MACROS_INTERNAL_H__
+#define __NM_MACROS_INTERNAL_H__
+
+#include <stdlib.h>
+
+/********************************************************/
+
+#define _nm_packed __attribute__ ((packed))
+#define _nm_unused __attribute__ ((unused))
+#define _nm_pure   __attribute__ ((pure))
+#define _nm_const  __attribute__ ((const))
+
+#define nm_auto(fcn) __attribute__ ((cleanup(fcn)))
+
+/**
+ * nm_auto_free:
+ *
+ * Call free() on a variable location when it goes out of scope.
+ */
+#define nm_auto_free nm_auto(_nm_auto_free_impl)
+GS_DEFINE_CLEANUP_FUNCTION(void*, _nm_auto_free_impl, free)
+
+static inline void
+_nm_auto_unset_gvalue_impl (GValue *v)
+{
+	g_value_unset (v);
+}
+#define nm_auto_unset_gvalue nm_auto(_nm_auto_unset_gvalue_impl)
+
+/********************************************************/
+
+/* http://stackoverflow.com/a/11172679 */
+#define  _NM_UTILS_MACRO_FIRST(...)                           __NM_UTILS_MACRO_FIRST_HELPER(__VA_ARGS__, throwaway)
+#define __NM_UTILS_MACRO_FIRST_HELPER(first, ...)             first
+
+#define  _NM_UTILS_MACRO_REST(...)                            __NM_UTILS_MACRO_REST_HELPER(__NM_UTILS_MACRO_REST_NUM(__VA_ARGS__), __VA_ARGS__)
+#define __NM_UTILS_MACRO_REST_HELPER(qty, ...)                __NM_UTILS_MACRO_REST_HELPER2(qty, __VA_ARGS__)
+#define __NM_UTILS_MACRO_REST_HELPER2(qty, ...)               __NM_UTILS_MACRO_REST_HELPER_##qty(__VA_ARGS__)
+#define __NM_UTILS_MACRO_REST_HELPER_ONE(first)
+#define __NM_UTILS_MACRO_REST_HELPER_TWOORMORE(first, ...)    , __VA_ARGS__
+#define __NM_UTILS_MACRO_REST_NUM(...) \
+    __NM_UTILS_MACRO_REST_SELECT_20TH(__VA_ARGS__, \
+                TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE,\
+                TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE,\
+                TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE,\
+                TWOORMORE, TWOORMORE, TWOORMORE, ONE, throwaway)
+#define __NM_UTILS_MACRO_REST_SELECT_20TH(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, ...) a20
+
+/********************************************************/
+
+/* http://stackoverflow.com/a/2124385/354393 */
+
+#define NM_NARG(...) \
+         _NM_NARG(__VA_ARGS__,_NM_NARG_RSEQ_N())
+#define _NM_NARG(...) \
+         _NM_NARG_ARG_N(__VA_ARGS__)
+#define _NM_NARG_ARG_N( \
+          _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \
+         _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \
+         _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \
+         _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \
+         _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \
+         _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \
+         _61,_62,_63,N,...) N
+#define _NM_NARG_RSEQ_N() \
+         63,62,61,60,                   \
+         59,58,57,56,55,54,53,52,51,50, \
+         49,48,47,46,45,44,43,42,41,40, \
+         39,38,37,36,35,34,33,32,31,30, \
+         29,28,27,26,25,24,23,22,21,20, \
+         19,18,17,16,15,14,13,12,11,10, \
+         9,8,7,6,5,4,3,2,1,0
+
+/********************************************************/
+
+#if defined (__GNUC__)
+#define _NM_PRAGMA_WARNING_DO(warning)       G_STRINGIFY(GCC diagnostic ignored warning)
+#elif defined (__clang__)
+#define _NM_PRAGMA_WARNING_DO(warning)       G_STRINGIFY(clang diagnostic ignored warning)
+#endif
+
+/* you can only suppress a specific warning that the compiler
+ * understands. Otherwise you will get another compiler warning
+ * about invalid pragma option.
+ * It's not that bad however, because gcc and clang often have the
+ * same name for the same warning. */
+
+#if defined (__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
+#define NM_PRAGMA_WARNING_DISABLE(warning) \
+        _Pragma("GCC diagnostic push") \
+        _Pragma(_NM_PRAGMA_WARNING_DO(warning))
+#elif defined (__clang__)
+#define NM_PRAGMA_WARNING_DISABLE(warning) \
+        _Pragma("clang diagnostic push") \
+        _Pragma(_NM_PRAGMA_WARNING_DO(warning))
+#else
+#define NM_PRAGMA_WARNING_DISABLE(warning)
+#endif
+
+#if defined (__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
+#define NM_PRAGMA_WARNING_REENABLE \
+    _Pragma("GCC diagnostic pop")
+#elif defined (__clang__)
+#define NM_PRAGMA_WARNING_REENABLE \
+    _Pragma("clang diagnostic pop")
+#else
+#define NM_PRAGMA_WARNING_REENABLE
+#endif
+
+/********************************************************/
+
+/**
+ * NM_G_ERROR_MSG:
+ * @error: (allow none): the #GError instance
+ *
+ * All functions must follow the convention that when they
+ * return a failure, they must also set the GError to a valid
+ * message. For external API however, we want to be extra
+ * careful before accessing the error instance. Use NM_G_ERROR_MSG()
+ * which is safe to use on NULL.
+ *
+ * Returns: the error message.
+ **/
+static inline const char *
+NM_G_ERROR_MSG (GError *error)
+{
+	return error ? (error->message ? : "(null)") : "(no-error)"; \
+}
+
+/********************************************************/
+
+/* macro to return strlen() of a compile time string. */
+#define NM_STRLEN(str)     ( sizeof ("" str) - 1 )
+
+#define NM_SET_OUT(out_val, value) \
+	G_STMT_START { \
+		typeof(*(out_val)) *_out_val = (out_val); \
+		\
+		if (_out_val) { \
+			*_out_val = (value); \
+		} \
+	} G_STMT_END
+
+/********************************************************/
+
+#define _NM_IN_SET_EVAL_1(op, _x, y1)                               \
+    (_x == (y1))
+
+#define _NM_IN_SET_EVAL_2(op, _x, y1, y2)                           \
+    (   (_x == (y1))                                                \
+     op (_x == (y2))                                                \
+    )
+
+#define _NM_IN_SET_EVAL_3(op, _x, y1, y2, y3)                       \
+    (   (_x == (y1))                                                \
+     op (_x == (y2))                                                \
+     op (_x == (y3))                                                \
+    )
+
+#define _NM_IN_SET_EVAL_4(op, _x, y1, y2, y3, y4)                   \
+    (   (_x == (y1))                                                \
+     op (_x == (y2))                                                \
+     op (_x == (y3))                                                \
+     op (_x == (y4))                                                \
+    )
+
+#define _NM_IN_SET_EVAL_5(op, _x, y1, y2, y3, y4, y5)               \
+    (   (_x == (y1))                                                \
+     op (_x == (y2))                                                \
+     op (_x == (y3))                                                \
+     op (_x == (y4))                                                \
+     op (_x == (y5))                                                \
+    )
+
+#define _NM_IN_SET_EVAL_6(op, _x, y1, y2, y3, y4, y5, y6)           \
+    (   (_x == (y1))                                                \
+     op (_x == (y2))                                                \
+     op (_x == (y3))                                                \
+     op (_x == (y4))                                                \
+     op (_x == (y5))                                                \
+     op (_x == (y6))                                                \
+    )
+
+#define _NM_IN_SET_EVAL_N2(op, _x, n, ...)        _NM_IN_SET_EVAL_##n(op, _x, __VA_ARGS__)
+#define _NM_IN_SET_EVAL_N(op, x, n, ...)                            \
+    ({                                                              \
+        typeof(x) _x = (x);                                         \
+        !!_NM_IN_SET_EVAL_N2(op, _x, n, __VA_ARGS__);               \
+    })
+
+/* Beware that this does short-circuit evaluation (use "||" instead of "|")
+ * which has a possibly unexpected non-function-like behavior.
+ * Use NM_IN_SET_SE if you need all arguments to be evaluted. */
+#define NM_IN_SET(x, ...)               _NM_IN_SET_EVAL_N(||, x, NM_NARG (__VA_ARGS__), __VA_ARGS__)
+
+/* "SE" stands for "side-effect". Contrary to NM_IN_SET(), this does not do
+ * short-circuit evaluation, which can make a difference if the arguments have
+ * side-effects. */
+#define NM_IN_SET_SE(x, ...)            _NM_IN_SET_EVAL_N(|, x, NM_NARG (__VA_ARGS__), __VA_ARGS__)
+
+/********************************************************/
+
+static inline gboolean
+_NM_IN_STRSET_streq (const char *x, const char *s)
+{
+	return s && strcmp (x, s) == 0;
+}
+
+#define _NM_IN_STRSET_EVAL_1(op, _x, y1)                            \
+    _NM_IN_STRSET_streq (_x, y1)
+
+#define _NM_IN_STRSET_EVAL_2(op, _x, y1, y2)                        \
+    (   _NM_IN_STRSET_streq (_x, y1)                                \
+     op _NM_IN_STRSET_streq (_x, y2)                                \
+    )
+
+#define _NM_IN_STRSET_EVAL_3(op, _x, y1, y2, y3)                    \
+    (   _NM_IN_STRSET_streq (_x, y1)                                \
+     op _NM_IN_STRSET_streq (_x, y2)                                \
+     op _NM_IN_STRSET_streq (_x, y3)                                \
+    )
+
+#define _NM_IN_STRSET_EVAL_4(op, _x, y1, y2, y3, y4)                \
+    (   _NM_IN_STRSET_streq (_x, y1)                                \
+     op _NM_IN_STRSET_streq (_x, y2)                                \
+     op _NM_IN_STRSET_streq (_x, y3)                                \
+     op _NM_IN_STRSET_streq (_x, y4)                                \
+    )
+
+#define _NM_IN_STRSET_EVAL_5(op, _x, y1, y2, y3, y4, y5)            \
+    (   _NM_IN_STRSET_streq (_x, y1)                                \
+     op _NM_IN_STRSET_streq (_x, y2)                                \
+     op _NM_IN_STRSET_streq (_x, y3)                                \
+     op _NM_IN_STRSET_streq (_x, y4)                                \
+     op _NM_IN_STRSET_streq (_x, y5)                                \
+    )
+
+#define _NM_IN_STRSET_EVAL_6(op, _x, y1, y2, y3, y4, y5, y6)        \
+    (   _NM_IN_STRSET_streq (_x, y1)                                \
+     op _NM_IN_STRSET_streq (_x, y2)                                \
+     op _NM_IN_STRSET_streq (_x, y3)                                \
+     op _NM_IN_STRSET_streq (_x, y4)                                \
+     op _NM_IN_STRSET_streq (_x, y5)                                \
+     op _NM_IN_STRSET_streq (_x, y6)                                \
+    )
+
+#define _NM_IN_STRSET_EVAL_N2(op, _x, n, ...) _NM_IN_STRSET_EVAL_##n(op, _x, __VA_ARGS__)
+#define _NM_IN_STRSET_EVAL_N(op, x, n, ...)                       \
+    ({                                                            \
+        const char *_x = (x);                                     \
+        (   ((_x == NULL) && _NM_IN_SET_EVAL_N2    (op, (const char *) NULL, n, __VA_ARGS__)) \
+         || ((_x != NULL) && _NM_IN_STRSET_EVAL_N2 (op, _x,                  n, __VA_ARGS__)) \
+        ); \
+    })
+
+/* Beware that this does short-circuit evaluation (use "||" instead of "|")
+ * which has a possibly unexpected non-function-like behavior.
+ * Use NM_IN_STRSET_SE if you need all arguments to be evaluted. */
+#define NM_IN_STRSET(x, ...)               _NM_IN_STRSET_EVAL_N(||, x, NM_NARG (__VA_ARGS__), __VA_ARGS__)
+
+/* "SE" stands for "side-effect". Contrary to NM_IN_STRSET(), this does not do
+ * short-circuit evaluation, which can make a difference if the arguments have
+ * side-effects. */
+#define NM_IN_STRSET_SE(x, ...)            _NM_IN_STRSET_EVAL_N(|, x, NM_NARG (__VA_ARGS__), __VA_ARGS__)
+
+/*****************************************************************************/
+
+#define nm_streq(s1, s2)  (strcmp (s1, s2) == 0)
+#define nm_streq0(s1, s2) (g_strcmp0 (s1, s2) == 0)
+
+/*****************************************************************************/
+
+#define NM_PRINT_FMT_QUOTED(cond, prefix, str, suffix, str_else) \
+	(cond) ? (prefix) : "", \
+	(cond) ? (str) : (str_else), \
+	(cond) ? (suffix) : ""
+#define NM_PRINT_FMT_QUOTE_STRING(arg) NM_PRINT_FMT_QUOTED((arg), "\"", (arg), "\"", "(null)")
+
+/*****************************************************************************/
+
+/* glib/C provides the following kind of assertions:
+ *   - assert() -- disable with NDEBUG
+ *   - g_return_if_fail() -- disable with G_DISABLE_CHECKS
+ *   - g_assert() -- disable with G_DISABLE_ASSERT
+ * but they are all enabled by default and usually even production builds have
+ * these kind of assertions enabled. It also means, that disabling assertions
+ * is an untested configuration, and might have bugs.
+ *
+ * Add our own assertion macro nm_assert(), which is disabled by default and must
+ * be explicitly enabled. They are useful for more expensive checks or checks that
+ * depend less on runtime conditions (that is, are generally expected to be true). */
+
+#ifndef NM_MORE_ASSERTS
+#define NM_MORE_ASSERTS 0
+#endif
+
+#if NM_MORE_ASSERTS
+#define nm_assert(cond) G_STMT_START { g_assert (cond); } G_STMT_END
+#define nm_assert_not_reached() G_STMT_START { g_assert_not_reached (); } G_STMT_END
+#else
+#define nm_assert(cond) G_STMT_START { if (FALSE) { if (cond) { } } } G_STMT_END
+#define nm_assert_not_reached() G_STMT_START { ; } G_STMT_END
+#endif
+
+/*****************************************************************************/
+
+#define NM_GOBJECT_PROPERTIES_DEFINE_BASE(...) \
+typedef enum { \
+	_PROPERTY_ENUMS_0, \
+	__VA_ARGS__ \
+	_PROPERTY_ENUMS_LAST, \
+} _PropertyEnums; \
+static GParamSpec *obj_properties[_PROPERTY_ENUMS_LAST] = { NULL, }
+
+#define NM_GOBJECT_PROPERTIES_DEFINE(obj_type, ...) \
+NM_GOBJECT_PROPERTIES_DEFINE_BASE (__VA_ARGS__); \
+static inline void \
+_notify (obj_type *obj, _PropertyEnums prop) \
+{ \
+	nm_assert (G_IS_OBJECT (obj)); \
+	nm_assert ((gsize) prop < G_N_ELEMENTS (obj_properties)); \
+	g_object_notify_by_pspec ((GObject *) obj, obj_properties[prop]); \
+}
+
+/*****************************************************************************/
+
+static inline gpointer
+nm_g_object_ref (gpointer obj)
+{
+	/* g_object_ref() doesn't accept NULL. */
+	if (obj)
+		g_object_ref (obj);
+	return obj;
+}
+
+static inline void
+nm_g_object_unref (gpointer obj)
+{
+	/* g_object_unref() doesn't accept NULL. Usully, we workaround that
+	 * by using g_clear_object(), but sometimes that is not convinient
+	 * (for example as as destroy function for a hash table that can contain
+	 * NULL values). */
+	if (obj)
+		g_object_unref (obj);
+}
+
+static inline gboolean
+nm_clear_g_source (guint *id)
+{
+	if (id && *id) {
+		g_source_remove (*id);
+		*id = 0;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static inline gboolean
+nm_clear_g_signal_handler (gpointer self, gulong *id)
+{
+	if (id && *id) {
+		g_signal_handler_disconnect (self, *id);
+		*id = 0;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static inline gboolean
+nm_clear_g_variant (GVariant **variant)
+{
+	if (variant && *variant) {
+		g_variant_unref (*variant);
+		*variant = NULL;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static inline gboolean
+nm_clear_g_cancellable (GCancellable **cancellable)
+{
+	if (cancellable && *cancellable) {
+		g_cancellable_cancel (*cancellable);
+		g_object_unref (*cancellable);
+		*cancellable = NULL;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+/*****************************************************************************/
+
+/* Determine whether @x is a power of two (@x being an integer type).
+ * For the special cases @x equals zero or one, it also returns true.
+ * For negative @x, always returns FALSE. That only applies, if the data
+ * type of @x is signed. */
+#define nm_utils_is_power_of_two(x) ({ \
+		typeof(x) __x = (x); \
+		\
+		/* Check if the value is negative. In that case, return FALSE.
+		 * The first expression is a compile time constant, depending on whether
+		 * the type is signed. The second expression is a clumsy way for (__x >= 0),
+		 * which causes a compiler warning for unsigned types. */ \
+		    ( ( ((typeof(__x)) -1) > ((typeof(__x)) 0) ) || (__x > 0) || (__x == 0) ) \
+		 && ((__x & (__x - 1)) == 0); \
+	})
+
+/*****************************************************************************/
+
+/* check if @flags has exactly one flag (@check) set. You should call this
+ * only with @check being a compile time constant and a power of two. */
+#define NM_FLAGS_HAS(flags, check)  \
+    ( (G_STATIC_ASSERT_EXPR ( ((check) != 0) && ((check) & ((check)-1)) == 0 )), (NM_FLAGS_ANY ((flags), (check))) )
+
+#define NM_FLAGS_ANY(flags, check)  ( ( ((flags) & (check)) != 0       ) ? TRUE : FALSE )
+#define NM_FLAGS_ALL(flags, check)  ( ( ((flags) & (check)) == (check) ) ? TRUE : FALSE )
+
+#define NM_FLAGS_SET(flags, val)  ({ \
+		const typeof(flags) _flags = (flags); \
+		const typeof(flags) _val = (val); \
+		\
+		_flags | _val; \
+	})
+
+#define NM_FLAGS_UNSET(flags, val)  ({ \
+		const typeof(flags) _flags = (flags); \
+		const typeof(flags) _val = (val); \
+		\
+		_flags & (~_val); \
+	})
+
+#define NM_FLAGS_ASSIGN(flags, val, assign)  ({ \
+		const typeof(flags) _flags = (flags); \
+		const typeof(flags) _val = (val); \
+		\
+		(assign) \
+			? _flags | (_val) \
+			: _flags & (~_val); \
+	})
+
+/*****************************************************************************/
+
+#define _NM_BACKPORT_SYMBOL_IMPL(VERSION, RETURN_TYPE, ORIG_FUNC, VERSIONED_FUNC, ARGS_TYPED, ARGS) \
+RETURN_TYPE VERSIONED_FUNC ARGS_TYPED; \
+RETURN_TYPE VERSIONED_FUNC ARGS_TYPED \
+{ \
+    return ORIG_FUNC ARGS; \
+} \
+RETURN_TYPE ORIG_FUNC ARGS_TYPED; \
+__asm__(".symver "G_STRINGIFY(VERSIONED_FUNC)", "G_STRINGIFY(ORIG_FUNC)"@"G_STRINGIFY(VERSION))
+
+#define NM_BACKPORT_SYMBOL(VERSION, RETURN_TYPE, FUNC, ARGS_TYPED, ARGS) \
+_NM_BACKPORT_SYMBOL_IMPL(VERSION, RETURN_TYPE, FUNC, _##FUNC##_##VERSION, ARGS_TYPED, ARGS)
+
+/*****************************************************************************/
+
+static inline char *
+nm_strstrip (char *str)
+{
+	/* g_strstrip doesn't like NULL. */
+	return str ? g_strstrip (str) : NULL;
+}
+
+/*****************************************************************************/
+
+static inline guint
+nm_encode_version (guint major, guint minor, guint micro) {
+	/* analog to the preprocessor macro NM_ENCODE_VERSION(). */
+	return (major << 16) | (minor << 8) | micro;
+}
+
+static inline void
+nm_decode_version (guint version, guint *major, guint *minor, guint *micro) {
+	*major = (version & 0xFFFF0000u) >> 16;
+	*minor = (version & 0x0000FF00u) >>  8;
+	*micro = (version & 0x000000FFu);
+}
+/*****************************************************************************/
+
+#define nm_sprintf_buf(buf, format, ...) ({ \
+		char * _buf = (buf); \
+		\
+		/* some static assert trying to ensure that the buffer is statically allocated.
+		 * It disallows a buffer size of sizeof(gpointer) to catch that. */ \
+		G_STATIC_ASSERT (G_N_ELEMENTS (buf) == sizeof (buf) && sizeof (buf) != sizeof (char *)); \
+		g_snprintf (_buf, sizeof (buf), \
+		            ""format"", ##__VA_ARGS__); \
+		_buf; \
+	})
+
+#define nm_sprintf_bufa(n_elements, format, ...) \
+	({ \
+		char *_buf; \
+		\
+		G_STATIC_ASSERT (sizeof (char[MAX ((n_elements), 1)]) == (n_elements)); \
+		_buf = g_alloca (n_elements); \
+		g_snprintf (_buf, n_elements, \
+		            ""format"", ##__VA_ARGS__); \
+		_buf; \
+	})
+
+/*****************************************************************************/
+
+/**
+ * The boolean type _Bool is C99 while we mostly stick to C89. However, _Bool is too
+ * convinient to miss and is effectively available in gcc and clang. So, just use it.
+ *
+ * Usually, one would include "stdbool.h" to get the "bool" define which aliases
+ * _Bool. We provide this define here, because we want to make use of it anywhere.
+ * (also, stdbool.h is again C99).
+ *
+ * Using _Bool has advantages over gboolean:
+ *
+ * - commonly _Bool is one byte large, instead of gboolean's 4 bytes (because gboolean
+ *   is a typedef for gint). Especially when having boolean fields in a struct, we can
+ *   thereby easily save some space.
+ *
+ * - _Bool type guarantees that two "true" expressions compare equal. E.g. the follwing
+ *   will not work:
+ *        gboolean v1 = 1;
+ *        gboolean v2 = 2;
+ *        g_assert_cmpint (v1, ==, v2); // will fail
+ *   For that, we often to use !! to coerce gboolean values to 0 or 1:
+ *        g_assert_cmpint (!!v2, ==, TRUE);
+ *   With _Bool type, this will be handled properly by the compiler.
+ *
+ * - For structs, we might want to safe even more space and use bitfields:
+ *       struct s1 {
+ *           gboolean v1:1;
+ *       };
+ *   But the problem here is that gboolean is signed, so that
+ *   v1 will be either 0 or -1 (not 1, TRUE). Thus, the following
+ *   fails:
+ *      struct s1 s = { .v1 = TRUE, };
+ *      g_assert_cmpint (s1.v1, ==, TRUE);
+ *   It will however work just fine with bool/_Bool while retaining the
+ *   notion of having a boolean value.
+ *
+ * Also, add the defines for "true" and "false". Those are nicely highlighted by the editor
+ * as special types, contrary to glib's "TRUE"/"FALSE".
+ */
+
+#ifndef bool
+#define bool _Bool
+#define true    1
+#define false   0
+#endif
+
+/*****************************************************************************/
+
+#endif /* __NM_MACROS_INTERNAL_H__ */
diff --git shared/nm-utils/nm-shared-utils.c shared/nm-utils/nm-shared-utils.c
new file mode 100644
index 0000000..38f6529
--- /dev/null
+++ shared/nm-utils/nm-shared-utils.c
@@ -0,0 +1,239 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2016 Red Hat, Inc.
+ */
+
+#include "nm-default.h"
+
+#include "nm-shared-utils.h"
+
+#include <errno.h>
+
+/*****************************************************************************/
+
+/* _nm_utils_ascii_str_to_int64:
+ *
+ * A wrapper for g_ascii_strtoll, that checks whether the whole string
+ * can be successfully converted to a number and is within a given
+ * range. On any error, @fallback will be returned and %errno will be set
+ * to a non-zero value. On success, %errno will be set to zero, check %errno
+ * for errors. Any trailing or leading (ascii) white space is ignored and the
+ * functions is locale independent.
+ *
+ * The function is guaranteed to return a value between @min and @max
+ * (inclusive) or @fallback. Also, the parsing is rather strict, it does
+ * not allow for any unrecognized characters, except leading and trailing
+ * white space.
+ **/
+gint64
+_nm_utils_ascii_str_to_int64 (const char *str, guint base, gint64 min, gint64 max, gint64 fallback)
+{
+	gint64 v;
+	char *s = NULL;
+
+	if (str) {
+		while (g_ascii_isspace (str[0]))
+			str++;
+	}
+	if (!str || !str[0]) {
+		errno = EINVAL;
+		return fallback;
+	}
+
+	errno = 0;
+	v = g_ascii_strtoll (str, &s, base);
+
+	if (errno != 0)
+		return fallback;
+	if (s[0] != '\0') {
+		while (g_ascii_isspace (s[0]))
+			s++;
+		if (s[0] != '\0') {
+			errno = EINVAL;
+			return fallback;
+		}
+	}
+	if (v > max || v < min) {
+		errno = ERANGE;
+		return fallback;
+	}
+
+	return v;
+}
+
+/*****************************************************************************/
+
+gint
+_nm_utils_ascii_str_to_bool (const char *str,
+                             gint default_value)
+{
+	gsize len;
+	char *s = NULL;
+
+	if (!str)
+		return default_value;
+
+	while (str[0] && g_ascii_isspace (str[0]))
+		str++;
+
+	if (!str[0])
+		return default_value;
+
+	len = strlen (str);
+	if (g_ascii_isspace (str[len - 1])) {
+		s = g_strdup (str);
+		g_strchomp (s);
+		str = s;
+	}
+
+	if (!g_ascii_strcasecmp (str, "true") || !g_ascii_strcasecmp (str, "yes") || !g_ascii_strcasecmp (str, "on") || !g_ascii_strcasecmp (str, "1"))
+		default_value = TRUE;
+	else if (!g_ascii_strcasecmp (str, "false") || !g_ascii_strcasecmp (str, "no") || !g_ascii_strcasecmp (str, "off") || !g_ascii_strcasecmp (str, "0"))
+		default_value = FALSE;
+	if (s)
+		g_free (s);
+	return default_value;
+}
+
+/*****************************************************************************/
+
+G_DEFINE_QUARK (nm-utils-error-quark, nm_utils_error)
+
+void
+nm_utils_error_set_cancelled (GError **error,
+                              gboolean is_disposing,
+                              const char *instance_name)
+{
+	if (is_disposing) {
+		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_CANCELLED_DISPOSING,
+		             "Disposing %s instance",
+		             instance_name && *instance_name ? instance_name : "source");
+	} else {
+		g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_CANCELLED,
+		                     "Request cancelled");
+	}
+}
+
+gboolean
+nm_utils_error_is_cancelled (GError *error,
+                             gboolean consider_is_disposing)
+{
+	if (error) {
+		if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
+			return TRUE;
+		if (   consider_is_disposing
+		    && g_error_matches (error, NM_UTILS_ERROR, NM_UTILS_ERROR_CANCELLED_DISPOSING))
+			return TRUE;
+	}
+	return FALSE;
+}
+
+/*****************************************************************************/
+
+/**
+ * nm_g_object_set_property:
+ * @object: the target object
+ * @property_name: the property name
+ * @value: the #GValue to set
+ * @error: (allow-none): optional error argument
+ *
+ * A reimplementation of g_object_set_property(), but instead
+ * returning an error instead of logging a warning. All g_object_set*()
+ * versions in glib require you to not pass invalid types or they will
+ * log a g_warning() -- without reporting an error. We don't want that,
+ * so we need to hack error checking around it.
+ *
+ * Returns: whether the value was successfully set.
+ */
+gboolean
+nm_g_object_set_property (GObject *object,
+                          const gchar  *property_name,
+                          const GValue *value,
+                          GError **error)
+{
+	GParamSpec *pspec;
+	nm_auto_unset_gvalue GValue tmp_value = G_VALUE_INIT;
+	GObjectClass *klass;
+
+	g_return_val_if_fail (G_IS_OBJECT (object), FALSE);
+	g_return_val_if_fail (property_name != NULL, FALSE);
+	g_return_val_if_fail (G_IS_VALUE (value), FALSE);
+	g_return_val_if_fail (!error || !*error, FALSE);
+
+	/* g_object_class_find_property() does g_param_spec_get_redirect_target(),
+	 * where we differ from a plain g_object_set_property(). */
+	pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (object), property_name);
+
+	if (!pspec) {
+		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
+		             _("object class '%s' has no property named '%s'"),
+		             G_OBJECT_TYPE_NAME (object),
+		             property_name);
+		return FALSE;
+	}
+	if (!(pspec->flags & G_PARAM_WRITABLE)) {
+		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
+		             _("property '%s' of object class '%s' is not writable"),
+		             pspec->name,
+		             G_OBJECT_TYPE_NAME (object));
+		return FALSE;
+	}
+	if ((pspec->flags & G_PARAM_CONSTRUCT_ONLY)) {
+		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
+		             _("construct property \"%s\" for object '%s' can't be set after construction"),
+		             pspec->name, G_OBJECT_TYPE_NAME (object));
+		return FALSE;
+	}
+
+	klass = g_type_class_peek (pspec->owner_type);
+	if (klass == NULL) {
+		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
+		             _("'%s::%s' is not a valid property name; '%s' is not a GObject subtype"),
+		            g_type_name (pspec->owner_type), pspec->name, g_type_name (pspec->owner_type));
+		return FALSE;
+	}
+
+	/* provide a copy to work from, convert (if necessary) and validate */
+	g_value_init (&tmp_value, pspec->value_type);
+	if (!g_value_transform (value, &tmp_value)) {
+		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
+		             _("unable to set property '%s' of type '%s' from value of type '%s'"),
+		             pspec->name,
+		             g_type_name (pspec->value_type),
+		             G_VALUE_TYPE_NAME (value));
+		return FALSE;
+	}
+	if (   g_param_value_validate (pspec, &tmp_value)
+	    && !(pspec->flags & G_PARAM_LAX_VALIDATION)) {
+		gs_free char *contents = g_strdup_value_contents (value);
+
+		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
+		             _("value \"%s\" of type '%s' is invalid or out of range for property '%s' of type '%s'"),
+		             contents,
+		             G_VALUE_TYPE_NAME (value),
+		             pspec->name,
+		             g_type_name (pspec->value_type));
+		return FALSE;
+	}
+
+	g_object_set_property (object, property_name, &tmp_value);
+	return TRUE;
+}
+
+/*****************************************************************************/
diff --git shared/nm-utils/nm-shared-utils.h shared/nm-utils/nm-shared-utils.h
new file mode 100644
index 0000000..cfa8f99
--- /dev/null
+++ shared/nm-utils/nm-shared-utils.h
@@ -0,0 +1,66 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2016 Red Hat, Inc.
+ */
+
+#ifndef __NM_SHARED_UTILS_H__
+#define __NM_SHARED_UTILS_H__
+
+/******************************************************************************/
+
+gint64 _nm_utils_ascii_str_to_int64 (const char *str, guint base, gint64 min, gint64 max, gint64 fallback);
+
+gint _nm_utils_ascii_str_to_bool (const char *str,
+                                  gint default_value);
+
+/******************************************************************************/
+
+/**
+ * NMUtilsError:
+ * @NM_UTILS_ERROR_UNKNOWN: unknown or unclassified error
+ * @NM_UTILS_ERROR_CANCELLED_DISPOSING: when disposing an object that has
+ *   pending aynchronous operations, the operation is cancelled with this
+ *   error reason. Depending on the usage, this might indicate a bug because
+ *   usually the target object should stay alive as long as there are pending
+ *   operations.
+ */
+typedef enum {
+	NM_UTILS_ERROR_UNKNOWN = 0,                 /*< nick=Unknown >*/
+	NM_UTILS_ERROR_CANCELLED_DISPOSING,         /*< nick=CancelledDisposing >*/
+} NMUtilsError;
+
+#define NM_UTILS_ERROR (nm_utils_error_quark ())
+GQuark nm_utils_error_quark (void);
+
+void nm_utils_error_set_cancelled (GError **error,
+                                   gboolean is_disposing,
+                                   const char *instance_name);
+gboolean nm_utils_error_is_cancelled (GError *error,
+                                      gboolean consider_is_disposing);
+
+/******************************************************************************/
+
+gboolean nm_g_object_set_property (GObject *object,
+                                   const gchar  *property_name,
+                                   const GValue *value,
+                                   GError **error);
+
+/******************************************************************************/
+
+#endif /* __NM_SHARED_UTILS_H__ */
diff --git shared/nm-utils/nm-test-utils.h shared/nm-utils/nm-test-utils.h
new file mode 100644
index 0000000..ad3cad6
--- /dev/null
+++ shared/nm-utils/nm-test-utils.h
@@ -0,0 +1,1743 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2014 Red Hat, Inc.
+ */
+
+#ifndef __NM_TEST_UTILS_H__
+#define __NM_TEST_UTILS_H__
+
+/*******************************************************************************
+ * HOWTO run tests.
+ *
+ * Our tests (make check) include this header-only file nm-test-utils.h.
+ *
+ * Logging:
+ *   In tests, nm-logging redirects to glib logging. By default, glib suppresses all debug
+ *   messages unless you set G_MESSAGES_DEBUG. To enable debug logging, you can explicitly set
+ *   G_MESSAGES_DEBUG. Otherwise, nm-test will set G_MESSAGES_DEBUG=all in debug mode (see below).
+ *   For nm-logging, you can configure the log-level and domains via NMTST_DEBUG environment
+ *   variable.
+ *
+ * Assert-logging:
+ *   Some tests assert against logged messages (g_test_expect_message()).
+ *   By specifying no-expect-message in NMTST_DEBUG, you can disable assert logging
+ *   and g_test_assert_expected_messages() will not fail.
+ *
+ * NMTST_SEED_RAND environment variable:
+ *   Tests that use random numbers from nmtst_get_rand() get seeded randomly at each start.
+ *   You can specify the seed by setting NMTST_SEED_RAND. Also, tests will print the seed
+ *   to stdout, so that you know the choosen seed.
+ *
+ *
+ * NMTST_DEBUG environment variable:
+ *
+ * "debug", "no-debug": when at test is run in debug mode, it might behave differently,
+ *   depending on the test. See nmtst_is_debug().
+ *   Known differences:
+ *    - a test might leave the logging level unspecified. In this case, running in
+ *      debug mode, will turn on DEBUG logging, otherwise WARN logging only.
+ *    - if G_MESSAGES_DEBUG is unset, nm-test will set G_MESSAGES_DEBUG=all
+ *      for tests that don't do assert-logging.
+ *   Debug mode is determined as follows (highest priority first):
+ *    - command line option --debug/--no-debug
+ *    - NMTST_DEBUG=debug/no-debug
+ *    - setting NMTST_DEBUG implies debugging turned on
+ *    - g_test_verbose()
+ *
+ * "no-expect-message": for tests that would assert against log messages, disable
+ *   those asserts.
+ *
+ * "log-level=LEVEL", "log-domains=DOMAIN": reset the log level and domain for tests.
+ *    It only has an effect for nm-logging messages.
+ *    This has no effect if the test asserts against logging (unless no-expect-message),
+ *    otherwise, changing the logging would break tests.
+ *    If you set the level to DEBUG or TRACE, it also sets G_MESSAGES_DEBUG=all (unless
+ *    in assert-logging mode and unless G_MESSAGES_DEBUG is already defined).
+ *
+ * "TRACE", this is shorthand for "log-level=TRACE".
+ *
+ * "D", this is shorthand for "log-level=TRACE,no-expect-message".
+ *
+ * "sudo-cmd=PATH": when running root tests as normal user, the test will execute
+ *   itself by invoking sudo at PATH.
+ *   For example
+ *     NMTST_DEBUG="sudo-cmd=$PWD/tools/test-sudo-wrapper.sh" make -C src/platform/tests/ check
+ *
+ * "slow|quick|thorough": enable/disable long-running tests. This sets nmtst_test_quick().
+ *   Whether long-running tests are enabled is determined as follows (highest priority first):
+ *     - specifying the value in NMTST_DEBUG has highest priority
+ *     - respect g_test_quick(), if the command line contains '-mslow', '-mquick', '-mthorough'.
+ *     - use compile time default
+ *
+ * "p=PATH"|"s=PATH": passes the path to g_test_init() as "-p" and "-s", respectively.
+ *   Unfortunately, these options conflict with "--tap" which our makefile passes to the
+ *   tests, thus it's only useful outside of `make check`.
+ *
+ *******************************************************************************/
+
+#include "nm-default.h"
+
+#include <arpa/inet.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+#include "nm-utils.h"
+
+/*******************************************************************************/
+
+/* general purpose functions that have no dependency on other nmtst functions */
+
+#define nmtst_assert_error(error, expect_error_domain, expect_error_code, expect_error_pattern) \
+	G_STMT_START { \
+		GError *_error = (error); \
+		GQuark _expect_error_domain = (expect_error_domain); \
+		const char *_expect_error_pattern = (expect_error_pattern); \
+		\
+		if (_expect_error_domain) \
+			g_assert_error (_error, _expect_error_domain, (expect_error_code)); \
+		else \
+			g_assert (_error); \
+		g_assert (_error->message); \
+		if (   _expect_error_pattern \
+		    && !g_pattern_match_simple (_expect_error_pattern, _error->message)) { \
+			g_error ("%s:%d: error message does not have expected pattern '%s'. Instead it is '%s' (%s, %d)", \
+			         __FILE__, __LINE__, \
+			         _expect_error_pattern, _error->message, g_quark_to_string (_error->domain), _error->code); \
+		} \
+	} G_STMT_END
+
+#define NMTST_WAIT(max_wait_ms, wait) \
+	({ \
+		gboolean _not_expired = TRUE; \
+		gint64 _nmtst_end, _nmtst_max_wait_us = (max_wait_ms) * 1000L; \
+		\
+		_nmtst_end = g_get_monotonic_time () + _nmtst_max_wait_us; \
+		while (TRUE) { \
+			{ wait }; \
+			if (g_get_monotonic_time () > _nmtst_end) { \
+				_not_expired = FALSE; \
+				break; \
+			} \
+		} \
+		_not_expired; \
+	})
+
+#define NMTST_WAIT_ASSERT(max_wait_ms, wait) \
+	G_STMT_START { \
+		if (!(NMTST_WAIT (max_wait_ms, wait))) \
+			g_assert_not_reached (); \
+	} G_STMT_END
+
+#define nmtst_assert_success(success, error) \
+	G_STMT_START { \
+		g_assert_no_error (error); \
+		g_assert ((success)); \
+	} G_STMT_END
+
+#define nmtst_assert_no_success(success, error) \
+	G_STMT_START { \
+		g_assert (error); \
+		g_assert (!(success)); \
+	} G_STMT_END
+
+/*******************************************************************************/
+
+struct __nmtst_internal
+{
+	GRand *rand0;
+	guint32 rand_seed;
+	GRand *rand;
+	gboolean is_debug;
+	gboolean assert_logging;
+	gboolean no_expect_message;
+	gboolean test_quick;
+	gboolean test_tap_log;
+	char *sudo_cmd;
+	char **orig_argv;
+};
+
+extern struct __nmtst_internal __nmtst_internal;
+
+#define NMTST_DEFINE() \
+struct __nmtst_internal __nmtst_internal = { 0 }; \
+\
+__attribute__ ((destructor)) static void \
+_nmtst_exit (void) \
+{ \
+	__nmtst_internal.assert_logging = FALSE; \
+	g_test_assert_expected_messages (); \
+	nmtst_free (); \
+}
+
+
+inline static gboolean
+nmtst_initialized (void)
+{
+	return !!__nmtst_internal.rand0;
+}
+
+#define __NMTST_LOG(cmd, ...) \
+	G_STMT_START { \
+		g_assert (nmtst_initialized ()); \
+		if (!__nmtst_internal.assert_logging || __nmtst_internal.no_expect_message) { \
+			cmd (__VA_ARGS__); \
+		} else { \
+			printf (_NM_UTILS_MACRO_FIRST (__VA_ARGS__) "\n" _NM_UTILS_MACRO_REST (__VA_ARGS__)); \
+		} \
+	} G_STMT_END
+
+/* split the string inplace at specific delimiters, allowing escaping with '\\'.
+ * Returns a zero terminated array of pointers into @str.
+ *
+ * The caller must g_free() the returned argv array.
+ **/
+inline static char **
+nmtst_str_split (char *str, const char *delimiters)
+{
+	const char *d;
+	GArray *result = g_array_sized_new (TRUE, FALSE, sizeof (char *), 3);
+
+	g_assert (str);
+	g_assert (delimiters && !strchr (delimiters, '\\'));
+
+	while (*str) {
+		gsize i = 0, j = 0;
+
+		while (TRUE) {
+			char c = str[i];
+
+			if (c == '\0') {
+				str[j++] = 0;
+				break;
+			} else if (c == '\\') {
+				str[j++] = str[++i];
+				if (!str[i])
+					break;
+			} else {
+				for (d = delimiters; *d; d++) {
+					if (c == *d) {
+						str[j++] = 0;
+						i++;
+						goto BREAK_INNER_LOOPS;
+					}
+				}
+				str[j++] = c;
+			}
+			i++;
+		}
+
+BREAK_INNER_LOOPS:
+		g_array_append_val (result, str);
+		str = &str[i];
+	}
+
+	return (char **) g_array_free (result, FALSE);
+}
+
+
+/* free instances allocated by nmtst (especially nmtst_init()) on shutdown
+ * to release memory. After nmtst_free(), the test is uninitialized again. */
+inline static void
+nmtst_free (void)
+{
+	if (!nmtst_initialized ())
+		return;
+
+	g_rand_free (__nmtst_internal.rand0);
+	if (__nmtst_internal.rand)
+		g_rand_free (__nmtst_internal.rand);
+	g_free (__nmtst_internal.sudo_cmd);
+	g_strfreev (__nmtst_internal.orig_argv);
+
+	memset (&__nmtst_internal, 0, sizeof (__nmtst_internal));
+}
+
+inline static void
+__nmtst_init (int *argc, char ***argv, gboolean assert_logging, const char *log_level, const char *log_domains, gboolean *out_set_logging)
+{
+	const char *nmtst_debug;
+	gboolean is_debug = FALSE;
+	char *c_log_level = NULL, *c_log_domains = NULL;
+	char *sudo_cmd = NULL;
+	GArray *debug_messages = g_array_new (TRUE, FALSE, sizeof (char *));
+	int i;
+	gboolean no_expect_message = FALSE;
+	gboolean _out_set_logging;
+	gboolean test_quick = FALSE;
+	gboolean test_quick_set = FALSE;
+	gboolean test_quick_argv = FALSE;
+	gs_unref_ptrarray GPtrArray *p_tests = NULL;
+	gs_unref_ptrarray GPtrArray *s_tests = NULL;
+
+	if (!out_set_logging)
+		out_set_logging = &_out_set_logging;
+	*out_set_logging = FALSE;
+
+	g_assert (!nmtst_initialized ());
+
+	g_assert (!((!!argc) ^ (!!argv)));
+	g_assert (!argc || (g_strv_length (*argv) == *argc));
+	g_assert (!assert_logging || (!log_level && !log_domains));
+
+#ifdef __NETWORKMANAGER_UTILS_H__
+	if (!nm_utils_get_testing_initialized ())
+		_nm_utils_set_testing (_NM_UTILS_TEST_GENERAL);
+#endif
+
+	if (argc)
+		__nmtst_internal.orig_argv = g_strdupv (*argv);
+
+	__nmtst_internal.assert_logging = !!assert_logging;
+
+	nm_g_type_init ();
+
+	is_debug = g_test_verbose ();
+
+	nmtst_debug = g_getenv ("NMTST_DEBUG");
+	if (nmtst_debug) {
+		char **d_argv, **i_argv, *nmtst_debug_copy;
+
+		/* By setting then NMTST_DEBUG variable, @is_debug is set automatically.
+		 * This can be reverted with no-debug (on command line or environment variable). */
+		is_debug = TRUE;
+
+		nmtst_debug_copy = g_strdup (nmtst_debug);
+		d_argv = nmtst_str_split (nmtst_debug_copy, ",; \t\r\n");
+
+		for (i_argv = d_argv; *i_argv; i_argv++) {
+			const char *debug = *i_argv;
+
+			if (!g_ascii_strcasecmp (debug, "debug"))
+				is_debug = TRUE;
+			else if (!g_ascii_strcasecmp (debug, "no-debug")) {
+				/* when specifying the NMTST_DEBUG variable, we set is_debug to true. Use this flag to disable this
+				 * (e.g. for only setting the log-level, but not is_debug). */
+				is_debug = FALSE;
+			} else if (!g_ascii_strncasecmp (debug, "log-level=", strlen ("log-level="))) {
+				g_free (c_log_level);
+				log_level = c_log_level = g_strdup (&debug[strlen ("log-level=")]);
+			} else if (!g_ascii_strcasecmp (debug, "D")) {
+				/* shorthand for "log-level=TRACE,no-expect-message" */
+				g_free (c_log_level);
+				log_level = c_log_level = g_strdup ("TRACE");
+				no_expect_message = TRUE;
+			} else if (!g_ascii_strcasecmp (debug, "TRACE")) {
+				g_free (c_log_level);
+				log_level = c_log_level = g_strdup ("TRACE");
+			} else if (!g_ascii_strncasecmp (debug, "log-domains=", strlen ("log-domains="))) {
+				g_free (c_log_domains);
+				log_domains = c_log_domains = g_strdup (&debug[strlen ("log-domains=")]);
+			} else if (!g_ascii_strncasecmp (debug, "sudo-cmd=", strlen ("sudo-cmd="))) {
+				g_free (sudo_cmd);
+				sudo_cmd = g_strdup (&debug[strlen ("sudo-cmd=")]);
+			} else if (!g_ascii_strcasecmp (debug, "no-expect-message")) {
+				no_expect_message = TRUE;
+			} else if (!g_ascii_strncasecmp (debug, "p=", strlen ("p="))) {
+				if (!p_tests)
+					p_tests = g_ptr_array_new_with_free_func (g_free);
+				g_ptr_array_add (p_tests, g_strdup (&debug[strlen ("p=")]));
+			} else if (!g_ascii_strncasecmp (debug, "s=", strlen ("s="))) {
+				if (!s_tests)
+					s_tests = g_ptr_array_new_with_free_func (g_free);
+				g_ptr_array_add (s_tests, g_strdup (&debug[strlen ("s=")]));
+			} else if (!g_ascii_strcasecmp (debug, "slow") || !g_ascii_strcasecmp (debug, "thorough")) {
+				test_quick = FALSE;
+				test_quick_set = TRUE;
+			} else if (!g_ascii_strcasecmp (debug, "quick")) {
+				test_quick = TRUE;
+				test_quick_set = TRUE;
+			} else {
+				char *msg = g_strdup_printf (">>> nmtst: ignore unrecognized NMTST_DEBUG option \"%s\"", debug);
+
+				g_array_append_val (debug_messages, msg);
+			}
+		}
+
+		g_free (d_argv);
+		g_free (nmtst_debug_copy);
+	}
+
+	if (__nmtst_internal.orig_argv) {
+		char **a = __nmtst_internal.orig_argv;
+
+		for (; *a; a++) {
+			if (!g_ascii_strcasecmp (*a, "--debug"))
+				is_debug = TRUE;
+			else if (!g_ascii_strcasecmp (*a, "--no-debug"))
+				is_debug = FALSE;
+			else if (   !strcmp (*a, "-m=slow")
+			         || !strcmp (*a, "-m=thorough")
+			         || !strcmp (*a, "-m=quick")
+			         || (!strcmp (*a, "-m") && *(a+1)
+			                                && (   !strcmp (*(a+1), "quick")
+			                                    || !strcmp (*(a+1), "slow")
+			                                    || !strcmp (*(a+1), "thorough"))))
+				test_quick_argv = TRUE;
+			else if (strcmp (*a, "--tap") == 0)
+				__nmtst_internal.test_tap_log = TRUE;
+		}
+	}
+
+	if (!argc || g_test_initialized ()) {
+		if (p_tests || s_tests) {
+			char *msg = g_strdup_printf (">>> nmtst: ignore -p and -s options for test which calls g_test_init() itself");
+
+			g_array_append_val (debug_messages, msg);
+		}
+	} else {
+		/* g_test_init() is a variadic function, so we cannot pass it
+		 * (variadic) arguments. If you need to pass additional parameters,
+		 * call nmtst_init() with argc==NULL and call g_test_init() yourself. */
+
+		/* g_test_init() sets g_log_set_always_fatal() for G_LOG_LEVEL_WARNING
+		 * and G_LOG_LEVEL_CRITICAL. So, beware that the test will fail if you
+		 * have any WARN or ERR log messages -- unless you g_test_expect_message(). */
+		GPtrArray *arg_array = g_ptr_array_new ();
+		gs_free char **arg_array_c = NULL;
+		int arg_array_n, j;
+		static char **s_tests_x, **p_tests_x;
+
+		if (*argc) {
+			for (i = 0; i < *argc; i++)
+				g_ptr_array_add (arg_array, (*argv)[i]);
+		} else
+			g_ptr_array_add (arg_array, "./test");
+
+		if (test_quick_set && !test_quick_argv)
+			g_ptr_array_add (arg_array, "-m=quick");
+
+		if (!__nmtst_internal.test_tap_log) {
+			for (i = 0; p_tests && i < p_tests->len; i++) {
+				g_ptr_array_add (arg_array, "-p");
+				g_ptr_array_add (arg_array, p_tests->pdata[i]);
+			}
+			for (i = 0; s_tests && i < s_tests->len; i++) {
+				g_ptr_array_add (arg_array, "-s");
+				g_ptr_array_add (arg_array, s_tests->pdata[i]);
+			}
+		} else if (p_tests || s_tests) {
+			char *msg = g_strdup_printf (">>> nmtst: ignore -p and -s options for tap-tests");
+
+			g_array_append_val (debug_messages, msg);
+		}
+
+		g_ptr_array_add (arg_array, NULL);
+
+		arg_array_n = arg_array->len - 1;
+		arg_array_c = (char **) g_ptr_array_free (arg_array, FALSE);
+
+		g_test_init (&arg_array_n, &arg_array_c, NULL);
+
+		if (*argc > 1) {
+			/* collaps argc/argv by removing the arguments detected
+			 * by g_test_init(). */
+			for (i = 1, j = 1; i < *argc; i++) {
+				if ((*argv)[i] == arg_array_c[j])
+					j++;
+				else
+					(*argv)[i] = NULL;
+			}
+			for (i = 1, j = 1; i < *argc; i++) {
+				if ((*argv)[i]) {
+					(*argv)[j++] = (*argv)[i];
+					if (i >= j)
+						(*argv)[i] = NULL;
+				}
+			}
+			*argc = j;
+		}
+
+		/* we must "leak" the test paths because they are not cloned by g_test_init(). */
+		if (!__nmtst_internal.test_tap_log) {
+			if (p_tests) {
+				p_tests_x = (char **) g_ptr_array_free (p_tests, FALSE);
+				p_tests = NULL;
+			}
+			if (s_tests) {
+				s_tests_x = (char **) g_ptr_array_free (s_tests, FALSE);
+				s_tests = NULL;
+			}
+		}
+	}
+
+	if (test_quick_set)
+		__nmtst_internal.test_quick = test_quick;
+	else if (test_quick_argv)
+		__nmtst_internal.test_quick = g_test_quick ();
+	else {
+#ifdef NMTST_TEST_QUICK
+		__nmtst_internal.test_quick = NMTST_TEST_QUICK;
+#else
+		__nmtst_internal.test_quick = FALSE;
+#endif
+	}
+
+	__nmtst_internal.is_debug = is_debug;
+	__nmtst_internal.rand0 = g_rand_new_with_seed (0);
+	__nmtst_internal.sudo_cmd = sudo_cmd;
+	__nmtst_internal.no_expect_message = no_expect_message;
+
+	if (!log_level && log_domains) {
+		/* if the log level is not specified (but the domain is), we assume
+		 * the caller wants to set it depending on is_debug */
+		log_level = is_debug ? "DEBUG" : "WARN";
+	}
+
+	if (!__nmtst_internal.assert_logging) {
+		gboolean success = TRUE;
+#ifdef _NMTST_INSIDE_CORE
+		success = nm_logging_setup (log_level, log_domains, NULL, NULL);
+		*out_set_logging = TRUE;
+#endif
+		g_assert (success);
+#if GLIB_CHECK_VERSION(2,34,0)
+		if (__nmtst_internal.no_expect_message)
+			g_log_set_always_fatal (G_LOG_FATAL_MASK);
+#else
+		/* g_test_expect_message() is a NOP, so allow any messages */
+		g_log_set_always_fatal (G_LOG_FATAL_MASK);
+#endif
+	} else if (__nmtst_internal.no_expect_message) {
+		/* We have a test that would be assert_logging, but the user specified no_expect_message.
+		 * This transforms g_test_expect_message() into a NOP, but we also have to relax
+		 * g_log_set_always_fatal(), which was set by g_test_init(). */
+		g_log_set_always_fatal (G_LOG_FATAL_MASK);
+#ifdef _NMTST_INSIDE_CORE
+		if (c_log_domains || c_log_level) {
+			/* Normally, tests with assert_logging do not overwrite the logging level/domains because
+			 * the logging statements are part of the assertions. But if the test is run with
+			 * no-expect-message *and* the logging is set explicitly via environment variables,
+			 * we still reset the logging. */
+			gboolean success;
+
+			success = nm_logging_setup (log_level, log_domains, NULL, NULL);
+			*out_set_logging = TRUE;
+			g_assert (success);
+		}
+#endif
+	} else {
+#if GLIB_CHECK_VERSION(2,34,0)
+		/* We were called not to set logging levels. This means, that the user
+		 * expects to assert against (all) messages. Any uncought message is fatal. */
+		g_log_set_always_fatal (G_LOG_LEVEL_MASK);
+#else
+		/* g_test_expect_message() is a NOP, so allow any messages */
+		g_log_set_always_fatal (G_LOG_FATAL_MASK);
+#endif
+	}
+
+	if ((!__nmtst_internal.assert_logging || (__nmtst_internal.assert_logging && __nmtst_internal.no_expect_message)) &&
+	    (is_debug || (c_log_level && (!g_ascii_strcasecmp (c_log_level, "DEBUG") || !g_ascii_strcasecmp (c_log_level, "TRACE")))) &&
+	    !g_getenv ("G_MESSAGES_DEBUG"))
+	{
+		/* if we are @is_debug or @log_level=="DEBUG" and
+		 * G_MESSAGES_DEBUG is unset, we set G_MESSAGES_DEBUG=all.
+		 * To disable this default behaviour, set G_MESSAGES_DEBUG='' */
+
+		/* Note that g_setenv is not thread safe, but you should anyway call
+		 * nmtst_init() at the very start. */
+		g_setenv ("G_MESSAGES_DEBUG", "all", TRUE);
+	}
+
+	/* Delay messages until we setup logging. */
+	for (i = 0; i < debug_messages->len; i++)
+		__NMTST_LOG (g_message, "%s", g_array_index (debug_messages, const char *, i));
+
+	g_strfreev ((char **) g_array_free (debug_messages, FALSE));
+	g_free (c_log_level);
+	g_free (c_log_domains);
+
+#ifdef __NETWORKMANAGER_UTILS_H__
+	/* ensure that monotonic timestamp is called (because it initially logs a line) */
+	nm_utils_get_monotonic_timestamp_s ();
+#endif
+
+#ifdef NM_UTILS_H
+	{
+		gs_free_error GError *error = NULL;
+
+		if (!nm_utils_init (&error))
+			g_assert_not_reached ();
+		g_assert_no_error (error);
+	}
+#endif
+}
+
+#ifndef _NMTST_INSIDE_CORE
+inline static void
+nmtst_init (int *argc, char ***argv, gboolean assert_logging)
+{
+	__nmtst_init (argc, argv, assert_logging, NULL, NULL, NULL);
+}
+#endif
+
+inline static gboolean
+nmtst_is_debug (void)
+{
+	g_assert (nmtst_initialized ());
+	return __nmtst_internal.is_debug;
+}
+
+inline static gboolean
+nmtst_test_quick (void)
+{
+	g_assert (nmtst_initialized ());
+	return __nmtst_internal.test_quick;
+}
+
+#if GLIB_CHECK_VERSION(2,34,0)
+#undef g_test_expect_message
+#define g_test_expect_message(...) \
+	G_STMT_START { \
+		g_assert (nmtst_initialized ()); \
+		if (__nmtst_internal.assert_logging && __nmtst_internal.no_expect_message) { \
+			g_debug ("nmtst: assert-logging: g_test_expect_message %s", G_STRINGIFY ((__VA_ARGS__))); \
+		} else { \
+			G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+			g_test_expect_message (__VA_ARGS__); \
+			G_GNUC_END_IGNORE_DEPRECATIONS \
+		} \
+	} G_STMT_END
+#undef g_test_assert_expected_messages_internal
+#define g_test_assert_expected_messages_internal(domain, file, line, func) \
+	G_STMT_START { \
+		const char *_domain = (domain); \
+		const char *_file = (file); \
+		const char *_func = (func); \
+		int _line = (line); \
+		\
+		if (__nmtst_internal.assert_logging && __nmtst_internal.no_expect_message) \
+			g_debug ("nmtst: assert-logging: g_test_assert_expected_messages(%s, %s:%d, %s)", _domain?:"", _file?:"", _line, _func?:""); \
+		\
+		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+		g_test_assert_expected_messages_internal (_domain, _file, _line, _func); \
+		G_GNUC_END_IGNORE_DEPRECATIONS \
+	} G_STMT_END
+#endif
+
+/*****************************************************************************/
+
+typedef struct _NmtstTestData NmtstTestData;
+
+typedef void (*NmtstTestDataRelease) (const NmtstTestData *test_data);
+
+struct _NmtstTestData {
+	const char *testpath;
+	NmtstTestDataRelease fcn_release;
+	gsize n_args;
+	gpointer args[1];
+};
+
+inline static void
+_nmtst_test_data_unpack (const NmtstTestData *test_data, gsize n_args, ...)
+{
+	gsize i;
+	va_list ap;
+	gpointer *p;
+
+	g_assert (test_data);
+	g_assert_cmpint (n_args, ==, test_data->n_args);
+
+	va_start (ap, n_args);
+	for (i = 0; i < n_args; i++) {
+		p = va_arg (ap, gpointer *);
+
+		g_assert (p);
+		*p = test_data->args[i];
+	}
+	va_end (ap);
+}
+#define nmtst_test_data_unpack(test_data, ...) _nmtst_test_data_unpack(test_data, NM_NARG (__VA_ARGS__), ##__VA_ARGS__)
+
+inline static void
+_nmtst_test_data_free (gpointer data)
+{
+	NmtstTestData *test_data = data;
+
+	g_assert (test_data);
+
+	if (test_data->fcn_release)
+		test_data->fcn_release (test_data);
+
+	g_free ((gpointer) test_data->testpath);
+	g_free (test_data);
+}
+
+inline static void
+_nmtst_add_test_func_full (const char *testpath, GTestDataFunc test_func, NmtstTestDataRelease fcn_release, gsize n_args, ...)
+{
+	gsize i;
+	NmtstTestData *data;
+	va_list ap;
+
+	data = g_malloc (G_STRUCT_OFFSET (NmtstTestData, args) + sizeof (gpointer) * (n_args + 1));
+
+	data->testpath = g_strdup (testpath);
+	data->fcn_release = fcn_release;
+	data->n_args = n_args;
+	va_start (ap, n_args);
+	for (i = 0; i < n_args; i++)
+		data->args[i] = va_arg (ap, gpointer);
+	data->args[i] = NULL;
+	va_end (ap);
+
+	g_test_add_data_func_full (testpath,
+	                           data,
+	                           test_func,
+	                           _nmtst_test_data_free);
+}
+#define nmtst_add_test_func_full(testpath, test_func, fcn_release, ...) _nmtst_add_test_func_full(testpath, test_func, fcn_release, NM_NARG (__VA_ARGS__), ##__VA_ARGS__)
+#define nmtst_add_test_func(testpath, test_func, ...) nmtst_add_test_func_full(testpath, test_func, NULL, ##__VA_ARGS__)
+
+/*****************************************************************************/
+
+inline static GRand *
+nmtst_get_rand0 (void)
+{
+	g_assert (nmtst_initialized ());
+	return __nmtst_internal.rand0;
+}
+
+inline static GRand *
+nmtst_get_rand (void)
+{
+	g_assert (nmtst_initialized ());
+
+	if (G_UNLIKELY (!__nmtst_internal.rand)) {
+		guint32 seed;
+		const char *str;
+
+		if ((str = g_getenv ("NMTST_SEED_RAND"))) {
+			gchar *s;
+			gint64 i;
+
+			i = g_ascii_strtoll (str, &s, 0);
+			g_assert (s[0] == '\0' && i >= 0 && i < G_MAXUINT32);
+
+			seed = i;
+			__nmtst_internal.rand = g_rand_new_with_seed (seed);
+		} else {
+			__nmtst_internal.rand = g_rand_new ();
+
+			seed = g_rand_int (__nmtst_internal.rand);
+			g_rand_set_seed (__nmtst_internal.rand, seed);
+		}
+		__nmtst_internal.rand_seed = seed;
+
+		g_print ("\nnmtst: initialize nmtst_get_rand() with NMTST_SEED_RAND=%u\n", seed);
+	}
+	return __nmtst_internal.rand;
+}
+
+inline static guint32
+nmtst_get_rand_int (void)
+{
+	return g_rand_int (nmtst_get_rand ());
+}
+
+inline static gpointer
+nmtst_rand_buf (GRand *rand, gpointer buffer, gsize buffer_length)
+{
+	guint32 v;
+	guint8 *b = buffer;
+
+	if (!buffer_length)
+		return buffer;
+
+	g_assert (buffer);
+
+	if (!rand)
+		rand = nmtst_get_rand ();
+
+	for (; buffer_length >= sizeof (guint32); buffer_length -= sizeof (guint32), b += sizeof (guint32)) {
+		v = g_rand_int (rand);
+		memcpy (b, &v, sizeof (guint32));
+	}
+	if (buffer_length > 0) {
+		v = g_rand_int (rand);
+		do {
+			*(b++) = v & 0xFF;
+			v >>= 8;
+		} while (--buffer_length > 0);
+	}
+	return buffer;
+}
+
+inline static void *
+nmtst_rand_perm (GRand *rand, void *dst, const void *src, gsize elmt_size, gsize n_elmt)
+{
+	gsize i, j;
+	char *p_, *pj;
+	char *bu;
+
+	g_assert (dst);
+	g_assert (elmt_size > 0);
+	g_assert (n_elmt < G_MAXINT32);
+
+	if (n_elmt == 0)
+		return dst;
+
+	if (src && dst != src)
+		memcpy (dst, src, elmt_size * n_elmt);
+
+	if (!rand)
+		rand = nmtst_get_rand ();
+
+	bu = g_slice_alloc (elmt_size);
+
+	p_ = dst;
+	for (i = n_elmt; i > 1; i--) {
+		j = g_rand_int_range (rand, 0, i);
+
+		if (j != 0) {
+			pj = &p_[j * elmt_size];
+
+			/* swap */
+			memcpy (bu, p_, elmt_size);
+			memcpy (p_, pj, elmt_size);
+			memcpy (pj, bu, elmt_size);
+		}
+		p_ += elmt_size;
+	}
+
+	g_slice_free1 (elmt_size, bu);
+	return dst;
+}
+
+/*****************************************************************************/
+
+inline static gboolean
+_nmtst_main_loop_run_timeout (gpointer user_data)
+{
+	GMainLoop **p_loop = user_data;
+
+	g_assert (p_loop);
+	g_assert (*p_loop);
+
+	g_main_loop_quit (*p_loop);
+	*p_loop = NULL;
+
+	return G_SOURCE_REMOVE;
+}
+
+inline static gboolean
+nmtst_main_loop_run (GMainLoop *loop, int timeout_ms)
+{
+	GSource *source = NULL;
+	guint id = 0;
+	GMainLoop *loopx = loop;
+
+	if (timeout_ms > 0) {
+		source = g_timeout_source_new (timeout_ms);
+		g_source_set_callback (source, _nmtst_main_loop_run_timeout, &loopx, NULL);
+		id = g_source_attach (source, g_main_loop_get_context (loop));
+		g_assert (id);
+		g_source_unref (source);
+	}
+
+	g_main_loop_run (loop);
+
+	/* if the timeout was reached, return FALSE. */
+	return loopx != NULL;
+}
+
+inline static void
+_nmtst_main_loop_quit_on_notify (GObject *object, GParamSpec *pspec, gpointer user_data)
+{
+	GMainLoop *loop = user_data;
+
+	g_assert (G_IS_OBJECT (object));
+	g_assert (loop);
+
+	g_main_loop_quit (loop);
+}
+#define nmtst_main_loop_quit_on_notify ((GCallback) _nmtst_main_loop_quit_on_notify)
+
+/*****************************************************************************/
+
+inline static const char *
+nmtst_get_sudo_cmd (void)
+{
+	g_assert (nmtst_initialized ());
+	return __nmtst_internal.sudo_cmd;
+}
+
+inline static void
+nmtst_reexec_sudo (void)
+{
+	char *str;
+	char **argv;
+	int i;
+	int errsv;
+
+	g_assert (nmtst_initialized ());
+	g_assert (__nmtst_internal.orig_argv);
+
+	if (!__nmtst_internal.sudo_cmd)
+		return;
+
+	str = g_strjoinv (" ", __nmtst_internal.orig_argv);
+	__NMTST_LOG (g_message, ">> exec %s %s", __nmtst_internal.sudo_cmd, str);
+
+	argv = g_new0 (char *, 1 + g_strv_length (__nmtst_internal.orig_argv) + 1);
+	argv[0] = __nmtst_internal.sudo_cmd;
+	for (i = 0; __nmtst_internal.orig_argv[i]; i++)
+		argv[i+1] = __nmtst_internal.orig_argv[i];
+
+	execvp (__nmtst_internal.sudo_cmd, argv);
+
+	errsv = errno;
+	g_error (">> exec %s failed: %d - %s", __nmtst_internal.sudo_cmd, errsv, strerror (errsv));
+}
+
+/*****************************************************************************/
+
+inline static gsize
+nmtst_find_all_indexes (gpointer *elements,
+                        gsize n_elements,
+                        gpointer *needles,
+                        gsize n_needles,
+                        gboolean (*equal_fcn) (gpointer element, gpointer needle, gpointer user_data),
+                        gpointer user_data,
+                        gssize *out_idx)
+{
+	gsize i, j, k;
+	gsize found = 0;
+
+	for (i = 0; i < n_needles; i++) {
+		gssize idx = -1;
+
+		for (j = 0; j < n_elements; j++) {
+
+			/* no duplicates */
+			for (k = 0; k < i; k++) {
+				if (out_idx[k] == j)
+					goto next;
+			}
+
+			if (equal_fcn (elements[j], needles[i], user_data)) {
+				idx = j;
+				break;
+			}
+next:
+			;
+		}
+
+		out_idx[i] = idx;
+		if (idx >= 0)
+			found++;
+	}
+
+	return found;
+}
+
+/*****************************************************************************/
+
+#define __define_nmtst_static(NUM,SIZE) \
+inline static const char * \
+nmtst_static_##SIZE##_##NUM (const char *str) \
+{ \
+	gsize l; \
+	static char buf[SIZE]; \
+\
+	if (!str) \
+		return NULL; \
+	l = g_strlcpy (buf, str, sizeof (buf)); \
+	g_assert (l < sizeof (buf)); \
+	return buf; \
+}
+__define_nmtst_static(01, 1024)
+__define_nmtst_static(02, 1024)
+__define_nmtst_static(03, 1024)
+#undef __define_nmtst_static
+
+inline static const char *
+nmtst_uuid_generate (void)
+{
+	static char u[37];
+	gs_free char *m = NULL;
+
+	m = nm_utils_uuid_generate ();
+	g_assert (m && strlen (m) == sizeof (u) - 1);
+	memcpy (u, m, sizeof (u));
+	return u;
+}
+
+#define NMTST_SWAP(x,y) \
+	G_STMT_START { \
+		char __nmtst_swap_temp[sizeof(x) == sizeof(y) ? (signed) sizeof(x) : -1]; \
+		memcpy(__nmtst_swap_temp, &y, sizeof(x)); \
+		memcpy(&y,                &x, sizeof(x)); \
+		memcpy(&x, __nmtst_swap_temp, sizeof(x)); \
+	} G_STMT_END
+
+#define nmtst_assert_str_has_substr(str, substr) \
+	G_STMT_START { \
+		const char *__str = (str); \
+		const char *__substr = (substr); \
+		\
+		g_assert (__str); \
+		g_assert (__substr); \
+		if (strstr (__str, __substr) == NULL) \
+			g_error ("%s:%d: Expects \"%s\" but got \"%s\"", __FILE__, __LINE__, __substr, __str); \
+	} G_STMT_END
+
+inline static guint32
+nmtst_inet4_from_string (const char *str)
+{
+	guint32 addr;
+	int success;
+
+	if (!str)
+		return 0;
+
+	success = inet_pton (AF_INET, str, &addr);
+
+	g_assert (success == 1);
+
+	return addr;
+}
+
+inline static const struct in6_addr *
+nmtst_inet6_from_string (const char *str)
+{
+	static struct in6_addr addr;
+	int success;
+
+	if (!str)
+		addr = in6addr_any;
+	else {
+		success = inet_pton (AF_INET6, str, &addr);
+		g_assert (success == 1);
+	}
+
+	return &addr;
+}
+
+inline static void
+_nmtst_assert_ip4_address (const char *file, int line, in_addr_t addr, const char *str_expected)
+{
+	if (nmtst_inet4_from_string (str_expected) != addr) {
+		char buf[100];
+
+		g_error ("%s:%d: Unexpected IPv4 address: expected %s, got %s",
+		         file, line, str_expected ? str_expected : "0.0.0.0",
+		         inet_ntop (AF_INET, &addr, buf, sizeof (buf)));
+	}
+}
+#define nmtst_assert_ip4_address(addr, str_expected) _nmtst_assert_ip4_address (__FILE__, __LINE__, addr, str_expected)
+
+inline static void
+_nmtst_assert_ip6_address (const char *file, int line, const struct in6_addr *addr, const char *str_expected)
+{
+	struct in6_addr any = in6addr_any;
+
+	if (!addr)
+		addr = &any;
+
+	if (memcmp (nmtst_inet6_from_string (str_expected), addr, sizeof (*addr)) != 0) {
+		char buf[100];
+
+		g_error ("%s:%d: Unexpected IPv6 address: expected %s, got %s",
+		         file, line, str_expected ? str_expected : "::",
+		         inet_ntop (AF_INET6, addr, buf, sizeof (buf)));
+	}
+}
+#define nmtst_assert_ip6_address(addr, str_expected) _nmtst_assert_ip6_address (__FILE__, __LINE__, addr, str_expected)
+
+#define nmtst_spawn_sync(working_directory, standard_out, standard_err, assert_exit_status, ...) \
+	__nmtst_spawn_sync (working_directory, standard_out, standard_err, assert_exit_status, ##__VA_ARGS__, NULL)
+inline static gint
+__nmtst_spawn_sync (const char *working_directory, char **standard_out, char **standard_err, int assert_exit_status, ...) G_GNUC_NULL_TERMINATED;
+inline static gint
+__nmtst_spawn_sync (const char *working_directory, char **standard_out, char **standard_err, int assert_exit_status, ...)
+{
+	gint exit_status = 0;
+	GError *error = NULL;
+	char *arg;
+	va_list va_args;
+	GPtrArray *argv = g_ptr_array_new ();
+	gboolean success;
+
+	va_start (va_args, assert_exit_status);
+	while ((arg = va_arg (va_args, char *)))
+		g_ptr_array_add (argv, arg);
+	va_end (va_args);
+
+	g_assert (argv->len >= 1);
+	g_ptr_array_add (argv, NULL);
+
+	success = g_spawn_sync (working_directory,
+	                        (char**) argv->pdata,
+	                        NULL,
+	                        0 /*G_SPAWN_DEFAULT*/,
+	                        NULL,
+	                        NULL,
+	                        standard_out,
+	                        standard_err,
+	                        &exit_status,
+	                        &error);
+	if (!success)
+		g_error ("nmtst_spawn_sync(%s): %s", ((char **) argv->pdata)[0], error->message);
+	g_assert (!error);
+
+	g_assert (!standard_out || *standard_out);
+	g_assert (!standard_err || *standard_err);
+
+	if (assert_exit_status != -1) {
+		/* exit status is a guint8 on success. Set @assert_exit_status to -1
+		 * not to check for the exit status. */
+		g_assert (WIFEXITED (exit_status));
+		g_assert_cmpint (WEXITSTATUS (exit_status), ==, assert_exit_status);
+	}
+
+	g_ptr_array_free (argv, TRUE);
+	return exit_status;
+}
+
+/*******************************************************************************/
+
+inline static char *
+nmtst_file_resolve_relative_path (const char *rel, const char *cwd)
+{
+	gs_free char *cwd_free = NULL;
+
+	g_assert (rel && *rel);
+
+	if (g_path_is_absolute (rel))
+		return g_strdup (rel);
+
+	if (!cwd)
+		cwd = cwd_free = g_get_current_dir ();
+	return g_build_filename (cwd, rel, NULL);
+}
+
+inline static void
+_nmtst_assert_resolve_relative_path_equals (const char *f1, const char *f2, const char *file, int line)
+{
+	gs_free char *p1 = NULL, *p2 = NULL;
+
+	p1 = nmtst_file_resolve_relative_path (f1, NULL);
+	p2 = nmtst_file_resolve_relative_path (f2, NULL);
+	g_assert (p1 && *p1);
+
+	/* Fixme: later we might need to coalesce repeated '/', "./", and "../".
+	 * For now, it's good enough. */
+	if (g_strcmp0 (p1, p2) != 0)
+		g_error ("%s:%d : filenames don't match \"%s\" vs. \"%s\" // \"%s\" - \"%s\"", file, line, f1, f2, p1, p2);
+}
+#define nmtst_assert_resolve_relative_path_equals(f1, f2) _nmtst_assert_resolve_relative_path_equals (f1, f2, __FILE__, __LINE__);
+
+/*******************************************************************************/
+
+#ifdef NM_SETTING_IP_CONFIG_H
+inline static void
+nmtst_setting_ip_config_add_address (NMSettingIPConfig *s_ip,
+                                     const char *address,
+                                     guint prefix)
+{
+	NMIPAddress *addr;
+	int family;
+
+	g_assert (s_ip);
+
+	if (nm_utils_ipaddr_valid (AF_INET, address))
+		family = AF_INET;
+	else if (nm_utils_ipaddr_valid (AF_INET6, address))
+		family = AF_INET6;
+	else
+		g_assert_not_reached ();
+
+	addr = nm_ip_address_new (family, address, prefix, NULL);
+	g_assert (addr);
+	g_assert (nm_setting_ip_config_add_address (s_ip, addr));
+	nm_ip_address_unref (addr);
+}
+
+inline static void
+nmtst_setting_ip_config_add_route (NMSettingIPConfig *s_ip,
+                                   const char *dest,
+                                   guint prefix,
+                                   const char *next_hop,
+                                   gint64 metric)
+{
+	NMIPRoute *route;
+	int family;
+
+	g_assert (s_ip);
+
+	if (nm_utils_ipaddr_valid (AF_INET, dest))
+		family = AF_INET;
+	else if (nm_utils_ipaddr_valid (AF_INET6, dest))
+		family = AF_INET6;
+	else
+		g_assert_not_reached ();
+
+	route = nm_ip_route_new (family, dest, prefix, next_hop, metric, NULL);
+	g_assert (route);
+	g_assert (nm_setting_ip_config_add_route (s_ip, route));
+	nm_ip_route_unref (route);
+}
+#endif /* NM_SETTING_IP_CONFIG_H */
+
+#if (defined(__NM_SIMPLE_CONNECTION_H__) && defined(__NM_SETTING_CONNECTION_H__)) || (defined(NM_CONNECTION_H))
+
+inline static NMConnection *
+nmtst_clone_connection (NMConnection *connection)
+{
+	g_assert (NM_IS_CONNECTION (connection));
+
+#if defined(__NM_SIMPLE_CONNECTION_H__)
+	return nm_simple_connection_new_clone (connection);
+#else
+	return nm_connection_duplicate (connection);
+#endif
+}
+
+inline static NMConnection *
+nmtst_create_minimal_connection (const char *id, const char *uuid, const char *type, NMSettingConnection **out_s_con)
+{
+	NMConnection *con;
+	NMSetting *s_base = NULL;
+	NMSettingConnection *s_con;
+	gs_free char *uuid_free = NULL;
+
+	g_assert (id);
+
+	if (uuid)
+		g_assert (nm_utils_is_uuid (uuid));
+	else
+		uuid = uuid_free = nm_utils_uuid_generate ();
+
+	if (type) {
+		GType type_g;
+
+#if defined(__NM_SIMPLE_CONNECTION_H__)
+		type_g = nm_setting_lookup_type (type);
+#else
+		type_g = nm_connection_lookup_setting_type (type);
+#endif
+
+		g_assert (type_g != G_TYPE_INVALID);
+
+		s_base = g_object_new (type_g, NULL);
+		g_assert (NM_IS_SETTING (s_base));
+	}
+
+#if defined(__NM_SIMPLE_CONNECTION_H__)
+	con = nm_simple_connection_new ();
+#else
+	con = nm_connection_new ();
+#endif
+
+	s_con = NM_SETTING_CONNECTION (nm_setting_connection_new ());
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, id,
+	              NM_SETTING_CONNECTION_UUID, uuid,
+	              NM_SETTING_CONNECTION_TYPE, type,
+	              NULL);
+	nm_connection_add_setting (con, NM_SETTING (s_con));
+
+	if (s_base)
+		nm_connection_add_setting (con, s_base);
+
+	if (out_s_con)
+		*out_s_con = s_con;
+	return con;
+}
+
+inline static gboolean
+_nmtst_connection_normalize_v (NMConnection *connection, va_list args)
+{
+	GError *error = NULL;
+	gboolean success;
+	gboolean was_modified = FALSE;
+	GHashTable *parameters = NULL;
+	const char *p_name;
+
+	g_assert (NM_IS_CONNECTION (connection));
+
+	while ((p_name = va_arg (args, const char *))) {
+		if (!parameters)
+			parameters =  g_hash_table_new (g_str_hash, g_str_equal);
+		g_hash_table_insert (parameters, (gpointer *) p_name, va_arg (args, gpointer));
+	}
+
+	success = nm_connection_normalize (connection,
+	                                   parameters,
+	                                   &was_modified,
+	                                   &error);
+	g_assert_no_error (error);
+	g_assert (success);
+
+	if (parameters)
+		g_hash_table_destroy (parameters);
+
+	return was_modified;
+}
+
+inline static gboolean
+_nmtst_connection_normalize (NMConnection *connection, ...)
+{
+	gboolean was_modified;
+	va_list args;
+
+	va_start (args, connection);
+	was_modified = _nmtst_connection_normalize_v (connection, args);
+	va_end (args);
+
+	return was_modified;
+}
+#define nmtst_connection_normalize(connection, ...) \
+    _nmtst_connection_normalize(connection, ##__VA_ARGS__, NULL)
+
+inline static NMConnection *
+_nmtst_connection_duplicate_and_normalize (NMConnection *connection, ...)
+{
+	gboolean was_modified;
+	va_list args;
+
+	connection = nmtst_clone_connection (connection);
+
+	va_start (args, connection);
+	was_modified = _nmtst_connection_normalize_v (connection, args);
+	va_end (args);
+
+	return connection;
+}
+#define nmtst_connection_duplicate_and_normalize(connection, ...) \
+    _nmtst_connection_duplicate_and_normalize(connection, ##__VA_ARGS__, NULL)
+
+inline static void
+nmtst_assert_connection_equals (NMConnection *a, gboolean normalize_a, NMConnection *b, gboolean normalize_b)
+{
+	gboolean compare;
+	gs_unref_object NMConnection *a2 = NULL;
+	gs_unref_object NMConnection *b2 = NULL;
+	GHashTable *out_settings = NULL;
+
+	g_assert (NM_IS_CONNECTION (a));
+	g_assert (NM_IS_CONNECTION (b));
+
+	if (normalize_a)
+		a = a2 = nmtst_connection_duplicate_and_normalize (a);
+	if (normalize_b)
+		b = b2 = nmtst_connection_duplicate_and_normalize (b);
+
+	compare = nm_connection_diff (a, b, NM_SETTING_COMPARE_FLAG_EXACT, &out_settings);
+	if (!compare || out_settings) {
+		const char *name, *pname;
+		GHashTable *setting;
+		GHashTableIter iter, iter2;
+
+		__NMTST_LOG (g_message, ">>> ASSERTION nmtst_assert_connection_equals() fails");
+		if (out_settings) {
+			g_hash_table_iter_init (&iter, out_settings);
+			while (g_hash_table_iter_next (&iter, (gpointer *) &name, (gpointer *) &setting)) {
+				__NMTST_LOG (g_message, ">>> differences in setting '%s':", name);
+
+				g_hash_table_iter_init (&iter2, setting);
+				while (g_hash_table_iter_next (&iter2, (gpointer *) &pname, NULL))
+					__NMTST_LOG (g_message, ">>> differences in setting '%s.%s'", name, pname);
+			}
+		}
+
+#ifdef __NM_KEYFILE_INTERNAL_H__
+		{
+			gs_unref_keyfile GKeyFile *kf_a = NULL, *kf_b = NULL;
+			gs_free char *str_a = NULL, *str_b = NULL;
+
+			kf_a = nm_keyfile_write (a, NULL, NULL, NULL);
+			kf_b = nm_keyfile_write (b, NULL, NULL, NULL);
+
+			if (kf_a)
+				str_a = g_key_file_to_data (kf_a, NULL, NULL);
+			if (kf_b)
+				str_b = g_key_file_to_data (kf_b, NULL, NULL);
+
+			__NMTST_LOG (g_message, ">>> Connection A as kf (*WARNING: keyfile representation might not show the difference*):\n%s", str_a);
+			__NMTST_LOG (g_message, ">>> Connection B as kf (*WARNING: keyfile representation might not show the difference*):\n%s", str_b);
+		}
+#endif
+	}
+	g_assert (compare);
+	g_assert (!out_settings);
+
+	compare = nm_connection_compare (a, b, NM_SETTING_COMPARE_FLAG_EXACT);
+	g_assert (compare);
+}
+
+inline static void
+nmtst_assert_connection_verifies (NMConnection *con)
+{
+	/* assert that the connection does verify, it might be normaliziable or not */
+	GError *error = NULL;
+	gboolean success;
+
+	g_assert (NM_IS_CONNECTION (con));
+
+	success = nm_connection_verify (con, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+}
+
+inline static void
+nmtst_assert_connection_verifies_without_normalization (NMConnection *con)
+{
+	/* assert that the connection verifies and does not need any normalization */
+	GError *error = NULL;
+	gboolean success;
+	gboolean was_modified = FALSE;
+	gs_unref_object NMConnection *clone = NULL;
+
+	clone = nmtst_clone_connection (con);
+
+	nmtst_assert_connection_verifies (con);
+
+	success = nm_connection_normalize (clone, NULL, &was_modified, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+	nmtst_assert_connection_equals (con, FALSE, clone, FALSE);
+	g_assert (!was_modified);
+}
+
+inline static void
+nmtst_assert_connection_verifies_and_normalizable (NMConnection *con)
+{
+	/* assert that the connection does verify, but normalization still modifies it */
+	GError *error = NULL;
+	gboolean success;
+	gboolean was_modified = FALSE;
+	gs_unref_object NMConnection *clone = NULL;
+
+	clone = nmtst_clone_connection (con);
+
+	nmtst_assert_connection_verifies (con);
+
+	success = nm_connection_normalize (clone, NULL, &was_modified, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+	g_assert (was_modified);
+
+	/* again! */
+	nmtst_assert_connection_verifies_without_normalization (clone);
+}
+
+inline static void
+nmtst_assert_connection_verifies_after_normalization (NMConnection *con,
+                                                      GQuark expect_error_domain,
+                                                      gint expect_error_code)
+{
+	/* assert that the connection does not verify, but normalization does fix it */
+	GError *error = NULL;
+	gboolean success;
+	gboolean was_modified = FALSE;
+	gs_unref_object NMConnection *clone = NULL;
+
+	clone = nmtst_clone_connection (con);
+
+	success = nm_connection_verify (con, &error);
+	nmtst_assert_error (error, expect_error_domain, expect_error_code, NULL);
+	g_assert (!success);
+	g_clear_error (&error);
+
+	success = nm_connection_normalize (clone, NULL, &was_modified, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+	g_assert (was_modified);
+
+	/* again! */
+	nmtst_assert_connection_verifies_without_normalization (clone);
+}
+
+inline static void
+nmtst_assert_connection_unnormalizable (NMConnection *con,
+                                        GQuark expect_error_domain,
+                                        gint expect_error_code)
+{
+	/* assert that the connection does not verify, and it cannot be fixed by normalization */
+
+	GError *error = NULL;
+	gboolean success;
+	gboolean was_modified = FALSE;
+	gs_unref_object NMConnection *clone = NULL;
+
+	clone = nmtst_clone_connection (con);
+
+	success = nm_connection_verify (con, &error);
+	nmtst_assert_error (error, expect_error_domain, expect_error_code, NULL);
+	g_assert (!success);
+	g_clear_error (&error);
+
+	success = nm_connection_normalize (clone, NULL, &was_modified, &error);
+	nmtst_assert_error (error, expect_error_domain, expect_error_code, NULL);
+	g_assert (!success);
+	g_assert (!was_modified);
+	nmtst_assert_connection_equals (con, FALSE, clone, FALSE);
+	g_clear_error (&error);
+}
+
+inline static void
+nmtst_assert_setting_verifies (NMSetting *setting)
+{
+	/* assert that the setting verifies without an error */
+
+	GError *error = NULL;
+	gboolean success;
+
+	g_assert (NM_IS_SETTING (setting));
+
+	success = nm_setting_verify (setting, NULL, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+}
+
+inline static void
+nmtst_assert_setting_verify_fails (NMSetting *setting,
+                                   GQuark expect_error_domain,
+                                   gint expect_error_code)
+{
+	/* assert that the setting verification fails */
+
+	GError *error = NULL;
+	gboolean success;
+
+	g_assert (NM_IS_SETTING (setting));
+
+	success = nm_setting_verify (setting, NULL, &error);
+	nmtst_assert_error (error, expect_error_domain, expect_error_code, NULL);
+	g_assert (!success);
+	g_clear_error (&error);
+}
+
+#endif
+
+#ifdef __NM_UTILS_H__
+static inline void
+nmtst_assert_hwaddr_equals (gconstpointer hwaddr1, gssize hwaddr1_len, const char *expected, const char *file, int line)
+{
+	guint8 buf2[NM_UTILS_HWADDR_LEN_MAX];
+	gsize hwaddr2_len = 1;
+	const char *p;
+	gboolean success;
+
+	g_assert (hwaddr1_len > 0 && hwaddr1_len <= NM_UTILS_HWADDR_LEN_MAX);
+
+	g_assert (expected);
+	for (p = expected; *p; p++) {
+		if (*p == ':' || *p == '-')
+			hwaddr2_len++;
+	}
+	g_assert (hwaddr2_len <= NM_UTILS_HWADDR_LEN_MAX);
+	g_assert (nm_utils_hwaddr_aton (expected, buf2, hwaddr2_len));
+
+	/* Manually check the entire hardware address instead of using
+	 * nm_utils_hwaddr_matches() because that function doesn't compare
+	 * entire InfiniBand addresses for various (legitimate) reasons.
+	 */
+	success = (hwaddr1_len == hwaddr2_len);
+	if (success)
+		success = !memcmp (hwaddr1, buf2, hwaddr1_len);
+	if (!success) {
+		g_error ("assert: %s:%d: hwaddr '%s' (%zd) expected, but got %s (%zd)",
+		         file, line, expected, hwaddr2_len, nm_utils_hwaddr_ntoa (hwaddr1, hwaddr1_len), hwaddr1_len);
+	}
+}
+#define nmtst_assert_hwaddr_equals(hwaddr1, hwaddr1_len, expected) \
+    nmtst_assert_hwaddr_equals (hwaddr1, hwaddr1_len, expected, __FILE__, __LINE__)
+#endif
+
+#if defined(__NM_SIMPLE_CONNECTION_H__) && defined(__NM_SETTING_CONNECTION_H__) && defined(__NM_KEYFILE_INTERNAL_H__)
+
+inline static NMConnection *
+nmtst_create_connection_from_keyfile (const char *keyfile_str, const char *keyfile_name, const char *base_dir)
+{
+	GKeyFile *keyfile;
+	GError *error = NULL;
+	gboolean success;
+	NMConnection *con;
+
+	g_assert (keyfile_str);
+
+	keyfile =  g_key_file_new ();
+	success = g_key_file_load_from_data (keyfile, keyfile_str, strlen (keyfile_str), G_KEY_FILE_NONE, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+
+	con = nm_keyfile_read (keyfile, keyfile_name, base_dir, NULL, NULL, &error);
+	g_assert_no_error (error);
+	g_assert (NM_IS_CONNECTION (con));
+
+	g_key_file_unref (keyfile);
+
+	nmtst_connection_normalize (con);
+
+	return con;
+}
+
+#endif
+
+#ifdef __NM_CONNECTION_H__
+
+inline static GVariant *
+_nmtst_variant_new_vardict (int dummy, ...)
+{
+	GVariantBuilder builder;
+	va_list ap;
+	const char *name;
+	GVariant *variant;
+
+	g_variant_builder_init (&builder, G_VARIANT_TYPE_VARDICT);
+
+	va_start (ap, dummy);
+	while ((name = va_arg (ap, const char *))) {
+		variant = va_arg (ap, GVariant *);
+		g_variant_builder_add (&builder, "{sv}", name, variant);
+	}
+	va_end (ap);
+
+	return g_variant_builder_end (&builder);
+}
+#define nmtst_variant_new_vardict(...) _nmtst_variant_new_vardict (0, __VA_ARGS__, NULL)
+
+#define nmtst_assert_variant_is_of_type(variant, type) \
+	G_STMT_START { \
+		GVariant *_variantx = (variant); \
+		\
+		g_assert (_variantx); \
+		g_assert (g_variant_is_of_type (_variantx, (type))); \
+	} G_STMT_END
+
+#define nmtst_assert_variant_uint32(variant, val) \
+	G_STMT_START { \
+		GVariant *_variant = (variant); \
+		\
+		nmtst_assert_variant_is_of_type (_variant, G_VARIANT_TYPE_UINT32); \
+		g_assert_cmpint (g_variant_get_uint32 (_variant), ==, (val)); \
+	} G_STMT_END
+
+#define nmtst_assert_variant_string(variant, str) \
+	G_STMT_START { \
+		gsize _l; \
+		GVariant *_variant = (variant); \
+		const char *_str = (str); \
+		\
+		nmtst_assert_variant_is_of_type (_variant, G_VARIANT_TYPE_STRING); \
+		g_assert (_str); \
+		g_assert_cmpstr (g_variant_get_string (_variant, &_l), ==, _str); \
+		g_assert_cmpint (_l, ==, strlen (_str)); \
+	} G_STMT_END
+
+typedef enum {
+	NMTST_VARIANT_EDITOR_CONNECTION,
+	NMTST_VARIANT_EDITOR_SETTING,
+	NMTST_VARIANT_EDITOR_PROPERTY
+} NmtstVariantEditorPhase;
+
+#define NMTST_VARIANT_EDITOR(__connection_variant, __code) \
+	G_STMT_START { \
+		GVariantIter __connection_iter, *__setting_iter; \
+		GVariantBuilder __connection_builder, __setting_builder; \
+		const char *__cur_setting_name, *__cur_property_name; \
+		GVariant *__property_val; \
+		NmtstVariantEditorPhase __phase; \
+                                                                        \
+		g_variant_builder_init (&__connection_builder, NM_VARIANT_TYPE_CONNECTION); \
+		g_variant_iter_init (&__connection_iter, __connection_variant); \
+		 \
+		__phase = NMTST_VARIANT_EDITOR_CONNECTION; \
+		__cur_setting_name = NULL; \
+		__cur_property_name = NULL; \
+		__code; \
+		while (g_variant_iter_next (&__connection_iter, "{&sa{sv}}", &__cur_setting_name, &__setting_iter)) { \
+			g_variant_builder_init (&__setting_builder, NM_VARIANT_TYPE_SETTING); \
+			__phase = NMTST_VARIANT_EDITOR_SETTING; \
+			__cur_property_name = NULL; \
+			__code; \
+			 \
+			while (   __cur_setting_name \
+			       && g_variant_iter_next (__setting_iter, "{&sv}", &__cur_property_name, &__property_val)) { \
+				__phase = NMTST_VARIANT_EDITOR_PROPERTY; \
+				__code; \
+				 \
+				if (__cur_property_name) { \
+					g_variant_builder_add (&__setting_builder, "{sv}", \
+					                       __cur_property_name, \
+					                       __property_val); \
+				} \
+				g_variant_unref (__property_val); \
+			} \
+			 \
+			if (__cur_setting_name) \
+				g_variant_builder_add (&__connection_builder, "{sa{sv}}", __cur_setting_name, &__setting_builder); \
+			else \
+				g_variant_builder_clear (&__setting_builder); \
+			g_variant_iter_free (__setting_iter); \
+		} \
+		 \
+		g_variant_unref (__connection_variant); \
+		 \
+		__connection_variant = g_variant_builder_end (&__connection_builder); \
+	} G_STMT_END;
+
+#define NMTST_VARIANT_ADD_SETTING(__setting_name, __setting_variant) \
+	G_STMT_START { \
+		if (__phase == NMTST_VARIANT_EDITOR_CONNECTION) \
+			g_variant_builder_add (&__connection_builder, "{s@a{sv}}", __setting_name, __setting_variant); \
+	} G_STMT_END
+
+#define NMTST_VARIANT_DROP_SETTING(__setting_name) \
+	G_STMT_START { \
+		if (__phase == NMTST_VARIANT_EDITOR_SETTING && __cur_setting_name) { \
+			if (!strcmp (__cur_setting_name, __setting_name)) \
+				__cur_setting_name = NULL; \
+		} \
+	} G_STMT_END
+
+#define NMTST_VARIANT_ADD_PROPERTY(__setting_name, __property_name, __format_string, __value) \
+	G_STMT_START { \
+		if (__phase == NMTST_VARIANT_EDITOR_SETTING) { \
+			if (!strcmp (__cur_setting_name, __setting_name)) { \
+				g_variant_builder_add (&__setting_builder, "{sv}", __property_name, \
+				                       g_variant_new (__format_string, __value)); \
+			} \
+		} \
+	} G_STMT_END
+
+#define NMTST_VARIANT_DROP_PROPERTY(__setting_name, __property_name) \
+	G_STMT_START { \
+		if (__phase == NMTST_VARIANT_EDITOR_PROPERTY && __cur_property_name) { \
+			if (   !strcmp (__cur_setting_name, __setting_name) \
+			    && !strcmp (__cur_property_name, __property_name)) \
+				__cur_property_name = NULL; \
+		} \
+	} G_STMT_END
+
+#define NMTST_VARIANT_CHANGE_PROPERTY(__setting_name, __property_name, __format_string, __value) \
+	G_STMT_START { \
+		NMTST_VARIANT_DROP_PROPERTY (__setting_name, __property_name); \
+		NMTST_VARIANT_ADD_PROPERTY (__setting_name, __property_name, __format_string, __value); \
+	} G_STMT_END
+
+#endif /* __NM_CONNECTION_H__ */
+
+#endif /* __NM_TEST_UTILS_H__ */
diff --git shared/nm-vpn/nm-vpn-plugin-utils.c shared/nm-vpn/nm-vpn-plugin-utils.c
new file mode 100644
index 0000000..772aa39
--- /dev/null
+++ shared/nm-vpn/nm-vpn-plugin-utils.c
@@ -0,0 +1,130 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2016 Red Hat, Inc.
+ */
+
+#include "nm-default.h"
+
+#include "nm-vpn-plugin-utils.h"
+
+#include <dlfcn.h>
+
+/*****************************************************************************/
+
+NMVpnEditor *
+nm_vpn_plugin_utils_load_editor (const char *module_name,
+                                 const char *factory_name,
+                                 NMVpnPluginUtilsEditorFactory editor_factory,
+                                 NMVpnEditorPlugin *editor_plugin,
+                                 NMConnection *connection,
+                                 gpointer user_data,
+                                 GError **error)
+
+{
+	static struct {
+		gpointer factory;
+		void *dl_module;
+		char *module_name;
+		char *factory_name;
+	} cached = { 0 };
+	NMVpnEditor *editor;
+
+	g_return_val_if_fail (module_name && g_path_is_absolute (module_name), NULL);
+	g_return_val_if_fail (factory_name && factory_name[0], NULL);
+	g_return_val_if_fail (editor_factory, NULL);
+	g_return_val_if_fail (NM_IS_VPN_EDITOR_PLUGIN (editor_plugin), NULL);
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+	g_return_val_if_fail (!error || !*error, NULL);
+
+	/* we really expect this function to be called with unchanging @module_name
+	 * and @factory_name. And we only want to load the module once, hence it would
+	 * be more complicated to accept changing @module_name/@factory_name arguments.
+	 *
+	 * The reason for only loading once is that due to glib types, we cannot create a
+	 * certain type-name more then once, so loading the same module or another version
+	 * of the same module will fail horribly as both try to create a GType with the same
+	 * name.
+	 *
+	 * Only support loading once, any future calls will reuse the handle. To simplify
+	 * that, we enforce that the @factory_name and @module_name is the same. */
+	if (cached.factory) {
+		g_return_val_if_fail (cached.dl_module, NULL);
+		g_return_val_if_fail (cached.factory_name && nm_streq0 (cached.factory_name, factory_name), NULL);
+		g_return_val_if_fail (cached.module_name && nm_streq0 (cached.module_name, module_name), NULL);
+	} else {
+		gpointer factory;
+		void *dl_module;
+
+		dl_module = dlopen (module_name, RTLD_LAZY | RTLD_LOCAL);
+		if (!dl_module) {
+			if (!g_file_test (module_name, G_FILE_TEST_EXISTS)) {
+				g_set_error (error,
+				             G_FILE_ERROR,
+				             G_FILE_ERROR_NOENT,
+				             _("missing plugin file \"%s\""), module_name);
+				return NULL;
+			}
+			g_set_error (error,
+			             NM_CONNECTION_ERROR,
+			             NM_CONNECTION_ERROR_FAILED,
+			             _("cannot load editor plugin: %s"), dlerror ());
+			return NULL;
+		}
+
+		factory = dlsym (dl_module, factory_name);
+		if (!factory) {
+			g_set_error (error,
+			             NM_CONNECTION_ERROR,
+			             NM_CONNECTION_ERROR_FAILED,
+			             _("cannot load factory %s from plugin: %s"),
+			             factory_name, dlerror ());
+			dlclose (dl_module);
+			return NULL;
+		}
+
+		/* we cannot ever unload the module because it creates glib types, which
+		 * cannot be unregistered.
+		 *
+		 * Thus we just leak the dl_module handle indefinitely. */
+		cached.factory = factory;
+		cached.dl_module = dl_module;
+		cached.module_name = g_strdup (module_name);
+		cached.factory_name = g_strdup (factory_name);
+	}
+
+	editor = editor_factory (cached.factory,
+	                         editor_plugin,
+	                         connection,
+	                         user_data,
+	                         error);
+	if (!editor) {
+		if (error && !*error ) {
+			g_set_error_literal (error,
+			                     NM_CONNECTION_ERROR,
+			                     NM_CONNECTION_ERROR_FAILED,
+			                     _("unknown error creating editor instance"));
+			g_return_val_if_reached (NULL);
+		}
+		return NULL;
+	}
+
+	g_return_val_if_fail (NM_IS_VPN_EDITOR (editor), NULL);
+	return editor;
+}
+
diff --git shared/nm-vpn/nm-vpn-plugin-utils.h shared/nm-vpn/nm-vpn-plugin-utils.h
new file mode 100644
index 0000000..3efad44
--- /dev/null
+++ shared/nm-vpn/nm-vpn-plugin-utils.h
@@ -0,0 +1,40 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2016 Red Hat, Inc.
+ */
+
+#ifndef __NM_VPN_PLUGIN_UTILS_H__
+#define __NM_VPN_PLUGIN_UTILS_H__
+
+typedef NMVpnEditor *(NMVpnPluginUtilsEditorFactory) (gpointer factory,
+                                                      NMVpnEditorPlugin *editor_plugin,
+                                                      NMConnection *connection,
+                                                      gpointer user_data,
+                                                      GError **error);
+
+NMVpnEditor *nm_vpn_plugin_utils_load_editor (const char *module_name,
+                                              const char *factory_name,
+                                              NMVpnPluginUtilsEditorFactory editor_factory,
+                                              NMVpnEditorPlugin *editor_plugin,
+                                              NMConnection *connection,
+                                              gpointer user_data,
+                                              GError **error);
+
+#endif /* __NM_VPN_PLUGIN_UTILS_H__ */
+
diff --git shared/utils.c shared/utils.c
index 13cb73d..f61cd42 100644
--- shared/utils.c
+++ shared/utils.c
@@ -19,15 +19,13 @@
  * (C) Copyright 2010 Red Hat, Inc.
  */
 
-#include "config.h"
+#include "nm-default.h"
+
+#include "utils.h"
 
 #include <string.h>
 #include <errno.h>
 
-#include "nm-default.h"
-#include "utils.h"
-#include "nm-macros-internal.h"
-
 gboolean
 is_pkcs12 (const char *filepath)
 {
diff --git shared/utils.h shared/utils.h
index 3d86762..6370871 100644
--- shared/utils.h
+++ shared/utils.h
@@ -22,8 +22,6 @@
 #ifndef UTILS_H
 #define UTILS_H
 
-#include <glib.h>
-
 #define NMV_OVPN_TAG_AUTH               "auth"
 #define NMV_OVPN_TAG_AUTH_NOCACHE       "auth-nocache"
 #define NMV_OVPN_TAG_AUTH_USER_PASS     "auth-user-pass"
@@ -66,6 +64,7 @@
 #define NMV_OVPN_TAG_SOCKS_PROXY_RETRY  "socks-proxy-retry"
 #define NMV_OVPN_TAG_SOCKS_PROXY        "socks-proxy"
 #define NMV_OVPN_TAG_TLS_AUTH           "tls-auth"
+#define NMV_OVPN_TAG_TLS_CIPHER         "tls-cipher"
 #define NMV_OVPN_TAG_TLS_CLIENT         "tls-client"
 #define NMV_OVPN_TAG_TLS_REMOTE         "tls-remote"
 #define NMV_OVPN_TAG_TOPOLOGY           "topology"
diff --git src/Makefile.am src/Makefile.am
index 0b8b7a5..1014392 100644
--- src/Makefile.am
+++ src/Makefile.am
@@ -17,11 +17,11 @@ libexec_PROGRAMS = nm-openvpn-service nm-openvpn-service-openvpn-helper
 nm_openvpn_service_SOURCES = \
 	nm-openvpn-service.c \
 	nm-openvpn-service.h \
-	$(top_srcdir)/shared/nm-openvpn-service-defines.h
+	$(top_srcdir)/shared/nm-service-defines.h
 
 nm_openvpn_service_LDADD = \
 	$(LIBNM_LIBS) \
-        $(top_builddir)/shared/libnm-vpn-plugin-openvpn-shared.la
+	$(top_builddir)/shared/libnm-vpn-plugin-openvpn-shared.la
 
 nm_openvpn_service_openvpn_helper_SOURCES = \
 	nm-openvpn-service-openvpn-helper.c
diff --git src/nm-openvpn-service-openvpn-helper.c src/nm-openvpn-service-openvpn-helper.c
index 5a2e0be..6deead7 100644
--- src/nm-openvpn-service-openvpn-helper.c
+++ src/nm-openvpn-service-openvpn-helper.c
@@ -25,7 +25,7 @@
  * $Id: nm-openvpn-service-openvpn-helper.c 4170 2008-10-11 14:44:45Z dcbw $
  */
 
-#include "config.h"
+#include "nm-default.h"
 
 #include <stdlib.h>
 #include <unistd.h>
@@ -39,10 +39,7 @@
 #include <ctype.h>
 #include <netdb.h>
 
-#include "nm-default.h"
-
 #include "nm-openvpn-service.h"
-#include "nm-utils.h"
 
 extern char **environ;
 
diff --git src/nm-openvpn-service.c src/nm-openvpn-service.c
index 61ecc58..85dc0ba 100644
--- src/nm-openvpn-service.c
+++ src/nm-openvpn-service.c
@@ -22,7 +22,9 @@
  *
  */
 
-#include "config.h"
+#include "nm-default.h"
+
+#include "nm-openvpn-service.h"
 
 #include <stdio.h>
 #include <string.h>
@@ -44,14 +46,7 @@
 #include <grp.h>
 #include "glib-unix.h"
 
-#include "nm-default.h"
-
-#include <nm-vpn-service-plugin.h>
-
-#include "nm-openvpn-service.h"
-#include "nm-utils.h"
 #include "utils.h"
-#include "nm-macros-internal.h"
 
 #if !defined(DIST_VERSION)
 # define DIST_VERSION VERSION
@@ -110,7 +105,7 @@ static ValidProperty valid_properties[] = {
 	{ NM_OPENVPN_KEY_CERT,                 G_TYPE_STRING, 0, 0, FALSE },
 	{ NM_OPENVPN_KEY_CIPHER,               G_TYPE_STRING, 0, 0, FALSE },
 	{ NM_OPENVPN_KEY_KEYSIZE,              G_TYPE_INT, 1, 65535, FALSE },
-	{ NM_OPENVPN_KEY_COMP_LZO,             G_TYPE_BOOLEAN, 0, 0, FALSE },
+	{ NM_OPENVPN_KEY_COMP_LZO,             G_TYPE_STRING, 0, 0, FALSE },
 	{ NM_OPENVPN_KEY_CONNECTION_TYPE,      G_TYPE_STRING, 0, 0, FALSE },
 	{ NM_OPENVPN_KEY_FLOAT,                G_TYPE_BOOLEAN, 0, 0, FALSE },
 	{ NM_OPENVPN_KEY_FRAGMENT_SIZE,        G_TYPE_INT, 0, G_MAXINT, FALSE },
@@ -139,6 +134,7 @@ static ValidProperty valid_properties[] = {
 	{ NM_OPENVPN_KEY_DEV,                  G_TYPE_STRING, 0, 0, FALSE },
 	{ NM_OPENVPN_KEY_DEV_TYPE,             G_TYPE_STRING, 0, 0, FALSE },
 	{ NM_OPENVPN_KEY_TUN_IPV6,             G_TYPE_STRING, 0, 0, FALSE },
+	{ NM_OPENVPN_KEY_TLS_CIPHER,           G_TYPE_STRING, 0, 0, FALSE },
 	{ NM_OPENVPN_KEY_TLS_REMOTE,           G_TYPE_STRING, 0, 0, FALSE },
 	{ NM_OPENVPN_KEY_REMOTE_CERT_TLS,      G_TYPE_STRING, 0, 0, FALSE },
 	{ NM_OPENVPN_KEY_NS_CERT_TYPE,         G_TYPE_STRING, 0, 0, FALSE },
@@ -1103,7 +1099,7 @@ nm_openvpn_start_openvpn_binary (NMOpenvpnPlugin *plugin,
 	char *stmp;
 	const char *defport, *proto_tcp;
 	const char *nm_openvpn_user, *nm_openvpn_group, *nm_openvpn_chroot;
-	gchar *bus_name;
+	gs_free char *bus_name = NULL;
 
 	/* Find openvpn */
 	openvpn_binary = nm_find_openvpn ();
@@ -1247,8 +1243,10 @@ nm_openvpn_start_openvpn_binary (NMOpenvpnPlugin *plugin,
 	}
 
 	tmp = nm_setting_vpn_get_data_item (s_vpn, NM_OPENVPN_KEY_COMP_LZO);
-	if (tmp && !strcmp (tmp, "yes"))
+	if (NM_IN_STRSET (tmp, "yes", "no", "adaptive")) {
 		add_openvpn_arg (args, "--comp-lzo");
+		add_openvpn_arg (args, tmp);
+	}
 
 	tmp = nm_setting_vpn_get_data_item (s_vpn, NM_OPENVPN_KEY_FLOAT);
 	if (tmp && !strcmp (tmp, "yes"))
@@ -1334,6 +1332,12 @@ nm_openvpn_start_openvpn_binary (NMOpenvpnPlugin *plugin,
 		add_openvpn_arg (args, tmp);
 	}
 
+	tmp = nm_setting_vpn_get_data_item (s_vpn, NM_OPENVPN_KEY_TLS_CIPHER);
+	if (tmp && tmp[0]) {
+		add_openvpn_arg (args, "--tls-cipher");
+		add_openvpn_arg (args, tmp);
+	}
+
 	/* Keysize */
 	tmp = nm_setting_vpn_get_data_item (s_vpn, NM_OPENVPN_KEY_KEYSIZE);
 	if (tmp && strlen (tmp)) {
diff --git src/nm-openvpn-service.h src/nm-openvpn-service.h
index df2ce60..28bb4db 100644
--- src/nm-openvpn-service.h
+++ src/nm-openvpn-service.h
@@ -23,12 +23,6 @@
 #ifndef NM_OPENVPN_SERVICE_H
 #define NM_OPENVPN_SERVICE_H
 
-#include <glib.h>
-#include <glib-object.h>
-#include <nm-vpn-service-plugin.h>
-
-#include "nm-openvpn-service-defines.h"
-
 #define NM_TYPE_OPENVPN_PLUGIN            (nm_openvpn_plugin_get_type ())
 #define NM_OPENVPN_PLUGIN(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_OPENVPN_PLUGIN, NMOpenvpnPlugin))
 #define NM_OPENVPN_PLUGIN_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_OPENVPN_PLUGIN, NMOpenvpnPluginClass))

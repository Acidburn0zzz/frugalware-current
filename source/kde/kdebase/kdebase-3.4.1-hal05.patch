--- kdebase/kioslave/media/configure.in.in	2005/03/30 21:25:59	1.7.2.1
+++ kdebase/kioslave/media/configure.in.in	2005/03/27 13:24:33	1.9
@@ -12,100 +12,100 @@
 AC_ARG_WITH(hal,AC_HELP_STRING([--with-hal],[Enable HAL support  [default=check]]),[hal_test="$withval"],[hal_test="yes"])
 
 if test "x$hal_test" = "xyes" ; then
-  
-########### Check for the HAL, version 0.4.x
-  
-  AC_MSG_CHECKING(for the HAL 0.4)
-  
+
+########### Check for the HAL
+
+  AC_MSG_CHECKING(for the HAL)
+
   hal_inc=NOTFOUND
   hal_lib=NOTFOUND
   hal=NOTFOUND
-  
-  search_incs="$kde_includes /usr/include /usr/local/include /usr/include/hal /usr/local/include/hal"
+
+  search_incs="$kde_includes /usr/include /usr/include/hal /usr/local/include /usr/local/include/hal"
   AC_FIND_FILE(libhal.h libhal-storage.h, $search_incs, hal_incdir)
-  
+
   if [test -r $hal_incdir/libhal.h] && [test -r $hal_incdir/libhal-storage.h] ; then
     HAL_INCS="-I$hal_incdir"
     hal_inc=FOUND
   fi
-  
+
+  if test -r $hal_incdir/libhal-storage.h ; then
+    hal_storage_version=4
+    grep LibHalVolume $hal_incdir/libhal-storage.h \
+    > /dev/null 2>&1 && hal_storage_version=5
+    if test $hal_storage_version = 4 ; then
+      AC_DEFINE(HAL_0_4, , [HAL API version 0.4])
+    fi
+  fi
+
   search_libs="$kde_libraries /usr/lib /usr/local/lib"
   AC_FIND_FILE(libhal.so libhal-storage.so, $search_libs, hal_libdir)
-  
+
   if [test -r $hal_libdir/libhal.so] && [test -r $hal_libdir/libhal-storage.so] ; then
     HAL_LIBS="-L$hal_libdir -lhal -lhal-storage"
     hal_lib=FOUND
   fi
-  
-  if test -r $hal_incdir/libhal.h ; then
-    hal_version=5
-    grep LibHalFunctions $hal_incdir/libhal.h \
-    > /dev/null 2>&1 && hal_version=4
-    if test $hal_version = 5 ; then
-      hal_lib=NOT_FOUND
-    fi
-  fi
-				
-  
+
+
   if [test $hal_inc = FOUND] && [test $hal_lib = FOUND] ; then
       AC_MSG_RESULT(headers $hal_incdir  libraries $hal_libdir)
   	hal=FOUND
   else
       AC_MSG_RESULT(searched but not found)
   fi
-  
+
   AC_SUBST(HAL_INCS)
   AC_SUBST(HAL_LIBS)
-  
-  
+
+
 ########### Check for DBus
-  
+
   AC_MSG_CHECKING(for DBus)
-  
+
   dbus_inc=NOTFOUND
   dbus_lib=NOTFOUND
   dbus=NOTFOUND
-  
-  search_incs="$kde_includes /usr/include /usr/local/include /usr/include/dbus-1.0 /usr/local/include/dbus-1.0"
+
+  search_incs="$kde_includes /usr/include /usr/include/dbus-1.0 /usr/local/include /usr/local/include/dbus-1.0"
   AC_FIND_FILE(dbus/dbus.h, $search_incs, dbus_incdir)
-  
+
   search_incs_arch_deps="$kde_includes /usr/lib/dbus-1.0/include /usr/local/lib/dbus-1.0/include"
   AC_FIND_FILE(dbus/dbus-arch-deps.h, $search_incs_arch_deps, dbus_incdir_arch_deps)
-  
+
   if [test -r $dbus_incdir/dbus/dbus.h] && [test -r $dbus_incdir_arch_deps/dbus/dbus-arch-deps.h] ; then
     DBUS_INCS="-I$dbus_incdir -I$dbus_incdir_arch_deps"
     dbus_inc=FOUND
   fi
-  
+
   search_libs="$kde_libraries /usr/lib /usr/local/lib"
   AC_FIND_FILE(libdbus-1.so, $search_libs, dbus_libdir)
-  
+
   if test -r $dbus_libdir/libdbus-1.so ; then
     DBUS_LIBS="-L$dbus_libdir -ldbus-1"
     dbus_lib=FOUND
   fi
-  
+
   if [test $dbus_inc = FOUND] && [test $dbus_lib = FOUND] ; then
     AC_MSG_RESULT(headers $dbus_incdir $dbus_incdir_arch_deps  libraries $dbus_libdir)
     dbus=FOUND
   else
     AC_MSG_RESULT(searched but not found)
   fi
-  
+
   AC_SUBST(DBUS_INCS)
   AC_SUBST(DBUS_LIBS)
-  
+
 ########### Check for DBus-Qt bindings
-  
+
   AC_MSG_CHECKING(for DBus-Qt bindings)
-  
+
   dbusqt_inc=NOTFOUND
   dbusqt_lib=NOTFOUND
   dbusqt=NOTFOUND
-  
-  search_incs="$kde_includes /usr/include /usr/local/include /usr/include/dbus-1.0 /usr/local/include/dbus-1.0"
+
+  search_incs="$kde_includes /usr/include /usr/include/dbus-1.0 /usr/local/include /usr/local/include/dbus-1.0"
   AC_FIND_FILE(dbus/connection.h, $search_incs, dbusqt_incdir)
-  
+
   if test -r $dbusqt_incdir/dbus/connection.h ; then
     have_qt_patch=0
     grep dbus_connection_setup_with_qt_main $dbusqt_incdir/dbus/connection.h \
@@ -115,15 +115,15 @@
       dbusqt_inc=FOUND
     fi
   fi
-  
+
   search_libs="$kde_libraries /usr/lib /usr/local/lib"
   AC_FIND_FILE(libdbus-qt-1.so, $search_libs, dbusqt_libdir)
-  
+
   if test -r $dbusqt_libdir/libdbus-qt-1.so ; then
     DBUSQT_LIBS="-L$dbusqt_libdir -ldbus-qt-1"
     dbusqt_lib=FOUND
   fi
-  
+
   if [test $dbusqt_inc = FOUND] && [test $dbusqt_lib = FOUND] ; then
     AC_MSG_RESULT(headers $dbusqt_incdir libraries $dbusqt_libdir)
     dbusqt=FOUND
--- kdebase/kioslave/media/kdedmodule/halbackend.h	2004/10/25 22:35:32	1.1
+++ kdebase/kioslave/media/kdedmodule/halbackend.h	2005/03/27 13:24:33	1.3
@@ -35,6 +35,8 @@
 #include <qstringlist.h>
 #include <qstring.h>
 
+#include <config.h>
+
 /* We acknowledge the the dbus API is unstable */
 #define DBUS_API_SUBJECT_TO_CHANGE
 /* DBus-Qt bindings */
@@ -43,6 +45,65 @@
 #include <libhal.h>
 #include <libhal-storage.h>
 
+/* The HAL API changed between 0.4 and 0.5 series.
+These defines enable backward compatibility */
+#ifdef HAL_0_4
+	// libhal-storage 0.4 API
+	#define LibHalStoragePolicy				HalStoragePolicy
+	#define LibHalDrive						HalDrive
+	#define LibHalVolume					HalVolume
+	#define LibHalVolumeDiscType			HalVolumeDiscType
+	#define libhal_storage_policy_free		hal_storage_policy_free
+	#define libhal_storage_policy_new		hal_storage_policy_new
+	#define libhal_drive_from_udi			hal_drive_from_udi
+	#define libhal_drive_find_all_volumes	hal_drive_find_all_volumes
+	#define libhal_drive_get_type			hal_drive_get_type
+	#define libhal_drive_get_device_file	hal_drive_get_device_file
+	#define libhal_drive_free				hal_drive_free
+	#define libhal_drive_policy_compute_display_name	hal_drive_policy_compute_display_name
+	#define libhal_drive_is_hotpluggable	hal_drive_is_hotpluggable
+	#define libhal_volume_from_udi			hal_volume_from_udi
+	#define libhal_volume_get_device_file	hal_volume_get_device_file
+	#define libhal_volume_get_mount_point	hal_volume_get_mount_point
+	#define libhal_volume_get_fstype		hal_volume_get_fstype
+	#define libhal_volume_is_mounted		hal_volume_is_mounted
+	#define libhal_volume_get_disc_type		hal_volume_get_disc_type
+	#define libhal_volume_free				hal_volume_free
+	#define libhal_volume_policy_compute_display_name	hal_volume_policy_compute_display_name
+	#define libhal_volume_disc_has_data		hal_volume_disc_has_data
+	#define libhal_volume_disc_has_audio	hal_volume_disc_has_audio
+	#define libhal_volume_disc_is_blank		hal_volume_disc_is_blank
+	#define libhal_volume_is_disc			hal_volume_is_disc
+	#define libhal_volume_get_storage_device_udi	hal_volume_get_storage_device_udi
+	#define LIBHAL_VOLUME_DISC_TYPE_CDROM		HAL_VOLUME_DISC_TYPE_CDROM
+	#define LIBHAL_VOLUME_DISC_TYPE_CDR			HAL_VOLUME_DISC_TYPE_CDR
+	#define LIBHAL_VOLUME_DISC_TYPE_CDRW		HAL_VOLUME_DISC_TYPE_CDRW
+	#define LIBHAL_VOLUME_DISC_TYPE_DVDROM		HAL_VOLUME_DISC_TYPE_DVDROM
+	#define LIBHAL_VOLUME_DISC_TYPE_DVDRAM		HAL_VOLUME_DISC_TYPE_DVDRAM
+	#define LIBHAL_VOLUME_DISC_TYPE_DVDR		HAL_VOLUME_DISC_TYPE_DVDR
+	#define LIBHAL_VOLUME_DISC_TYPE_DVDRW		HAL_VOLUME_DISC_TYPE_DVDRW
+	#define LIBHAL_VOLUME_DISC_TYPE_DVDPLUSR	HAL_VOLUME_DISC_TYPE_DVDPLUSR
+	#define LIBHAL_VOLUME_DISC_TYPE_DVDPLUSRW	HAL_VOLUME_DISC_TYPE_DVDPLUSRW
+	#define LIBHAL_DRIVE_TYPE_COMPACT_FLASH			HAL_DRIVE_TYPE_COMPACT_FLASH
+	#define LIBHAL_DRIVE_TYPE_MEMORY_STICK			HAL_DRIVE_TYPE_MEMORY_STICK
+	#define LIBHAL_DRIVE_TYPE_SMART_MEDIA 			HAL_DRIVE_TYPE_SMART_MEDIA
+	#define LIBHAL_DRIVE_TYPE_SD_MMC				HAL_DRIVE_TYPE_SD_MMC
+	#define LIBHAL_DRIVE_TYPE_PORTABLE_AUDIO_PLAYER	HAL_DRIVE_TYPE_PORTABLE_AUDIO_PLAYER
+	#define LIBHAL_DRIVE_TYPE_CAMERA				HAL_DRIVE_TYPE_CAMERA
+	#define LIBHAL_DRIVE_TYPE_TAPE					HAL_DRIVE_TYPE_TAPE
+
+	// libhal 0.4 API
+	#define libhal_free_string hal_free_string
+	#define libhal_device_exists(ctx, udi, error) hal_device_exists(ctx, udi)
+	#define libhal_device_property_watch_all(ctx, error) hal_device_property_watch_all(ctx)
+	#define libhal_get_all_devices(ctx, num_devices, error) hal_get_all_devices(ctx, num_devices)
+	#define libhal_device_property_exists(ctx, udi, key, error) hal_device_property_exists(ctx, udi, key)
+	#define libhal_device_get_property_bool(ctx, udi, key, error) hal_device_get_property_bool(ctx, udi, key)
+	#define libhal_device_get_property_string(ctx, udi, key, error) hal_device_get_property_string(ctx, udi, key)
+	#define libhal_device_query_capability(ctx, udi, capability, error) hal_device_query_capability(ctx, udi, capability)
+#endif
+
+
 /**
 * A handy function to query a hal string
 *
@@ -175,7 +236,13 @@
 	*  @param  message             D-BUS message with variable parameters depending on condition
 	*/
 	static void hal_device_condition(LibHalContext *ctx, const char *udi,
-				const char *condition_name, DBusMessage *message);
+				const char *condition_name,
+				#ifdef HAL_0_4
+				DBusMessage *message
+				#else
+				const char* message
+				#endif
+				);
 
 /* HAL and DBus structures */
 private:
@@ -184,15 +251,17 @@
 	*/
 	LibHalContext*		m_halContext;
 
+#ifdef HAL_0_4
 	/**
 	* Structure defining the hal callback function for devices events
 	*/
 	LibHalFunctions 	m_halFunctions;
+#endif
 
 	/**
 	* libhal-storage HAL policy, e.g. for icon names
 	*/
-	HalStoragePolicy*	m_halStoragePolicy;
+	LibHalStoragePolicy*	m_halStoragePolicy;
 
 	/**
 	* The DBus-Qt bindings connection for mainloop integration
--- kdebase/kioslave/media/kdedmodule/halbackend.cpp	2005/03/30 21:25:59	1.7.2.2
+++ kdebase/kioslave/media/kdedmodule/halbackend.cpp	2005/03/30 21:37:21	1.11
@@ -23,7 +23,7 @@
 #include <kurl.h>
 #include <kdebug.h>
 
-#define MOUNT_SUFFIX	(hal_volume_is_mounted(halVolume) ? QString("_mounted") : QString("_unmounted"))
+#define MOUNT_SUFFIX	(libhal_volume_is_mounted(halVolume) ? QString("_mounted") : QString("_unmounted"))
 
 /* Static instance of this class, for static HAL callbacks */
 static HALBackend* s_HALBackend;
@@ -33,9 +33,9 @@
 {
 	char*   _ppt_string;
 	QString _ppt_QString;
-	_ppt_string = hal_device_get_property_string(ctx, udi, key);
+	_ppt_string = libhal_device_get_property_string(ctx, udi, key, NULL);
 	_ppt_QString = QString(_ppt_string ? _ppt_string : "");
-	hal_free_string(_ppt_string);
+	libhal_free_string(_ppt_string);
 	return _ppt_QString;
 }
 
@@ -55,14 +55,22 @@
 {
 	/* Close HAL connection */
 	if (m_halContext)
+	{
+		#ifdef HAL_0_4
 		hal_shutdown(m_halContext);
+		#else
+		libhal_ctx_shutdown(m_halContext, NULL);
+		libhal_ctx_free(m_halContext);
+		#endif
+	}
 	if (m_halStoragePolicy)
-		hal_storage_policy_free(m_halStoragePolicy);
+		libhal_storage_policy_free(m_halStoragePolicy);
 }
 
 /* Connect to the HAL */
 bool HALBackend::InitHal()
 {
+#ifdef HAL_0_4 /* HAL API 0.4 */
 	/* libhal initialization */
 	m_halFunctions.main_loop_integration	= HALBackend::hal_main_loop_integration;
 	m_halFunctions.device_added				= HALBackend::hal_device_added;
@@ -75,19 +83,60 @@
 	m_halContext = hal_initialize(&m_halFunctions, FALSE);
 	if (!m_halContext)
 	{
-		kdDebug()<<"Failed to initialize HAL!"<<endl;
+		kdDebug() << "Failed to initialize HAL!" << endl;
 		return false;
 	}
 
 	/** @todo customize watch policy */
-	if (hal_device_property_watch_all(m_halContext))
+	/* NOTICE: this code chunk doesn't seem necessary for the .05 API... still, it should */
+	kdDebug() << "Watch properties" << endl;
+	if (libhal_device_property_watch_all(m_halContext, NULL))
+	{
+		kdDebug() << "Failed to watch HAL properties!" << endl;
+		return false;
+	}
+
+#else /* HAL API >= 0.5 */
+	kdDebug() << "Context new" << endl;
+	m_halContext = libhal_ctx_new();
+	if (!m_halContext)
 	{
-		kdDebug()<<"Failed to watch HAL properties!"<<endl;
+		kdDebug() << "Failed to initialize HAL!" << endl;
 		return false;
 	}
 
+	// Main loop integration
+	kdDebug() << "Main loop integration" << endl;
+	DBusError error;
+	dbus_error_init(&error);
+	DBusConnection *dbus_connection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
+	if (dbus_error_is_set(&error)) {
+   dbus_error_free(&error);
+		return false;
+ }
+	MainLoopIntegration(dbus_connection);
+	libhal_ctx_set_dbus_connection(m_halContext, dbus_connection);
+
+	// HAL callback functions
+	kdDebug() << "Callback functions" << endl;
+	libhal_ctx_set_device_added(m_halContext, HALBackend::hal_device_added);
+	libhal_ctx_set_device_removed(m_halContext, HALBackend::hal_device_removed);
+	libhal_ctx_set_device_new_capability (m_halContext, NULL);
+	libhal_ctx_set_device_lost_capability (m_halContext, NULL);
+	libhal_ctx_set_device_property_modified (m_halContext, HALBackend::hal_device_property_modified);
+	libhal_ctx_set_device_condition(m_halContext, HALBackend::hal_device_condition);
+
+	kdDebug() << "Context Init" << endl;
+	if (!libhal_ctx_init(m_halContext, NULL))
+	{
+		kdDebug() << "Failed to init HAL context!" << endl;
+		return false;
+	}
+#endif
+
 	/* libhal-storage initialization */
-	m_halStoragePolicy = hal_storage_policy_new();
+	kdDebug() << "Storage Policy" << endl;
+	m_halStoragePolicy = libhal_storage_policy_new();
 	/** @todo define libhal-storage icon policy */
 
 	/* List devices at startup */
@@ -97,8 +144,10 @@
 /* List devices (at startup)*/
 bool HALBackend::ListDevices()
 {
+	kdDebug() << "ListDevices" << endl;
+
 	int numDevices;
-	char** halDeviceList = hal_get_all_devices(m_halContext, &numDevices);
+	char** halDeviceList = libhal_get_all_devices(m_halContext, &numDevices, NULL);
 
 	if (!halDeviceList)
 		return false;
@@ -116,7 +165,7 @@
 {
 	/* We don't deal with devices that do not expose their capabilities.
 	If we don't check this, we will get a lot of warning messages from libhal */
-	if (!hal_device_property_exists(m_halContext, udi, "info.capabilities"))
+	if (!libhal_device_property_exists(m_halContext, udi, "info.capabilities", NULL))
 		return;
 
 	/* If the device is already listed, do not process.
@@ -126,11 +175,11 @@
 		return;
 
 	/* Add volume block devices */
-	if (hal_device_query_capability(m_halContext, udi, "volume"))
+	if (libhal_device_query_capability(m_halContext, udi, "volume", NULL))
 	{
 		/* We only list volume that have a filesystem or volume that have an audio track*/
 		if ( (hal_device_get_property_QString(m_halContext, udi, "volume.fsusage") != "filesystem") &&
-		     (!hal_device_get_property_bool(m_halContext, udi, "volume.disc.has_audio")) )
+		     (!libhal_device_get_property_bool(m_halContext, udi, "volume.disc.has_audio", NULL)) )
 			return;
 		/* Query drive udi */
 		QString driveUdi = hal_device_get_property_QString(m_halContext, udi, "block.storage_device");
@@ -150,7 +199,7 @@
 	}
 
 	/* Floppy & zip drives */
-	if (hal_device_query_capability(m_halContext, udi, "storage"))
+	if (libhal_device_query_capability(m_halContext, udi, "storage", NULL))
 		if ((hal_device_get_property_QString(m_halContext, udi, "storage.drive_type") == "floppy") ||
 		    (hal_device_get_property_QString(m_halContext, udi, "storage.drive_type") == "zip"))
 		{
@@ -162,7 +211,7 @@
 		}
 
 	/* Camera handled by gphoto2*/
-	if (hal_device_query_capability(m_halContext, udi, "camera"))
+	if (libhal_device_query_capability(m_halContext, udi, "camera", NULL))
 
 		{
 			/* Create medium */
@@ -229,8 +278,8 @@
 		return medium->id().ascii();
 
 	/* Hard part : this is a volume whose drive is registered */
-	if (hal_device_property_exists(m_halContext, udi, "info.capabilities"))
-		if (hal_device_query_capability(m_halContext, udi, "volume"))
+	if (libhal_device_property_exists(m_halContext, udi, "info.capabilities", NULL))
+		if (libhal_device_query_capability(m_halContext, udi, "volume", NULL))
 		{
 			QString driveUdi = hal_device_get_property_QString(m_halContext, udi, "block.storage_device");
 			return findMediumUdiFromUdi(driveUdi.ascii());
@@ -244,11 +293,11 @@
 	kdDebug() << "HALBackend::setProperties" << endl;
 
 	Medium* m = new Medium(mediumUdi, "");
-	if (hal_device_query_capability(m_halContext, mediumUdi, "volume"))
+	if (libhal_device_query_capability(m_halContext, mediumUdi, "volume", NULL))
 		setVolumeProperties(m);
-	if (hal_device_query_capability(m_halContext, mediumUdi, "storage"))
+	if (libhal_device_query_capability(m_halContext, mediumUdi, "storage", NULL))
 		setFloppyProperties(m);
-	if (hal_device_query_capability(m_halContext, mediumUdi, "camera"))
+	if (libhal_device_query_capability(m_halContext, mediumUdi, "camera", NULL))
 		setCameraProperties(m);
 
 	m_mediaList.changeMediumState(*m);
@@ -262,34 +311,35 @@
 
 	const char* udi = medium->id().ascii();
 	/* Check if the device still exists */
-	if (!hal_device_exists(m_halContext, udi))
+	if (!libhal_device_exists(m_halContext, udi, NULL))
 			return;
 
 	/* Get device information from libhal-storage */
-	HalVolume* halVolume = hal_volume_from_udi(m_halContext, udi);
+	LibHalVolume* halVolume = libhal_volume_from_udi(m_halContext, udi);
 	if (!halVolume)
 		return;
-
-	QString driveUdi = hal_volume_get_storage_device_udi(halVolume);
-	HalDrive*  halDrive  = hal_drive_from_udi(m_halContext, driveUdi.ascii());
+	QString driveUdi = libhal_volume_get_storage_device_udi(halVolume);
+	LibHalDrive*  halDrive  = libhal_drive_from_udi(m_halContext, driveUdi.ascii());
 
 	medium->setName(
-		generateName(hal_volume_get_device_file(halVolume)) );
+		generateName(libhal_volume_get_device_file(halVolume)) );
 
 	medium->mountableState(
-		hal_volume_get_device_file(halVolume),		/* Device node */
-		hal_volume_get_mount_point(halVolume),		/* Mount point */
-		hal_volume_get_fstype(halVolume),			/* Filesystem type */
-		hal_volume_is_mounted(halVolume) );			/* Mounted ? */
+		libhal_volume_get_device_file(halVolume),		/* Device node */
+		libhal_volume_get_mount_point(halVolume),		/* Mount point */
+		libhal_volume_get_fstype(halVolume),			/* Filesystem type */
+		libhal_volume_is_mounted(halVolume) );			/* Mounted ? */
 
 	QString mimeType;
-	if (hal_volume_is_disc(halVolume))
+	if (libhal_volume_is_disc(halVolume))
 	{
 		mimeType = "media/cdrom" + MOUNT_SUFFIX;
 
-		HalVolumeDiscType discType = hal_volume_get_disc_type(halVolume);
-		if ((discType == HAL_VOLUME_DISC_TYPE_CDR) || (discType == HAL_VOLUME_DISC_TYPE_CDRW))
-			if (hal_volume_disc_is_blank(halVolume))
+		LibHalVolumeDiscType discType = libhal_volume_get_disc_type(halVolume);
+		if ((discType == LIBHAL_VOLUME_DISC_TYPE_CDROM) ||
+		    (discType == LIBHAL_VOLUME_DISC_TYPE_CDR) ||
+			(discType == LIBHAL_VOLUME_DISC_TYPE_CDRW))
+			if (libhal_volume_disc_is_blank(halVolume))
 			{
 				mimeType = "media/blankcd";
 				medium->unmountableState("");
@@ -297,10 +347,10 @@
 			else
 				mimeType = "media/cdwriter" + MOUNT_SUFFIX;
 
-		if ((discType == HAL_VOLUME_DISC_TYPE_DVDROM) || (discType == HAL_VOLUME_DISC_TYPE_DVDRAM) ||
-			(discType == HAL_VOLUME_DISC_TYPE_DVDR) || (discType == HAL_VOLUME_DISC_TYPE_DVDRW) ||
-			(discType == HAL_VOLUME_DISC_TYPE_DVDPLUSR) || (discType == HAL_VOLUME_DISC_TYPE_DVDPLUSRW) )
-			if (hal_volume_disc_is_blank(halVolume))
+		if ((discType == LIBHAL_VOLUME_DISC_TYPE_DVDROM) || (discType == LIBHAL_VOLUME_DISC_TYPE_DVDRAM) ||
+			(discType == LIBHAL_VOLUME_DISC_TYPE_DVDR) || (discType == LIBHAL_VOLUME_DISC_TYPE_DVDRW) ||
+			(discType == LIBHAL_VOLUME_DISC_TYPE_DVDPLUSR) || (discType == LIBHAL_VOLUME_DISC_TYPE_DVDPLUSRW) )
+			if (libhal_volume_disc_is_blank(halVolume))
 			{
 				mimeType = "media/blankdvd";
 				medium->unmountableState("");
@@ -308,16 +358,16 @@
 			else
 				mimeType = "media/dvd" + MOUNT_SUFFIX;
 
-		if (hal_volume_disc_has_audio(halVolume) && !hal_volume_disc_has_data(halVolume))
+		if (libhal_volume_disc_has_audio(halVolume) && !libhal_volume_disc_has_data(halVolume))
 		{
 			mimeType = "media/audiocd";
-			medium->unmountableState( "audiocd:/?device=" + QString(hal_volume_get_device_file(halVolume)) );
+			medium->unmountableState( "audiocd:/?device=" + QString(libhal_volume_get_device_file(halVolume)) );
 		}
 
 		medium->setIconName(QString::null);
-		
+
 		/* check if the disc id a vcd or a video dvd */
-		DiscType type = LinuxCDPolling::identifyDiscType(hal_volume_get_device_file(halVolume));
+		DiscType type = LinuxCDPolling::identifyDiscType(libhal_volume_get_device_file(halVolume));
 		switch (type)
 		{
 		  case DiscType::VCD:
@@ -334,44 +384,46 @@
 	else
 	{
 		mimeType = "media/hdd" + MOUNT_SUFFIX;
-		if (hal_drive_is_hotpluggable(halDrive))
-		{		
+		if (libhal_drive_is_hotpluggable(halDrive))
+		{
 			mimeType = "media/removable" + MOUNT_SUFFIX;
 			medium->needMounting();
-			switch (hal_drive_get_type(halDrive)) {
-			case HAL_DRIVE_TYPE_COMPACT_FLASH:
+			switch (libhal_drive_get_type(halDrive)) {
+			case LIBHAL_DRIVE_TYPE_COMPACT_FLASH:
 				medium->setIconName("compact_flash" + MOUNT_SUFFIX);
 				break;
-			case HAL_DRIVE_TYPE_MEMORY_STICK:
+			case LIBHAL_DRIVE_TYPE_MEMORY_STICK:
 				medium->setIconName("memory_stick" + MOUNT_SUFFIX);
 				break;
-			case HAL_DRIVE_TYPE_SMART_MEDIA:
+			case LIBHAL_DRIVE_TYPE_SMART_MEDIA:
 				medium->setIconName("smart_media" + MOUNT_SUFFIX);
 				break;
-			case HAL_DRIVE_TYPE_SD_MMC:
+			case LIBHAL_DRIVE_TYPE_SD_MMC:
 				medium->setIconName("sd_mmc" + MOUNT_SUFFIX);
 				break;
-			case HAL_DRIVE_TYPE_PORTABLE_AUDIO_PLAYER:
+			case LIBHAL_DRIVE_TYPE_PORTABLE_AUDIO_PLAYER:
 				medium->setIconName(QString::null); //FIXME need icon
 				break;
-			case HAL_DRIVE_TYPE_CAMERA:
+			case LIBHAL_DRIVE_TYPE_CAMERA:
 				medium->setIconName("camera" + MOUNT_SUFFIX);
-				break;			
-			case HAL_DRIVE_TYPE_TAPE:
+				break;
+			case LIBHAL_DRIVE_TYPE_TAPE:
 				medium->setIconName(QString::null); //FIXME need icon
-				break;			
-			default:	
+				break;
+			default:
 				medium->setIconName(QString::null);
 			};
 		};
 	}
 	medium->setMimeType(mimeType);
 
-	medium->setLabel(QString::fromUtf8( hal_volume_policy_compute_display_name(halDrive,
-		halVolume, m_halStoragePolicy) ) );
+	QString volume_name = QString::fromUtf8(libhal_volume_policy_compute_display_name(halDrive, halVolume, m_halStoragePolicy));
+	//QString drive_name =  QString::fromUtf8(libhal_drive_policy_compute_display_name(halDrive, halVolume, m_halStoragePolicy));
+	QString media_name = volume_name;
+	medium->setLabel(media_name);
 
-	hal_drive_free(halDrive);
-	hal_volume_free(halVolume);
+	libhal_drive_free(halDrive);
+	libhal_volume_free(halVolume);
 }
 
 // Handle floppies and zip drives
@@ -381,34 +433,34 @@
 
 	const char* udi = medium->id().ascii();
 	/* Check if the device still exists */
-	if (!hal_device_exists(m_halContext, udi))
+	if (!libhal_device_exists(m_halContext, udi, NULL))
 		return;
 
-	HalDrive*  halDrive  = hal_drive_from_udi(m_halContext, udi);
+	LibHalDrive*  halDrive  = libhal_drive_from_udi(m_halContext, udi);
 	if (!halDrive)
 		return;
 	int numVolumes;
-	char** volumes = hal_drive_find_all_volumes(m_halContext, halDrive, &numVolumes);
-	HalVolume* halVolume = NULL;
+	char** volumes = libhal_drive_find_all_volumes(m_halContext, halDrive, &numVolumes);
+	LibHalVolume* halVolume = NULL;
 	kdDebug() << " found " << numVolumes << " volumes" << endl;
 	if (numVolumes)
-		halVolume = hal_volume_from_udi(m_halContext, volumes[0]);
+		halVolume = libhal_volume_from_udi(m_halContext, volumes[0]);
 
 	medium->setName(
-		generateName(hal_drive_get_device_file(halDrive)) );
+		generateName(libhal_drive_get_device_file(halDrive)) );
 
 	if (halVolume)
 	{
 		medium->mountableState(
-			hal_volume_get_device_file(halVolume),		/* Device node */
-			hal_volume_get_mount_point(halVolume),		/* Mount point */
-			hal_volume_get_fstype(halVolume),			/* Filesystem type */
-			hal_volume_is_mounted(halVolume) );			/* Mounted ? */
+			libhal_volume_get_device_file(halVolume),		/* Device node */
+			libhal_volume_get_mount_point(halVolume),		/* Mount point */
+			libhal_volume_get_fstype(halVolume),			/* Filesystem type */
+			libhal_volume_is_mounted(halVolume) );			/* Mounted ? */
 	}
 	else
 	{
 		medium->mountableState(
-			hal_drive_get_device_file(halDrive),		/* Device node */
+			libhal_drive_get_device_file(halDrive),		/* Device node */
 			"",											/* Mount point */
 			"",											/* Filesystem type */
 			false );									/* Mounted ? */
@@ -421,7 +473,7 @@
 		else
 			medium->setMimeType("media/floppy_unmounted");
 	}
-	
+
 	if (hal_device_get_property_QString(m_halContext, udi, "storage.drive_type") == "zip")
 	{
 		if (halVolume)
@@ -429,14 +481,24 @@
 		else
 			medium->setMimeType("media/zip_unmounted");
 	}
-	
+
 	medium->setIconName(QString::null);
 
-	medium->setLabel(QString::fromUtf8( hal_drive_policy_compute_display_name(halDrive,
-		halVolume, m_halStoragePolicy) ) );
+	QString media_name;
+	if (halVolume)
+	{
+		QString volume_name = QString::fromUtf8(libhal_drive_policy_compute_display_name(halDrive, halVolume, m_halStoragePolicy));
+		media_name = volume_name;
+	}
+	else
+	{
+		QString drive_name =  QString::fromUtf8(libhal_drive_policy_compute_display_name(halDrive, halVolume, m_halStoragePolicy));
+		media_name = drive_name;
+	}
+	medium->setLabel(media_name);
 
-	hal_drive_free(halDrive);
-	hal_volume_free(halVolume);
+	libhal_drive_free(halDrive);
+	libhal_volume_free(halVolume);
 }
 
 void HALBackend::setCameraProperties(Medium* medium)
@@ -445,7 +507,7 @@
 
 	const char* udi = medium->id().ascii();
 	/* Check if the device still exists */
-	if (!hal_device_exists(m_halContext, udi))
+	if (!libhal_device_exists(m_halContext, udi, NULL))
 		return;
 
 	/** @todo find name */
@@ -467,6 +529,7 @@
 ** HAL CALL-BACKS                        **
 ******************************************/
 
+#ifdef HAL_0_4
 void HALBackend::hal_main_loop_integration(LibHalContext *ctx,
 			DBusConnection *dbus_connection)
 {
@@ -474,6 +537,7 @@
 	Q_UNUSED(ctx);
 	s_HALBackend->MainLoopIntegration(dbus_connection);
 }
+#endif
 
 void HALBackend::hal_device_added(LibHalContext *ctx, const char *udi)
 {
@@ -498,8 +562,15 @@
 	Q_UNUSED(is_added);
 	s_HALBackend->ModifyDevice(udi, key);
 }
+
 void HALBackend::hal_device_condition(LibHalContext *ctx, const char *udi,
-			const char *condition_name, DBusMessage *message)
+			const char *condition_name,
+			#ifdef HAL_0_4
+			DBusMessage *message
+			#else
+			const char* message
+			#endif
+			)
 {
 	kdDebug() << "HALBackend::hal_device_condition " << udi << " -- " << condition_name << endl;
 	Q_UNUSED(ctx);
--- kioslave/media/kdedmodule/halbackend.cpp	2005/03/30 21:37:21	402030
+++ kdebase/kioslave/media/kdedmodule/halbackend.cpp	2005/06/08 20:39:37	423547
@@ -19,6 +19,8 @@
 #include "halbackend.h"
 #include "linuxcdpolling.h"
 
+#include <stdlib.h>
+
 #include <klocale.h>
 #include <kurl.h>
 #include <kdebug.h>
@@ -65,6 +67,8 @@
 	}
 	if (m_halStoragePolicy)
 		libhal_storage_policy_free(m_halStoragePolicy);
+
+	/** @todo empty media list ? */
 }
 
 /* Connect to the HAL */
@@ -83,30 +87,21 @@
 	m_halContext = hal_initialize(&m_halFunctions, FALSE);
 	if (!m_halContext)
 	{
-		kdDebug() << "Failed to initialize HAL!" << endl;
-		return false;
-	}
-
-	/** @todo customize watch policy */
-	/* NOTICE: this code chunk doesn't seem necessary for the .05 API... still, it should */
-	kdDebug() << "Watch properties" << endl;
-	if (libhal_device_property_watch_all(m_halContext, NULL))
-	{
-		kdDebug() << "Failed to watch HAL properties!" << endl;
+		kdDebug(1219) << "Failed to initialize HAL!" << endl;
 		return false;
 	}
 
 #else /* HAL API >= 0.5 */
-	kdDebug() << "Context new" << endl;
+	kdDebug(1219) << "Context new" << endl;
 	m_halContext = libhal_ctx_new();
 	if (!m_halContext)
 	{
-		kdDebug() << "Failed to initialize HAL!" << endl;
+		kdDebug(1219) << "Failed to initialize HAL!" << endl;
 		return false;
 	}
 
 	// Main loop integration
-	kdDebug() << "Main loop integration" << endl;
+	kdDebug(1219) << "Main loop integration" << endl;
 	DBusError error;
 	dbus_error_init(&error);
 	DBusConnection *dbus_connection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
@@ -116,7 +111,7 @@
 	libhal_ctx_set_dbus_connection(m_halContext, dbus_connection);
 
 	// HAL callback functions
-	kdDebug() << "Callback functions" << endl;
+	kdDebug(1219) << "Callback functions" << endl;
 	libhal_ctx_set_device_added(m_halContext, HALBackend::hal_device_added);
 	libhal_ctx_set_device_removed(m_halContext, HALBackend::hal_device_removed);
 	libhal_ctx_set_device_new_capability (m_halContext, NULL);
@@ -124,16 +119,24 @@
 	libhal_ctx_set_device_property_modified (m_halContext, HALBackend::hal_device_property_modified);
 	libhal_ctx_set_device_condition(m_halContext, HALBackend::hal_device_condition);
 
-	kdDebug() << "Context Init" << endl;
+	kdDebug(1219) << "Context Init" << endl;
 	if (!libhal_ctx_init(m_halContext, NULL))
 	{
-		kdDebug() << "Failed to init HAL context!" << endl;
+		kdDebug(1219) << "Failed to init HAL context!" << endl;
 		return false;
 	}
 #endif
 
+	/** @todo customize watch policy */
+	kdDebug(1219) << "Watch properties" << endl;
+	if (libhal_device_property_watch_all(m_halContext, NULL))
+	{
+		kdDebug(1219) << "Failed to watch HAL properties!" << endl;
+		return false;
+	}
+
 	/* libhal-storage initialization */
-	kdDebug() << "Storage Policy" << endl;
+	kdDebug(1219) << "Storage Policy" << endl;
 	m_halStoragePolicy = libhal_storage_policy_new();
 	/** @todo define libhal-storage icon policy */
 
@@ -144,7 +147,7 @@
 /* List devices (at startup)*/
 bool HALBackend::ListDevices()
 {
-	kdDebug() << "ListDevices" << endl;
+	kdDebug(1219) << "ListDevices" << endl;
 
 	int numDevices;
 	char** halDeviceList = libhal_get_all_devices(m_halContext, &numDevices, NULL);
@@ -152,7 +155,7 @@
 	if (!halDeviceList)
 		return false;
 
-	kdDebug() << "HALBackend::ListDevices : " << numDevices << " devices found" << endl;
+	kdDebug(1219) << "HALBackend::ListDevices : " << numDevices << " devices found" << endl;
 	for (int i = 0; i < numDevices; i++)
 		AddDevice(halDeviceList[i]);
 
@@ -243,7 +246,7 @@
 		return;
 
 	QString conditionName = QString(condition);
-	kdDebug() << "Processing device condition " << conditionName << " for " << udi << endl;
+	kdDebug(1219) << "Processing device condition " << conditionName << " for " << udi << endl;
 
 	/* TODO: Warn the user that (s)he should unmount devices before unplugging */
 	if (conditionName == "VolumeUnmountForced")
@@ -290,7 +293,7 @@
 
 void HALBackend::ResetProperties(const char* mediumUdi)
 {
-	kdDebug() << "HALBackend::setProperties" << endl;
+	kdDebug(1219) << "HALBackend::setProperties" << endl;
 
 	Medium* m = new Medium(mediumUdi, "");
 	if (libhal_device_query_capability(m_halContext, mediumUdi, "volume", NULL))
@@ -307,7 +310,7 @@
 
 void HALBackend::setVolumeProperties(Medium* medium)
 {
-	kdDebug() << "HALBackend::setVolumeProperties for " << medium->id() << endl;
+	kdDebug(1219) << "HALBackend::setVolumeProperties for " << medium->id() << endl;
 
 	const char* udi = medium->id().ascii();
 	/* Check if the device still exists */
@@ -417,10 +420,12 @@
 	}
 	medium->setMimeType(mimeType);
 
-	QString volume_name = QString::fromUtf8(libhal_volume_policy_compute_display_name(halDrive, halVolume, m_halStoragePolicy));
-	//QString drive_name =  QString::fromUtf8(libhal_drive_policy_compute_display_name(halDrive, halVolume, m_halStoragePolicy));
+	char* name = libhal_volume_policy_compute_display_name(halDrive, halVolume, m_halStoragePolicy);
+	//char* name = libhal_drive_policy_compute_display_name(halDrive, halVolume, m_halStoragePolicy);
+	QString volume_name = QString::fromUtf8(name);
 	QString media_name = volume_name;
 	medium->setLabel(media_name);
+	free(name);
 
 	libhal_drive_free(halDrive);
 	libhal_volume_free(halVolume);
@@ -429,7 +434,7 @@
 // Handle floppies and zip drives
 void HALBackend::setFloppyProperties(Medium* medium)
 {
-	kdDebug() << "HALBackend::setFloppyProperties for " << medium->id() << endl;
+	kdDebug(1219) << "HALBackend::setFloppyProperties for " << medium->id() << endl;
 
 	const char* udi = medium->id().ascii();
 	/* Check if the device still exists */
@@ -442,7 +447,7 @@
 	int numVolumes;
 	char** volumes = libhal_drive_find_all_volumes(m_halContext, halDrive, &numVolumes);
 	LibHalVolume* halVolume = NULL;
-	kdDebug() << " found " << numVolumes << " volumes" << endl;
+	kdDebug(1219) << " found " << numVolumes << " volumes" << endl;
 	if (numVolumes)
 		halVolume = libhal_volume_from_udi(m_halContext, volumes[0]);
 
@@ -487,23 +492,28 @@
 	QString media_name;
 	if (halVolume)
 	{
-		QString volume_name = QString::fromUtf8(libhal_drive_policy_compute_display_name(halDrive, halVolume, m_halStoragePolicy));
+		char* name = libhal_drive_policy_compute_display_name(halDrive, halVolume, m_halStoragePolicy);
+		QString volume_name = QString::fromUtf8(name);
 		media_name = volume_name;
+		free(name);
 	}
 	else
 	{
-		QString drive_name =  QString::fromUtf8(libhal_drive_policy_compute_display_name(halDrive, halVolume, m_halStoragePolicy));
+		char* name = libhal_drive_policy_compute_display_name(halDrive, halVolume, m_halStoragePolicy);
+		QString drive_name =  QString::fromUtf8(name);
 		media_name = drive_name;
+		free(name);
 	}
 	medium->setLabel(media_name);
 
+	free(volumes);
 	libhal_drive_free(halDrive);
 	libhal_volume_free(halVolume);
 }
 
 void HALBackend::setCameraProperties(Medium* medium)
 {
-	kdDebug() << "HALBackend::setCameraProperties for " << medium->id() << endl;
+	kdDebug(1219) << "HALBackend::setCameraProperties for " << medium->id() << endl;
 
 	const char* udi = medium->id().ascii();
 	/* Check if the device still exists */
@@ -533,7 +543,7 @@
 void HALBackend::hal_main_loop_integration(LibHalContext *ctx,
 			DBusConnection *dbus_connection)
 {
-	kdDebug() << "HALBackend::hal_main_loop_integration" << endl;
+	kdDebug(1219) << "HALBackend::hal_main_loop_integration" << endl;
 	Q_UNUSED(ctx);
 	s_HALBackend->MainLoopIntegration(dbus_connection);
 }
@@ -541,14 +551,14 @@
 
 void HALBackend::hal_device_added(LibHalContext *ctx, const char *udi)
 {
-	kdDebug() << "HALBackend::hal_device_added " << udi <<  endl;
+	kdDebug(1219) << "HALBackend::hal_device_added " << udi <<  endl;
 	Q_UNUSED(ctx);
 	s_HALBackend->AddDevice(udi);
 }
 
 void HALBackend::hal_device_removed(LibHalContext *ctx, const char *udi)
 {
-	kdDebug() << "HALBackend::hal_device_removed " << udi << endl;
+	kdDebug(1219) << "HALBackend::hal_device_removed " << udi << endl;
 	Q_UNUSED(ctx);
 	s_HALBackend->RemoveDevice(udi);
 }
@@ -556,7 +566,7 @@
 void HALBackend::hal_device_property_modified(LibHalContext *ctx, const char *udi,
 			const char *key, dbus_bool_t is_removed, dbus_bool_t is_added)
 {
-	kdDebug() << "HALBackend::hal_property_modified " << udi << " -- " << key << endl;
+	kdDebug(1219) << "HALBackend::hal_property_modified " << udi << " -- " << key << endl;
 	Q_UNUSED(ctx);
 	Q_UNUSED(is_removed);
 	Q_UNUSED(is_added);
@@ -572,7 +582,7 @@
 			#endif
 			)
 {
-	kdDebug() << "HALBackend::hal_device_condition " << udi << " -- " << condition_name << endl;
+	kdDebug(1219) << "HALBackend::hal_device_condition " << udi << " -- " << condition_name << endl;
 	Q_UNUSED(ctx);
 	Q_UNUSED(message);
 	s_HALBackend->DeviceCondition(udi, condition_name);
--- kdebase/kioslave/media/kdedmodule/halbackend.h	2005/03/27 13:24:33	400980
+++ kdebase/kioslave/media/kdedmodule/halbackend.h	2005/05/22 13:00:51	416751
@@ -198,12 +198,14 @@
 
 /* Hal call-backs -- from gvm*/
 public:
+#ifdef HAL_0_4
 	/** Invoked by libhal for integration with our mainloop.
 	*
 	*  @param  ctx                 LibHal context
 	*  @param  dbus_connection     D-BUS connection to integrate
 	*/
 	static void hal_main_loop_integration(LibHalContext *ctx, DBusConnection *dbus_connection);
+#endif
 
 	/** Invoked when a device is added to the Global Device List.
 	*

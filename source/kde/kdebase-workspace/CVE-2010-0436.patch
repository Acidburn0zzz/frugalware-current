From f7dd54043ddc3f9e07e4da6ad4a82e22edff53f6 Mon Sep 17 00:00:00 2001
From: Oswald Buddenhagen <ossi@kde.org>
Date: Mon, 1 Mar 2010 18:33:27 +0100
Subject: [PATCH] fix local root hole relating to command sockets

the user owns the socket directory. if he prevented its deletion (e.g.,
by creating another file in it), he would subsequently get the chance to
inject a symlink to an arbitrary file whose permissions kdm would
conveniently change to 0666.

chmod()ing a directory to the user opens a can of worms, as he might
do all kinds of nasty things with it which would prevent us from
reclaiming it.

so instead rely on the system's ability to honor file ownership and
permissions of the socket's inode instead of its parent directory.

for systems where we cannot rely on this behavior (solaris), we create a
new randomly named socket directory for each session and symlink it from
the proper name. if the user tries to mess with us, he will pollute the
top-level socket directory but cause no real harm.

discovered by Sebastian Krahmer from the SUSE security team.
---
 kdm/ConfigureChecks.cmake |   34 ++++++++++++++++++++++++++++++++++
 kdm/backend/ctrl.c        |   20 +++++++++-----------
 2 files changed, 43 insertions(+), 11 deletions(-)

diff --git a/kdm/ConfigureChecks.cmake b/kdm/ConfigureChecks.cmake
index 36544a2..5e35756 100644
--- a/kdm/ConfigureChecks.cmake
+++ b/kdm/ConfigureChecks.cmake
@@ -37,6 +37,40 @@ int main()
 }
 " HAVE_SETLOGIN)
 
+check_c_source_runs("
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+int main()
+{
+    int fd, fd2;
+    struct sockaddr_un sa;
+
+    if ((fd = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
+        return 2;
+    sa.sun_family = AF_UNIX;
+    strcpy(sa.sun_path, \"testsock\");
+    unlink(sa.sun_path);
+    if (bind(fd, (struct sockaddr *)&sa, sizeof(sa)))
+        return 2;
+    chmod(sa.sun_path, 0);
+    setuid(getuid() + 1000);
+    if ((fd2 = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
+        return 2;
+    connect(fd2, (struct sockaddr *)&sa, sizeof(sa));
+    return errno != EACCES;
+}
+" HONORS_SOCKET_PERMS)
+
+if (NOT HONORS_SOCKET_PERMS)
+	# This should affect only BSD < 4.4 and Solaris < 2.7.
+	message(FATAL_ERROR "System does not honor file permissions on UNIX domain sockets.")
+endif (NOT HONORS_SOCKET_PERMS)
+
 # for config-kdm.h
 check_function_exists(seteuid HAVE_SETEUID)
 
diff --git a/kdm/backend/ctrl.c b/kdm/backend/ctrl.c
index 155667c..12b8f79 100644
--- a/kdm/backend/ctrl.c
+++ b/kdm/backend/ctrl.c
@@ -112,22 +112,24 @@ openCtrl( struct display *d )
 				if (strlen( cr->path ) >= sizeof(sa.sun_path))
 					logError( "path %\"s too long; no control sockets will be available\n",
 					          cr->path );
-				else if (mkdir( sockdir, 0755 ) && errno != EEXIST)
+				else if (mkdir( sockdir, 0700 ) && errno != EEXIST)
 					logError( "mkdir %\"s failed; no control sockets will be available\n",
 					          sockdir );
+				else if (unlink( cr->path ) && errno != ENOENT)
+					logError( "unlink %\"s failed: %m; control socket will not be available\n",
+							cr->path );
 				else {
-					if (!d)
-						chown( sockdir, -1, fifoGroup );
-					chmod( sockdir, 0750 );
 					if ((cr->fd = socket( PF_UNIX, SOCK_STREAM, 0 )) < 0)
 						logError( "Cannot create control socket\n" );
 					else {
-						unlink( cr->path );
 						sa.sun_family = AF_UNIX;
 						strcpy( sa.sun_path, cr->path );
 						if (!bind( cr->fd, (struct sockaddr *)&sa, sizeof(sa) )) {
 							if (!listen( cr->fd, 5 )) {
-								chmod( cr->path, 0666 );
+								chmod( cr->path, 0660 );
+								if (!d)
+									chown( cr->path, -1, fifoGroup );
+								chmod( sockdir, 0755 );
 								registerCloseOnFork( cr->fd );
 								registerInput( cr->fd );
 								free( sockdir );
@@ -176,12 +178,8 @@ closeCtrl( struct display *d )
 void
 chownCtrl( CtrlRec *cr, int uid )
 {
-	if (cr->path) {
-		char *ptr = strrchr( cr->path, '/' );
-		*ptr = 0;
+	if (cr->path)
 		chown( cr->path, uid, -1 );
-		*ptr = '/';
-	}
 }
 
 void
-- 
1.6.5.3


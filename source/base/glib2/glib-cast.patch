Index: glib/gthread.c
===================================================================
--- glib/gthread.c.orig
+++ glib/gthread.c
@@ -200,7 +200,7 @@ g_once_impl (GOnce       *once,
 }
 
 gboolean
-g_once_init_enter_impl (volatile gsize *value_location)
+g_once_init_enter_impl (volatile gpointer *value_location)
 {
   gboolean need_init;
   g_mutex_lock (g_once_mutex);
@@ -220,8 +220,8 @@ g_once_init_enter_impl (volatile gsize *
 }
 
 void
-g_once_init_leave (volatile gsize *value_location,
-                   gsize           initialization_value)
+g_once_init_leave (volatile gpointer *value_location,
+                   gpointer           initialization_value)
 {
   g_return_if_fail (g_atomic_pointer_get (value_location) == 0);
   g_return_if_fail (initialization_value != 0);
Index: glib/gthread.h
===================================================================
--- glib/gthread.h.orig
+++ glib/gthread.h
@@ -324,13 +324,13 @@ gpointer g_once_impl (GOnce *once, GThre
 #endif /* G_ATOMIC_OP_MEMORY_BARRIER_NEEDED */
 
 /* initialize-once guards, keyed by value_location */
-G_INLINE_FUNC gboolean  g_once_init_enter       (volatile gsize *value_location);
-gboolean                g_once_init_enter_impl  (volatile gsize *value_location);
-void                    g_once_init_leave       (volatile gsize *value_location,
-                                                 gsize           initialization_value);
+G_INLINE_FUNC gboolean  g_once_init_enter       (volatile gpointer *value_location);
+gboolean                g_once_init_enter_impl  (volatile gpointer *value_location);
+void                    g_once_init_leave       (volatile gpointer *value_location,
+                                                 gpointer           initialization_value);
 #if defined (G_CAN_INLINE) || defined (__G_THREAD_C__)
 G_INLINE_FUNC gboolean
-g_once_init_enter (volatile gsize *value_location)
+g_once_init_enter (volatile gpointer *value_location)
 {
   if G_LIKELY (g_atomic_pointer_get (value_location) !=0)
     return FALSE;
Index: gobject/gtype.h
===================================================================
--- gobject/gtype.h.orig
+++ gobject/gtype.h
@@ -368,7 +368,7 @@ static void     type_name##_class_intern
 GType \
 type_name##_get_type (void) \
 { \
-  static volatile gsize g_define_type_id__volatile = 0; \
+  static volatile gpointer g_define_type_id__volatile = 0; \
   if (g_once_init_enter (&g_define_type_id__volatile))  \
     { \
       GType g_define_type_id = \
@@ -383,9 +383,9 @@ type_name##_get_type (void) \
 #define _G_DEFINE_TYPE_EXTENDED_END()	\
         /* following custom code */	\
       }					\
-      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id); \
+      g_once_init_leave (&g_define_type_id__volatile, (gpointer) g_define_type_id); \
     }					\
-  return g_define_type_id__volatile;	\
+  return (GType) g_define_type_id__volatile;	\
 } /* closes type_name##_get_type() */
 
 
Index: glib/garray.h
===================================================================
--- glib/garray.h.orig
+++ glib/garray.h
@@ -61,7 +61,7 @@ struct _GPtrArray
 #define g_array_append_val(a,v)	  g_array_append_vals (a, &(v), 1)
 #define g_array_prepend_val(a,v)  g_array_prepend_vals (a, &(v), 1)
 #define g_array_insert_val(a,i,v) g_array_insert_vals (a, i, &(v), 1)
-#define g_array_index(a,t,i)      (((t*) (a)->data) [(i)])
+#define g_array_index(a,t,i)      (((t*) ((void *) ((a)->data))) [(i)])
 
 GArray* g_array_new               (gboolean          zero_terminated,
 				   gboolean          clear_,

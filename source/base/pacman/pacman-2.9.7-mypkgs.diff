Date: 2005-09-18
Initial Package Version: 2.9.7
Upstream Status: http://bugs.archlinux.org/index.php?do=details&id=3223
Origin: Miklos Vajna <vmiklos@frugalware.org>
Description: Adds a -Qm option to list pkgs that weren't found in the sync dbs
 doc/pacman.8.in |    4 ++
 src/pacman.c    |   85 ++++++++++++++++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 86 insertions(+), 3 deletions(-)
diff -Naur pacman-2.9.7.orig/doc/pacman.8.in pacman-2.9.7/doc/pacman.8.in
--- pacman-2.9.7.orig/doc/pacman.8.in	2005-09-18 00:43:58.000000000 +0200
+++ pacman-2.9.7/doc/pacman.8.in	2005-09-18 02:11:51.000000000 +0200
@@ -182,6 +182,10 @@
 List all files owned by <package>.  Multiple packages can be specified on
 the command line.
 .TP
+.B "\-m, \-\-mypkgs"
+List all packages that were not found in the sync database(s). Probably
+you installed these packages by hand.
+.TP
 .B "\-o, \-\-owns <file>"
 Search for the package that owns <file>.
 .TP
diff -Naur pacman-2.9.7.orig/src/pacman.c pacman-2.9.7/src/pacman.c
--- pacman-2.9.7.orig/src/pacman.c	2005-09-18 00:43:58.000000000 +0200
+++ pacman-2.9.7/src/pacman.c	2005-09-18 02:12:11.000000000 +0200
@@ -71,6 +71,7 @@
 unsigned short pmo_q_isfile     = 0;
 unsigned short pmo_q_info       = 0;
 unsigned short pmo_q_list       = 0;
+unsigned short pmo_q_mypkgs       = 0;
 unsigned short pmo_q_orphans    = 0;
 unsigned short pmo_q_owns       = 0;
 unsigned short pmo_q_search     = 0;
@@ -2535,8 +2536,33 @@
 	char *package = NULL;
 	char path[PATH_MAX+1];
 	pkginfo_t *info = NULL;
-	PMList *targ, *lp, *q;
+	PMList *targ, *lp, *q, *databases;
 	int done = 0;
+	PMList *i, *j;
+	
+	if(pmo_q_mypkgs)
+	{
+		/* open sync db(s) */
+		PMList *dbp;
+		for(dbp = pmc_syncs; dbp; dbp = dbp->next) {
+			pacdb_t *db_sync = NULL;
+			dbsync_t *dbs = NULL;
+			sync_t *sync = (sync_t*)dbp->data;
+	
+			db_sync = db_open(pmo_root, pmo_dbpath, sync->treename);
+			if(db_sync == NULL) {
+				fprintf(stderr, "error: could not open sync database: %s\n", sync->treename);
+				fprintf(stderr, "       have you used --refresh yet?\n");
+				return(1);
+			}
+			MALLOC(dbs, sizeof(dbsync_t));
+			dbs->sync = sync;
+			dbs->db = db_sync;
+			/* cache packages */
+			dbs->pkgcache = db_loadpkgs(db_sync);
+			databases = list_add(databases, dbs);
+		}
+	}
 
 	if(pmo_q_search) {
 		db_search(db, pm_packages, "local", targets);
@@ -2643,7 +2669,7 @@
 			/* no target */
 			for(lp = pm_packages; lp; lp = lp->next) {
 				pkginfo_t *tmpp = (pkginfo_t*)lp->data;
-				if(pmo_q_list || pmo_q_orphans) {
+				if(pmo_q_list || pmo_q_orphans || pmo_q_mypkgs) {
 					info = db_scan(db, tmpp->name, INFRQ_ALL);
 					if(info == NULL) {
 						/* something weird happened */
@@ -2659,6 +2685,29 @@
 							printf("%s %s\n", tmpp->name, tmpp->version);
 						}
 					}
+					if(pmo_q_mypkgs) {
+						int match = 0;
+						for(i = databases; i; i = i->next) {
+							dbsync_t *dbs = (dbsync_t*)i->data;
+							for(j = dbs->pkgcache; j; j = j->next) {
+								pkginfo_t *pkg = (pkginfo_t*)j->data;
+								char *haystack;
+								char *needle;
+								haystack = strdup(pkg->name);
+								strtoupper(haystack);
+								needle = strdup(info->name);
+								strtoupper(needle);
+								if(strstr(haystack, needle)) {
+									match = 1;
+								}
+								FREE(haystack);
+								FREE(needle);
+							}
+						}
+						if(match==0) {
+							printf("%s %s\n", tmpp->name, tmpp->version);
+						}
+					}
 					FREEPKG(info);
 				} else {
 					printf("%s %s\n", tmpp->name, tmpp->version);
@@ -2748,6 +2797,33 @@
 				if(info->requiredby == NULL) {
 					printf("%s %s\n", info->name, info->version);
 				}
+			} else if(pmo_q_mypkgs) {
+				info = db_scan(db, package, INFRQ_DESC | INFRQ_DEPENDS);
+				if(info == NULL) {
+					fprintf(stderr, "Package \"%s\" was not found.\n", package);
+					return(2);
+				}
+				int match = 0;
+				for(i = databases; i; i = i->next) {
+					dbsync_t *dbs = (dbsync_t*)i->data;
+					for(j = dbs->pkgcache; j; j = j->next) {
+						pkginfo_t *pkg = (pkginfo_t*)j->data;
+						char *haystack;
+						char *needle;
+						haystack = strdup(pkg->name);
+						strtoupper(haystack);
+						needle = strdup(info->name);
+						strtoupper(needle);
+						if(strstr(haystack, needle)) {
+							match = 1;
+						}
+						FREE(haystack);
+						FREE(needle);
+					}
+				}
+				if(match==0) {
+					printf("%s %s\n", info->name, info->version);
+				}
 			} else {
 				info = db_scan(db, package, INFRQ_DESC);
 				if(info == NULL) {
@@ -3626,6 +3702,7 @@
 		{"dbonly",     no_argument,       0, 'k'},
 		{"list",       no_argument,       0, 'l'},
 		{"nosave",     no_argument,       0, 'n'},
+		{"mypkgs",     no_argument,       0, 'm'},
 		{"owns",       no_argument,       0, 'o'},
 		{"file",       no_argument,       0, 'p'},
 		{"print-uris", no_argument,       0, 'p'},
@@ -3642,7 +3719,7 @@
 		{0, 0, 0, 0}
 	};
 
-	while((opt = getopt_long(argc, argv, "ARUFQSTDYr:b:vkhscVfnoldepiuwyg", opts, &option_index))) {
+	while((opt = getopt_long(argc, argv, "ARUFQSTDYr:b:vkhscVfmnoldepiuwyg", opts, &option_index))) {
 		if(opt < 0) {
 			break;
 		}
@@ -3672,6 +3749,7 @@
 			case 'k': pmo_r_dbonly = 1; break;
 			case 'l': pmo_q_list = 1; break;
 			case 'n': pmo_nosave = 1; break;
+			case 'm': pmo_q_mypkgs = 1; break;
 			case 'p': pmo_q_isfile = 1; pmo_s_printuris = 1; break;
 			case 'o': pmo_q_owns = 1; break;
 			case 'r': if(realpath(optarg, pmo_root) == NULL) {
@@ -4012,6 +4090,7 @@
 			printf("  -g, --groups        view all members of a package group\n");
 			printf("  -i, --info          view package information (use -ii for more)\n");
 			printf("  -l, --list          list the contents of the queried package\n");
+			printf("  -m, --mypkgs        list all packages that were not found in the sync db(s)\n");
 			printf("  -o, --owns <file>   query the package that owns <file>\n");
 			printf("  -p, --file          pacman will query the package file [package] instead of\n");
 			printf("                      looking in the database\n");

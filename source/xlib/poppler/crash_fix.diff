diff --git a/poppler/Stream.cc b/poppler/Stream.cc
index 85d46bf..3e44e27 100644
--- a/poppler/Stream.cc
+++ b/poppler/Stream.cc
@@ -1261,14 +1261,18 @@ CCITTFaxStream::CCITTFaxStream(Stream *strA, int encodingA, GBool endOfLineA,
   // ---> max codingLine size = columns + 1
   // refLine has one extra guard entry at the end
   // ---> max refLine size = columns + 2
-  codingLine = (int *)gmallocn(columns + 1, sizeof(int));
-  refLine = (int *)gmallocn(columns + 2, sizeof(int));
+  codingLine = (int *)gmallocn_checkoverflow(columns + 1, sizeof(int));
+  refLine = (int *)gmallocn_checkoverflow(columns + 2, sizeof(int));
 
-  eof = gFalse;
+  if (codingLine != NULL && refLine != NULL) {
+    eof = gFalse;
+    codingLine[0] = columns;
+  } else {
+    eof = gTrue;
+  }
   row = 0;
   nextLine2D = encoding < 0;
   inputBits = 0;
-  codingLine[0] = columns;
   a0i = 0;
   outputBits = 0;
 
@@ -1285,11 +1289,16 @@ void CCITTFaxStream::reset() {
   short code1;
 
   str->reset();
-  eof = gFalse;
+
+  if (codingLine != NULL && refLine != NULL) {
+    eof = gFalse;
+    codingLine[0] = columns;
+  } else {
+    eof = gTrue;
+  }
   row = 0;
   nextLine2D = encoding < 0;
   inputBits = 0;
-  codingLine[0] = columns;
   a0i = 0;
   outputBits = 0;
   buf = EOF;
diff --git a/goo/gmem.cc b/goo/gmem.cc
index f1f8f5f..3dce8ea 100644
--- a/goo/gmem.cc
+++ b/goo/gmem.cc
@@ -172,6 +172,24 @@ void *gmallocn(int nObjs, int objSize) GMEM_EXCEP {
   return gmalloc(n);
 }
 
+void *gmallocn_checkoverflow(int nObjs, int objSize) GMEM_EXCEP {
+  int n;
+
+  if (nObjs == 0) {
+    return NULL;
+  }
+  n = nObjs * objSize;
+  if (objSize <= 0 || nObjs < 0 || nObjs >= INT_MAX / objSize) {
+#if USE_EXCEPTIONS
+    throw GMemException();
+#else
+    fprintf(stderr, "Bogus memory allocation size\n");
+    return NULL;
+#endif
+  }
+  return gmalloc(n);
+}
+
 void *greallocn(void *p, int nObjs, int objSize) GMEM_EXCEP {
   int n;
 
diff --git a/goo/gmem.h b/goo/gmem.h
index ebe1455..39c2334 100644
--- a/goo/gmem.h
+++ b/goo/gmem.h
@@ -49,8 +49,11 @@ extern void *grealloc(void *p, size_t size) GMEM_EXCEP;
  * and size.  The result is similar to allocating nObjs * objSize
  * bytes, but there is an additional error check that the total size
  * doesn't overflow an int.
+ * The gmallocn_checkoverflow variant returns NULL instead of exiting
+ * the application if a overflow is detected
  */
 extern void *gmallocn(int nObjs, int objSize) GMEM_EXCEP;
+extern void *gmallocn_checkoverflow(int nObjs, int objSize) GMEM_EXCEP;
 extern void *greallocn(void *p, int nObjs, int objSize) GMEM_EXCEP;
 
 /*

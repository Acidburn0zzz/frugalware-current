diff --git a/src/bin/e_bryce.c b/src/bin/e_bryce.c
index 2042e7ad6..00af04e3d 100644
--- a/src/bin/e_bryce.c
+++ b/src/bin/e_bryce.c
@@ -208,6 +208,7 @@ _bryce_autosize(Bryce *b)
         if (b->size_changed)
           elm_object_content_unset(b->scroller);
         _bryce_position(b, w, h, &x, &y);
+        evas_object_move(b->bryce, x, y);
         if (b->orient == E_GADGET_SITE_ORIENT_HORIZONTAL)
           e_efx_resize(b->bryce, E_EFX_EFFECT_SPEED_LINEAR, E_EFX_POINT(x, y), w, b->size * e_scale, 0.1, NULL, NULL);
         else if (b->orient == E_GADGET_SITE_ORIENT_VERTICAL)
@@ -261,6 +262,7 @@ _bryce_autosize(Bryce *b)
      w = MIN(MAX(lw + sw, b->size * e_scale), maxw), h = b->size * e_scale;
    else if (b->orient == E_GADGET_SITE_ORIENT_VERTICAL)
      w = b->size * e_scale, h = MIN(MAX(lh + sh, b->size * e_scale), maxh);
+   evas_object_move(b->bryce, x, y);
    e_efx_resize(b->bryce, E_EFX_EFFECT_SPEED_LINEAR, E_EFX_POINT(x, y), w, h, 0.1, NULL, NULL);
    b->size_changed = 0;
 }
diff --git a/src/bin/e_client.c b/src/bin/e_client.c
index b4d2c2576..5fdccebf3 100644
--- a/src/bin/e_client.c
+++ b/src/bin/e_client.c
@@ -445,8 +445,11 @@ _e_client_free(E_Client *ec)
         ec->pixmap = NULL;
      }
 
-   e_comp_object_redirected_set(ec->frame, 0);
-   e_comp_object_render_update_del(ec->frame);
+   if (ec->frame)
+     {
+        e_comp_object_redirected_set(ec->frame, 0);
+        e_comp_object_render_update_del(ec->frame);
+     }
 
    E_OBJECT(ec)->references++;
    if (ec->fullscreen)
@@ -778,6 +781,12 @@ _e_client_move_begin(E_Client *ec)
    if (!_e_client_action_input_win_new()) return 0;
    ec->moving = 1;
    ecmove = ec;
+   if (!ec->lock_user_stacking)
+     {
+        if (e_config->border_raise_on_mouse_action)
+          evas_object_raise(ec->frame);
+     }
+
    _e_client_hook_call(E_CLIENT_HOOK_MOVE_BEGIN, ec);
    if (!ec->moving)
      {
@@ -785,11 +794,7 @@ _e_client_move_begin(E_Client *ec)
         _e_client_action_input_win_del();
         return 0;
      }
-   if (!ec->lock_user_stacking)
-     {
-        if (e_config->border_raise_on_mouse_action)
-          evas_object_raise(ec->frame);
-     }
+   E_FREE_FUNC(ec->raise_timer, ecore_timer_del);
    return 1;
 }
 
@@ -916,6 +921,7 @@ _e_client_resize_handle(E_Client *ec)
    int tw, th;
    Eina_List *skiplist = NULL;
 
+   if (e_comp->updating) return;
    x = ec->x;
    y = ec->y;
    w = ec->w;
@@ -1415,7 +1421,7 @@ _e_client_cb_evas_move(void *data, Evas *e EINA_UNUSED, Evas_Object *obj EINA_UN
 
    _e_client_event_simple(ec, E_EVENT_CLIENT_MOVE);
 
-   _e_client_zone_update(ec);
+   if (!e_client_util_ignored_get(ec)) _e_client_zone_update(ec);
    evas_object_geometry_get(ec->frame, &x, &y, NULL, NULL);
    if ((e_config->transient.move) && (ec->transients))
      {
@@ -1447,7 +1453,7 @@ _e_client_cb_evas_resize(void *data, Evas *e EINA_UNUSED, Evas_Object *obj EINA_
 
    _e_client_event_simple(ec, E_EVENT_CLIENT_RESIZE);
 
-   _e_client_zone_update(ec);
+   if (!e_client_util_ignored_get(ec)) _e_client_zone_update(ec);
    evas_object_geometry_get(ec->frame, &x, &y, &w, &h);
    if ((e_config->transient.resize) && (ec->transients))
      {
@@ -2804,6 +2810,7 @@ e_client_mouse_move(E_Client *ec, Evas_Point *output)
 {
    EINA_SAFETY_ON_NULL_RETURN(ec);
    if (ec->iconic || e_client_util_ignored_get(ec)) return;
+   if ((ec->mouse.current.mx == output->x) && (ec->mouse.current.my == output->y)) return;
    ec->mouse.current.mx = output->x;
    ec->mouse.current.my = output->y;
    if (ec->moving)
@@ -3969,9 +3976,11 @@ e_client_unmaximize(E_Client *ec, E_Maximize max)
                   vert = EINA_TRUE;
                   if ((unmax & E_MAXIMIZE_VERTICAL) == E_MAXIMIZE_VERTICAL)
                     {
+                       if ((ec->maximized & E_MAXIMIZE_LEFT) == E_MAXIMIZE_LEFT)
+                         ec->maximized &= ~E_MAXIMIZE_LEFT;
+                       if ((ec->maximized & E_MAXIMIZE_RIGHT) == E_MAXIMIZE_RIGHT)
+                         ec->maximized &= ~E_MAXIMIZE_RIGHT;
                        ec->maximized &= ~E_MAXIMIZE_VERTICAL;
-                       ec->maximized &= ~E_MAXIMIZE_LEFT;
-                       ec->maximized &= ~E_MAXIMIZE_RIGHT;
                     }
                   if ((unmax & E_MAXIMIZE_LEFT) == E_MAXIMIZE_LEFT)
                     ec->maximized &= ~E_MAXIMIZE_LEFT;
@@ -4776,6 +4785,11 @@ e_client_resize_begin(E_Client *ec)
        (ec->fullscreen) || (ec->lock_user_size))
      goto error;
    if (!_e_client_action_input_win_new()) goto error;
+   if (!ec->lock_user_stacking)
+     {
+        if (e_config->border_raise_on_mouse_action)
+          evas_object_raise(ec->frame);
+     }
    ecresize = ec;
    _e_client_hook_call(E_CLIENT_HOOK_RESIZE_BEGIN, ec);
    if (!e_client_util_resizing_get(ec))
@@ -4784,11 +4798,7 @@ e_client_resize_begin(E_Client *ec)
         _e_client_action_input_win_del();
         return EINA_FALSE;
      }
-   if (!ec->lock_user_stacking)
-     {
-        if (e_config->border_raise_on_mouse_action)
-          evas_object_raise(ec->frame);
-     }
+   E_FREE_FUNC(ec->raise_timer, ecore_timer_del);
    return EINA_TRUE;
 error:
    ec->resize_mode = E_POINTER_RESIZE_NONE;
diff --git a/src/bin/e_comp.c b/src/bin/e_comp.c
index a94858f1a..85dd68782 100644
--- a/src/bin/e_comp.c
+++ b/src/bin/e_comp.c
@@ -311,16 +311,19 @@ _e_comp_client_update(E_Client *ec)
           {
              e_pixmap_image_clear(ec->pixmap, 0);
              e_comp_object_render_update_del(ec->frame); //clear update
+             if (ec->changes.visible && (!evas_object_visible_get(ec->frame)))
+               evas_object_show(ec->frame);
           }
         else if (!e_pixmap_size_get(ec->pixmap, NULL, NULL))
           {
              WRN("FAIL %p", ec);
              e_comp_object_redirected_set(ec->frame, 0);
-             if (e_pixmap_failures_get(ec->pixmap) < 3)
+             if (e_pixmap_failures_get(ec->pixmap) > 3)
                e_comp_object_render_update_add(ec->frame);
           }
      }
-   if ((!e_comp->saver) && e_pixmap_size_get(ec->pixmap, &pw, &ph))
+   if (!(e_comp->saver && ecore_evas_manual_render_get(e_comp->ee)) &&
+       e_pixmap_size_get(ec->pixmap, &pw, &ph))
      {
         //INF("PX DIRTY: PX(%dx%d) CLI(%dx%d)", pw, ph, ec->client.w, ec->client.h);
         e_pixmap_image_refresh(ec->pixmap);
@@ -375,6 +378,7 @@ _e_comp_cb_update(void)
         if (e_comp->grab_cb) e_comp->grab_cb();
         e_comp->grabbed = 1;
      }
+   e_comp->updating = 1;
    l = e_comp->updates;
    e_comp->updates = NULL;
    EINA_LIST_FREE(l, ec)
@@ -383,6 +387,7 @@ _e_comp_cb_update(void)
         e_comp_object_render_update_del(ec->frame);
         _e_comp_client_update(ec);
      }
+   e_comp->updating = 0;
    _e_comp_fps_update();
    if (conf->fps_show)
      {
@@ -549,7 +554,7 @@ _e_comp_shape_debug_rect(Eina_Rectangle *rect, E_Color *color)
      evas_object_color_set(o, 0, (color->g += COLOR_INCREMENT), 0, 255);
    else
      evas_object_color_set(o, 0, 0, (color->b += COLOR_INCREMENT), 255);
-   evas_object_repeat_events_set(o, 1);
+   evas_object_pass_events_set(o, 1);
    evas_object_layer_set(o, E_LAYER_MENU - 1);
    evas_object_move(o, rect->x, rect->y);
    evas_object_resize(o, rect->w, rect->h);
@@ -1007,7 +1012,6 @@ EINTERN Eina_Bool
 e_comp_init(void)
 {
    _e_comp_log_dom = eina_log_domain_register("e_comp", EINA_COLOR_YELLOW);
-   eina_log_domain_level_set("e_comp", EINA_LOG_LEVEL_INFO);
 
    ecore_frametime = ecore_animator_frametime_get();
    shape_debug = !!getenv("E_SHAPE_DEBUG");
diff --git a/src/bin/e_comp.h b/src/bin/e_comp.h
index 04865820c..6859a9cd2 100644
--- a/src/bin/e_comp.h
+++ b/src/bin/e_comp.h
@@ -161,6 +161,7 @@ struct _E_Comp
    Eina_Bool       shape_queue_blocked : 1; //x11 input shape updates are blocked
 
    Eina_Bool       rendering : 1; // we've received a pre-render callback but no post-render yet.
+   Eina_Bool       updating : 1; // running client updates
 };
 
 
diff --git a/src/bin/e_comp_canvas.c b/src/bin/e_comp_canvas.c
index 0289b4295..9bdd57f71 100644
--- a/src/bin/e_comp_canvas.c
+++ b/src/bin/e_comp_canvas.c
@@ -244,6 +244,7 @@ _e_comp_cb_screensaver_on()
               (e_config->desklock_post_screensaver_time,
               _e_comp_cb_timer_post_screensaver_lock, NULL);
      }
+   e_pointers_freeze_set(1);
    return ECORE_CALLBACK_PASS_ON;
 }
 
@@ -252,6 +253,7 @@ _e_comp_cb_screensaver_off()
 {
    E_FREE_FUNC(timer_post_screensaver_lock, ecore_timer_del);
    E_FREE_FUNC(timer_post_screensaver_on, ecore_timer_del);
+   e_pointers_freeze_set(0);
    return ECORE_CALLBACK_PASS_ON;
 }
 ////////////////////////////////////
@@ -634,6 +636,7 @@ e_comp_canvas_update(void)
           }
         e_comp_canvas_zone_update(zone);
      }
+   evas_object_resize(e_comp->bg_blank_object, e_comp->w, e_comp->h);
 }
 
 E_API void
diff --git a/src/bin/e_comp_object.c b/src/bin/e_comp_object.c
index df2a87839..299943772 100644
--- a/src/bin/e_comp_object.c
+++ b/src/bin/e_comp_object.c
@@ -48,8 +48,8 @@
 /* enable along with display-specific damage INF calls to enable render tracing
  * SLOW!
  */
-static Eina_Bool render_debug_enabled;
-#define RENDER_DEBUG(...) do { if (render_debug_enabled) INF(__VA_ARGS__); } while (0)
+static int render_debug_enabled;
+#define RENDER_DEBUG(...) do { if ((render_debug_enabled == 1) || ((render_debug_enabled == -1) && cw->ec->focused)) INF(__VA_ARGS__); } while (0)
 
 typedef struct _E_Comp_Object
 {
@@ -925,6 +925,19 @@ _e_comp_object_mirror_pixels_get(void *data, Evas_Object *obj)
         return;
      }
 
+   /* This is a big fat hack - ideally we're already on this list
+    * if the parent is visible, but there are some circumstances
+    * where a client receives damage while visible but its own pixels_get
+    * callback doesn't fire (new damage during the start frame of a desk
+    * switch animation).
+    * Thus we can't make this addition conditional on visibility or we can
+    * (under wayland at least) lose a frame callback and stop updating.
+    *
+    * e_comp_client_post_update_add() prevents clients from being
+    * on the list twice, so this is theoretically not harmful.
+    */
+   e_comp_client_post_update_add(ec);
+
    if (cw->native) return;
 
    evas_object_image_data_set(obj, e_pixmap_image_data_get(cw->ec->pixmap));
@@ -1133,6 +1146,8 @@ _e_comp_intercept_resize(void *data, Evas_Object *obj, int w, int h)
    E_Comp_Object *cw = data;
    int pw = 0, ph = 0, fw, fh, iw, ih, prev_w, prev_h, x, y;
 
+
+   if ((w < 1) || (h < 1)) return;
    /* if frame_object does not exist, client_inset indicates CSD.
     * this means that ec->client matches cw->w/h, the opposite
     * of SSD.
@@ -1232,13 +1247,23 @@ _e_comp_intercept_resize(void *data, Evas_Object *obj, int w, int h)
           {
              /* client can't be resized if its pixmap isn't usable, try again */
              e_pixmap_dirty(cw->ec->pixmap);
-             e_comp_object_render_update_add(obj);
-             e_comp_render_queue();
+             if (e_comp->nocomp)
+               e_pixmap_refresh(cw->ec->pixmap);
+             else
+               {
+                  e_comp_object_render_update_add(obj);
+                  e_comp_render_queue();
+               }
           }
         cw->ec->changes.size = 1;
         EC_CHANGED(cw->ec);
         return;
      }
+   if (e_pixmap_failures_get(cw->ec->pixmap) && (!cw->redirected))
+     {
+        e_comp_object_redirected_set(obj, 1);
+        return;
+     }
    prev_w = cw->w, prev_h = cw->h;
    e_comp_object_frame_wh_adjust(obj, 0, 0, &fw, &fh);
    /* check shading and clamp to pixmap size for regular clients */
@@ -1307,7 +1332,6 @@ _e_comp_intercept_resize(void *data, Evas_Object *obj, int w, int h)
        e_win_centered_get(cw->ec->internal_elm_win))
      {
         e_comp_object_util_center(obj);
-        elm_win_center(cw->ec->internal_elm_win, 0, 0);
      }
    cw->force_move = 0;
 }
@@ -1692,9 +1716,6 @@ _e_comp_intercept_show_helper(E_Comp_Object *cw)
         evas_object_show(cw->smart_obj);
         return;
      }
-   /* re-set geometry */
-   if (cw->ec->placed)
-     evas_object_move(cw->smart_obj, cw->ec->x, cw->ec->y);
    /* ensure that some kind of frame calc has occurred if there's a frame */
    if (e_pixmap_is_x(cw->ec->pixmap) && cw->frame_object &&
        (cw->ec->h == cw->ec->client.h) && (cw->ec->w == cw->ec->client.w))
@@ -1708,6 +1729,10 @@ _e_comp_intercept_show_helper(E_Comp_Object *cw)
         EC_CHANGED(cw->ec);
         return;
      }
+   /* re-set geometry */
+   if (cw->ec->placed)
+     evas_object_move(cw->smart_obj, cw->ec->x, cw->ec->y);
+
    /* if pixmap not available, clear pixmap since we're going to fetch it again */
    if (!e_pixmap_size_get(cw->ec->pixmap, &w, &h))
      e_pixmap_clear(cw->ec->pixmap);
@@ -2309,9 +2334,7 @@ _e_comp_smart_hide(Evas_Object *obj)
 {
    INTERNAL_ENTRY;
    cw->visible = 0;
-   cw->deleted = e_object_is_del(E_OBJECT(cw->ec));
-   if (cw->deleted)
-     _e_comp_object_layers_remove(cw);
+   cw->deleted |= cw->ec->delete_requested || e_object_is_del(E_OBJECT(cw->ec));
    evas_object_hide(cw->clip);
    if (cw->input_obj) evas_object_hide(cw->input_obj);
    evas_object_hide(cw->effect_obj);
@@ -2386,6 +2409,15 @@ _e_comp_smart_show(Evas_Object *obj)
      }
 }
 
+static void
+_e_comp_object_client_del(void *d, void *obj EINA_UNUSED)
+{
+   E_Comp_Object *cw = d;
+   cw->deleted = 1;
+   e_comp_object_render_update_del(cw->smart_obj);
+   _e_comp_object_layers_remove(cw);
+}
+
 static void
 _e_comp_smart_del(Evas_Object *obj)
 {
@@ -2394,8 +2426,6 @@ _e_comp_smart_del(Evas_Object *obj)
 
    INTERNAL_ENTRY;
 
-   if (!cw->deleted)
-     e_comp_object_render_update_del(cw->smart_obj);
    E_FREE_FUNC(cw->updates, eina_tiler_free);
    E_FREE_FUNC(cw->pending_updates, eina_tiler_free);
    free(cw->ns);
@@ -2549,9 +2579,14 @@ _e_comp_smart_resize(Evas_Object *obj, int w, int h)
 static void
 _e_comp_smart_init(void)
 {
+   const char *env;
    if (_e_comp_smart) return;
 
-   render_debug_enabled = !!getenv("E_RENDER_DEBUG");
+   env = getenv("E_RENDER_DEBUG");
+   if (eina_streq(env, "focus"))
+     render_debug_enabled = -1;
+   else if (env)
+     render_debug_enabled = 1;
    {
       static const Evas_Smart_Class sc =
       {
@@ -2951,6 +2986,7 @@ e_comp_object_client_add(E_Client *ec)
    cw->ec = ec;
    ec->frame = o;
    evas_object_data_set(o, "comp_object", (void*)1);
+   e_object_delfn_add(E_OBJECT(ec), _e_comp_object_client_del, cw);
 
    _e_comp_object_event_add(o);
 
@@ -3252,7 +3288,8 @@ E_API Eina_Bool
 e_comp_object_frame_allowed(Evas_Object *obj)
 {
    API_ENTRY EINA_FALSE;
-   return (!cw->ec->mwm.borderless) && (cw->frame_object || (!cw->client_inset.calc));
+   return (!e_client_util_ignored_get(cw->ec)) && (!cw->ec->mwm.borderless) &&
+     (cw->frame_object || (!cw->client_inset.calc));
 }
 
 E_API void
@@ -3580,7 +3617,7 @@ E_API Eina_Bool
 e_comp_object_damage_exists(Evas_Object *obj)
 {
    API_ENTRY EINA_FALSE;
-   return cw->updates_exist;
+   return cw->updates_exist || cw->updates_full;
 }
 
 E_API void
@@ -3880,17 +3917,32 @@ e_comp_object_dirty(Evas_Object *obj)
         return;
      }
    e_comp_object_native_surface_set(obj, 1);
-   it = eina_tiler_iterator_new(cw->updates);
-   EINA_ITERATOR_FOREACH(it, rect)
+   if (cw->updates_full)
      {
-        RENDER_DEBUG("UPDATE ADD [%p]: %d %d %dx%d", cw->ec, rect->x, rect->y, rect->w, rect->h);
-        evas_object_image_data_update_add(cw->obj, rect->x, rect->y, rect->w, rect->h);
+        Eina_Rectangle r = {0};
+
+        eina_tiler_area_size_get(cw->updates, &r.w, &r.h);
+        RENDER_DEBUG("UPDATE ADD [%p]: %d %d %dx%d", cw->ec, r.x, r.y, r.w, r.h);
+        evas_object_image_data_update_add(cw->obj, r.x, r.y, r.w, r.h);
         EINA_LIST_FOREACH(cw->obj_mirror, ll, o)
-          evas_object_image_data_update_add(o, rect->x, rect->y, rect->w, rect->h);
+          evas_object_image_data_update_add(o, r.x, r.y, r.w, r.h);
         if (cw->pending_updates)
-          eina_tiler_rect_add(cw->pending_updates, rect);
+          eina_tiler_rect_add(cw->pending_updates, &r);
+     }
+   else
+     {
+        it = eina_tiler_iterator_new(cw->updates);
+        EINA_ITERATOR_FOREACH(it, rect)
+          {
+             RENDER_DEBUG("UPDATE ADD [%p]: %d %d %dx%d", cw->ec, rect->x, rect->y, rect->w, rect->h);
+             evas_object_image_data_update_add(cw->obj, rect->x, rect->y, rect->w, rect->h);
+             EINA_LIST_FOREACH(cw->obj_mirror, ll, o)
+               evas_object_image_data_update_add(o, rect->x, rect->y, rect->w, rect->h);
+             if (cw->pending_updates)
+               eina_tiler_rect_add(cw->pending_updates, rect);
+          }
+        eina_iterator_free(it);
      }
-   eina_iterator_free(it);
    if (cw->pending_updates)
      eina_tiler_clear(cw->updates);
    else
diff --git a/src/bin/e_comp_wl.c b/src/bin/e_comp_wl.c
index 8d6cc9463..e82884769 100644
--- a/src/bin/e_comp_wl.c
+++ b/src/bin/e_comp_wl.c
@@ -439,9 +439,9 @@ _e_comp_wl_evas_cb_mouse_wheel(void *data, Evas *evas EINA_UNUSED, Evas_Object *
      axis = WL_POINTER_AXIS_HORIZONTAL_SCROLL;
 
    if (ev->z < 0)
-     dir = -wl_fixed_from_int(abs(ev->z));
+     dir = -wl_fixed_from_int(abs(10 * ev->z));
    else
-     dir = wl_fixed_from_int(ev->z);
+     dir = wl_fixed_from_int(10 * ev->z);
 
    if (!ec->comp_data->surface) return;
 
@@ -941,7 +941,7 @@ _e_comp_wl_evas_cb_delete_request(void *data, Evas_Object *obj EINA_UNUSED, void
    if (!e_client_has_xwindow(ec))
      {
         if (ec->internal_elm_win)
-          E_FREE_FUNC(ec->internal_elm_win, evas_object_del);
+          evas_object_del(ec->internal_elm_win);
         else
           e_object_del(E_OBJECT(ec));
      }
@@ -1101,12 +1101,23 @@ _e_comp_wl_client_evas_init(E_Client *ec)
 static Eina_Bool
 _e_comp_wl_cb_randr_change(void *data EINA_UNUSED, int type EINA_UNUSED, void *event EINA_UNUSED)
 {
-   Eina_List *l;
+   const Eina_List *l;
    E_Randr2_Screen *screen;
    unsigned int transform = WL_OUTPUT_TRANSFORM_NORMAL;
 
    if (!e_randr2) return ECORE_CALLBACK_RENEW;
 
+   if (e_xinerama_fake_screens_exist())
+     {
+        E_Screen *scr;
+        EINA_LIST_FOREACH(e_xinerama_screens_get(), l, scr)
+          {
+             e_comp_wl_output_init(NULL, NULL, NULL,
+               scr->x, scr->y, scr->w, scr->h,
+               0, 0, 0, 0, 0, scr->escreen);
+          }
+        return ECORE_CALLBACK_RENEW;
+     }
    EINA_LIST_FOREACH(e_randr2->screens, l, screen)
      {
         if (!screen->config.enabled)
@@ -1137,7 +1148,7 @@ _e_comp_wl_cb_randr_change(void *data EINA_UNUSED, int type EINA_UNUSED, void *e
                                    screen->config.geom.x, screen->config.geom.y,
                                    screen->config.geom.w, screen->config.geom.h,
                                    screen->info.size.w, screen->info.size.h,
-                                   screen->config.mode.refresh, 0, transform))
+                                   screen->config.mode.refresh, 0, transform, 0))
           ERR("Could not initialize screen %s", screen->info.name);
      }
 
@@ -1171,8 +1182,8 @@ _e_comp_wl_cb_mouse_move(void *d EINA_UNUSED, int t EINA_UNUSED, Ecore_Event_Mou
 {
    _last_event_time = ecore_loop_time_get();
 
-   e_comp_wl->ptr.x = wl_fixed_from_int(ev->x);
-   e_comp_wl->ptr.y = wl_fixed_from_int(ev->y);
+   e_comp_wl->ptr.x = ev->x;
+   e_comp_wl->ptr.y = ev->y;
    e_screensaver_notidle();
    if (e_comp_wl->selection.target &&
        (!e_client_has_xwindow(e_comp_wl->selection.target)) &&
@@ -2442,6 +2453,7 @@ _e_comp_wl_client_cb_del(void *data EINA_UNUSED, E_Client *ec)
         ec->parent->lock_close = EINA_FALSE;
         ec->parent->modal = NULL;
      }
+   if (e_comp_wl->selection.target == ec) e_comp_wl->selection.target = NULL;
 
    if ((ec == e_client_focused_get()) && ec->visible) _e_comp_wl_keyboard_leave(ec);
 
@@ -2525,11 +2537,17 @@ _e_comp_wl_client_cb_focus_unset(void *data EINA_UNUSED, E_Client *ec)
      e_comp_wl->kbd.focus = NULL;
 }
 
+static void
+_e_comp_wl_client_cb_move_begin(void *data EINA_UNUSED, E_Client *ec EINA_UNUSED)
+{
+   e_comp_wl->ptr.button_mask = 0;
+}
+
 static void
 _e_comp_wl_client_cb_resize_begin(void *data EINA_UNUSED, E_Client *ec)
 {
+   e_comp_wl->ptr.button_mask = 0;
    if (e_client_has_xwindow(ec)) return;
-
    e_comp_wl->resize.edges = 0;
    if (ec->keyboard_resizing) return;
    switch (ec->resize_mode)
@@ -2862,6 +2880,8 @@ e_comp_wl_init(void)
    e_client_hook_add(E_CLIENT_HOOK_FOCUS_UNSET,
                      _e_comp_wl_client_cb_focus_unset, NULL);
 
+   e_client_hook_add(E_CLIENT_HOOK_MOVE_BEGIN,
+                     _e_comp_wl_client_cb_move_begin, NULL);
    e_client_hook_add(E_CLIENT_HOOK_RESIZE_BEGIN,
                      _e_comp_wl_client_cb_resize_begin, NULL);
    e_client_hook_add(E_CLIENT_HOOK_RESIZE_END,
@@ -3092,7 +3112,7 @@ E_API Eina_Bool
 e_comp_wl_output_init(const char *id, const char *make, const char *model,
                       int x, int y, int w, int h, int pw, int ph,
                       unsigned int refresh, unsigned int subpixel,
-                      unsigned int transform)
+                      unsigned int transform, unsigned int num)
 {
    E_Comp_Wl_Output *output;
    Eina_List *l2;
@@ -3103,7 +3123,10 @@ e_comp_wl_output_init(const char *id, const char *make, const char *model,
    output = _e_comp_wl_output_get(e_comp_wl->outputs, id);
    if (!output)
      {
-        zone = e_zone_for_id_get(id);
+        if (e_xinerama_fake_screens_exist())
+          zone = e_comp_zone_number_get(num);
+        else
+          zone = e_zone_for_id_get(id);
         if (!zone) return EINA_FALSE;
         if (!(output = E_NEW(E_Comp_Wl_Output, 1))) return EINA_FALSE;
 
diff --git a/src/bin/e_comp_wl.h b/src/bin/e_comp_wl.h
index 52165d684..b81b4f3c7 100644
--- a/src/bin/e_comp_wl.h
+++ b/src/bin/e_comp_wl.h
@@ -220,7 +220,7 @@ struct _E_Comp_Wl_Data
      {
         void *source;
         struct wl_listener listener;
-        E_Client *xwl_owner;
+        Ecore_Window xwl_owner;
      } clipboard;
 
    struct
@@ -359,7 +359,7 @@ E_API E_Comp_Wl_Buffer *e_comp_wl_buffer_get(struct wl_resource *resource);
 
 E_API struct wl_signal e_comp_wl_surface_create_signal_get(void);
 E_API double e_comp_wl_idle_time_get(void);
-E_API Eina_Bool e_comp_wl_output_init(const char *id, const char *make, const char *model, int x, int y, int w, int h, int pw, int ph, unsigned int refresh, unsigned int subpixel, unsigned int transform);
+E_API Eina_Bool e_comp_wl_output_init(const char *id, const char *make, const char *model, int x, int y, int w, int h, int pw, int ph, unsigned int refresh, unsigned int subpixel, unsigned int transform, unsigned int num);
 E_API void e_comp_wl_output_remove(const char *id);
 
 EINTERN Eina_Bool e_comp_wl_key_down(Ecore_Event_Key *ev);
diff --git a/src/bin/e_comp_wl_data.c b/src/bin/e_comp_wl_data.c
index fb160f7ad..48cab4ab1 100644
--- a/src/bin/e_comp_wl_data.c
+++ b/src/bin/e_comp_wl_data.c
@@ -501,7 +501,7 @@ _e_comp_wl_data_device_selection_set(void *data EINA_UNUSED, E_Comp_Wl_Data_Sour
      }
 
    e_comp_wl->selection.data_source = sel_source = source;
-   e_comp_wl->clipboard.xwl_owner = NULL;
+   e_comp_wl->clipboard.xwl_owner = 0;
    source->serial = e_comp_wl->selection.serial = serial;
 
    if (e_comp_wl->kbd.enabled)
@@ -765,16 +765,19 @@ static void
 _e_comp_wl_data_cb_bind_manager(struct wl_client *client, void *data EINA_UNUSED, uint32_t version EINA_UNUSED, uint32_t id)
 {
    struct wl_resource *res;
+   pid_t pid;
 
    /* try to create data manager resource */
-   e_comp_wl->mgr.resource = res =
-       wl_resource_create(client, &wl_data_device_manager_interface, 3, id);
+   res = wl_resource_create(client, &wl_data_device_manager_interface, 3, id);
    if (!res)
      {
         ERR("Could not create data device manager");
         wl_client_post_no_memory(client);
         return;
      }
+   wl_client_get_credentials(client, &pid, NULL, NULL);
+   if (pid == getpid())
+     e_comp_wl->mgr.resource = res;
 
    wl_resource_set_implementation(res, &_e_manager_interface,
                                   e_comp->wl_comp_data, NULL);
@@ -940,15 +943,6 @@ _e_comp_wl_clipboard_create(void)
    wl_signal_add(&e_comp_wl->selection.signal, &e_comp_wl->clipboard.listener);
 }
 
-static void
-_e_comp_wl_data_device_target_del(void *data, Evas *e EINA_UNUSED, Evas_Object *obj EINA_UNUSED, void *event_info EINA_UNUSED)
-{
-   E_Client *ec = data;
-
-   if (e_comp_wl->selection.target == ec)
-     e_comp_wl->selection.target = NULL;
-}
-
 E_API void
 e_comp_wl_data_device_send_enter(E_Client *ec)
 {
@@ -968,6 +962,11 @@ e_comp_wl_data_device_send_enter(E_Client *ec)
         if (!data_device_res) return;
         offer_res = e_comp_wl_data_device_send_offer(ec);
         if (e_comp_wl->drag_source && (!offer_res)) return;
+        if (e_client_has_xwindow(e_comp_wl->drag_client))
+          {
+             drag_source->offer->dnd_actions = drag_source->dnd_actions;
+             drag_source->offer->preferred_dnd_action = drag_source->current_dnd_action;
+          }
         data_offer_update_action(drag_source->offer);
         if (offer_res)
           {
@@ -976,8 +975,6 @@ e_comp_wl_data_device_send_enter(E_Client *ec)
           }
      }
    e_comp_wl->selection.target = ec;
-   evas_object_event_callback_add(ec->frame, EVAS_CALLBACK_DEL,
-                                  _e_comp_wl_data_device_target_del, ec);
 
 #ifndef HAVE_WAYLAND_ONLY
    if (e_client_has_xwindow(ec))
@@ -1036,8 +1033,6 @@ e_comp_wl_data_device_send_leave(E_Client *ec)
        e_client_has_xwindow(e_comp_wl->drag_client))
      return;
    if (e_comp_wl->drag && (e_comp_wl->drag->object == ec->frame)) return;
-   evas_object_event_callback_del_full(ec->frame, EVAS_CALLBACK_DEL,
-                                       _e_comp_wl_data_device_target_del, ec);
    if (e_comp_wl->selection.target == ec)
      e_comp_wl->selection.target = NULL;
 #ifndef HAVE_WAYLAND_ONLY
@@ -1093,6 +1088,7 @@ e_comp_wl_data_device_keyboard_focus_set(void)
 {
    struct wl_resource *data_device_res, *offer_res = NULL, *focus;
    E_Comp_Wl_Data_Source *source;
+   E_Client *focused;
 
    if (!e_comp_wl->kbd.enabled)
      {
@@ -1105,6 +1101,7 @@ e_comp_wl_data_device_keyboard_focus_set(void)
         ERR("No focused resource");
         return;
      }
+   focused = wl_resource_get_user_data(focus);
    source = (E_Comp_Wl_Data_Source *)e_comp_wl->selection.data_source;
 
 #ifndef HAVE_WAYLAND_ONLY
@@ -1113,10 +1110,10 @@ e_comp_wl_data_device_keyboard_focus_set(void)
         if (!e_comp_util_has_xwayland()) break;
         if (e_comp_wl->clipboard.xwl_owner)
           {
-             if (e_client_has_xwindow(e_client_focused_get())) return;
+             if (e_client_has_xwindow(focused)) return;
              break;
           }
-        else if (source && e_client_has_xwindow(e_client_focused_get()))
+        else if (source && e_client_has_xwindow(focused))
           {
              /* wl -> x11 */
              ecore_x_selection_owner_set(e_comp->cm_selection,
diff --git a/src/bin/e_comp_wl_input.c b/src/bin/e_comp_wl_input.c
index d8281c0dd..3cbb605c7 100644
--- a/src/bin/e_comp_wl_input.c
+++ b/src/bin/e_comp_wl_input.c
@@ -450,7 +450,7 @@ e_comp_wl_input_init(void)
 {
    /* set default seat name */
    if (!e_comp_wl->seat.name)
-     e_comp_wl->seat.name = "default";
+     e_comp_wl->seat.name = "seat0";
 
    e_comp_wl->xkb.fd = -1;
 
@@ -661,8 +661,13 @@ _e_comp_wl_input_context_keymap_set(struct xkb_keymap *keymap, struct xkb_contex
         dev = ecore_evas_data_get(e_comp->ee, "device");
         if (dev)
           {
-             ecore_drm2_device_keyboard_cached_context_set(dev, context);
-             ecore_drm2_device_keyboard_cached_keymap_set(dev, keymap);
+#ifndef EFL_VERSION_1_20
+             if (!E_EFL_VERSION_MINIMUM(1, 19, 99))
+               {
+                  ecore_drm2_device_keyboard_cached_context_set(dev, context);
+                  ecore_drm2_device_keyboard_cached_keymap_set(dev, keymap);
+               }
+#endif
           }
      }
 # else
diff --git a/src/bin/e_comp_x.c b/src/bin/e_comp_x.c
index 3b67fe260..7f1f2afa8 100644
--- a/src/bin/e_comp_x.c
+++ b/src/bin/e_comp_x.c
@@ -120,7 +120,7 @@ _e_comp_x_focus_check(void)
    focused = e_client_focused_get();
    /* if there is no new focused or it is a non-X client,
     * focus comp canvas on focus-out */
-   if ((!focused) || (e_pixmap_type_get(focused->pixmap) != E_PIXMAP_TYPE_X))
+   if ((!focused) || (!e_client_has_xwindow(focused)))
      {
         focus_canvas_time = ecore_x_current_time_get();
         focus_time = 0;
@@ -3920,15 +3920,19 @@ _e_comp_x_hook_client_fetch(void *d EINA_UNUSED, E_Client *ec)
      {
         unsigned int val;
 
-        if (ecore_x_window_prop_card32_get(win, ECORE_X_ATOM_NET_WM_WINDOW_OPACITY, &val, 1) > 0)
+        if (ecore_x_netwm_opacity_get(win, &val))
           {
-             val = (val >> 24);
              if (ec->netwm.opacity != val)
                {
                   ec->netwm.opacity = val;
+                  evas_object_color_set(ec->frame,
+                    ec->netwm.opacity, ec->netwm.opacity, ec->netwm.opacity, ec->netwm.opacity);
                   rem_change = 1;
                }
+             ec->netwm.fetch.opacity = !ec->netwm.opacity;
           }
+        else
+          ec->netwm.fetch.opacity = 0;
      }
    if (ec->netwm.fetch.icon)
      {
@@ -4633,6 +4637,7 @@ _e_comp_x_hook_client_focus_unset(void *d EINA_UNUSED, E_Client *ec)
         focus_job_client = NULL;
         E_FREE_FUNC(focus_job, ecore_job_del);
      }
+   if (ec->override) return;
    unfocus_job_client = ec;
    if (!unfocus_job)
      unfocus_job = ecore_job_add(_e_comp_x_hook_client_focus_unset_job, NULL);
@@ -4677,6 +4682,7 @@ _e_comp_x_hook_client_focus_set(void *d EINA_UNUSED, E_Client *ec)
         unfocus_job_client = NULL;
         E_FREE_FUNC(unfocus_job, ecore_job_del);
      }
+   if (ec->override) return;
    focus_job_client = ec;
    if (!focus_job)
      focus_job = ecore_job_add(_e_comp_x_hook_client_focus_set_job, NULL);
@@ -5485,7 +5491,10 @@ _e_comp_x_setup(Ecore_X_Window root, int w, int h)
         if (!e_comp_canvas_init(w, h)) return EINA_FALSE;
      }
 
-   e_grabinput_focus(e_comp->ee_win, E_FOCUS_METHOD_PASSIVE);
+   if (e_comp->comp_type == E_PIXMAP_TYPE_X)
+     e_grabinput_focus(e_comp->ee_win, E_FOCUS_METHOD_PASSIVE);
+   else
+     e_grabinput_focus(e_comp->root, E_FOCUS_METHOD_PASSIVE);
 
    /* init layers */
    for (i = e_comp_canvas_layer_map(E_LAYER_CLIENT_DESKTOP); i <= e_comp_canvas_layer_map(E_LAYER_CLIENT_PRIO); i++)
diff --git a/src/bin/e_comp_x_randr.c b/src/bin/e_comp_x_randr.c
index 20ab4e54b..a539a6e3f 100644
--- a/src/bin/e_comp_x_randr.c
+++ b/src/bin/e_comp_x_randr.c
@@ -104,6 +104,8 @@ _is_lid_name(const char *name)
    else if (strstr(name, "eDP"))  return EINA_TRUE;
    else if (strstr(name, "edp"))  return EINA_TRUE;
    else if (strstr(name, "EDP"))  return EINA_TRUE;
+   else if (strstr(name, "DSI"))  return EINA_TRUE;
+   else if (strstr(name, "dsi"))  return EINA_TRUE;
    return EINA_FALSE;
 }
 
diff --git a/src/bin/e_fm.c b/src/bin/e_fm.c
index 43ac2cdf3..03d0cee56 100644
--- a/src/bin/e_fm.c
+++ b/src/bin/e_fm.c
@@ -7061,7 +7061,7 @@ _e_fm2_cb_dnd_selection_notify(void *data, const char *type, void *event)
                     }
                }
           }
-        else
+        else if (sd->realpath)
           {
              if (_e_fm2_view_mode_get(sd) == E_FM2_VIEW_MODE_LIST && sd->order_file) /* list */
                {
diff --git a/src/bin/e_gadget.c b/src/bin/e_gadget.c
index 7935b5fc1..2aa1e410c 100644
--- a/src/bin/e_gadget.c
+++ b/src/bin/e_gadget.c
@@ -275,6 +275,15 @@ _gadget_object_free(E_Object *eobj)
    if (zgc->id == -1) _gadget_free(zgc);
 }
 
+static void
+_gadget_remove(E_Gadget_Config *zgc)
+{
+   evas_object_smart_callback_call(zgc->site->layout, "gadget_removed", zgc->gadget);
+   zgc->site->gadget_list = eina_inlist_remove(zgc->site->gadget_list, EINA_INLIST_GET(zgc));
+   zgc->site->gadgets = eina_list_remove(zgc->site->gadgets, zgc);
+   _gadget_free(zgc);
+}
+
 static void
 _gadget_wizard_end(void *data, int id)
 {
@@ -282,7 +291,10 @@ _gadget_wizard_end(void *data, int id)
 
    zgc->id = id;
    evas_object_smart_callback_call(zgc->site->layout, "gadget_site_unlocked", NULL);
-   _gadget_object_finalize(zgc);
+   if (id)
+     _gadget_object_finalize(zgc);
+   else
+     _gadget_remove(zgc);
 }
 
 static Eina_Bool
@@ -322,7 +334,7 @@ _gadget_object_create(E_Gadget_Config *zgc)
 
    if (!zgc->site->orient)
      evas_object_smart_need_recalculate_set(zgc->site->layout, 1);
-   evas_object_event_callback_priority_add(g, EVAS_CALLBACK_DEL, EVAS_CALLBACK_PRIORITY_BEFORE, _gadget_del, zgc);
+   evas_object_event_callback_priority_add(g, EVAS_CALLBACK_DEL, EVAS_CALLBACK_PRIORITY_AFTER, _gadget_del, zgc);
    _gadget_reparent(zgc->site, zgc);
    elm_object_tree_focus_allow_set(zgc->gadget, 0);
    evas_object_raise(zgc->site->events);
@@ -386,16 +398,16 @@ _site_gadget_resize(Evas_Object *g, int w, int h, Evas_Coord *ww, Evas_Coord *hh
         switch (aspect)
           {
            case EVAS_ASPECT_CONTROL_HORIZONTAL:
-             *hh = (*ww * ay / ax);
+             *hh = (*ww * (double)ay / ax);
              break;
            case EVAS_ASPECT_CONTROL_VERTICAL:
-             *ww = (*hh * ax / ay);
+             *ww = (*hh * (double)ax / ay);
              break;
            default:
              if (IS_HORIZ(zgc->site->orient))
-               *ww = (*hh * ax / ay);
+               *ww = (*hh * (double)ax / ay);
              else if (IS_VERT(zgc->site->orient))
-               *hh = (*ww * ay / ax);
+               *hh = (*ww * (double)ay / ax);
              else if (aspect)
                {
                   double ar = ax / (double) ay;
@@ -408,9 +420,9 @@ _site_gadget_resize(Evas_Object *g, int w, int h, Evas_Coord *ww, Evas_Coord *hh
                          *ww = *hh;
                     }
                   else if (ar > 1.0)
-                    *hh = (*ww * ay / ax);
+                    *hh = (*ww * (double)ay / ax);
                   else
-                    *ww = (*hh * ax / ay);
+                    *ww = (*hh * (double)ax / ay);
                }
           }
      }
@@ -540,6 +552,7 @@ _site_layout(Evas_Object *o, Evas_Object_Box_Data *priv EINA_UNUSED, void *data)
    E_Gadget_Config *zgc;
 
    evas_object_geometry_get(o, &x, &y, &w, &h);
+   if ((!w) || (!h)) return;
    evas_object_geometry_set(zgs->events, x, y, w, h);
 
    evas_object_box_align_get(o, &ax, &ay);
@@ -631,11 +644,17 @@ _gadget_mouse_resize(E_Gadget_Config *zgc, int t EINA_UNUSED, Ecore_Event_Mouse_
    gw = zgc->w * w;
    gh = zgc->h * h;
    if (zgc->resizing & E_GADGET_SITE_ANCHOR_LEFT)
-     gw -= (ev->x - zgc->down.x);
+     {
+        gw -= (ev->x - zgc->down.x);
+        zgc->x = ev->x / (double)w;
+     }
    else
      gw += (ev->x - zgc->down.x);
    if (zgc->resizing & E_GADGET_SITE_ANCHOR_TOP)
-     gh -= (ev->y - zgc->down.y);
+     {
+        gh -= (ev->y - zgc->down.y);
+        zgc->y = ev->y / (double)h;
+     }
    else
      gh += (ev->y - zgc->down.y);
    zgc->w = gw / w;
@@ -777,15 +796,6 @@ _gadget_act_configure(E_Object *obj, const char *params EINA_UNUSED, E_Binding_E
    return EINA_TRUE;
 }
 
-static void
-_gadget_remove(E_Gadget_Config *zgc)
-{
-   evas_object_smart_callback_call(zgc->site->layout, "gadget_removed", zgc->gadget);
-   zgc->site->gadget_list = eina_inlist_remove(zgc->site->gadget_list, EINA_INLIST_GET(zgc));
-   zgc->site->gadgets = eina_list_remove(zgc->site->gadgets, zgc);
-   _gadget_free(zgc);
-}
-
 static void
 _gadget_menu_remove(void *data, E_Menu *m EINA_UNUSED, E_Menu_Item *mi EINA_UNUSED)
 {
@@ -1141,17 +1151,17 @@ _site_del(void *data, Evas *e EINA_UNUSED, Evas_Object *obj EINA_UNUSED, void *e
 {
    E_Gadget_Site *zgs = data;
    E_Gadget_Config *zgc;
-   Eina_List *l;
+   Eina_List *l, *ll;
 
    E_FREE_FUNC(zgs->events, evas_object_del);
+   E_FREE_FUNC(zgs->move_handler, ecore_event_handler_del);
+   E_FREE_FUNC(zgs->mouse_up_handler, ecore_event_handler_del);
+   EINA_LIST_FOREACH_SAFE(zgs->gadgets, l, ll, zgc)
+     evas_object_del(zgc->display);
    zgs->layout = NULL;
    zgs->cur_size = 0;
    zgs->action = NULL;
    zgs->style_cb = NULL;
-   E_FREE_FUNC(zgs->move_handler, ecore_event_handler_del);
-   E_FREE_FUNC(zgs->mouse_up_handler, ecore_event_handler_del);
-   EINA_LIST_FOREACH(zgs->gadgets, l, zgc)
-     evas_object_del(zgc->display);
    if (zgs->name) return;
    eina_stringshare_del(zgs->name);
    free(zgs);
@@ -1223,13 +1233,26 @@ _site_create(E_Gadget_Site *zgs)
    evas_object_raise(zgs->events);
 }
 
+static void
+_site_auto_add_comp_object_del(void *data, Evas *e EINA_UNUSED, Evas_Object *obj EINA_UNUSED, void *event_info EINA_UNUSED)
+{
+   E_Gadget_Site *zgs = data;
+   Eina_List *l, *ll;
+   E_Gadget_Config *zgc;
+
+   /* prune unconfigured gadgets */
+   EINA_LIST_FOREACH_SAFE(zgs->gadgets, l, ll, zgc)
+     if (zgc->id <= 0) _gadget_remove(zgc);
+   evas_object_del(zgs->layout);
+}
+
 static void
 _site_auto_add(E_Gadget_Site *zgs, Evas_Object *comp_object)
 {
    int x, y, w, h;
 
    _site_create(zgs);
-   e_comp_object_util_del_list_append(comp_object, zgs->layout);
+   evas_object_event_callback_add(comp_object, EVAS_CALLBACK_DEL, _site_auto_add_comp_object_del, zgs);
    evas_object_layer_set(zgs->layout, evas_object_layer_get(comp_object));
    evas_object_stack_above(zgs->layout, comp_object);
    evas_object_geometry_get(comp_object, &x, &y, &w, &h);
@@ -1508,12 +1531,13 @@ e_gadget_util_layout_style_init(Evas_Object *g, Evas_Object *style)
    EINA_SAFETY_ON_NULL_RETURN_VAL(zgc, NULL);
 
    prev = zgc->style.obj;
+   if ((!prev) && (!style)) return NULL;
    zgc->style.obj = style;
    if (style)
      {
         elm_layout_file_get(style, NULL, &grp);
         eina_stringshare_replace(&zgc->style.name, strrchr(grp, '/') + 1);
-        evas_object_event_callback_priority_add(style, EVAS_CALLBACK_DEL, EVAS_CALLBACK_PRIORITY_BEFORE, _gadget_del, zgc);
+        evas_object_event_callback_priority_add(style, EVAS_CALLBACK_DEL, EVAS_CALLBACK_PRIORITY_AFTER, _gadget_del, zgc);
      }
    else
      eina_stringshare_replace(&zgc->style.name, NULL);
diff --git a/src/bin/e_main.c b/src/bin/e_main.c
index ceab4bd8e..25acd837d 100644
--- a/src/bin/e_main.c
+++ b/src/bin/e_main.c
@@ -327,22 +327,6 @@ main(int argc, char **argv)
    e_util_env_set("DESKTOP", "Enlightenment");
    TS("Environment Variables Done");
 
-   /* KDE5 applications don't understand anything other then gnome or kde     */
-   /* They expect everyone else to set QT_QPA_PLATFORMTHEME to tell them how  */
-   /* to theme there apps otherwise they use a fallback mode which results in */
-   /* missing icons and a inability to change the appearance of applications  */
-   /* see https://bugzilla.suse.com/show_bug.cgi?id=920792 for more info.     */
-   /* There are two sensible defaults for this variable, "kde" which will     */
-   /* make apps appear the same as they do if they are run in kde. and gtk2   */
-   /* which will make kde applications follow the gtk/gnome theme, we have    */
-   /* decided on choosing gtk2 as it means that kde/qt apps will follow the   */
-   /* app and icon theme set in the enlightenment settings dialog. Some users */
-   /* who wish to use Qt apps without any gnome or gtk usage may choose to    */
-   /* install qt5ct and overwrite this variable with qt5ct and use that to    */
-   /* configure there Qt5 applications.                                       */
-   e_util_env_set("QT_QPA_PLATFORMTHEME", "gtk2");
-   e_util_env_set("QT_STYLE_OVERRIDE", "gtk2");
-
    TS("Parse Arguments");
    _e_main_parse_arguments(argc, argv);
    TS("Parse Arguments Done");
@@ -566,6 +550,26 @@ main(int argc, char **argv)
    TS("E_Config Init Done");
    _e_main_shutdown_push(e_config_shutdown);
 
+   if (e_config->xsettings.match_e17_theme)
+     {
+
+        /* KDE5 applications don't understand anything other then gnome or kde     */
+        /* They expect everyone else to set QT_QPA_PLATFORMTHEME to tell them how  */
+        /* to theme there apps otherwise they use a fallback mode which results in */
+        /* missing icons and a inability to change the appearance of applications  */
+        /* see https://bugzilla.suse.com/show_bug.cgi?id=920792 for more info.     */
+        /* There are two sensible defaults for this variable, "kde" which will     */
+        /* make apps appear the same as they do if they are run in kde. and gtk2   */
+        /* which will make kde applications follow the gtk/gnome theme, we have    */
+        /* decided on choosing gtk2 as it means that kde/qt apps will follow the   */
+        /* app and icon theme set in the enlightenment settings dialog. Some users */
+        /* who wish to use Qt apps without any gnome or gtk usage may choose to    */
+        /* install qt5ct and overwrite this variable with qt5ct and use that to    */
+        /* configure there Qt5 applications.                                       */
+        e_util_env_set("QT_QPA_PLATFORMTHEME", "gtk2");
+        e_util_env_set("QT_STYLE_OVERRIDE", "gtk2");
+     }
+
    TS("E_Env Init");
    if (!e_env_init())
      {
@@ -1521,6 +1525,14 @@ _e_main_test_formats(void)
    Evas_Object *im, *txt;
    Evas_Coord tw, th;
    char buff[PATH_MAX];
+   char *types[] =
+   {
+      "svg",
+      "jpg",
+      "png",
+      "edj"
+   };
+   unsigned int i, t_edj = 3;
 
    if (e_config->show_splash)
      e_init_status_set(_("Testing Format Support"));
@@ -1534,45 +1546,32 @@ _e_main_test_formats(void)
    evas = ecore_evas_get(ee);
    im = evas_object_image_add(evas);
 
-   e_prefix_data_concat_static(buff, "data/images/test.svg");
-   evas_object_image_file_set(im, buff, NULL);
-   if (evas_object_image_load_error_get(im) != EVAS_LOAD_ERROR_NONE)
+   for (i = 0; i < EINA_C_ARRAY_LENGTH(types); i++)
      {
-        e_error_message_show(_("Enlightenment found Evas can't load SVG files. "
-                               "Check Evas has SVG loader support.\n"));
-     }
-   else
-     efreet_icon_extension_add(".svg");
+        char b[128], *t = types[i];
 
-   e_prefix_data_concat_static(buff, "data/images/test.jpg");
-   evas_object_image_file_set(im, buff, NULL);
-   if (evas_object_image_load_error_get(im) != EVAS_LOAD_ERROR_NONE)
-     {
-        e_error_message_show(_("Enlightenment found Evas can't load JPEG files. "
-                               "Check Evas has JPEG loader support.\n"));
-        _e_main_shutdown(-1);
-     }
-   efreet_icon_extension_add(".jpg");
-
-   e_prefix_data_concat_static(buff, "data/images/test.png");
-   evas_object_image_file_set(im, buff, NULL);
-   if (evas_object_image_load_error_get(im) != EVAS_LOAD_ERROR_NONE)
-     {
-        e_error_message_show(_("Enlightenment found Evas can't load PNG files. "
-                               "Check Evas has PNG loader support.\n"));
-        _e_main_shutdown(-1);
-     }
-   efreet_icon_extension_add(".png");
-
-   e_prefix_data_concat_static(buff, "data/images/test.edj");
-   evas_object_image_file_set(im, buff, "images/0");
-   if (evas_object_image_load_error_get(im) != EVAS_LOAD_ERROR_NONE)
-     {
-        e_error_message_show(_("Enlightenment found Evas can't load EET files. "
-                               "Check Evas has EET loader support.\n"));
-        _e_main_shutdown(-1);
+        snprintf(b, sizeof(b), "data/images/test.%s", types[i]);
+        e_prefix_data_concat_static(buff, b);
+        evas_object_image_file_set(im, buff, NULL);
+        if (i == t_edj) t = "eet";
+        switch (evas_object_image_load_error_get(im))
+          {
+           default:
+             e_error_message_show(_("Enlightenment found Evas can't load '%s' files. "
+                                    "Check Evas has '%s' loader support.\n"), t, t);
+             if (i) _e_main_shutdown(-1);
+             break;
+           case EVAS_LOAD_ERROR_CORRUPT_FILE:
+           case EVAS_LOAD_ERROR_DOES_NOT_EXIST:
+           case EVAS_LOAD_ERROR_PERMISSION_DENIED:
+             e_error_message_show(_("Enlightenment cannot access test image for '%s' filetype. "
+                                    "Check your install for setup issues.\n"), t);
+           case EVAS_LOAD_ERROR_NONE:
+             snprintf(b, sizeof(b), ".%s", types[i]);
+             efreet_icon_extension_add(b);
+             break;
+          }
      }
-   efreet_icon_extension_add(".edj");
 
    evas_object_del(im);
 
diff --git a/src/bin/e_pixmap.c b/src/bin/e_pixmap.c
index 2849e598d..e22ec6221 100644
--- a/src/bin/e_pixmap.c
+++ b/src/bin/e_pixmap.c
@@ -46,7 +46,6 @@ struct _E_Pixmap
 
 #ifdef HAVE_WAYLAND
    E_Comp_Wl_Buffer *buffer;
-   E_Comp_Wl_Buffer *native_buffer;
    E_Comp_Wl_Buffer *held_buffer;
    struct wl_listener buffer_destroy_listener;
    struct wl_listener held_buffer_destroy_listener;
@@ -704,6 +703,17 @@ e_pixmap_native_surface_init(E_Pixmap *cp, Evas_Native_Surface *ns)
    EINA_SAFETY_ON_NULL_RETURN_VAL(cp, EINA_FALSE);
    EINA_SAFETY_ON_NULL_RETURN_VAL(ns, EINA_FALSE);
 
+   /* This structure is stack automatic in the caller, so it's all
+    * uninitialized. Clear it to 0 so we don't have uninit data for
+    * variables only present in a newer version of native surface
+    * than this code was written for.
+    *
+    * The other option would be to set ns->version to whatever version
+    * this code was actually written against, but I've been told all
+    * native surface users are expected to set ns->version to the
+    * version provided in the headers (EVAS_NATIVE_SURFACE_VERSION)
+    */
+   memset(ns, 0, sizeof(*ns));
    ns->version = EVAS_NATIVE_SURFACE_VERSION;
    switch (cp->type)
      {
@@ -721,17 +731,14 @@ e_pixmap_native_surface_init(E_Pixmap *cp, Evas_Native_Surface *ns)
         if (cp->buffer->dmabuf_buffer)
           {
              ns->type = EVAS_NATIVE_SURFACE_WL_DMABUF;
-             ns->version = EVAS_NATIVE_SURFACE_VERSION;
 
              ns->data.wl_dmabuf.attr = &cp->buffer->dmabuf_buffer->attributes;
              ns->data.wl_dmabuf.resource = cp->buffer->resource;
-             cp->native_buffer = cp->buffer;
              ret = EINA_TRUE;
           }
         else if (!cp->buffer->shm_buffer)
           {
              ns->type = EVAS_NATIVE_SURFACE_WL;
-             ns->version = EVAS_NATIVE_SURFACE_VERSION;
              ns->data.wl.legacy_buffer = cp->buffer->resource;
              ret = EINA_TRUE;
           }
@@ -1059,23 +1066,24 @@ e_pixmap_dmabuf_test(struct linux_dmabuf_buffer *dmabuf)
 {
    Evas_Native_Surface ns;
    Evas_Object *test;
+   Eina_Bool ret;
    int size;
    void *data;
 
-   if (e_comp->gl)
-     {
-        Eina_Bool ret;
-        ns.type = EVAS_NATIVE_SURFACE_WL_DMABUF;
-        ns.version = EVAS_NATIVE_SURFACE_VERSION;
-        ns.data.wl_dmabuf.attr = &dmabuf->attributes;
-        ns.data.wl_dmabuf.resource = NULL;
-        test = evas_object_image_add(e_comp->evas);
-        evas_object_image_native_surface_set(test, &ns);
-        ret = evas_object_image_load_error_get(test) == EVAS_LOAD_ERROR_NONE;
-        evas_object_del(test);
-        if (!ns.data.wl_dmabuf.attr) return EINA_FALSE;
-        return ret;
-     }
+   memset(&ns, 0, sizeof(ns));
+
+   ns.type = EVAS_NATIVE_SURFACE_WL_DMABUF;
+   ns.version = EVAS_NATIVE_SURFACE_VERSION;
+   ns.data.wl_dmabuf.attr = &dmabuf->attributes;
+   ns.data.wl_dmabuf.resource = NULL;
+   test = evas_object_image_add(e_comp->evas);
+   evas_object_image_native_surface_set(test, &ns);
+   ret = evas_object_image_load_error_get(test) == EVAS_LOAD_ERROR_NONE;
+   evas_object_del(test);
+   if (!ns.data.wl_dmabuf.attr) return EINA_FALSE;
+
+   if (e_comp->gl || !ret)
+      return ret;
 
    /* TODO: Software rendering for multi-plane formats */
    if (dmabuf->attributes.n_planes != 1) return EINA_FALSE;
@@ -1084,7 +1092,7 @@ e_pixmap_dmabuf_test(struct linux_dmabuf_buffer *dmabuf)
 
    /* This is only legit for ARGB8888 */
    size = dmabuf->attributes.height * dmabuf->attributes.stride[0];
-   data = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, dmabuf->attributes.fd[0], 0);
+   data = mmap(NULL, size, PROT_READ, MAP_SHARED, dmabuf->attributes.fd[0], 0);
    if (data == MAP_FAILED) return EINA_FALSE;
    munmap(data, size);
 
diff --git a/src/bin/e_pointer.c b/src/bin/e_pointer.c
index 07b1761fa..dbf9b1123 100644
--- a/src/bin/e_pointer.c
+++ b/src/bin/e_pointer.c
@@ -780,7 +780,10 @@ e_pointer_object_set(E_Pointer *ptr, Evas_Object *obj, int x, int y)
           }
         ec = e_comp_object_client_get(o);
         if (ec)
-          ec->hidden = 1;
+          {
+             ec->hidden = 1;
+             evas_object_hide(ec->frame);
+          }
      }
 
    if (obj)
@@ -807,3 +810,18 @@ e_pointer_window_add(E_Pointer *ptr, Ecore_Window win)
    _e_pointer_theme_buf(ptr, buf);
    _e_pointer_x11_setup(ptr, buf);
 }
+
+EINTERN void
+e_pointers_freeze_set(Eina_Bool set)
+{
+   Eina_List *l;
+   E_Pointer *ptr;
+
+   EINA_LIST_FOREACH(_ptrs, l, ptr)
+     {
+        if (isedje(ptr->o_ptr))
+          edje_object_play_set(ptr->o_ptr, !set);
+        if (isedje(ptr->buffer_o_ptr))
+          edje_object_play_set(ptr->buffer_o_ptr, !set);
+     }
+}
diff --git a/src/bin/e_pointer.h b/src/bin/e_pointer.h
index 91185a6c4..df74d882d 100644
--- a/src/bin/e_pointer.h
+++ b/src/bin/e_pointer.h
@@ -60,6 +60,7 @@ struct _E_Pointer
 
 EINTERN int e_pointer_init(void);
 EINTERN int e_pointer_shutdown(void);
+EINTERN void e_pointers_freeze_set(Eina_Bool set);
 
 E_API E_Pointer *e_pointer_window_new(Ecore_Window win, Eina_Bool filled);
 E_API E_Pointer *e_pointer_canvas_new(Ecore_Evas *ee, Eina_Bool filled);
diff --git a/src/bin/e_sys.c b/src/bin/e_sys.c
index 72e926087..cbc24f345 100644
--- a/src/bin/e_sys.c
+++ b/src/bin/e_sys.c
@@ -762,7 +762,7 @@ _e_sys_logout_after(void)
 static void
 _e_sys_logout_begin(E_Sys_Action a_after, Eina_Bool raw)
 {
-   const Eina_List *l;
+   const Eina_List *l, *ll;
    E_Client *ec;
    E_Obj_Dialog *od;
 
@@ -783,7 +783,7 @@ _e_sys_logout_begin(E_Sys_Action a_after, Eina_Bool raw)
      }
    _e_sys_action_after = a_after;
    _e_sys_action_after_raw = raw;
-   EINA_LIST_FOREACH(e_comp->clients, l, ec)
+   EINA_LIST_FOREACH_SAFE(e_comp->clients, l, ll, ec)
      {
         e_client_act_close_begin(ec);
      }
diff --git a/src/bin/e_utils.c b/src/bin/e_utils.c
index a48622464..ae46aa068 100644
--- a/src/bin/e_utils.c
+++ b/src/bin/e_utils.c
@@ -1056,7 +1056,7 @@ _e_util_size_debug(void *data EINA_UNUSED, Evas *e EINA_UNUSED, Evas_Object *obj
 
    evas_object_geometry_get(obj, &x, &y, &w, &h);
    name = evas_object_name_get(obj);
-   fprintf(stderr, "%s %d OBJ[%s%s%p]: (%d,%d) - %dx%d\n", evas_object_visible_get(obj) ? "VIS" : "HID", evas_object_layer_get(obj), name ?: "", name ? "|" : "", obj, x, y, w, h);
+   fprintf(stderr, "%s %d OBJ[%s%s%p]: (%d,%d) - %dx%d\n", evas_object_visible_get(obj) ? "VIS" : "HID", evas_object_layer_get(obj), name ?: evas_object_type_get(obj), "|", obj, x, y, w, h);
 }
 
 E_API void
diff --git a/src/bin/e_widget_entry.c b/src/bin/e_widget_entry.c
index 9426830be..46cd4c7c9 100644
--- a/src/bin/e_widget_entry.c
+++ b/src/bin/e_widget_entry.c
@@ -6,6 +6,7 @@ struct _E_Widget_Data
    Evas_Object *o_entry, *o_inout;
    char       **text_location;
    void         (*func)(void *data, void *data2);
+   char        *text;
    void        *data;
    void        *data2;
 };
@@ -81,7 +82,16 @@ e_widget_entry_add(Evas_Object *parent, char **text_location, void (*func)(void
 
    o = wd->o_entry;
    if ((text_location) && (*text_location))
-     elm_object_text_set(o, *text_location);
+     {
+        char *tmp = elm_entry_utf8_to_markup(*text_location);
+
+        if (tmp)
+          {
+             elm_object_text_set(o, tmp);
+             free(tmp);
+          }
+        else elm_object_text_set(wd->o_entry, NULL);
+     }
 
    wd->func = func;
    wd->data = data;
@@ -101,10 +111,17 @@ E_API void
 e_widget_entry_text_set(Evas_Object *entry, const char *text)
 {
    E_Widget_Data *wd;
+   char *tmp;
 
    if (!(entry) || (!(wd = e_widget_data_get(entry))))
      return;
-   elm_object_text_set(wd->o_entry, text);
+   tmp = elm_entry_utf8_to_markup(text);
+   if (tmp)
+     {
+        elm_object_text_set(wd->o_entry, tmp);
+        free(tmp);
+     }
+   else elm_object_text_set(wd->o_entry, NULL);
 }
 
 /**
@@ -117,10 +134,20 @@ E_API const char *
 e_widget_entry_text_get(Evas_Object *entry)
 {
    E_Widget_Data *wd;
+   char *tmp;
 
    if (!(entry) || (!(wd = e_widget_data_get(entry))))
      return NULL;
-   return elm_object_text_get(wd->o_entry);
+   tmp = elm_entry_markup_to_utf8(elm_object_text_get(wd->o_entry));
+   if (tmp)
+     {
+        if (wd->text) free(wd->text);
+        wd->text = tmp;
+        return wd->text;
+     }
+   if (wd->text) free(wd->text);
+   wd->text = NULL;
+   return NULL;
 }
 
 /**
@@ -197,10 +224,12 @@ _e_wid_del_hook(Evas_Object *obj)
 
    if (!(obj) || (!(wd = e_widget_data_get(obj))))
      return;
+   if (wd->text) free(wd->text);
    evas_object_del(wd->o_entry);
    evas_object_del(wd->o_inout);
    wd->o_entry = NULL;
    wd->o_inout = NULL;
+   wd->text = NULL;
    free(wd);
 }
 
@@ -237,16 +266,26 @@ _e_wid_changed_cb(void *data, Evas_Object *obj EINA_UNUSED, void *event_info EIN
 {
    Evas_Object *entry;
    E_Widget_Data *wd;
-   const char *text;
+   char *tmp;
 
    if (!(entry = data) || (!(wd = e_widget_data_get(entry))))
      return;
 
+   tmp = elm_entry_markup_to_utf8(elm_object_text_get(wd->o_entry));
+   if (tmp)
+     {
+        if (wd->text) free(wd->text);
+        wd->text = tmp;
+     }
+   else
+     {
+        if (wd->text) free(wd->text);
+        wd->text = NULL;
+     }
    if (wd->text_location)
      {
-        text = elm_object_text_get(wd->o_entry);
         free(*wd->text_location);
-        *wd->text_location = text ? strdup(text) : NULL;
+        *wd->text_location = wd->text ? strdup(wd->text) : NULL;
      }
    e_widget_change(data);
 
diff --git a/src/bin/e_win.c b/src/bin/e_win.c
index 5ae728353..de8093e6c 100644
--- a/src/bin/e_win.c
+++ b/src/bin/e_win.c
@@ -166,13 +166,13 @@ _e_elm_win_trap_show(void *data, Evas_Object *o)
    ctx->client->borderless |= borderless;
    e_comp_object_frame_xy_adjust(ctx->client->frame, ctx->client->client.x, ctx->client->client.y, &ctx->client->x, &ctx->client->y);
    e_comp_object_frame_wh_adjust(ctx->client->frame, ctx->client->client.w, ctx->client->client.h, &ctx->client->w, &ctx->client->h);
+   if (ctx->sized) evas_object_resize(o, ctx->w, ctx->h);
+   if (ctx->placed) evas_object_move(o, ctx->x, ctx->y);
    if (ctx->centered)
      {
-        e_comp_object_util_center(ctx->client->frame);
-        ctx->centered =0;
+        e_comp_object_util_center(o);
+        ctx->centered = 0;
      }
-   else if (ctx->placed) evas_object_move(o, ctx->x, ctx->y);
-   if (ctx->sized) evas_object_resize(o, ctx->w, ctx->h);
    return EINA_TRUE;
 }
 
diff --git a/src/bin/e_zone.c b/src/bin/e_zone.c
index 4397ad0a7..f6c70864f 100644
--- a/src/bin/e_zone.c
+++ b/src/bin/e_zone.c
@@ -78,6 +78,7 @@ _e_zone_cb_mouse_in(void *data, Evas *e EINA_UNUSED, Evas_Object *obj, void *eve
    E_Zone_Edge edge;
    E_Zone *zone = data;
 
+   if (!ev->timestamp) return;
    edge = _e_zone_detect_edge(zone, obj);
    if (edge == E_ZONE_EDGE_NONE) return;
 
@@ -101,6 +102,7 @@ _e_zone_cb_mouse_out(void *data, Evas *e EINA_UNUSED, Evas_Object *obj, void *ev
    E_Zone_Edge edge;
    E_Zone *zone = data;
 
+   if (!ev->timestamp) return;
    edge = _e_zone_detect_edge(zone, obj);
    if (edge == E_ZONE_EDGE_NONE) return;
 
@@ -124,6 +126,7 @@ _e_zone_cb_mouse_down(void *data, Evas *e EINA_UNUSED, Evas_Object *obj, void *e
    E_Zone_Edge edge;
    E_Zone *zone = data;
 
+   if (!ev->timestamp) return;
    edge = _e_zone_detect_edge(zone, obj);
    if (edge == E_ZONE_EDGE_NONE) return;
 
@@ -146,6 +149,7 @@ _e_zone_cb_mouse_up(void *data, Evas *e EINA_UNUSED, Evas_Object *obj, void *eve
    E_Zone_Edge edge;
    E_Zone *zone = data;
 
+   if (!ev->timestamp) return;
    edge = _e_zone_detect_edge(zone, obj);
    if (edge == E_ZONE_EDGE_NONE) return;
 
diff --git a/src/modules/clock/e_mod_main.c b/src/modules/clock/e_mod_main.c
index b2356a671..9011238a0 100644
--- a/src/modules/clock/e_mod_main.c
+++ b/src/modules/clock/e_mod_main.c
@@ -38,7 +38,7 @@ static void             _clock_popup_free(Instance *inst);
 static Eio_Monitor *clock_tz_monitor = NULL;
 static Eio_Monitor *clock_tz2_monitor = NULL;
 static Eio_Monitor *clock_tzetc_monitor = NULL;
-static Eina_List *clock_eio_handlers = NULL;
+static Eina_List *handlers = NULL;
 Config *clock_config = NULL;
 
 static E_Config_DD *conf_edd = NULL;
@@ -839,6 +839,20 @@ _clock_time_update(void *d EINA_UNUSED, int type EINA_UNUSED, void *event EINA_U
    return ECORE_CALLBACK_PASS_ON;
 }
 
+static Eina_Bool
+_clock_screensaver_on()
+{
+   E_FREE_FUNC(update_today, ecore_timer_del);
+   return ECORE_CALLBACK_RENEW;
+}
+
+static Eina_Bool
+_clock_screensaver_off()
+{
+   if (clock_instances) _update_today_timer(NULL);
+   return ECORE_CALLBACK_RENEW;
+}
+
 /* module setup */
 E_API E_Module_Api e_modapi =
 {
@@ -893,14 +907,16 @@ e_modapi_init(E_Module *m)
      clock_tz2_monitor = eio_monitor_add("/etc/timezone");
    if (ecore_file_is_dir("/etc"))
      clock_tzetc_monitor = eio_monitor_add("/etc");
-   E_LIST_HANDLER_APPEND(clock_eio_handlers, EIO_MONITOR_ERROR, _clock_eio_error, NULL);
-   E_LIST_HANDLER_APPEND(clock_eio_handlers, EIO_MONITOR_FILE_CREATED, _clock_eio_update, NULL);
-   E_LIST_HANDLER_APPEND(clock_eio_handlers, EIO_MONITOR_FILE_MODIFIED, _clock_eio_update, NULL);
-   E_LIST_HANDLER_APPEND(clock_eio_handlers, EIO_MONITOR_FILE_DELETED, _clock_eio_update, NULL);
-   E_LIST_HANDLER_APPEND(clock_eio_handlers, EIO_MONITOR_SELF_DELETED, _clock_eio_update, NULL);
-   E_LIST_HANDLER_APPEND(clock_eio_handlers, EIO_MONITOR_SELF_RENAME, _clock_eio_update, NULL);
-   E_LIST_HANDLER_APPEND(clock_eio_handlers, E_EVENT_SYS_RESUME, _clock_time_update, NULL);
-   E_LIST_HANDLER_APPEND(clock_eio_handlers, ECORE_EVENT_SYSTEM_TIMEDATE_CHANGED, _clock_time_update, NULL);
+   E_LIST_HANDLER_APPEND(handlers, EIO_MONITOR_ERROR, _clock_eio_error, NULL);
+   E_LIST_HANDLER_APPEND(handlers, EIO_MONITOR_FILE_CREATED, _clock_eio_update, NULL);
+   E_LIST_HANDLER_APPEND(handlers, EIO_MONITOR_FILE_MODIFIED, _clock_eio_update, NULL);
+   E_LIST_HANDLER_APPEND(handlers, EIO_MONITOR_FILE_DELETED, _clock_eio_update, NULL);
+   E_LIST_HANDLER_APPEND(handlers, EIO_MONITOR_SELF_DELETED, _clock_eio_update, NULL);
+   E_LIST_HANDLER_APPEND(handlers, EIO_MONITOR_SELF_RENAME, _clock_eio_update, NULL);
+   E_LIST_HANDLER_APPEND(handlers, E_EVENT_SYS_RESUME, _clock_time_update, NULL);
+   E_LIST_HANDLER_APPEND(handlers, ECORE_EVENT_SYSTEM_TIMEDATE_CHANGED, _clock_time_update, NULL);
+   E_LIST_HANDLER_APPEND(handlers, E_EVENT_SCREENSAVER_ON, _clock_screensaver_on, NULL);
+   E_LIST_HANDLER_APPEND(handlers, E_EVENT_SCREENSAVER_OFF, _clock_screensaver_off, NULL);
 
    e_gadcon_provider_register(&_gadcon_class);
 
diff --git a/src/modules/conf_randr/e_int_config_randr2.c b/src/modules/conf_randr/e_int_config_randr2.c
index 50512bd69..adb9c3e89 100644
--- a/src/modules/conf_randr/e_int_config_randr2.c
+++ b/src/modules/conf_randr/e_int_config_randr2.c
@@ -443,7 +443,7 @@ _basic_screen_info_fill(E_Config_Dialog_Data *cfdata, E_Config_Randr2_Screen *cs
    else if (cs->rel_mode == E_RANDR2_RELATIVE_TO_BELOW)
      elm_object_text_set(cfdata->rel_mode_obj, _("Below"));
    else
-     elm_object_text_set(cfdata->rel_mode_obj, "???");
+     elm_object_text_set(cfdata->rel_mode_obj, _("Unconfigured"));
 
    elm_slider_value_set(cfdata->rel_align_obj, cs->rel_align);
 
@@ -864,6 +864,7 @@ _basic_create(E_Config_Dialog *cfd, Evas *evas EINA_UNUSED, E_Config_Dialog_Data
 
 ///////////////////////////////////////////////////////////////////////
    o = elm_list_add(win);
+   elm_scroller_content_min_limit(o, 1, 0);
    evas_object_size_hint_weight_set(o, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
    evas_object_size_hint_align_set(o, EVAS_HINT_FILL, EVAS_HINT_FILL);
    elm_table_pack(tb, o, 1, 0, 1, 14);
diff --git a/src/modules/conf_randr/e_mod_main.c b/src/modules/conf_randr/e_mod_main.c
index 8aa8e20e3..7667be912 100644
--- a/src/modules/conf_randr/e_mod_main.c
+++ b/src/modules/conf_randr/e_mod_main.c
@@ -15,6 +15,7 @@ _cb_randr(void *data EINA_UNUSED, int type EINA_UNUSED, void *info EINA_UNUSED)
    Eina_List *l;
    E_Randr2_Screen *s;
 
+   if (!e_randr2) return ECORE_CALLBACK_RENEW;
    EINA_LIST_FOREACH(e_randr2->screens, l, s)
      {
         if (!s->config.configured)
diff --git a/src/modules/lokker/lokker.c b/src/modules/lokker/lokker.c
index db9fb8211..e462d7605 100644
--- a/src/modules/lokker/lokker.c
+++ b/src/modules/lokker/lokker.c
@@ -518,14 +518,14 @@ _lokker_cb_exit(void *data EINA_UNUSED, int type EINA_UNUSED, void *event)
 
    _auth_child_pid = -1;
    /* ok */
-   if (ev->exit_code == 0)
+   if (ev->exited && (ev->exit_code == 0))
      {
         /* security - null out passwd string once we are done with it */
         _lokker_null();
         e_desklock_hide();
      }
    /* error */
-   else if (ev->exit_code < 128)
+   else if ((!ev->exited) || (ev->exit_code < 128))
      {
         /* security - null out passwd string once we are done with it */
         _lokker_null();
@@ -534,7 +534,7 @@ _lokker_cb_exit(void *data EINA_UNUSED, int type EINA_UNUSED, void *event)
                            _("Authentication via PAM had errors setting up the<br>"
                              "authentication session. The error code was <hilight>%i</hilight>.<br>"
                              "This is bad and should not be happening. Please report this bug.")
-                           , ev->exit_code);
+                           , ev->exited ? ev->exit_code : ev->exit_signal);
      }
    /* failed auth */
    else
diff --git a/src/modules/mixer/lib/backends/pulseaudio/pulse.c b/src/modules/mixer/lib/backends/pulseaudio/pulse.c
index 99d697270..3c9c96338 100644
--- a/src/modules/mixer/lib/backends/pulseaudio/pulse.c
+++ b/src/modules/mixer/lib/backends/pulseaudio/pulse.c
@@ -329,7 +329,15 @@ _sink_input_cb(pa_context *c EINA_UNUSED, const pa_sink_input_info *info,
        info->name);
 
    input->idx = info->index;
-   input->base.name = eina_stringshare_add(info->name);
+
+   Eina_Strbuf *input_name;
+
+   input_name = eina_strbuf_new();
+   eina_strbuf_append(input_name, pa_proplist_gets(info->proplist, PA_PROP_APPLICATION_NAME));
+   eina_strbuf_append(input_name, ":");
+   eina_strbuf_append(input_name, info->name);
+   input->base.name = eina_stringshare_add(eina_strbuf_string_get(input_name));
+   eina_strbuf_free(input_name);
    input->base.volume = _pa_cvolume_convert(&info->volume);
    input->base.mute = !!info->mute;
    EINA_LIST_FOREACH(ctx->sinks, l, s)
@@ -799,17 +807,11 @@ _pulse_connect(void *data)
      }
 #endif
    c->context = pa_context_new_with_proplist(&(c->api), NULL, proplist);
-   if (!c->context)
+   if (c->context)
      {
-        WRN("Could not create the pulseaudio context");
-        goto err;
-     }
-
-   pa_context_set_state_callback(c->context, _pulse_pa_state_cb, c);
-   if (pa_context_connect(c->context, NULL, PA_CONTEXT_NOFLAGS, NULL) < 0)
-     {
-        WRN("Could not connect to pulse");
-        goto err;
+        pa_context_set_state_callback(c->context, _pulse_pa_state_cb, c);
+        if (pa_context_connect(c->context, NULL, PA_CONTEXT_NOFLAGS, NULL) < 0)
+          ERR("Could not connect to pulse");
      }
 #if !defined(EMIXER_BUILD) && defined(HAVE_WAYLAND) && !defined(HAVE_WAYLAND_ONLY)
    if (e_comp->comp_type != E_PIXMAP_TYPE_X)
@@ -824,10 +826,6 @@ _pulse_connect(void *data)
 
    pa_proplist_free(proplist);
    return ECORE_CALLBACK_DONE;
-
- err:
-   pa_proplist_free(proplist);
-   return ECORE_CALLBACK_RENEW;
 }
 
 static void
diff --git a/src/modules/mixer/lib/backends/pulseaudio/pulse_ml.c b/src/modules/mixer/lib/backends/pulseaudio/pulse_ml.c
index 469aaca29..e4776fdc7 100644
--- a/src/modules/mixer/lib/backends/pulseaudio/pulse_ml.c
+++ b/src/modules/mixer/lib/backends/pulseaudio/pulse_ml.c
@@ -18,6 +18,18 @@
 #define DBG(...)      EINA_LOG_DBG(__VA_ARGS__)
 #define WRN(...)      EINA_LOG_WARN(__VA_ARGS__)
 
+#define PULSEAUDIO_START \
+   char *disp = NULL; \
+   if (getenv("WAYLAND_DISPLAY")) \
+     { \
+        disp = eina_strdup(getenv("DISPLAY")); \
+        unsetenv("DISPLAY"); \
+     }
+
+#define PULSEAUDIO_END \
+   if (disp) setenv("DISPLAY", disp, 1); \
+   free(disp)
+
 /* Ecore mainloop integration start */
 struct pa_io_event
 {
@@ -71,9 +83,9 @@ _ecore_io_wrapper(void *data, Ecore_Fd_Handler *handler)
       flags |= PA_IO_EVENT_OUTPUT;
    if (ecore_main_fd_handler_active_get(handler, ECORE_FD_ERROR))
       flags |= PA_IO_EVENT_ERROR;
-
+PULSEAUDIO_START;
    event->callback(event->mainloop, event, fd, flags, event->userdata);
-
+PULSEAUDIO_END;
    return ECORE_CALLBACK_RENEW;
 }
 
@@ -133,8 +145,9 @@ _ecore_time_wrapper(void *data)
 {
    pa_time_event *event = (pa_time_event *)data;
 
+PULSEAUDIO_START;
    event->callback(event->mainloop, event, &event->tv, event->userdata);
-
+PULSEAUDIO_END;
    return ECORE_CALLBACK_CANCEL;
 }
 
@@ -231,10 +244,10 @@ Eina_Bool
 _ecore_defer_wrapper(void *data)
 {
    pa_defer_event *event = (pa_defer_event *)data;
-
+PULSEAUDIO_START;
    event->idler = NULL;
    event->callback(event->mainloop, event, event->userdata);
-
+PULSEAUDIO_END;
    return ECORE_CALLBACK_CANCEL;
 }
 
diff --git a/src/modules/time/clock.c b/src/modules/time/clock.c
index c52d2b6a7..99f3618ce 100644
--- a/src/modules/time/clock.c
+++ b/src/modules/time/clock.c
@@ -199,6 +199,8 @@ _clock_timer(void *d EINA_UNUSED)
         seconds |= inst->cfg->show_seconds;
         sec = time_string_format(inst, buf, sizeof(buf));
         elm_object_part_text_set(inst->o_clock, "e.text", buf);
+        time_datestring_format(inst, buf, sizeof(buf) - 1);
+        elm_object_part_text_set(inst->o_clock, "e.text.sub", buf);
         _eval_instance_size(inst);
      }
    sec = seconds ? 1 : (61 - sec);
@@ -520,3 +522,14 @@ time_config_update(Config_Item *ci)
      E_FREE_FUNC(clock_timer, ecore_timer_del);
    e_config_save_queue();
 }
+
+EINTERN void
+clock_timer_set(Eina_Bool set)
+{
+   if (set)
+     {
+        if (clock_instances) _clock_timer(NULL);
+     }
+   else
+     E_FREE_FUNC(clock_timer, ecore_timer_del);
+}
diff --git a/src/modules/time/clock.h b/src/modules/time/clock.h
index 912aa730a..0058eaf8e 100644
--- a/src/modules/time/clock.h
+++ b/src/modules/time/clock.h
@@ -86,6 +86,7 @@ EINTERN void digital_clock_wizard(E_Gadget_Wizard_End_Cb cb, void *data);
 EINTERN void analog_clock_wizard(E_Gadget_Wizard_End_Cb cb, void *data);
 EINTERN void clock_popup_new(Instance *inst);
 EINTERN void time_config_update(Config_Item *ci);
+EINTERN void clock_timer_set(Eina_Bool set);
 
 extern Config *time_config;
 extern Eina_List *clock_instances;
diff --git a/src/modules/time/time.c b/src/modules/time/time.c
index b3f93d628..224416e48 100644
--- a/src/modules/time/time.c
+++ b/src/modules/time/time.c
@@ -6,7 +6,7 @@
 static Eio_Monitor *clock_te_monitor = NULL;
 static Eio_Monitor *clock_tz2_monitor = NULL;
 static Eio_Monitor *clock_tzetc_monitor = NULL;
-static Eina_List *clock_eio_handlers = NULL;
+static Eina_List *handlers = NULL;
 
 static Ecore_Timer *update_today = NULL;
 
@@ -22,14 +22,14 @@ static Ecore_Timer *update_today = NULL;
    if (tzenv) \
      strncpy(prevtz, tzenv, sizeof(prevtz) - 1); \
    if (inst->cfg->timezone) \
-     setenv("TZ", inst->cfg->timezone, 1); \
+     e_util_env_set("TZ", inst->cfg->timezone); \
    tzset()
 
 #define TZUNSET() \
    if (prevtz[0]) \
-     setenv("TZ", prevtz, 1); \
+     e_util_env_set("TZ", prevtz); \
    else \
-     unsetenv("TZ"); \
+     e_util_env_set("TZ", NULL); \
    tzset()
 
 static void
@@ -323,6 +323,20 @@ _clock_eio_error(void *d EINA_UNUSED, int type EINA_UNUSED, void *event)
    return ECORE_CALLBACK_PASS_ON;
 }
 
+static Eina_Bool
+_clock_screensaver_on()
+{
+   clock_timer_set(0);
+   return ECORE_CALLBACK_RENEW;
+}
+
+static Eina_Bool
+_clock_screensaver_off()
+{
+   clock_timer_set(1);
+   return ECORE_CALLBACK_RENEW;
+}
+
 EINTERN void
 time_init(void)
 {
@@ -333,14 +347,16 @@ time_init(void)
    if (ecore_file_is_dir("/etc"))
      clock_tzetc_monitor = eio_monitor_add("/etc");
 
-    E_LIST_HANDLER_APPEND(clock_eio_handlers, EIO_MONITOR_ERROR, _clock_eio_error, NULL);
-    E_LIST_HANDLER_APPEND(clock_eio_handlers, EIO_MONITOR_FILE_CREATED, _clock_eio_update, NULL);
-    E_LIST_HANDLER_APPEND(clock_eio_handlers, EIO_MONITOR_FILE_MODIFIED, _clock_eio_update, NULL);
-    E_LIST_HANDLER_APPEND(clock_eio_handlers, EIO_MONITOR_FILE_DELETED, _clock_eio_update, NULL);
-    E_LIST_HANDLER_APPEND(clock_eio_handlers, EIO_MONITOR_SELF_DELETED, _clock_eio_update, NULL);
-    E_LIST_HANDLER_APPEND(clock_eio_handlers, EIO_MONITOR_SELF_RENAME, _clock_eio_update, NULL);
-    E_LIST_HANDLER_APPEND(clock_eio_handlers, E_EVENT_SYS_RESUME, _clock_time_update, NULL);
-    E_LIST_HANDLER_APPEND(clock_eio_handlers, ECORE_EVENT_SYSTEM_TIMEDATE_CHANGED, _clock_time_update, NULL);
+   E_LIST_HANDLER_APPEND(handlers, EIO_MONITOR_ERROR, _clock_eio_error, NULL);
+   E_LIST_HANDLER_APPEND(handlers, EIO_MONITOR_FILE_CREATED, _clock_eio_update, NULL);
+   E_LIST_HANDLER_APPEND(handlers, EIO_MONITOR_FILE_MODIFIED, _clock_eio_update, NULL);
+   E_LIST_HANDLER_APPEND(handlers, EIO_MONITOR_FILE_DELETED, _clock_eio_update, NULL);
+   E_LIST_HANDLER_APPEND(handlers, EIO_MONITOR_SELF_DELETED, _clock_eio_update, NULL);
+   E_LIST_HANDLER_APPEND(handlers, EIO_MONITOR_SELF_RENAME, _clock_eio_update, NULL);
+   E_LIST_HANDLER_APPEND(handlers, E_EVENT_SYS_RESUME, _clock_time_update, NULL);
+   E_LIST_HANDLER_APPEND(handlers, ECORE_EVENT_SYSTEM_TIMEDATE_CHANGED, _clock_time_update, NULL);
+   E_LIST_HANDLER_APPEND(handlers, E_EVENT_SCREENSAVER_ON, _clock_screensaver_on, NULL);
+   E_LIST_HANDLER_APPEND(handlers, E_EVENT_SCREENSAVER_OFF, _clock_screensaver_off, NULL);
    _update_today_timer(NULL);
 }
 
diff --git a/src/modules/wl_drm/e_mod_main.c b/src/modules/wl_drm/e_mod_main.c
index 0c80e8d40..602e10f9c 100644
--- a/src/modules/wl_drm/e_mod_main.c
+++ b/src/modules/wl_drm/e_mod_main.c
@@ -56,19 +56,11 @@ _e_mod_drm_cb_activate(void *data EINA_UNUSED, int type EINA_UNUSED, void *event
 
    if (ev->active)
      {
-        E_Client *ec;
-
         if (session_state) goto end;
         session_state = EINA_TRUE;
 
         ecore_evas_show(e_comp->ee);
-        E_CLIENT_FOREACH(ec)
-          {
-             if (ec->visible && (!ec->input_only))
-               e_comp_object_damage(ec->frame, 0, 0, ec->w, ec->h);
-          }
-        e_comp_render_queue();
-        e_comp_shape_queue_block(0);
+        evas_damage_rectangle_add(e_comp->evas, 0, 0, e_comp->w, e_comp->h);
         ecore_event_add(E_EVENT_COMPOSITOR_ENABLE, NULL, NULL, NULL);
      }
    else
@@ -81,8 +73,6 @@ _e_mod_drm_cb_activate(void *data EINA_UNUSED, int type EINA_UNUSED, void *event
         evas_font_cache_flush(e_comp->evas);
         evas_render_dump(e_comp->evas);
 
-        e_comp_render_queue();
-        e_comp_shape_queue_block(1);
         ecore_event_add(E_EVENT_COMPOSITOR_DISABLE, NULL, NULL, NULL);
      }
 
@@ -91,56 +81,10 @@ end:
 }
 
 static Eina_Bool
-_e_mod_drm_cb_output(void *data EINA_UNUSED, int type EINA_UNUSED, void *event)
+_e_mod_drm_cb_output(void *data EINA_UNUSED, int type EINA_UNUSED, void *event EINA_UNUSED)
 {
-   const Eina_List *l;
-   E_Randr2_Screen *screen;
-   Eina_Bool connected = EINA_FALSE;
-   int subpixel = 0;
-#ifdef HAVE_DRM2
-   Ecore_Drm2_Event_Output_Changed *e;
-#else
-   Ecore_Drm_Event_Output *e;
-#endif
-
-   if (!(e = event)) goto end;
-
-   DBG("WL_DRM OUTPUT CHANGE");
-
-   EINA_LIST_FOREACH(e_randr2->screens, l, screen)
-     {
-        if ((!strcmp(screen->info.name, e->name)) && 
-            (!strcmp(screen->info.screen, e->model)))
-          {
-#ifdef HAVE_DRM2
-             connected = e->enabled;
-             subpixel = e->subpixel;
-#else
-             connected = e->plug;
-             subpixel = e->subpixel_order;
-#endif
-
-             if (connected)
-               {
-                  if (!e_comp_wl_output_init(screen->id, e->make, e->model,
-                                             e->x, e->y, e->w, e->h, 
-                                             e->phys_width, e->phys_height,
-                                             e->refresh, subpixel,
-                                             e->transform))
-                    {
-                       ERR("Could not setup new output: %s", screen->id);
-                    }
-               }
-             else
-               e_comp_wl_output_remove(screen->id);
-
-             break;
-          }
-     }
-
-end:
    if (!e_randr2_cfg->ignore_hotplug_events)
-     e_randr2_screen_refresh_queue(EINA_TRUE);
+     e_randr2_screen_refresh_queue(1);
 
    return ECORE_CALLBACK_PASS_ON;
 }
@@ -678,8 +622,7 @@ _drm2_randr_apply(void)
         if (s->config.priority > top_priority)
           top_priority = s->config.priority;
 
-        ecore_drm2_output_mode_set(output, mode,
-                                   s->config.geom.x, s->config.geom.y);
+        ecore_drm2_output_mode_set(output, mode, 0, 0);
 
         /* TODO: cannot support rotations until we support planes
          * and we cannot support planes until Atomic support is in */
diff --git a/src/modules/xwayland/dnd.c b/src/modules/xwayland/dnd.c
index 47c5d9569..2c0594d82 100644
--- a/src/modules/xwayland/dnd.c
+++ b/src/modules/xwayland/dnd.c
@@ -143,6 +143,12 @@ _xwayland_send_send(E_Comp_Wl_Data_Source *source EINA_UNUSED, const char* mime_
    xconvertselection(ecore_x_display_get(), sel, type, xwl_dnd_atom, e_comp->cm_selection, 0);
 }
 
+static void
+_xwayland_send_cancelled(E_Comp_Wl_Data_Source *source)
+{
+   e_comp_wl_clipboard_source_unref((void*)source);
+}
+
 static void
 _xwayland_cancelled_send(E_Comp_Wl_Data_Source *source EINA_UNUSED)
 {
@@ -155,16 +161,16 @@ _xwl_fixes_selection_notify(void *d EINA_UNUSED, int t EINA_UNUSED, Ecore_X_Even
 {
    if (ev->owner == e_comp->cm_selection)
      {
-        e_comp_wl->clipboard.xwl_owner = NULL;
+        e_comp_wl->clipboard.xwl_owner = 0;
         return ECORE_CALLBACK_RENEW;
      }
    if (ev->atom == ECORE_X_ATOM_SELECTION_XDND)
      {
         if (ev->owner)
           {
-             int x, y, num;
+             int x, y, num, i;
              unsigned char *data;
-             const char **names = NULL;
+             char **names = NULL;
              Eina_Array *namelist = NULL;
              E_Comp_Wl_Data_Source *source;
 
@@ -175,22 +181,22 @@ _xwl_fixes_selection_notify(void *d EINA_UNUSED, int t EINA_UNUSED, Ecore_X_Even
                                                   &data,
                                                   &num))
                {
-                  int i;
                   Ecore_X_Atom *types = (void*)data;
 
                   names = malloc(num * sizeof(void*));
                   namelist = eina_array_new(num);
                   for (i = 0; i < num; i++)
                     {
-                       const char *name;
+                       char *name;
 
                        if (types[i] == string_atom)
                          {
-                            name = names[i] = "UTF8_STRING";
+                            name = names[i] = strdup("UTF8_STRING");
                             eina_array_push(namelist, eina_stringshare_add(WL_TEXT_STR));
                          }
                        else
                          names[i] = name = ecore_x_atom_name_get(types[i]);
+                       DBG("XWL TARGET: %s", name);
                        eina_array_push(namelist, eina_stringshare_add(name));
                     }
                   if (num > 3)
@@ -203,7 +209,7 @@ _xwl_fixes_selection_notify(void *d EINA_UNUSED, int t EINA_UNUSED, Ecore_X_Even
                }
              evas_pointer_canvas_xy_get(e_comp->evas, &x, &y);
              e_comp_wl->drag_client = e_pixmap_find_client(E_PIXMAP_TYPE_X, ev->owner);
-             e_comp_wl->drag = e_drag_new(x, y, names, num, NULL, 0, NULL, _xwayland_drop);
+             e_comp_wl->drag = e_drag_new(x, y, (const char**)names, num, NULL, 0, NULL, _xwayland_drop);
              e_comp_wl->drag->button_mask = evas_pointer_button_down_mask_get(e_comp->evas);
              ecore_x_window_move_resize(e_comp->cm_selection, 0, 0, e_comp->w, e_comp->h);
              ecore_x_window_show(e_comp->cm_selection);
@@ -212,12 +218,16 @@ _xwl_fixes_selection_notify(void *d EINA_UNUSED, int t EINA_UNUSED, Ecore_X_Even
                e_comp_wl_data_device_send_enter(e_comp_wl->ptr.ec);
              e_comp_canvas_feed_mouse_up(0);
              source = e_comp_wl_data_manager_source_create(e_comp_wl->xwl_client,
-               e_comp_wl->mgr.resource, 1);
+               e_comp_wl->mgr.resource, 0);
+             source->current_dnd_action = WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY;
+             source->dnd_actions = WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY;
              e_comp_wl->drag_source = source;
              source->target = _xwayland_target_send;
              source->send = _xwayland_send_send;
              source->cancelled = _xwayland_cancelled_send;
              source->mime_types = namelist;
+             for (i = 0; i < num; i++)
+               free(names[i]);
              free(names);
           }
         else
@@ -234,15 +244,20 @@ _xwl_fixes_selection_notify(void *d EINA_UNUSED, int t EINA_UNUSED, Ecore_X_Even
      {
         if (ev->owner)
           {
-             if (e_comp_wl->clipboard.source)
-               e_comp_wl_clipboard_source_unref(e_comp_wl->clipboard.source);
+             if (e_comp_wl->selection.data_source)
+               {
+                  E_Comp_Wl_Data_Source *psource = e_comp_wl->selection.data_source;
+                  if (psource->cancelled)
+                    psource->cancelled(psource);
+               }
              e_comp_wl->clipboard.source = NULL;
-             e_comp_wl->clipboard.xwl_owner = ev->owner ? e_pixmap_find_client(E_PIXMAP_TYPE_X, ev->owner) : NULL;
+             e_comp_wl->selection.data_source = NULL;
+             e_comp_wl->clipboard.xwl_owner = ev->owner;
              xconvertselection(ecore_x_display_get(), ECORE_X_ATOM_SELECTION_CLIPBOARD,
                ECORE_X_ATOM_SELECTION_TARGETS, xwl_dnd_atom, e_comp->cm_selection, 0);
           }
         else
-          e_comp_wl->clipboard.xwl_owner = NULL;
+          e_comp_wl->clipboard.xwl_owner = 0;
      }
    return ECORE_CALLBACK_RENEW;
 }
@@ -270,16 +285,22 @@ _xwl_selection_notify(void *d EINA_UNUSED, int t EINA_UNUSED, Ecore_X_Event_Sele
 
              source = e_comp_wl_clipboard_source_create(NULL, 0, -1);
              dsource = e_comp_wl_data_manager_source_create(e_comp_wl->xwl_client,
-               e_comp_wl->mgr.resource, 1);
+               e_comp_wl->mgr.resource, 0);
              source->data_source.mime_types = eina_array_new(tgs->num_targets);
              for (i = 0; i < tgs->num_targets; i++)
                if (tgs->targets[i])
-                 eina_array_push(source->data_source.mime_types, eina_stringshare_add(tgs->targets[i]));
+                 {
+                    DBG("XWL TARGET: %s", tgs->targets[i]);
+                    if (eina_streq(tgs->targets[i], "UTF8_STRING"))
+                      eina_array_push(source->data_source.mime_types, eina_stringshare_add(WL_TEXT_STR));
+                    eina_array_push(source->data_source.mime_types, eina_stringshare_add(tgs->targets[i]));
+                 }
+
              e_comp_wl->clipboard.source = source;
              e_comp_wl->selection.data_source = &source->data_source;
              source->data_source.resource = dsource->resource;
              source->data_source.send = _xwayland_send_send;
-             free(dsource);
+             source->data_source.cancelled = _xwayland_send_cancelled;
              if (e_client_has_xwindow(e_client_focused_get()))
                e_comp_wl_data_device_keyboard_focus_set();
              return ECORE_CALLBACK_RENEW;
@@ -380,7 +401,7 @@ _xwl_selection_request(void *d EINA_UNUSED, int t EINA_UNUSED, Ecore_X_Event_Sel
         ecore_x_window_prop_property_set(ev->requestor, ev->property, int_atom, 32, (void*)&timestamp, 1);
         ecore_x_selection_notify_send(ev->requestor, ev->selection, ev->target, ev->property, 0);
      }
-   else
+   else if (ev->requestor != e_comp->cm_selection)
      {
         const char *name;
         Pipe *p;
@@ -399,7 +420,7 @@ _xwl_selection_request(void *d EINA_UNUSED, int t EINA_UNUSED, Ecore_X_Event_Sel
                p->fdh = ecore_main_fd_handler_add(fds[0], ECORE_FD_READ, _xwl_pipe_read, p, NULL, NULL);
                p->win = ev->requestor;
                p->source = source;
-               wl_data_source_send_send(source->resource, type, dup(fds[1]));
+               wl_data_source_send_send(source->resource, type, fds[1]);
                close(fds[1]);
                p->atom = ev->target;
                p->selection = ev->selection;
diff --git a/src/modules/xwayland/e_mod_main.c b/src/modules/xwayland/e_mod_main.c
index 793f2e151..89309c01e 100644
--- a/src/modules/xwayland/e_mod_main.c
+++ b/src/modules/xwayland/e_mod_main.c
@@ -225,7 +225,7 @@ _cb_xserver_event(void *data EINA_UNUSED, Ecore_Fd_Handler *hdlr EINA_UNUSED)
         snprintf(xserver, sizeof(xserver), "%s", XWAYLAND_BIN);
         DBG("\tLaunching %s: %s", xserver, disp);
         if (execl(xserver, xserver, disp, "-rootless", "-listen", abs_fd,
-                  "-listen", unx_fd, "-terminate", "-shm",
+                  "-listen", unx_fd, "-terminate",
                   NULL) < 0)
           {
              ERR("Failed to exec %s: %m", XWAYLAND_BIN);
@@ -289,8 +289,10 @@ xinit(void *d, Ecore_Thread *eth)
 
    init_threads = dlsym(NULL, "XInitThreads");
    if (init_threads) init_threads();
+   else ERR("Could not resolve XInitThreads");
    open_display = dlsym(NULL, "XOpenDisplay");
    if (open_display) disp = open_display(d);
+   else ERR("Could not resolve XOpenDisplay");
    free(d);
    ecore_thread_feedback(eth, disp);
 }

diff --git a/data/elementary/themes/edc/start.edc b/data/elementary/themes/edc/start.edc
index bdf4726170..edd558f155 100644
--- a/data/elementary/themes/edc/start.edc
+++ b/data/elementary/themes/edc/start.edc
@@ -50,7 +50,7 @@ group { name: "e/modules/start/main";
             max: 14 17;
          }
       }
-      part { name: "arrow";
+      part { name: "arrow"; clip: "arrow_base";
          description { state: "default" 0.0;
             image.normal: "big_arrow_up.png";
             aspect: (17/14) (17/14);
diff --git a/src/bin/elementary/test_win_stack.c b/src/bin/elementary/test_win_stack.c
index 23df1bf16b..77b88b89af 100644
--- a/src/bin/elementary/test_win_stack.c
+++ b/src/bin/elementary/test_win_stack.c
@@ -91,12 +91,20 @@ _bt_pressed(void *data, Evas_Object *obj EINA_UNUSED, void *event_info EINA_UNUS
    evas_object_show(win);
 }
 
+static void
+_del()
+{
+   level = 0;
+   popto_win = NULL;
+}
+
 void
 test_win_stack(void *data EINA_UNUSED, Evas_Object *obj EINA_UNUSED, void *event_info EINA_UNUSED)
 {
    Evas_Object *bg, *bx, *bt, *lb, *win;
 
    win = elm_win_add(NULL, "window-stack", ELM_WIN_BASIC);
+   evas_object_event_callback_add(win, EVAS_CALLBACK_DEL, _del, NULL);
    efl_ui_win_stack_base_set(win, EINA_TRUE);
    elm_win_title_set(win, "Window Stack");
    elm_win_autodel_set(win, EINA_TRUE);
diff --git a/src/lib/ecore_drm2/ecore_drm2_device.c b/src/lib/ecore_drm2/ecore_drm2_device.c
index 446230edb9..3545d1a299 100644
--- a/src/lib/ecore_drm2/ecore_drm2_device.c
+++ b/src/lib/ecore_drm2/ecore_drm2_device.c
@@ -77,7 +77,7 @@ _drm2_device_modeset_capable(int fd)
    int ret = EINA_TRUE;
    drmModeRes *res;
 
-   res = drmModeGetResources(fd);
+   res = sym_drmModeGetResources(fd);
    if (!res)
      return EINA_FALSE;
 
@@ -86,7 +86,7 @@ _drm2_device_modeset_capable(int fd)
        res->count_encoders <= 0)
      ret = EINA_FALSE;
 
-   drmModeFreeResources(res);
+   sym_drmModeFreeResources(res);
 
    return ret;
 }
diff --git a/src/lib/ecore_wl2/ecore_wl2_display.c b/src/lib/ecore_wl2/ecore_wl2_display.c
index f1699ecbad..79a9e59fc5 100644
--- a/src/lib/ecore_wl2/ecore_wl2_display.c
+++ b/src/lib/ecore_wl2/ecore_wl2_display.c
@@ -143,7 +143,7 @@ _aux_hints_supported_aux_hints(void *data, struct efl_aux_hints *aux_hints EINA_
    ev->win = win->id;
    ev->display = ewd;
    ewd->refs++;
-   ecore_event_add(ECORE_WL2_EVENT_AUX_HINT_SUPPORTED, ev, _display_event_free, NULL);
+   ecore_event_add(ECORE_WL2_EVENT_AUX_HINT_SUPPORTED, ev, _display_event_free, ewd);
 }
 
 static void
@@ -163,7 +163,7 @@ _aux_hints_allowed_aux_hint(void *data, struct efl_aux_hints *aux_hints  EINA_UN
    ev->id = id;
    ev->display = ewd;
    ewd->refs++;
-   ecore_event_add(ECORE_WL2_EVENT_AUX_HINT_ALLOWED, ev, _display_event_free, NULL);
+   ecore_event_add(ECORE_WL2_EVENT_AUX_HINT_ALLOWED, ev, _display_event_free, ewd);
 }
 
  static void
@@ -852,7 +852,7 @@ found:
    return ewd;
 }
 
-static Eina_Bool
+Eina_Bool
 _ecore_wl2_display_sync_get(void)
 {
    Ecore_Wl2_Display *sewd;
diff --git a/src/lib/ecore_wl2/ecore_wl2_private.h b/src/lib/ecore_wl2/ecore_wl2_private.h
index 2bdf0610e0..3569db9f39 100644
--- a/src/lib/ecore_wl2/ecore_wl2_private.h
+++ b/src/lib/ecore_wl2/ecore_wl2_private.h
@@ -170,6 +170,8 @@ struct _Ecore_Wl2_Window
    uint32_t configure_serial;
    void (*configure_ack)(struct xdg_surface *surface, uint32_t serial);
    void (*zxdg_configure_ack)(struct zxdg_surface_v6 *surface, uint32_t serial);
+   void (*zxdg_set_min_size)(struct zxdg_toplevel_v6 *toplevel, int32_t w, int32_t h);
+   void (*zxdg_set_max_size)(struct zxdg_toplevel_v6 *toplevel, int32_t w, int32_t h);
 
    Eina_Rectangle saved;
    Eina_Rectangle geometry;
@@ -515,6 +517,7 @@ void _ecore_wl2_window_www_surface_init(Ecore_Wl2_Window *window);
 void _ecore_wl2_window_semi_free(Ecore_Wl2_Window *window);
 
 void _ecore_wl2_offer_unref(Ecore_Wl2_Offer *offer);
+Eina_Bool _ecore_wl2_display_sync_get(void);
 
 EAPI extern int _ecore_wl2_event_window_www;
 EAPI extern int _ecore_wl2_event_window_www_drag;
diff --git a/src/lib/ecore_wl2/ecore_wl2_window.c b/src/lib/ecore_wl2/ecore_wl2_window.c
index f12d73230c..78f6129af0 100644
--- a/src/lib/ecore_wl2/ecore_wl2_window.c
+++ b/src/lib/ecore_wl2/ecore_wl2_window.c
@@ -356,14 +356,13 @@ _ecore_wl2_window_type_set(Ecore_Wl2_Window *win)
       case ECORE_WL2_WINDOW_TYPE_TOPLEVEL:
         if (win->zxdg_surface)
           {
-             struct zxdg_toplevel_v6 *ptop;
+             struct zxdg_toplevel_v6 *ptop = NULL;
 
              if (win->parent)
                ptop = win->parent->zxdg_toplevel;
-             else
-               ptop = NULL;
 
-             zxdg_toplevel_v6_set_parent(win->zxdg_toplevel, ptop);
+             if (ptop)
+               zxdg_toplevel_v6_set_parent(win->zxdg_toplevel, ptop);
           }
         else if (win->xdg_surface)
           xdg_surface_set_parent(win->xdg_surface, NULL);
@@ -460,8 +459,8 @@ _ecore_wl2_window_shell_surface_init(Ecore_Wl2_Window *window)
         if (window->class)
           zxdg_toplevel_v6_set_app_id(window->zxdg_toplevel, window->class);
 
-        zxdg_toplevel_v6_set_min_size(window->zxdg_toplevel, 1, 1);
-        zxdg_toplevel_v6_set_max_size(window->zxdg_toplevel, 32767, 32767);
+        window->zxdg_set_min_size = zxdg_toplevel_v6_set_min_size;
+        window->zxdg_set_max_size = zxdg_toplevel_v6_set_max_size;
 
         window->zxdg_configure_ack = zxdg_surface_v6_ack_configure;
         _ecore_wl2_window_type_set(window);
@@ -556,7 +555,11 @@ _ecore_wl2_window_surface_create(Ecore_Wl2_Window *window)
         window->surface_id =
           wl_proxy_get_id((struct wl_proxy *)window->surface);
         if (window->display->wl.efl_aux_hints)
-          efl_aux_hints_get_supported_aux_hints(window->display->wl.efl_aux_hints, window->surface);
+          {
+             efl_aux_hints_get_supported_aux_hints(window->display->wl.efl_aux_hints, window->surface);
+             if (_ecore_wl2_display_sync_get())
+               wl_display_roundtrip(window->display->wl.display);
+          }
      }
 }
 
@@ -619,11 +622,11 @@ ecore_wl2_window_new(Ecore_Wl2_Display *display, Ecore_Wl2_Window *parent, int x
    win->opaque.h = h;
 
    win->pending.configure = EINA_TRUE;
-   _ecore_wl2_window_surface_create(win);
-
    display->windows =
      eina_inlist_append(display->windows, EINA_INLIST_GET(win));
 
+   _ecore_wl2_window_surface_create(win);
+
    return win;
 }
 
diff --git a/src/lib/edje/edje_callbacks.c b/src/lib/edje/edje_callbacks.c
index ac6f52c9eb..06ed0f81a7 100644
--- a/src/lib/edje/edje_callbacks.c
+++ b/src/lib/edje/edje_callbacks.c
@@ -387,35 +387,51 @@ _edje_timer_cb(void *data, const Efl_Event *event EINA_UNUSED)
    _edje_util_freeze(ed);
    if ((!ed->paused) && (!ed->delete_me))
      {
-        const void *tmp;
+        Edje_Running_Program *tmp;
 
         ed->walking_actions = EINA_TRUE;
         EINA_LIST_FOREACH(ed->actions, l, tmp)
-          newl = eina_list_append(newl, tmp);
+          {
+             tmp->ref++;
+             newl = eina_list_append(newl, tmp);
+          }
         while (newl)
           {
              Edje_Running_Program *runp;
 
              runp = eina_list_data_get(newl);
              newl = eina_list_remove(newl, eina_list_data_get(newl));
+             runp->ref--;
              if (!runp->delete_me)
                _edje_program_run_iterate(runp, t);
              if (_edje_block_break(ed))
                {
-                  eina_list_free(newl);
+                  EINA_LIST_FREE(newl, tmp)
+                    {
+                       tmp->ref--;
+                       if ((tmp->delete_me) && (tmp->ref == 0))
+                         {
+                            _edje_program_run_cleanup(ed, tmp);
+                            free(tmp);
+                         }
+                    }
                   newl = NULL;
                   goto break_prog;
                }
           }
         EINA_LIST_FOREACH(ed->actions, l, tmp)
-          newl = eina_list_append(newl, tmp);
+          {
+             tmp->ref++;
+             newl = eina_list_append(newl, tmp);
+          }
         while (newl)
           {
              Edje_Running_Program *runp;
 
              runp = eina_list_data_get(newl);
              newl = eina_list_remove(newl, eina_list_data_get(newl));
-             if (runp->delete_me)
+             runp->ref--;
+             if ((runp->delete_me) && (runp->ref == 0))
                {
                   _edje_program_run_cleanup(ed, runp);
                   free(runp);
diff --git a/src/lib/edje/edje_private.h b/src/lib/edje/edje_private.h
index af7075208f..b29d77f4a9 100644
--- a/src/lib/edje/edje_private.h
+++ b/src/lib/edje/edje_private.h
@@ -2058,6 +2058,7 @@ struct _Edje_Running_Program
    Edje           *edje;
    Edje_Program   *program;
    double          start_time;
+   unsigned short  ref;
    Eina_Bool       delete_me : 1;
 };
 
diff --git a/src/lib/edje/edje_program.c b/src/lib/edje/edje_program.c
index 28b9300ccf..c5c915e220 100644
--- a/src/lib/edje/edje_program.c
+++ b/src/lib/edje/edje_program.c
@@ -387,20 +387,32 @@ _edje_object_animation_set(Eo *obj, Edje *ed, Eina_Bool on)
    if (!on)
      {
         Eina_List *newl = NULL;
-        const void *data;
+        Edje_Running_Program *data;
 
         EINA_LIST_FOREACH(ed->actions, l, data)
-          newl = eina_list_append(newl, data);
+          {
+             data->ref++;
+             newl = eina_list_append(newl, data);
+          }
         while (newl)
           {
              Edje_Running_Program *runp;
 
              runp = eina_list_data_get(newl);
              newl = eina_list_remove(newl, eina_list_data_get(newl));
+             runp->ref--;
              _edje_program_run_iterate(runp, runp->start_time + TO_DOUBLE(runp->program->tween.time));
              if (_edje_block_break(ed))
                {
-                  eina_list_free(newl);
+                 EINA_LIST_FREE(newl, data)
+                    {
+                       data->ref--;
+                       if ((data->delete_me) && (data->ref == 0))
+                         {
+                            _edje_program_run_cleanup(ed, data);
+                            free(data);
+                         }
+                    }
                   goto break_prog;
                }
           }
@@ -522,7 +534,14 @@ _edje_program_run_iterate(Edje_Running_Program *runp, double tim)
         //	_edje_emit(ed, "program,stop", runp->program->name);
         if (_edje_block_break(ed))
           {
-             if (!ed->walking_actions) free(runp);
+             if (!ed->walking_actions)
+               {
+                  if (runp->ref == 0)
+                    {
+                       _edje_program_run_cleanup(ed, runp);
+                       free(runp);
+                    }
+               }
              goto break_prog;
           }
         EINA_LIST_FOREACH(runp->program->after, l, pa)
@@ -535,14 +554,22 @@ _edje_program_run_iterate(Edje_Running_Program *runp, double tim)
                   if (pr) _edje_program_run(ed, pr, 0, "", "");
                   if (_edje_block_break(ed))
                     {
-                       if (!ed->walking_actions) free(runp);
+                       if ((!ed->walking_actions) && (runp->ref == 0))
+                         {
+                            _edje_program_run_cleanup(ed, runp);
+                            free(runp);
+                         }
                        goto break_prog;
                     }
                }
           }
         _edje_util_thaw(ed);
         _edje_unref(ed);
-        if (!ed->walking_actions) free(runp);
+        if ((!ed->walking_actions) && (runp->ref == 0))
+          {
+             _edje_program_run_cleanup(ed, runp);
+             free(runp);
+          }
         _edje_unblock(ed);
         return EINA_FALSE;
      }
@@ -601,7 +628,7 @@ _edje_program_end(Edje *ed, Edje_Running_Program *runp)
    //   _edje_emit(ed, "program,stop", pname);
    _edje_util_thaw(ed);
    _edje_unref(ed);
-   if (free_runp) free(runp);
+   if ((free_runp) && (runp->ref == 0)) free(runp);
 }
 
 #ifdef HAVE_EPHYSICS
diff --git a/src/lib/efl_wl/efl_wl.c b/src/lib/efl_wl/efl_wl.c
index 691ae69beb..03e1128836 100644
--- a/src/lib/efl_wl/efl_wl.c
+++ b/src/lib/efl_wl/efl_wl.c
@@ -99,6 +99,7 @@ typedef struct Comp_Buffer
    int x, y, w, h;
    struct wl_listener destroy_listener;
    struct wl_shm_buffer *shm_buffer;
+   struct wl_shm_pool *pool;
    struct linux_dmabuf_buffer *dmabuf_buffer;
    Eina_Bool dbg : 1;
 } Comp_Buffer;
@@ -118,6 +119,9 @@ typedef struct Comp
    Evas_Object *clip;
    Evas_Object *events;
 
+   Eina_Hash *exes;
+   Ecore_Event_Handler *exe_handler;
+
    Eina_Inlist *surfaces;
    unsigned int surfaces_count;
    Eina_Hash *client_surfaces;
@@ -427,6 +431,22 @@ array_clear(Eina_Array **arr)
    *arr = NULL;
 }
 
+static inline Eina_Bool
+client_allowed_check(Comp *c, struct wl_client *client)
+{
+   pid_t p;
+   int32_t pid;
+   Eina_Bool err;
+
+   wl_client_get_credentials(client, &p, NULL, NULL);
+   if (p == getpid()) return EINA_TRUE;
+   pid = p;
+   err = (!c->exes) || !eina_hash_find(c->exes, &pid);
+   if (err)
+     wl_client_post_no_memory(client);
+   return !err;
+}
+
 static inline void
 comp_data_device_source_reader_clear(Comp_Data_Device_Source *ds)
 {
@@ -1235,6 +1255,7 @@ comp_surface_buffer_detach(Comp_Buffer **pbuffer)
    eina_list_free(buffer->renders);
    wl_list_remove(&buffer->destroy_listener.link);
    //if (buffer->dbg) fprintf(stderr, "BUFFER(%d) RELEASE\n", wl_resource_get_id(buffer->res));
+   if (buffer->pool) wl_shm_pool_unref(buffer->pool);
    wl_resource_queue_event(buffer->res, WL_BUFFER_RELEASE);
    free(buffer);
    *pbuffer = NULL;
@@ -1282,6 +1303,7 @@ comp_surface_commit_image_state(Comp_Surface *cs, Comp_Buffer *buffer, Evas_Obje
         //if (cs->subsurface)
           //fprintf(stderr, "SET CB\n");
         evas_object_image_pixels_get_callback_set(o, comp_surface_pixels_get, cs);
+        buffer->pool = wl_shm_buffer_ref_pool(buffer->shm_buffer);
      }
    else
      {
@@ -1323,7 +1345,8 @@ comp_surface_commit_state(Comp_Surface *cs, Comp_Buffer_State *state)
           {
              //if (cs->subsurface)
                //fprintf(stderr, "BUFFER(%d) COMMIT %d\n", wl_resource_get_id(buffer->res), wl_resource_get_id(cs->res));
-             if ((!cs->post_render_queue) && ((!cs->buffer[1]) || (!cs->buffer[1]->post_renders)))
+             if ((!cs->c->rendering) && (!cs->post_render_queue) &&
+               ((!cs->buffer[1]) || (!cs->buffer[1]->post_renders)))
                comp_surface_buffer_detach(&cs->buffer[1]);
           }
         else
@@ -2450,6 +2473,8 @@ comp_bind(struct wl_client *client, void *data, uint32_t version, uint32_t id)
 {
    struct wl_resource *res;
 
+   if (!client_allowed_check(data, client)) return;
+
    res = wl_resource_create(client, &wl_compositor_interface, version, id);
    wl_resource_set_implementation(res, &comp_interface, data, NULL);
 }
@@ -2595,6 +2620,7 @@ subcomp_bind(struct wl_client *client, void *data, uint32_t version, uint32_t id
 {
    struct wl_resource *res;
 
+   if (!client_allowed_check(data, client)) return;
    res = wl_resource_create(client, &wl_subcompositor_interface, version, id);
    wl_resource_set_implementation(res, &subcomp_interface, data, NULL);
 }
@@ -2932,6 +2958,7 @@ data_device_manager_bind(struct wl_client *client, void *data, uint32_t version,
 {
    struct wl_resource *res;
 
+   if (!client_allowed_check(data, client)) return;
    res = wl_resource_create(client, &wl_data_device_manager_interface, MIN(3, version), id);
    wl_resource_set_implementation(res, &data_device_manager_interface, data, NULL);
 }
@@ -2980,6 +3007,7 @@ output_bind(struct wl_client *client, void *data, uint32_t version, uint32_t id)
    Comp_Surface *cs;
    struct wl_resource *res;
 
+   if (!client_allowed_check(data, client)) return;
    res = wl_resource_create(client, &wl_output_interface, version, id);
    c->output_resources = eina_list_append(c->output_resources, res);
    wl_resource_set_implementation(res, NULL, data, output_unbind);
@@ -3403,6 +3431,7 @@ shell_bind(struct wl_client *client, void *data, uint32_t version, uint32_t id)
    struct wl_resource *res;
    Shell_Data *sd;
 
+   if (!client_allowed_check(data, client)) return;
    sd = calloc(1, sizeof(Shell_Data));
    sd->c = c;
    c->shells = eina_inlist_append(c->shells, EINA_INLIST_GET(sd));
@@ -3630,7 +3659,7 @@ seat_ptr_set_cursor(struct wl_client *client, struct wl_resource *resource, uint
    if (s->ptr.enter_serial - serial > UINT32_MAX / 2) return;
    if (surface_resource)
      cs = wl_resource_get_user_data(surface_resource);
-   if (cs && cs->role)
+   if (cs && cs->role && (!cs->cursor))
      {
         wl_resource_post_error(surface_resource,
                                WL_POINTER_ERROR_ROLE, "surface already has role");
@@ -3657,7 +3686,10 @@ seat_ptr_set_cursor(struct wl_client *client, struct wl_resource *resource, uint
                  seat_ptr_inherit(s, dev);
                ecore_evas_cursor_device_unset(ee, dev);
                if (cs)
-                 ecore_evas_object_cursor_device_set(ee, dev, cs->obj, EVAS_LAYER_MAX, x, y);
+                 {
+                    cs->role = cs->res;
+                    ecore_evas_object_cursor_device_set(ee, dev, cs->obj, EVAS_LAYER_MAX, x, y);
+                 }
             }
      }
    if (cs)
@@ -3750,6 +3782,7 @@ seat_bind(struct wl_client *client, void *data, uint32_t version, uint32_t id)
    struct wl_resource *res;
    Comp_Seat *s = data;
 
+   if (!client_allowed_check(s->c, client)) return;
    res = wl_resource_create(client, &wl_seat_interface, version, id);
    s->resources = eina_list_append(s->resources, res);
    if (s->c->active_surface)
@@ -3866,6 +3899,8 @@ comp_render_pre(Comp *c, Evas *e EINA_UNUSED, void *event_info EINA_UNUSED)
      {
         Comp_Buffer *buffer;
 //if (cs->subsurface) fprintf(stderr, "RENDER PRE\n");
+
+        comp_surface_buffer_detach(&cs->buffer[1]);
         cs->buffer[1] = cs->buffer[0];
         cs->buffer[0] = NULL;
         cs->render_queue = 0;
@@ -4742,9 +4777,10 @@ comp_mouse_in(void *data, Evas *e, Evas_Object *obj, void *event_info)
    seat_ptr_inherit(s, ev->dev);
    ecore_evas_cursor_device_unset(ecore_evas_ecore_evas_get(e), ev->dev);
    if (s->ptr.efl.obj) evas_object_hide(s->ptr.efl.obj);
-   if (s->ptr.cursor.surface)
-     ecore_evas_object_cursor_device_set(ecore_evas_ecore_evas_get(e), ev->dev,
-       s->ptr.cursor.surface->obj, EVAS_LAYER_MAX, s->ptr.cursor.x, s->ptr.cursor.y);
+   if (!s->ptr.cursor.surface) return;
+   s->ptr.cursor.surface->role = s->ptr.cursor.surface->res;
+   ecore_evas_object_cursor_device_set(ecore_evas_ecore_evas_get(e), ev->dev,
+     s->ptr.cursor.surface->obj, EVAS_LAYER_MAX, s->ptr.cursor.x, s->ptr.cursor.y);
 }
 
 static void
@@ -4801,7 +4837,11 @@ comp_mouse_out(void *data, Evas *e EINA_UNUSED, Evas_Object *obj, void *event_in
           s->ptr.efl.obj, s->ptr.efl.layer, s->ptr.efl.x, s->ptr.efl.y);
         seat_ptr_del(s, NULL, NULL, NULL);
      }
-   if (s->ptr.cursor.surface) evas_object_hide(s->ptr.cursor.surface->obj);
+   if (s->ptr.cursor.surface)
+     {
+        s->ptr.cursor.surface->role = NULL;
+        evas_object_hide(s->ptr.cursor.surface->obj);
+     }
    if ((!s->drag.res) || (!s->drag.source) || s->drag.source->proxy) return;
    if (s->drag.enter) comp_surface_send_data_device_leave(s->drag.enter, s);
    if (s->drag.surface)
@@ -4962,6 +5002,8 @@ comp_smart_del(Evas_Object *obj)
    evas_event_callback_del_full(c->evas, EVAS_CALLBACK_RENDER_PRE, (Evas_Event_Cb)comp_render_pre, c);
    evas_event_callback_del_full(c->evas, EVAS_CALLBACK_RENDER_POST, (Evas_Event_Cb)comp_render_post, c);
    efl_event_callback_array_del(c->evas, comp_device_cbs(), c);
+   ecore_event_handler_del(c->exe_handler);
+   eina_hash_free(c->exes);
    comps = eina_list_remove(comps, c);
    free(c);
    if (!comps)
@@ -5093,6 +5135,18 @@ comp_smart_init(void)
    }
 }
 
+static Eina_Bool
+exe_event_del(void *data, int t EINA_UNUSED, Ecore_Exe_Event_Del *ev)
+{
+   Comp *c = data;
+   int32_t pid = ev->pid;
+
+   if (!eina_streq(ecore_exe_tag_get(ev->exe), "__efl_wl")) return ECORE_CALLBACK_RENEW;
+
+   eina_hash_del_by_key(c->exes, &pid);
+   return ECORE_CALLBACK_RENEW;
+}
+
 # ifdef __GNUC__
 #  if __GNUC__ >= 4
 __attribute__ ((visibility("hidden")))
@@ -5153,6 +5207,11 @@ efl_wl_run(Evas_Object *obj, const char *cmd)
 
    if (!eina_streq(evas_object_type_get(obj), "comp")) abort();
    c = evas_object_smart_data_get(obj);
+   if (!c->exes)
+     c->exes = eina_hash_int32_new(NULL);
+   if (!c->exe_handler)
+     c->exe_handler =
+       ecore_event_handler_add(ECORE_EXE_EVENT_DEL, (Ecore_Event_Handler_Cb)exe_event_del, c);
    disp = getenv("DISPLAY");
    if (disp) disp = strdup(disp);
    unsetenv("DISPLAY");
@@ -5177,6 +5236,12 @@ efl_wl_run(Evas_Object *obj, const char *cmd)
      }
    free(env);
    free(disp);
+   if (exe)
+     {
+        int32_t pid = ecore_exe_pid_get(exe);
+        ecore_exe_tag_set(exe, "__efl_wl");
+        eina_hash_add(c->exes, &pid, exe);
+     }
    return exe;
 }
 
diff --git a/src/lib/elementary/efl_ui_win.c b/src/lib/elementary/efl_ui_win.c
index 63f3957dd5..f27e1a4f01 100644
--- a/src/lib/elementary/efl_ui_win.c
+++ b/src/lib/elementary/efl_ui_win.c
@@ -1460,14 +1460,17 @@ _elm_win_frame_obj_update(Efl_Ui_Win_Data *sd)
 {
    int ox, oy, ow, oh;
    int cx, cy, cw, ch;
+   int w, h;
 
    if (!sd->frame_obj) return;
    _elm_win_opaque_dirty(sd);
    _elm_win_frame_geometry_adjust(sd);
    evas_object_geometry_get(sd->frame_obj, &ox, &oy, &ow, &oh);
    edje_object_part_geometry_get(sd->frame_obj, "elm.spacer.content", &cx, &cy, &cw, &ch);
-   if (_elm_win_framespace_set(sd, cx, cy, ow - cw, oh - ch))
-     _elm_win_resize_objects_eval(sd->obj, EINA_TRUE);
+   if (!_elm_win_framespace_set(sd, cx, cy, ow - cw, oh - ch)) return;
+   _elm_win_frame_geometry_adjust(sd);
+   evas_object_geometry_get(sd->obj, NULL, NULL, &w, &h);
+   TRAP(sd, resize, w, h);
 }
 
 static void
@@ -4420,7 +4423,7 @@ _elm_win_frame_style_update(Efl_Ui_Win_Data *sd, Eina_Bool force_emit, Eina_Bool
    alpha = sd->application_alpha || sd->theme_alpha;
    borderless = sd->csd.need_borderless || (!sd->csd.need) || sd->fullscreen;
    maximized = sd->maximized;
-   shadow = sd->csd.need_shadow && (!sd->fullscreen) && (!sd->maximized);
+   shadow = sd->csd.need_shadow && (!sd->fullscreen) && (!sd->maximized) && (!borderless);
    if (alpha && borderless) shadow = 0;
 #ifdef HAVE_ELEMENTARY_WL2
    if (sd->wl.win)
diff --git a/src/modules/ecore_evas/engines/wayland/ecore_evas_wayland_common.c b/src/modules/ecore_evas/engines/wayland/ecore_evas_wayland_common.c
index df0a6bafe1..d6b6350174 100644
--- a/src/modules/ecore_evas/engines/wayland/ecore_evas_wayland_common.c
+++ b/src/modules/ecore_evas/engines/wayland/ecore_evas_wayland_common.c
@@ -1193,31 +1193,11 @@ _ecore_evas_wl_common_free(Ecore_Evas *ee)
 }
 
 static void
-_ecore_evas_wl_common_move(Ecore_Evas *ee, int x, int y)
+_ecore_evas_wl_common_move_resize(Ecore_Evas *ee, int x EINA_UNUSED, int y EINA_UNUSED, int w, int h)
 {
    LOGFN(__FILE__, __LINE__, __FUNCTION__);
 
    if (!ee) return;
-
-   ee->req.x = x;
-   ee->req.y = y;
-
-   if ((ee->x != x) || (ee->y != y))
-     {
-        ee->x = x;
-        ee->y = y;
-        if (ee->func.fn_move) ee->func.fn_move(ee);
-     }
-}
-
-static void
-_ecore_evas_wl_common_move_resize(Ecore_Evas *ee, int x, int y, int w, int h)
-{
-   LOGFN(__FILE__, __LINE__, __FUNCTION__);
-
-   if (!ee) return;
-   if ((ee->x != x) || (ee->y != y))
-     _ecore_evas_wl_common_move(ee, x, y);
    if ((ee->w != w) || (ee->h != h))
      _ecore_evas_wl_common_resize(ee, w, h);
 }
@@ -1434,27 +1414,36 @@ _ecore_evas_wl_common_name_class_set(Ecore_Evas *ee, const char *n, const char *
 static void
 _ecore_evas_wl_common_size_min_set(Ecore_Evas *ee, int w, int h)
 {
+   Ecore_Evas_Engine_Wl_Data *wdata;
    LOGFN(__FILE__, __LINE__, __FUNCTION__);
 
    if (!ee) return;
+
    if (w < 0) w = 0;
    if (h < 0) h = 0;
    if ((ee->prop.min.w == w) && (ee->prop.min.h == h)) return;
    ee->prop.min.w = w;
    ee->prop.min.h = h;
+   wdata = ee->engine.data;
+   if (wdata->win->zxdg_set_min_size && wdata->win->zxdg_toplevel)
+     wdata->win->zxdg_set_min_size(wdata->win->zxdg_toplevel, w, h);
+   _ecore_evas_wl_common_resize(ee, ee->w, ee->h);
 }
 
 static void
 _ecore_evas_wl_common_size_max_set(Ecore_Evas *ee, int w, int h)
 {
+   Ecore_Evas_Engine_Wl_Data *wdata;
    LOGFN(__FILE__, __LINE__, __FUNCTION__);
 
    if (!ee) return;
-   if (w < 0) w = 0;
-   if (h < 0) h = 0;
    if ((ee->prop.max.w == w) && (ee->prop.max.h == h)) return;
    ee->prop.max.w = w;
    ee->prop.max.h = h;
+   wdata = ee->engine.data;
+   if (wdata->win->zxdg_set_max_size && wdata->win->zxdg_toplevel)
+     wdata->win->zxdg_set_max_size(wdata->win->zxdg_toplevel, w, h);
+   _ecore_evas_wl_common_resize(ee, ee->w, ee->h);
 }
 
 static void
@@ -1468,6 +1457,7 @@ _ecore_evas_wl_common_size_base_set(Ecore_Evas *ee, int w, int h)
    if ((ee->prop.base.w == w) && (ee->prop.base.h == h)) return;
    ee->prop.base.w = w;
    ee->prop.base.h = h;
+   _ecore_evas_wl_common_resize(ee, ee->w, ee->h);
 }
 
 static void
@@ -1481,6 +1471,7 @@ _ecore_evas_wl_common_size_step_set(Ecore_Evas *ee, int w, int h)
    if ((ee->prop.step.w == w) && (ee->prop.step.h == h)) return;
    ee->prop.step.w = w;
    ee->prop.step.h = h;
+   _ecore_evas_wl_common_resize(ee, ee->w, ee->h);
 }
 
 static void
@@ -1491,6 +1482,7 @@ _ecore_evas_wl_common_aspect_set(Ecore_Evas *ee, double aspect)
    if (!ee) return;
    if (EINA_FLT_EQ(ee->prop.aspect, aspect)) return;
    ee->prop.aspect = aspect;
+   _ecore_evas_wl_common_resize(ee, ee->w, ee->h);
 }
 
 static void
@@ -2213,7 +2205,7 @@ static Ecore_Evas_Engine_Func _ecore_wl_engine_func =
    NULL, // unsticky_set
    NULL, // pre_render_set
    NULL, // post_render_set
-   _ecore_evas_wl_common_move,
+   NULL,
    NULL, // managed_move
    _ecore_evas_wl_common_resize,
    _ecore_evas_wl_common_move_resize,
@@ -2343,8 +2335,6 @@ _ecore_evas_wl_common_new_internal(const char *disp_name, unsigned int parent, i
    ee->driver = engine_name;
    if (disp_name) ee->name = strdup(disp_name);
 
-   ee->x = x;
-   ee->y = y;
    ee->w = w;
    ee->h = h;
    ee->req.x = ee->x;
diff --git a/src/modules/evas/engines/wayland_egl/evas_wl_main.c b/src/modules/evas/engines/wayland_egl/evas_wl_main.c
index 59c69c6dfb..90f3d403bf 100644
--- a/src/modules/evas/engines/wayland_egl/evas_wl_main.c
+++ b/src/modules/evas/engines/wayland_egl/evas_wl_main.c
@@ -111,7 +111,13 @@ eng_window_new(Evas_Engine_Info_Wayland *einfo, int w, int h, Render_Engine_Swap
      }
 
    if (context == EGL_NO_CONTEXT) context = gw->egl_context;
-
+   if (eglMakeCurrent(gw->egl_disp, EGL_NO_SURFACE,
+                 EGL_NO_SURFACE, gw->egl_context) == EGL_FALSE)
+     {
+        ERR("eglMakeCurrent() fail. code=%#x", eglGetError());
+        eng_window_free(gw);
+        return NULL;
+     }
    vendor = glGetString(GL_VENDOR);
    renderer = glGetString(GL_RENDERER);
    version = glGetString(GL_VERSION);
@@ -144,17 +150,8 @@ eng_window_new(Evas_Engine_Info_Wayland *einfo, int w, int h, Render_Engine_Swap
         return NULL;
      }
 
-   if (w && h)
-     eng_window_resurf(gw);
-   else
+   if (!gw->gl_context)
      {
-        if (eglMakeCurrent(gw->egl_disp, EGL_NO_SURFACE,
-                      EGL_NO_SURFACE, gw->egl_context) == EGL_FALSE)
-          {
-             ERR("eglMakeCurrent() fail. code=%#x", eglGetError());
-             eng_window_free(gw);
-             return NULL;
-          }
         eng_gl_symbols(gw->egl_disp);
 
         if (!(gw->gl_context = glsym_evas_gl_common_context_new()))
@@ -165,8 +162,9 @@ eng_window_new(Evas_Engine_Info_Wayland *einfo, int w, int h, Render_Engine_Swap
         gw->gl_context->egldisp = gw->egl_disp;
         gw->gl_context->eglctxt = gw->egl_context;
         eng_window_use(gw);
-
      }
+   if (w && h)
+     eng_window_resurf(gw);
    return gw;
 }
 

diff -Naur vlc-0.8.5/modules/codec/x264.c vlc-0.8.5-p/modules/codec/x264.c
--- vlc-0.8.5/modules/codec/x264.c	2006-05-06 17:52:19.000000000 +0200
+++ vlc-0.8.5-p/modules/codec/x264.c	2006-09-27 11:37:59.000000000 +0200
@@ -2,7 +2,7 @@
  * x264.c: h264 video encoder
  *****************************************************************************
  * Copyright (C) 2004-2006 the VideoLAN team
- * $Id: x264.c 15199 2006-04-13 09:04:34Z zorglub $
+ * $Id$
  *
  * Authors: Laurent Aimar <fenrir@via.ecp.fr>
  *
@@ -43,20 +43,20 @@
 
 #define KEYINT_TEXT N_("Maximum GOP size")
 #define KEYINT_LONGTEXT N_( "Sets maximum interval between IDR-frames." \
-  "Larger values save bits, thus improving quality for a given bitrate at " \
-  "the cost of seeking precision." )
+    "Larger values save bits, thus improving quality for a given bitrate at " \
+    "the cost of seeking precision." )
 
 #define MIN_KEYINT_TEXT N_("Minimum GOP size")
 #define MIN_KEYINT_LONGTEXT N_( "Sets minimum interval between IDR-frames. " \
     "In H.264, I-frames do not necessarily bound a closed GOP because it is " \
     "allowable for a P-frame to be predicted from more frames than just the " \
-    "one frame before it (also see frameref). Therefore, I-frames are not " \
-    "necessarily seekable. IDR-Frames restrict subsequent P-frames from " \
-    "referring to any frame prior to the IDR-Frame. \n" \
+    "one frame before it (also see reference frame option). Therefore, " \
+    "I-frames are not necessarily seekable. IDR-frames restrict subsequent " \
+    "P-frames from referring to any frame prior to the IDR-frame. \n" \
     "If scenecuts appear within this interval, they are still encoded as " \
     "I-frames, but do not start a new GOP." )
 
-#define SCENE_TEXT N_("Extra I-Frames aggressivity" )
+#define SCENE_TEXT N_("Extra I-frames aggressivity" )
 #define SCENE_LONGTEXT N_( "Scene-cut detection. Controls how " \
     "aggressively to insert extra I-frames. With small values of " \
     "scenecut, the codec often has " \
@@ -64,22 +64,20 @@
     "Good values of scenecut may find a better location for the " \
     "I-frame. Large values use more I-frames " \
     "than necessary, thus wasting bits. -1 disables scene-cut detection, so " \
-    "I-frames are be inserted only every other keyint frames, which probably " \
-    "leads to ugly encoding artifacts. (1-100)." )
+    "I-frames are inserted only every other keyint frames, which probably " \
+    "leads to ugly encoding artifacts. Range 1 to 100." )
 
 #define BFRAMES_TEXT N_("B-frames between I and P")
 #define BFRAMES_LONGTEXT N_( "Number of consecutive B-frames between I and " \
-    "P-frames. (1 to 16)" )
+    "P-frames. Range 1 to 16." )
 
-/// \bug [String] extra space
 #define B_ADAPT_TEXT N_("Adaptive B-frame decision")
 #define B_ADAPT_LONGTEXT N_( "Force the specified number of " \
-    "consecutive B-frames to be used, except possibly before an I-frame. " )
+    "consecutive B-frames to be used, except possibly before an I-frame." )
 
-/// \bug [String] extra space
 #define B_BIAS_TEXT N_("B-frames usage")
 #define B_BIAS_LONGTEXT N_( "Bias the choice to use B-frames. Positive values " \
-    "cause more B-frames, negative values cause less B-frames. " )
+    "cause more B-frames, negative values cause less B-frames." )
 
 #define BPYRAMID_TEXT N_("Keep some B-frames as references")
 #define BPYRAMID_LONGTEXT N_( "Allows B-frames to be used as references for " \
@@ -89,33 +87,36 @@
 #define CABAC_TEXT N_("CABAC")
 #define CABAC_LONGTEXT N_( "CABAC (Context-Adaptive Binary Arithmetic "\
     "Coding). Slightly slows down encoding and decoding, but should save " \
-    "10-15% bitrate." )
-/// \bug [String] Missing final dot
+    "10 to 15% bitrate." )
+
 #define REF_TEXT N_("Number of reference frames")
 #define REF_LONGTEXT N_( "Number of previous frames used as predictors. " \
     "This is effective in Anime, but seems to make little difference in " \
     "live-action source material. Some decoders are unable to deal with " \
-    "large frameref values. From 1 to 16" )
+    "large frameref values. Range 1 to 16." )
 
 #define NF_TEXT N_("Skip loop filter")
 #define NF_LONGTEXT N_( "Deactivate the deblocking loop filter (decreases quality).")
 
+#define FILTER_TEXT N_("Loop filter AlphaC0 and Beta parameters alpha:beta")
+#define FILTER_LONGTEXT N_( "Loop filter AlphaC0 and Beta parameters. " \
+    "Range -6 to 6 for both alpha and beta parameters. -6 means light " \
+    "filter, 6 means strong.")
+
 /* Ratecontrol */
 
 #define QP_TEXT N_("Set QP")
 #define QP_LONGTEXT N_( "This selects the quantizer to use. " \
     "Lower values result in better fidelity, but higher bitrates. 26 is a " \
-    "good default value. From 0 to 51. 0 means lossless" )
+    "good default value. Range 0 (lossless) to 51." )
 
-/// \bug [String] missing point
 #define CRF_TEXT N_("Quality-based VBR")
-#define CRF_LONGTEXT N_( "1-pass Quality-based VBR. From 0 to 51" )
+#define CRF_LONGTEXT N_( "1-pass Quality-based VBR. Range 0 to 51." )
 
 #define QPMIN_TEXT N_("Min QP")
-#define QPMIN_LONGTEXT N_( "Minimum quantizer, 15/35 seems to be a useful " \
-    "range." )
+#define QPMIN_LONGTEXT N_( "Minimum quantizer parameter. 15 to 35 seems to " \
+    "be a useful range." )
 
-/// \bug [String] typo ? Why doesn't it work in po ?
 #define QPMAX_TEXT N_("Max QP")
 #define QPMAX_LONGTEXT N_( "Maximum quantizer parameter." )
 
@@ -123,39 +124,41 @@
 #define QPSTEP_LONGTEXT N_( "Max QP step between frames.")
 
 #define RATETOL_TEXT N_("Average bitrate tolerance")
-#define RATETOL_LONGTEXT N_( "Allowed variance in average. " \
+#define RATETOL_LONGTEXT N_( "Allowed variance in average " \
     "bitrate (in kbits/s).")
 
 #define VBV_MAXRATE_TEXT N_("Max local bitrate")
-#define VBV_MAXRATE_LONGTEXT N_( "Sets a maximum local bitrate in kbits/s.")
+#define VBV_MAXRATE_LONGTEXT N_( "Sets a maximum local bitrate (in kbits/s).")
 
 #define VBV_BUFSIZE_TEXT N_("VBV buffer")
 #define VBV_BUFSIZE_LONGTEXT N_( "Averaging period for the maximum " \
-    "local bitrate in kbits.")
+    "local bitrate (in kbits).")
 
 #define VBV_INIT_TEXT N_("Initial VBV buffer occupancy")
 #define VBV_INIT_LONGTEXT N_( "Sets the initial buffer occupancy as a " \
-    "fraction of the buffer size.")
+    "fraction of the buffer size. Range 0.0 to 1.0.")
 
+/* IP Ratio < 1 is technically valid but should never improve quality */
 #define IPRATIO_TEXT N_("QP factor between I and P")
-#define IPRATIO_LONGTEXT N_( "QP factor between I and P.")
+#define IPRATIO_LONGTEXT N_( "QP factor between I and P. Range 1.0 to 2.0.")
 
+/* PB ratio < 1 is not valid and breaks ratecontrol */
 #define PBRATIO_TEXT N_("QP factor between P and B")
-#define PBRATIO_LONGTEXT N_( "QP factor between P and B.")
+#define PBRATIO_LONGTEXT N_( "QP factor between P and B. Range 1.0 to 2.0.")
 
 #define CHROMA_QP_OFFSET_TEXT N_("QP difference between chroma and luma")
 #define CHROMA_QP_OFFSET_LONGTEXT N_( "QP difference between chroma and luma.")
 
 #define QCOMP_TEXT N_("QP curve compression")
-#define QCOMP_LONGTEXT N_( "QP curve compression. (0.0=CBR to 1.0=QCP)")
+#define QCOMP_LONGTEXT N_( "QP curve compression. Range 0.0 (CBR) to 1.0 (QCP).")
 
 #define CPLXBLUR_TEXT N_("Reduce fluctuations in QP")
 #define CPLXBLUR_LONGTEXT N_( "This reduces the fluctuations in QP " \
-                "before curve compression. Temporally blurs complexity.")
+    "before curve compression. Temporally blurs complexity.")
 
 #define QBLUR_TEXT N_("Reduce fluctuations in QP")
 #define QBLUR_LONGTEXT N_( "This reduces the fluctations in QP " \
-                        "after curve compression. Temporally blurs quants.")
+    "after curve compression. Temporally blurs quants.")
 
 /* Analysis */
 
@@ -168,9 +171,8 @@
     " - all   : i4x4,p8x8,(i8x8),b8x8,p4x4\n" \
     "(p4x4 requires p8x8. i8x8 requires 8x8dct).")
 
-/// \bug [String] Extra space
 #define DIRECT_PRED_TEXT N_("Direct MV prediction mode")
-#define DIRECT_PRED_LONGTEXT N_( "Direct MV prediction mode. ")
+#define DIRECT_PRED_LONGTEXT N_( "Direct MV prediction mode.")
 
 #define WEIGHTB_TEXT N_("Weighted prediction for B-frames")
 #define WEIGHTB_LONGTEXT N_( "Weighted prediction for B-frames.")
@@ -185,57 +187,82 @@
 #define MERANGE_TEXT N_("Maximum motion vector search range")
 #define MERANGE_LONGTEXT N_( "Maximum distance to search for " \
     "motion estimation, measured from predicted position(s). " \
-    "Default of 16 is good for most footage, "\
-    "high motion sequences may benefit from settings between 24-32. " \
-    "From 0 to 64." )
+    "Default of 16 is good for most footage, high motion sequences may " \
+    "benefit from settings between 24 and 32. Range 0 to 64." )
 
 #define SUBME_TEXT N_("Subpixel motion estimation and partition decision " \
     "quality")
+#if X264_BUILD >= 46 /* r477 */
+#define SUBME_MAX 7
+#define SUBME_LONGTEXT N_( "This parameter controls quality versus speed " \
+    "tradeoffs involved in the motion estimation decision process " \
+    "(lower = quicker and higher = better quality). Range 1 to 7." )
+#elif X264_BUILD >= 30 /* r262 */
+#define SUBME_MAX 6
+#define SUBME_LONGTEXT N_( "This parameter controls quality versus speed " \
+    "tradeoffs involved in the motion estimation decision process " \
+    "(lower = quicker and higher = better quality). Range 1 to 6." )
+#else
+#define SUBME_MAX 5
 #define SUBME_LONGTEXT N_( "This parameter controls quality versus speed " \
     "tradeoffs involved in the motion estimation decision process " \
-    "(lower = quicker and higher = better quality). From 1 to 6." )
+    "(lower = quicker and higher = better quality). Range 1 to 5." )
+#endif
 
-#define B_RDO_TEXT N_("RD based mode decision for B-frames.")
+#define B_RDO_TEXT N_("RD based mode decision for B-frames")
 #define B_RDO_LONGTEXT N_( "RD based mode decision for B-frames. This " \
-                        "requires subme 6.")
+    "requires subme 6 (or higher).")
 
 #define MIXED_REFS_TEXT N_("Decide references on a per partition basis")
 #define MIXED_REFS_LONGTEXT N_( "Allows each 8x8 or 16x8 partition to " \
-     "independently " \
-     "select a reference frame, as opposed to only one ref per macroblock." )
+    "independently select a reference frame, as opposed to only one ref " \
+    "per macroblock." )
 
 #define CHROMA_ME_TEXT N_("Ignore chroma in motion estimation")
 #define CHROMA_ME_LONGTEXT N_( "Chroma ME for subpel and mode decision in " \
-                "P-frames.")
+    "P-frames.")
 
 #define BIME_TEXT N_("Jointly optimize both MVs in B-frames")
 #define BIME_LONGTEXT N_( "Joint bidirectional motion refinement.")
 
 #define TRANSFORM_8X8DCT_TEXT N_("Adaptive spatial transform size")
 #define TRANSFORM_8X8DCT_LONGTEXT N_( \
-        "SATD-based decision for 8x8 transform in inter-MBs.")
+    "SATD-based decision for 8x8 transform in inter-MBs.")
 
 #define TRELLIS_TEXT N_("Trellis RD quantization" )
 #define TRELLIS_LONGTEXT N_( "Trellis RD quantization: \n" \
-     " - 0: disabled\n" \
-     " - 1: enabled only on the final encode of a MB\n" \
-     " - 2: enabled on all mode decisions\n" \
-     "This requires CABAC." )
+    " - 0: disabled\n" \
+    " - 1: enabled only on the final encode of a MB\n" \
+    " - 2: enabled on all mode decisions\n" \
+    "This requires CABAC." )
 
 #define FAST_PSKIP_TEXT N_("Early SKIP detection on P-frames")
 #define FAST_PSKIP_LONGTEXT N_( "Early SKIP detection on P-frames.")
 
+#define DCT_DECIMATE_TEXT N_("Coefficient thresholding on P-frames")
+#define DCT_DECIMATE_LONGTEXT N_( "Coefficient thresholding on P-frames." \
+    "Eliminate dct blocks containing only a small single coefficient.")
+
+/* Noise reduction 1 is too weak to measure, suggest at least 10 */
 #define NR_TEXT N_("Noise reduction")
-#define NR_LONGTEXT N_( "Dct-domain noise reduction. Adaptive pseudo-deadzone.")
+#define NR_LONGTEXT N_( "Dct-domain noise reduction. Adaptive pseudo-deadzone. " \
+    "10 to 1000 seems to be a useful range." )
 
 /* Input/Output */
 
 #define ASM_TEXT N_("CPU optimizations")
 #define ASM_LONGTEXT N_( "Use assembler CPU optimizations.")
 
-#define PSNR_TEXT N_("PSNR calculation")
-#define PSNR_LONGTEXT N_( "This has no effect on actual encoding quality, "\
-    "it just prevents the stats from being calculated (for speed)." )
+#define PSNR_TEXT N_("PSNR computation")
+#define PSNR_LONGTEXT N_( "Compute and print PSNR stats. This has no effect on " \
+    "the actual encoding quality." )
+
+#define SSIM_TEXT N_("SSIM computation")
+#define SSIM_LONGTEXT N_( "Compute and print SSIM stats. This has no effect on " \
+    "the actual encoding quality." )
+
+#define QUIET_TEXT N_("Quiet mode")
+#define QUIET_LONGTEXT N_( "Quiet mode.")
 
 #define VERBOSE_TEXT N_("Statistics")
 #define VERBOSE_LONGTEXT N_( "Print stats for each frame.")
@@ -253,10 +280,17 @@
   { N_("default"), N_("none"), N_("fast"), N_("normal"),
     N_("slow"), N_("all") };
 
+#if X264_BUILD >= 45 /* r457 */
+static char *direct_pred_list[] =
+  { "", "none", "spatial", "temporal", "auto" };
+static char *direct_pred_list_text[] =
+  { N_("default"), N_("none"), N_("spatial"), N_("temporal"), N_("auto") };
+#else
 static char *direct_pred_list[] =
   { "", "none", "spatial", "temporal" };
 static char *direct_pred_list_text[] =
   { N_("default"), N_("none"), N_("spatial"), N_("temporal") };
+#endif
 
 vlc_module_begin();
     set_description( _("H.264/MPEG4 AVC encoder (using x264 library)"));
@@ -264,7 +298,7 @@
     set_callbacks( Open, Close );
     set_category( CAT_INPUT );
     set_subcategory( SUBCAT_INPUT_VCODEC );
-    
+
 /* Frame-type options */
 
     add_integer( SOUT_CFG_PREFIX "keyint", 250, NULL, KEYINT_TEXT,
@@ -306,6 +340,9 @@
               NF_LONGTEXT, VLC_FALSE );
         add_deprecated( SOUT_CFG_PREFIX "loopfilter", VLC_FALSE ); /* Deprecated since 0.8.5 */
 
+    add_string( SOUT_CFG_PREFIX "filter", "", NULL, FILTER_TEXT,
+                 FILTER_LONGTEXT, VLC_FALSE );
+
 /* Ratecontrol */
 
     add_integer( SOUT_CFG_PREFIX "qp", 26, NULL, QP_TEXT, QP_LONGTEXT,
@@ -349,11 +386,11 @@
 
     add_float( SOUT_CFG_PREFIX "ipratio", 1.40, NULL, IPRATIO_TEXT,
                IPRATIO_LONGTEXT, VLC_FALSE );
-        change_float_range( 0, 100 );
+        change_float_range( 1, 2 );
 
     add_float( SOUT_CFG_PREFIX "pbratio", 1.30, NULL, PBRATIO_TEXT,
                PBRATIO_LONGTEXT, VLC_FALSE );
-        change_float_range( 0, 100 );
+        change_float_range( 1, 2 );
 
 #if X264_BUILD >= 23 /* r190 */
     add_integer( SOUT_CFG_PREFIX "chroma-qp-offset", 0, NULL, CHROMA_QP_OFFSET_TEXT,
@@ -372,11 +409,12 @@
 
 /* Analysis */
 
-    add_string( SOUT_CFG_PREFIX "analyse", "all", NULL, ANALYSE_TEXT,
+    /* x264 analyse = none (default). set at least "normal" mode. */
+    add_string( SOUT_CFG_PREFIX "analyse", "normal", NULL, ANALYSE_TEXT,
                 ANALYSE_LONGTEXT, VLC_FALSE );
         change_string_list( enc_analyse_list, enc_analyse_list_text, 0 );
 
-    add_string( SOUT_CFG_PREFIX "direct", "temporal", NULL, DIRECT_PRED_TEXT,
+    add_string( SOUT_CFG_PREFIX "direct", "spatial", NULL, DIRECT_PRED_TEXT,
                 DIRECT_PRED_LONGTEXT, VLC_FALSE );
         change_string_list( direct_pred_list, direct_pred_list_text, 0 );
 
@@ -398,11 +436,7 @@
     add_integer( SOUT_CFG_PREFIX "subme", 5, NULL, SUBME_TEXT,
                  SUBME_LONGTEXT, VLC_FALSE );
         add_deprecated( SOUT_CFG_PREFIX "subpel", VLC_FALSE ); /* Deprecated since 0.8.5 */
-#if X264_BUILD >= 30 /* r262 */
-        change_integer_range( 1, 6 );
-#else
-        change_integer_range( 1, 5 );
-#endif
+        change_integer_range( 1, SUBME_MAX );
 
 #if X264_BUILD >= 41 /* r368 */
     add_bool( SOUT_CFG_PREFIX "b-rdo", 0, NULL, B_RDO_TEXT,
@@ -440,9 +474,15 @@
               FAST_PSKIP_LONGTEXT, VLC_FALSE );
 #endif
 
+#if X264_BUILD >= 46 /* r503 */
+    add_bool( SOUT_CFG_PREFIX "dct-decimate", 1, NULL, DCT_DECIMATE_TEXT,
+              DCT_DECIMATE_LONGTEXT, VLC_FALSE );
+#endif
+
 #if X264_BUILD >= 44 /* r398 */
     add_integer( SOUT_CFG_PREFIX "nr", 0, NULL, NR_TEXT,
                  NR_LONGTEXT, VLC_FALSE );
+        change_integer_range( 0, 1000 );
 #endif
 
 /* Input/Output */
@@ -450,10 +490,19 @@
     add_bool( SOUT_CFG_PREFIX "asm", 1, NULL, ASM_TEXT,
               ASM_LONGTEXT, VLC_FALSE );
 
-    /* x264 psnr = 1 (default). disable PSNR calculation for speed. */
+    /* x264 psnr = 1 (default). disable PSNR computation for speed. */
     add_bool( SOUT_CFG_PREFIX "psnr", 0, NULL, PSNR_TEXT,
               PSNR_LONGTEXT, VLC_FALSE );
 
+#if X264_BUILD >= 50 /* r554 */
+    /* x264 ssim = 1 (default). disable SSIM computation for speed. */
+    add_bool( SOUT_CFG_PREFIX "ssim", 0, NULL, SSIM_TEXT,
+              SSIM_LONGTEXT, VLC_FALSE );
+#endif
+
+    add_bool( SOUT_CFG_PREFIX "quiet", 0, NULL, QUIET_TEXT,
+              QUIET_LONGTEXT, VLC_FALSE );
+
 #if X264_BUILD >= 0x000e /* r81 */
     add_bool( SOUT_CFG_PREFIX "verbose", 0, NULL, VERBOSE_TEXT,
               VERBOSE_LONGTEXT, VLC_FALSE );
@@ -467,12 +516,13 @@
 static const char *ppsz_sout_options[] = {
     "8x8dct", "analyse", "asm", "bframes", "bime", "bpyramid", "b-adapt",
     "b-bias", "b-rdo", "cabac", "chroma-me", "chroma-qp-offset", "cplxblur",
-    "crf", "direct", "fast-pskip", "frameref", "ipratio", "keyint",
-    "keyint-min", "loopfilter", "me", "merange", "min-keyint", "mixed-refs",
-    "nf", "nr", "pbratio", "psnr", "qblur", "qp", "qcomp", "qpstep",
-    "qpmax", "qpmin", "qp-max", "qp-min", "ratetol", "ref", "scenecut",
-    "subme", "subpel", "tolerance", "trellis", "verbose", "vbv-bufsize",
-    "vbv-init", "vbv-maxrate", "weightb" , NULL
+    "crf", "dct-decimate", "direct", "filter", "fast-pskip", "frameref",
+    "ipratio", "keyint", "keyint-min", "loopfilter", "me", "merange",
+    "min-keyint", "mixed-refs", "nf", "nr", "pbratio", "psnr", "qblur",
+    "qp", "qcomp", "qpstep", "qpmax", "qpmin", "qp-max", "qp-min", "quiet",
+    "ratetol", "ref", "scenecut", "ssim", "subme", "subpel", "tolerance",
+    "trellis", "verbose", "vbv-bufsize", "vbv-init", "vbv-maxrate",
+    "weightb", NULL
 };
 
 static block_t *Encode( encoder_t *, picture_t * );
@@ -497,6 +547,8 @@
     encoder_sys_t *p_sys;
     vlc_value_t    val;
     int i_qmin = 0, i_qmax = 0;
+    x264_nal_t    *nal;
+    int i, i_nal;
 
     if( p_enc->fmt_out.i_codec != VLC_FOURCC( 'h', '2', '6', '4' ) &&
         !p_enc->b_force )
@@ -545,9 +597,13 @@
     /* average bitrate specified by transcode vb */
     p_sys->param.rc.i_bitrate = p_enc->fmt_out.i_bitrate / 1000;
 
+#if X264_BUILD < 48
     /* cbr = 1 overrides qp or crf and sets an average bitrate
        but maxrate = average bitrate is needed for "real" CBR */
     if( p_sys->param.rc.i_bitrate > 0 ) p_sys->param.rc.b_cbr = 1;
+#else
+    if( p_sys->param.rc.i_bitrate > 0 ) p_sys->param.rc.i_rc_method = X264_RC_ABR;
+#endif
 
     var_Get( p_enc, SOUT_CFG_PREFIX "qpstep", &val );
     if( val.i_int >= 0 && val.i_int <= 51 ) p_sys->param.rc.i_qp_step = val.i_int;
@@ -603,6 +659,15 @@
     var_Get( p_enc, SOUT_CFG_PREFIX "nf", &val );
     p_sys->param.b_deblocking_filter = !val.b_bool;
 
+    var_Get( p_enc, SOUT_CFG_PREFIX "filter", &val );
+    if( val.psz_string )
+    {
+        char *p = strchr( val.psz_string, ':' );
+        p_sys->param.i_deblocking_filter_alphac0 = atoi( val.psz_string );
+        p_sys->param.i_deblocking_filter_beta = p ? atoi( p+1 ) : p_sys->param.i_deblocking_filter_alphac0;
+        free( val.psz_string );
+    }
+
     var_Get( p_enc, SOUT_CFG_PREFIX "ipratio", &val );
     p_sys->param.rc.f_ip_factor = val.f_float;
 
@@ -623,6 +688,9 @@
     if( val.b_bool ) p_sys->param.i_log_level = X264_LOG_DEBUG;
 #endif
 
+    var_Get( p_enc, SOUT_CFG_PREFIX "quiet", &val );
+    if( val.b_bool ) p_sys->param.i_log_level = X264_LOG_NONE;
+
     var_Get( p_enc, SOUT_CFG_PREFIX "keyint", &val );
 #if X264_BUILD >= 0x000e
     if( val.i_int > 0 ) p_sys->param.i_keyint_max = val.i_int;
@@ -656,14 +724,9 @@
         p_sys->param.i_scenecut_threshold = val.i_int;
 #endif
 
-#if X264_BUILD >= 30
     var_Get( p_enc, SOUT_CFG_PREFIX "subme", &val );
-    if( val.i_int >= 1 && val.i_int <= 6 )
+    if( val.i_int >= 1 && val.i_int <= SUBME_MAX )
         p_sys->param.analyse.i_subpel_refine = val.i_int;
-#else
-    if( val.i_int >= 1 && val.i_int <= 5 )
-        p_sys->param.analyse.i_subpel_refine = val.i_int;
-#endif
 
 #if X264_BUILD >= 24
     var_Get( p_enc, SOUT_CFG_PREFIX "me", &val );
@@ -703,11 +766,22 @@
     {
         p_sys->param.analyse.i_direct_mv_pred = X264_DIRECT_PRED_TEMPORAL;
     }
+#if X264_BUILD >= 45 /* r457 */
+    else if( !strcmp( val.psz_string, "auto" ) )
+    {
+        p_sys->param.analyse.i_direct_mv_pred = X264_DIRECT_PRED_AUTO;
+    }
+#endif
     if( val.psz_string ) free( val.psz_string );
 
     var_Get( p_enc, SOUT_CFG_PREFIX "psnr", &val );
     p_sys->param.analyse.b_psnr = val.b_bool;
 
+#if X264_BUILD >= 50 /* r554 */
+    var_Get( p_enc, SOUT_CFG_PREFIX "ssim", &val );
+    p_sys->param.analyse.b_ssim = val.b_bool;
+#endif
+
 #if X264_BUILD >= 0x0012
     var_Get( p_enc, SOUT_CFG_PREFIX "weightb", &val );
     p_sys->param.analyse.b_weighted_bipred = val.b_bool;
@@ -736,8 +810,13 @@
 
 #if X264_BUILD >= 37
     var_Get( p_enc, SOUT_CFG_PREFIX "crf", &val ); 
-    if( val.i_int >= 0 && val.i_int <= 51 ) /* crf != 0 overrides qp */
+    if( val.i_int > 0 && val.i_int <= 51 )
+    {
         p_sys->param.rc.i_rf_constant = val.i_int;
+#if X264_BUILD >= 48
+        p_sys->param.rc.i_rc_method = X264_RC_CRF;
+#endif
+    }
 #endif
 
 #if X264_BUILD >= 39
@@ -763,7 +842,13 @@
 
 #if X264_BUILD >= 44
     var_Get( p_enc, SOUT_CFG_PREFIX "nr", &val );
-    p_sys->param.analyse.i_noise_reduction = val.i_int;
+    if( val.i_int >= 0 && val.i_int <= 1000 )
+        p_sys->param.analyse.i_noise_reduction = val.i_int;
+#endif
+
+#if X264_BUILD >= 46
+    var_Get( p_enc, SOUT_CFG_PREFIX "dct-decimate", &val );
+    p_sys->param.analyse.b_dct_decimate = val.b_bool;
 #endif
 
     var_Get( p_enc, SOUT_CFG_PREFIX "asm", &val );
@@ -854,6 +939,9 @@
     }
 
 #if X264_BUILD >= 29
+    /* As of r543 x264 will autodetect the number of cpus and will set
+       the number of threads accordingly unless ofcourse the number of
+       threads is explicitly specified... */
     if( p_enc->i_threads >= 1 )
         p_sys->param.i_threads = p_enc->i_threads;
 #endif
@@ -870,7 +958,6 @@
     p_enc->fmt_out.i_extra = 0;
     p_enc->fmt_out.p_extra = NULL;
 
-#if 0
     x264_encoder_headers( p_sys->h, &nal, &i_nal );
     for( i = 0; i < i_nal; i++ )
     {
@@ -885,7 +972,6 @@
 
         p_enc->fmt_out.i_extra += i_size;
     }
-#endif
 
     return VLC_SUCCESS;
 }

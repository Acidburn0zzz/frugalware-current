# HG changeset patch
# User root@xen-trw1.amd.com
# Node ID 3bad8977e840a96f5d2c153059778458ce1d8cd0
# Parent  6a8a7123916e3e2d611f0ba606d4002feb3a8a05
Add flag to indicate that an exception event needs injecting, and to delay
the ext interrupt injection.
Remove unnecessary check of RFLAGS.IF for ExtInt injection.

Index: xen-3.0.3-testing/xen/arch/x86/hvm/svm/intr.c
===================================================================
--- xen-3.0.3-testing.orig/xen/arch/x86/hvm/svm/intr.c
+++ xen-3.0.3-testing/xen/arch/x86/hvm/svm/intr.c
@@ -62,7 +62,7 @@ static inline int svm_inject_extint(stru
 //  printf( "IRQ = %d\n", trap );
     return 0;
 }
-
+    
 asmlinkage void svm_intr_assist(void) 
 {
     struct vcpu *v = current;
@@ -74,7 +74,6 @@ asmlinkage void svm_intr_assist(void) 
     int intr_type = APIC_DM_EXTINT;
     int intr_vector = -1;
     int re_injecting = 0;
-    unsigned long rflags;
 
     ASSERT(vmcb);
 
@@ -82,12 +81,19 @@ asmlinkage void svm_intr_assist(void) 
     /* Previous Interrupt delivery caused this Intercept? */
     if (vmcb->exitintinfo.fields.v && (vmcb->exitintinfo.fields.type == 0)) {
         v->arch.hvm_svm.saved_irq_vector = vmcb->exitintinfo.fields.vector;
-//           printk("Injecting PF#: saving IRQ from ExitInfo\n");
         vmcb->exitintinfo.bytes = 0;
         re_injecting = 1;
     }
 
     /*
+     * If event requires injecting then do not inject int.
+     */
+    if (unlikely(v->arch.hvm_svm.inject_event)) {
+        v->arch.hvm_svm.inject_event = 0;
+        return;
+    }
+
+    /*
      * create a 'fake' virtual interrupt on to intercept as soon
      * as the guest _can_ take interrupts
      */
@@ -97,14 +103,6 @@ asmlinkage void svm_intr_assist(void) 
         return;
     }
 
-    /* Guest's interrputs masked? */
-    rflags = vmcb->rflags;
-    if (irq_masked(rflags)) {
-        HVM_DBG_LOG(DBG_LEVEL_1, "Guest IRQs masked: rflags: %lx", rflags);
-        /* bail out, we won't be injecting an interrupt this time */
-        return;
-    }
-    
     /* Previous interrupt still pending? */
     if (vmcb->vintr.fields.irq) {
 //        printk("Re-injecting IRQ from Vintr\n");
@@ -157,7 +155,6 @@ asmlinkage void svm_intr_assist(void) 
             /* let's inject this interrupt */
             TRACE_3D(TRC_VMX_INT, v->domain->domain_id, intr_vector, 0);
             svm_inject_extint(v, intr_vector);
-            hvm_interrupt_post(v, intr_vector, intr_type);
             break;
         case APIC_DM_SMI:
         case APIC_DM_NMI:
@@ -168,6 +165,7 @@ asmlinkage void svm_intr_assist(void) 
             BUG();
             break;
         }
+        hvm_interrupt_post(v, intr_vector, intr_type);
     }
 }
 
Index: xen-3.0.3-testing/xen/arch/x86/hvm/svm/svm.c
===================================================================
--- xen-3.0.3-testing.orig/xen/arch/x86/hvm/svm/svm.c
+++ xen-3.0.3-testing/xen/arch/x86/hvm/svm/svm.c
@@ -196,6 +196,7 @@ static inline void svm_inject_exception(
     ASSERT(vmcb->eventinj.fields.v == 0);
     
     vmcb->eventinj = event;
+    v->arch.hvm_svm.inject_event=1;
 }
 
 static void stop_svm(void)
@@ -2581,7 +2582,7 @@ asmlinkage void svm_vmexit_handler(struc
     save_svm_cpu_user_regs(v, regs);
 
     vmcb->tlb_control = 1;
-
+    v->arch.hvm_svm.inject_event = 0;
 
     if (exit_reason == VMEXIT_INVALID)
     {
Index: xen-3.0.3-testing/xen/include/asm-x86/hvm/svm/vmcb.h
===================================================================
--- xen-3.0.3-testing.orig/xen/include/asm-x86/hvm/svm/vmcb.h
+++ xen-3.0.3-testing/xen/include/asm-x86/hvm/svm/vmcb.h
@@ -484,6 +484,7 @@ struct arch_svm_struct {
     u32                 *msrpm;
     u64                 vmexit_tsc; /* tsc read at #VMEXIT. for TSC_OFFSET */
     int                 saved_irq_vector;
+    u32                 inject_event;
     u32                 launch_core;
     u32                 asid_core;
     

# HG changeset patch
# User root@xenhog02.amd.com
# Node ID 72ba2378d87ffb48458d2ae4a85a5b2643785790
# Parent  e6155cc09f4ac9cece2c43f945d35ae18bed0b81
signal guest's ability to take interrupt using VMEXIT_VINTR

This patch uses the VINTR intercept to signal the hypervisor when a
guest can take an interrupt.  When guest's interrupts are masked by
EFLAGS.IF or the guests are in an interrupt shadow, we create a 'fake'
virtual interrupt to inject while also enabling the VINTR intercept.
When the guest _can_ take interrupts, the hypervisor will #VMEXIT on 
VINTR.  The VINTR exit handler then clears the VINTR intercept bit and 
clears the V_IRQ bit so that svm_intr_assist() can inject a legitimate 
interrupt.

Index: xen-3.0.3-testing/xen/arch/x86/hvm/svm/intr.c
===================================================================
--- xen-3.0.3-testing.orig/xen/arch/x86/hvm/svm/intr.c
+++ xen-3.0.3-testing/xen/arch/x86/hvm/svm/intr.c
@@ -43,7 +43,7 @@
  * to be suitable for SVM.
  */
 
-static inline int svm_inject_extint(struct vcpu *v, int trap, int error_code)
+static inline int svm_inject_extint(struct vcpu *v, int trap)
 {
     struct vmcb_struct *vmcb = v->arch.hvm_svm.vmcb;
     vintr_t intr;
@@ -87,6 +87,16 @@ asmlinkage void svm_intr_assist(void) 
         re_injecting = 1;
     }
 
+    /*
+     * create a 'fake' virtual interrupt on to intercept as soon
+     * as the guest _can_ take interrupts
+     */
+    if (irq_masked(vmcb->rflags) || vmcb->interrupt_shadow) {
+        vmcb->general1_intercepts |= GENERAL1_INTERCEPT_VINTR;
+        svm_inject_extint(v, 0x0); /* actual vector doesn't really matter */
+        return;
+    }
+
     /* Guest's interrputs masked? */
     rflags = vmcb->rflags;
     if (irq_masked(rflags)) {
@@ -146,7 +156,7 @@ asmlinkage void svm_intr_assist(void) 
             }
             /* let's inject this interrupt */
             TRACE_3D(TRC_VMX_INT, v->domain->domain_id, intr_vector, 0);
-            svm_inject_extint(v, intr_vector, VMX_DELIVER_NO_ERROR_CODE);
+            svm_inject_extint(v, intr_vector);
             hvm_interrupt_post(v, intr_vector, intr_type);
             break;
         case APIC_DM_SMI:
Index: xen-3.0.3-testing/xen/arch/x86/hvm/svm/svm.c
===================================================================
--- xen-3.0.3-testing.orig/xen/arch/x86/hvm/svm/svm.c
+++ xen-3.0.3-testing/xen/arch/x86/hvm/svm/svm.c
@@ -2794,6 +2794,11 @@ asmlinkage void svm_vmexit_handler(struc
         svm_inject_exception(v, TRAP_double_fault, 1, 0);
         break;
 
+    case VMEXIT_VINTR:
+	vmcb->vintr.fields.irq = 0;
+	vmcb->general1_intercepts &= ~GENERAL1_INTERCEPT_VINTR;
+	break;
+
     case VMEXIT_INTR:
         break;
 

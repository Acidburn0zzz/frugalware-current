diff -ur virtualbox-ose_1.5.6/r0drv/linux/the-linux-kernel.h virtualbox-ose/r0drv/linux/the-linux-kernel.h
--- src/VBox/Runtime/r0drv/linux/the-linux-kernel.h	2008-02-23 11:10:06.000000000 +0100
+++ src/VBox/Runtime/r0drv/linux/the-linux-kernel.h	2008-02-27 01:57:20.000000000 +0100
@@ -225,12 +225,16 @@
 #undef bool
 
 /*
- * There are post-2.6.24 kernels (confusingly with unchanged version number)
- * which eliminate macros which were marked as deprecated.
+ * The 2.6.25 kernel eliminates macros that were marked as deprecated and eliminates
+ * routine change_page_attr() in favor of the set_pages_* API.
  */
 #ifndef __attribute_used__
 #define __attribute_used__ __used
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+int change_page_attr(struct page *page, int numpages, pgprot_t prot);
+#endif
+
 #endif
 
diff -ur virtualbox-ose_1.5.6/linux/SUPDrv-linux.c virtualbox-ose/linux/SUPDrv-linux.c
--- src/VBox/HostDrivers/Support/linux/SUPDrv-linux.c	2008-02-23 11:10:05.000000000 +0100
+++ src/VBox/HostDrivers/Support/linux/SUPDrv-linux.c	2008-02-27 01:54:17.000000000 +0100
@@ -2069,6 +2069,17 @@
 /* GCC C++ hack. */
 unsigned __gxx_personality_v0 = 0xcccccccc;
 
+/* Add the change_page_attr routine for kernels 2.6.25 or later */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+int change_page_attr(struct page *page, int numpages, pgprot_t prot)
+{
+	/* use the set_pages_* API */
+	if (pgprot_val(prot) & _PAGE_NX)
+		set_pages_nx(page, numpages);
+	set_pages_uc(page, numpages);
+	return 0;
+}
+#endif
 
 module_init(VBoxSupDrvInit);
 module_exit(VBoxSupDrvUnload);
Index: src/VBox/Additions/linux/sharedfolders/vfsmod.c
===================================================================
--- src/VBox/Additions/linux/sharedfolders/vfsmod.c	(revision 7549)
+++ src/VBox/Additions/linux/sharedfolders/vfsmod.c	(revision 7550)
@@ -224,7 +224,11 @@
         sb->s_blocksize = 1024;
         sb->s_op = &sf_super_ops;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (2, 4, 25)
+        iroot = iget_locked (sb, 0);
+#else
         iroot = iget (sb, 0);
+#endif
         if (!iroot) {
                 err = -ENOMEM;  /* XXX */
                 LogFunc(("could not get root inode\n"));
@@ -234,6 +238,10 @@
         sf_init_inode (sf_g, iroot, &fsinfo);
         SET_INODE_INFO (iroot, sf_i);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (2, 4, 25)
+        unlock_new_inode(iroot);
+#endif
+
         droot = d_alloc_root (iroot);
         if (!droot) {
                 err = -ENOMEM;  /* XXX */
@@ -296,10 +304,12 @@
    the only thing that is known about inode at this point is its index
    hence we can't do anything here, and let lookup/whatever with the
    job to properly fill then [inode] */
+#if LINUX_VERSION_CODE < KERNEL_VERSION (2, 6, 25)
 static void
 sf_read_inode (struct inode *inode)
 {
 }
+#endif
 
 /* vfs is done with [sb] (umount called) call [sf_glob_free] to unmap
    the folder and free [sf_g] */
@@ -337,7 +347,9 @@
 
 static struct super_operations sf_super_ops = {
         .clear_inode = sf_clear_inode,
+#if LINUX_VERSION_CODE < KERNEL_VERSION (2, 6, 25)
         .read_inode  = sf_read_inode,
+#endif
         .put_super   = sf_put_super,
         .statfs      = sf_statfs,
         .remount_fs  = sf_remount_fs
Index: src/VBox/Additions/linux/sharedfolders/dirops.c
===================================================================
--- src/VBox/Additions/linux/sharedfolders/dirops.c	(revision 7549)
+++ src/VBox/Additions/linux/sharedfolders/dirops.c	(revision 7550)
@@ -291,7 +291,11 @@
                 }
 
                 ino = iunique (parent->i_sb, 1);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (2, 4, 25)
+                inode = iget_locked (parent->i_sb, ino);
+#else
                 inode = iget (parent->i_sb, ino);
+#endif
                 if (!inode) {
                         LogFunc(("iget failed\n"));
                         err = -ENOMEM;          /* XXX: ??? */
@@ -301,6 +305,10 @@
                 SET_INODE_INFO (inode, sf_new_i);
                 sf_init_inode (sf_g, inode, &fsinfo);
                 sf_new_i->path = path;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (2, 4, 25)
+                unlock_new_inode(inode);
+#endif
         }
 
         sf_i->force_restat = 0;
@@ -342,7 +350,11 @@
         }
 
         ino = iunique (parent->i_sb, 1);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (2, 4, 25)
+        inode = iget_locked (parent->i_sb, ino);
+#else
         inode = iget (parent->i_sb, ino);
+#endif
         if (!inode) {
                 LogFunc(("iget failed.  caller=%s\n", caller));
                 err = -ENOMEM;
@@ -358,6 +370,11 @@
         sf_new_i->force_restat = 1;
 
         d_instantiate (dentry, inode);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (2, 4, 25)
+                unlock_new_inode(inode);
+#endif
+
         return 0;
 
  fail1:

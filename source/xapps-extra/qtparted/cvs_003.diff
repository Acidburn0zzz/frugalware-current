diff -Naur qtparted-0.4.5.orig/src/main.cpp qtparted-0.4.5/src/main.cpp
--- qtparted-0.4.5.orig/src/main.cpp	2005-07-06 23:29:54.000000000 +0200
+++ qtparted-0.4.5/src/main.cpp	2005-10-15 12:58:31.000000000 +0200
@@ -1,22 +1,22 @@
 /*
-    qtparted - a frontend to libparted for manipulating disk partitions
-    Copyright (C) 2002-2003 Vanni Brutto
+	qtparted - a frontend to libparted for manipulating disk partitions
+	Copyright (C) 2002-2003 Vanni Brutto
 
-    Vanni Brutto <zanac (-at-) libero dot it>
+	Vanni Brutto <zanac (-at-) libero dot it>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
 /* About main.cpp
@@ -50,14 +50,14 @@
 
 void print_usage(const char *program_name) {
 	cout << "Usage: " << program_name << " [OPTION]..." << endl
-	     << "A nice QT GUI for libparted" << endl << endl
-	     << "Options used by qtparted:" << endl
-	     << "  -l, --log=value       use 1 to enable log, 0 for disable it." << endl
-	     << "                        [default = 1])" << endl
-	     << "  -h, --help            Show this usage message" << endl
-	     << endl << endl
-	     << program_name << " by Zanac copyright 2003, (C) 2005 Ark Linux" << endl
-	     << "Send bug reports to bero@arklinux.org" << endl;
+		 << "A nice QT GUI for libparted" << endl << endl
+		 << "Options used by qtparted:" << endl
+		 << "  -l, --log=value	   use 1 to enable log, 0 for disable it." << endl
+		 << "						[default = 1])" << endl
+		 << "  -h, --help			Show this usage message" << endl
+		 << endl << endl
+		 << program_name << " by Zanac copyright 2003, (C) 2005 Ark Linux" << endl
+		 << "Send bug reports to bero@arklinux.org" << endl;
 	exit(EXIT_SUCCESS);
 }
 
@@ -69,108 +69,106 @@
 // from another QWS application (OPIE, Ark Linux installer, .....) - so we
 // add a configure option to turn it off...
 #if defined(Q_WS_QWS) && !defined(QWS_CLIENT) // Frame Buffer
-    QApplication app(argc, argv, QApplication::GuiServer);
+	QApplication app(argc, argv, QApplication::GuiServer);
 #else // X11
-    QApplication app(argc, argv);
+	QApplication app(argc, argv);
 #endif // Q_WS_QWS
 
-    /*---program name ;)---*/
-    const char *program_name = argv[0];
+	/*---program name ;)---*/
+	const char *program_name = argv[0];
 
-    int next_option;
+	int next_option;
 
-    /*---Flag log on/off, default 1 = on---*/
-    int iLog = 1;
+	/*---Flag log on/off, default 1 = on---*/
+	int iLog = 1;
 
-    /*---valid short options---*/
-    const char *const short_options = "hl:";
-
-    /*---valid long options---*/
-    const struct option long_options[] = {
-        { "help",    0, NULL, 'h' },
-        { "log",     1, NULL, 'l' },
-        { NULL,      0, NULL, 0   } // end of getopt array
-    };
-
-    do {
-        next_option = getopt_long(argc, 
-                                  argv, 
-                                  short_options, 
-                                  long_options, 
-                                  NULL);
-
-        switch (next_option) {
-            case 'h': // -h ... --help
-                print_usage(program_name);
-                break;
-                
-            case 'l': // -l ... --log
-                if (!sscanf(optarg, "%d", &iLog)) {
-                    printf("You must specify a numeric value.\n"
-                           "Parameter \"%s\" is not valid for --log\n\n", optarg);
-                    print_usage(program_name);
-                }
-                
-                if ((iLog != 0) && (iLog != 1)) {
-                    printf("You must use 1/0 to set log on/off.\n"
-                           "Parameter \"%s\" is not valid for --log\n\n", optarg);
-                    print_usage(program_name);
-                }
-
-                break;
-                
-            case '?': // opzione invalida :(
-                print_usage(program_name);
-
-            case -1:  // opzioni concluse
-                break;
-
-            default:  // errore! inaspettato pure!
-                abort();
-        }
-    } while (next_option != -1);
-
-    /*---install translation file for application strings---*/
-    QTranslator *translator = new QTranslator(0);
-    translator->load(QString(DATADIR "/locale/qtparted_") + QString(QTextCodec::locale()));
-    app.installTranslator(translator);
-
-    /*---initialize the debug system---*/
-    if (iLog) g_debug.open();
-    showDebug("QtParted debug logfile (http://qtparted.sf.net) version %s\n---------\n", VERSION);
-
-    /*---check the Parted version---*/
-    if (!QP_LibParted::checkForParted())
-        return EXIT_FAILURE;
-
-    /*---check if the kernel support devfs---*/
-    isDevfsEnabled();
-
-    QP_Settings settings;
-
-    mainwindow = new QP_MainWindow(&settings, 0, "QP_MainWindow");
-    app.setMainWidget(mainwindow);
-
-    QSplashScreen *splash=new QSplashScreen(QPixmap(DATADIR "/pics/qtp_splash.png"), Qt::WType_Modal | Qt::WStyle_Customize | Qt::WStyle_NoBorder | Qt::WDestructiveClose);
-    splash->connect(mainwindow, SIGNAL(sigSplashInfo(const QString &)),
-                    SLOT(message(const QString &)));
-    splash->finish(mainwindow);
-    splash->show();
+	/*---valid short options---*/
+	const char *const short_options = "hl:";
+
+	/*---valid long options---*/
+	const struct option long_options[] = {
+		{ "help",	0, NULL, 'h' },
+		{ "log",	 1, NULL, 'l' },
+		{ NULL,	  0, NULL, 0   } // end of getopt array
+	};
+
+	do {
+		next_option = getopt_long(argc, 
+					  argv, 
+					  short_options, 
+					  long_options, 
+					  NULL);
+
+		switch (next_option) {
+		case 'h': // -h ... --help
+			print_usage(program_name);
+			break;
+
+		case 'l': // -l ... --log
+			if (!sscanf(optarg, "%d", &iLog)) {
+				printf("You must specify a numeric value.\n"
+					   "Parameter \"%s\" is not valid for --log\n\n", optarg);
+				print_usage(program_name);
+			}
+
+			if ((iLog != 0) && (iLog != 1)) {
+				printf("You must use 1/0 to set log on/off.\n"
+				       "Parameter \"%s\" is not valid for --log\n\n", optarg);
+				print_usage(program_name);
+			}
+			break;
+				
+		case '?': // opzione invalida :(
+			print_usage(program_name);
+
+		case -1:  // opzioni concluse
+			break;
+
+		default:  // errore! inaspettato pure!
+			abort();
+		}
+	} while (next_option != -1);
+
+	/*---install translation file for application strings---*/
+	QTranslator *translator = new QTranslator(0);
+	translator->load(QString(DATADIR "/locale/qtparted_") + QString(QTextCodec::locale()));
+	app.installTranslator(translator);
+
+	/*---initialize the debug system---*/
+	if (iLog) g_debug.open();
+	showDebug("QtParted debug logfile (http://qtparted.sf.net) version %s\n---------\n", VERSION);
+
+	/*---check the Parted version---*/
+	if (!QP_LibParted::checkForParted())
+		return EXIT_FAILURE;
+
+	/*---check if the kernel support devfs---*/
+	isDevfsEnabled();
+
+	QP_Settings settings;
+
+	mainwindow = new QP_MainWindow(&settings, 0, "QP_MainWindow");
+	app.setMainWidget(mainwindow);
+
+	QSplashScreen *splash=new QSplashScreen(QPixmap(DATADIR "/pics/qtp_splash.png"), Qt::WType_Modal | Qt::WStyle_Customize | Qt::WStyle_NoBorder | Qt::WDestructiveClose);
+	splash->connect(mainwindow, SIGNAL(sigSplashInfo(const QString &)),
+			SLOT(message(const QString &)));
+	splash->finish(mainwindow);
+	splash->show();
 
-    mainwindow->init();
+	mainwindow->init();
 
 #ifdef Q_WS_QWS // Frame Buffer
-    mainwindow->showMaximized();
+	mainwindow->showMaximized();
 #endif // Q_WS_QWS
 
+	mainwindow->show();
 
-    mainwindow->show();
+	bool rc = app.exec();
 
-    bool rc = app.exec();
+	delete mainwindow;
 
-    delete mainwindow;
+	if (iLog) g_debug.close();
 
-    if (iLog) g_debug.close();
-
-    return rc;
+	return rc;
 }
diff -Naur qtparted-0.4.5.orig/src/qp_actlist.cpp qtparted-0.4.5/src/qp_actlist.cpp
--- qtparted-0.4.5.orig/src/qp_actlist.cpp	2004-04-17 12:14:15.000000000 +0200
+++ qtparted-0.4.5/src/qp_actlist.cpp	2005-10-15 12:35:30.000000000 +0200
@@ -28,775 +28,753 @@
 #include "statistics.h"
 
 /*---type (move+resize), num, start, end---*/
-QP_ActListItem::QP_ActListItem(QTParted::actType action,
-                               int num,
-                               PedSector start,
-                               PedSector end,
-                               PedGeometry geom,
-                               PedPartitionType part_type) {
-    showDebug("%s", "actlistitem::actlistitem, move/resize\n");
-
-    _action = action;
-    _num = num;
-    _start = start;
-    _end = end;
-    _geom = geom;
-    _part_type = part_type;
+QP_ActListItem::QP_ActListItem(QTParted::actType action, int num,
+                               PedSector start, PedSector end,
+                               PedGeometry geom, PedPartitionType part_type)
+                              :_action(action),_num(num),_start(start),
+                               _end(end),_geom(geom),_part_type(part_type)
+{
+	showDebug("%s", "actlistitem::actlistitem, move/resize\n");
 }
 
 /*---type, num---*/
-QP_ActListItem::QP_ActListItem(QTParted::actType action,
-                               int num) {
-    showDebug("%s", "actlistitem::actlistitem, rm\n");
-
-    _action = action;
-    _num = num;
+QP_ActListItem::QP_ActListItem(QTParted::actType action, int num)
+	:_action(action),_num(num)
+{
+	showDebug("%s", "actlistitem::actlistitem, rm\n");
 }
 
-QP_ActListItem::QP_ActListItem(QTParted::actType action,
-                               int num,
-                               bool status) {
-    showDebug("%s", "actlistitem::actlistitem, active\n");
-
-    _action = action;
-    _num = num;
-    _status = status;
+QP_ActListItem::QP_ActListItem(QTParted::actType action, int num, bool status)
+	:_action(action),_num(num),_status(status)
+{
+	showDebug("%s", "actlistitem::actlistitem, active\n");
 }
 
 /*---for format! :)---*/
 QP_ActListItem::QP_ActListItem(QTParted::actType action,
-                               int num,
-                               QP_FileSystemSpec *fsspec,
-                               QString label,
-                               PedGeometry geom,
-                               PedPartitionType part_type) {
-    showDebug("%s", "actlistitem::actlistitem, mkfs\n");
-
-    _action = action;
-    _num = num;
-    _fsspec = fsspec;
-    _label = label;
-    _geom = geom;
-    _part_type = part_type;
+			   int num,
+			   QP_FileSystemSpec *fsspec,
+			   QString label,
+			   PedGeometry geom,
+			   PedPartitionType part_type)
+			:_action(action),_num(num),_fsspec(fsspec)
+			,_label(label),_geom(geom),_part_type(part_type)
+{
+	showDebug("%s", "actlistitem::actlistitem, mkfs\n");
 }
 
 /*---type, logical/extended, start, end, typoFS, label---*/
 QP_ActListItem::QP_ActListItem(QTParted::actType action,
-                               QTParted::partType type,
-                               PedSector start,
-                               PedSector end,
-                               QP_FileSystemSpec *fsspec,
-                               QString label,
-                               PedGeometry geom,
-                               PedPartitionType part_type) {
-    showDebug("%s", "actlistitem::actlistitem, mkpartfs\n");
-
-    _action = action;
-    _type = type;
-    _start = start;
-    _end = end;
-    _fsspec = fsspec;
-    _label = label;
-    _geom = geom;
-    _part_type = part_type;
-}
-
-QP_ActionList::QP_ActionList(QP_LibParted *libparted) {
-    showDebug("%s", "actionlist::actionlist\n");
-
-    /*---prevent from memory leak: when list are cleared destroy actlistitem object!---*/
-    actlist.setAutoDelete(true);
-
-    /*---prevent from memory leak: when list are cleared destroy partinfo object!---*/
-    orig_logilist.setAutoDelete(true);
-    orig_partlist.setAutoDelete(true);
-
-
-    PedDisk *disk;
-    _libparted = libparted;
-
-    /*---save of the original device state---*/
-    disk = ped_disk_new(_libparted->dev);
-    if (!disk) {
-        showDebug("%s", "actionlist::actionlist, ped_disk_new ko\n");
-        
-        QString label = QString(tr("Critical error during ped_disk_new!"));
-        QMessageBox::information(NULL, PROG_NAME, label);
-
-        return ;
-    }
-
-    listdisk.append(disk);
-
-    /*---make a backup of the disk (we will use this)---*/
-    _disk = ped_disk_duplicate(disk);
-    if (!_disk) {
-        showDebug("%s", "actionlist::actionlist, ped_disk_duplicate ko\n");
-        ped_disk_destroy(disk);
-        listdisk.removeLast();
-        disk = NULL;
-        
-        QString label = QString(tr("Critical error during ped_disk_duplicate!"));
-        QMessageBox::information(NULL, PROG_NAME, label);
+			 QTParted::partType type,
+			 PedSector start,
+			 PedSector end,
+			 QP_FileSystemSpec *fsspec,
+			 QString label,
+			 PedGeometry geom,
+			 PedPartitionType part_type)
+			:_action(action), _type(type), _start(start)
+			,_end(end), _fsspec(fsspec), _label(label)
+			,_geom(geom), _part_type(part_type)
+{
+	showDebug("%s", "actlistitem::actlistitem, mkpartfs\n");
+}
+
+QP_ActionList::QP_ActionList(QP_LibParted *libparted):_libparted(libparted)
+{
+	showDebug("%s", "actionlist::actionlist\n");
+
+	/*---prevent from memory leak: when list are cleared destroy actlistitem object!---*/
+	actlist.setAutoDelete(true);
+
+	/*---prevent from memory leak: when list are cleared destroy partinfo object!---*/
+	orig_logilist.setAutoDelete(true);
+	orig_partlist.setAutoDelete(true);
+
+
+	PedDisk *disk;
+
+	/*---save of the original device state---*/
+	disk = ped_disk_new(_libparted->dev);
+	if (!disk) {
+		showDebug("%s", "actionlist::actionlist, ped_disk_new ko\n");
+		
+		QString label = QString(tr("Critical error during ped_disk_new!"));
+		QMessageBox::information(NULL, PROG_NAME, label);
 
-        return ;
-    }
+		return ;
+	}
+
+	listdisk.append(disk);
+
+	/*---make a backup of the disk (we will use this)---*/
+	_disk = ped_disk_duplicate(disk);
+	if (!_disk) {
+		showDebug("%s", "actionlist::actionlist, ped_disk_duplicate ko\n");
+		ped_disk_destroy(disk);
+		listdisk.removeLast();
+		disk = NULL;
+		
+		QString label = QString(tr("Critical error during ped_disk_duplicate!"));
+		QMessageBox::information(NULL, PROG_NAME, label);
+
+		return ;
+	}
 
-    /*---make the partlist of the disk---*/
-    scan_partitions();
+	/*---make the partlist of the disk---*/
+	scan_partitions();
 }
 
 QP_ActionList::~QP_ActionList() {
-    showDebug("%s", "actionlist::~actionlist\n");
+	showDebug("%s", "actionlist::~actionlist\n");
 
-    actlist.clear();
-    orig_logilist.clear();
-    orig_partlist.clear();
-    
+	actlist.clear();
+	orig_logilist.clear();
+	orig_partlist.clear();
+	
 }
 
 void QP_ActionList::update_listpartitions() {
-    showDebug("%s", "actionlist::update_listpartitions\n");
+	showDebug("%s", "actionlist::update_listpartitions\n");
 
-    /*---initialize active partition---*/
-    _partActive = NULL;
+	/*---initialize active partition---*/
+	_partActive = NULL;
 
-    logilist.clear();
-    partlist.clear();
+	logilist.clear();
+	partlist.clear();
 
-    _libparted->has_extended = false;
+	_libparted->has_extended = false;
 
 
-    /*---look if exist a partition in orig_list that match with the partitions into disk device---*/
-    PedConstraint* constraint = NULL;
+	/*---look if exist a partition in orig_list that match with the partitions into disk device---*/
+	PedConstraint* constraint = NULL;
 	PedPartition*	part = NULL;
 	for (part = ped_disk_next_partition(disk(), NULL); part;
-	     part = ped_disk_next_partition(disk(), part)) {
+		 part = ped_disk_next_partition(disk(), part)) {
 
-        if (part->type & PED_PARTITION_METADATA)
-            continue;
+		if (part->type & PED_PARTITION_METADATA)
+			continue;
 
-        QP_PartInfo *found = NULL;
-        
-        /*---if not freespace...*/
-        if (!(part->type & PED_PARTITION_FREESPACE)) {
-            /*---loop for all partition of the disk---*/
-            QP_PartInfo *p;
-            for (p = (QP_PartInfo*)orig_partlist.first(); p; p = (QP_PartInfo*)orig_partlist.next()) {
-                if (p->type != QTParted::extended) {
-                    if ((p->_geometry.start == part->geom.start)
-                    &&  (p->_geometry.end == part->geom.end)
-                    &&  (p->_geometry.length == part->geom.length)) {
-                        found = p;
-                    }
-                } else {
-                    QP_PartInfo *logi;
-                    /*---loop for every logical partitions---*/
-                    for (logi = (QP_PartInfo*)orig_logilist.first(); logi; logi = (QP_PartInfo*)orig_logilist.next()) {
-                        if ((logi->_geometry.start == part->geom.start)
-                        &&  (logi->_geometry.end == part->geom.end)
-                        &&  (logi->_geometry.length == part->geom.length)) {
-                            found = logi;
-                        }
-                    }
-                }
-            }
-        }
-
-        showDebug("%s", "actionlist::update_listpartitions, looked if partition was in orig_logilist\n");
-
-        QP_PartInfo *partinfo;
-        if (found) {
-            showDebug("%s", "actionlist::update_listpartitions, partition matched!\n");
-            partinfo = new QP_PartInfo();
-            partinfo->start = found->start;
-            partinfo->end = found->end;
-            partinfo->_geometry = found->_geometry;
-            partinfo->setDevice(found->device());
-            partinfo->min_size = found->min_size;
-            partinfo->_label = found->_label;
-            partinfo->_free = found->_free;
-            partinfo->_unknow = found->_unknow;
-            partinfo->_libparted = found->_libparted;
-            partinfo->_active = found->_active;
-            partinfo->_canBeActive = found->_canBeActive;
-            partinfo->_canBeHidden = found->_canBeHidden;
-            partinfo->_virtual = found->_virtual;
-            partinfo->fsspec = found->fsspec;
-        } else {
-            showDebug("%s", "actionlist::update_listpartitions, partition missmatched!\n");
-            partinfo = new QP_PartInfo();
-            partinfo->start = part->geom.start;
-            partinfo->end = part->geom.end;
-            partinfo->_geometry = part->geom;
-            partinfo->setDevice(_libparted->_qpdevice);
-            partinfo->min_size = -1;
-            partinfo->_label = QString::null;
-            partinfo->_free = _libparted->filesystem->free();
-            partinfo->_unknow = _libparted->filesystem->unknow();
-            partinfo->_libparted = _libparted;
-            partinfo->_active = false;
-            partinfo->_canBeActive = false;
-            partinfo->_canBeHidden = false;
-            partinfo->_virtual = false;
-
-
-            const char *part_filesystem = part->fs_type ? part->fs_type->name : "";
-            if (part->type & PED_PARTITION_FREESPACE) {
-                partinfo->fsspec = _libparted->filesystem->free();
-            } else {
-                partinfo->fsspec = _libparted->filesystem->nameToFSSpec(part_filesystem); //fat16, fat32 etc etc
-            }
-        }
-
-        //'cause the number can change use ALWAYS the right PedPartition number!
-        partinfo->num = part->num;
-        
-        if (part->type & PED_PARTITION_LOGICAL)
-            partinfo->type = QTParted::logical;
-        else if (part->type & PED_PARTITION_EXTENDED) {
-            partinfo->type = QTParted::extended;
-            _libparted->has_extended = true;
-        }
-        else partinfo->type = QTParted::primary;
-
-
-        showDebug("%s", "actionlist::update_listpartitions, get partitions flags\n");
-
-        //---get how much the partition can grow at left and at right
-        //---get also if the partiton is "active"
-        //---of course do all this stuff only if this is not freespace ;)
-        //FIXME: t_start/t_end if the partition is free? is right?
-        if (!partinfo->isFree()) {
-            constraint = ped_constraint_any(_libparted->dev);
-            PedGeometry *geometry = ped_disk_get_max_partition_geometry(disk(), part, constraint);
-            if (geometry != NULL) {
-                partinfo->t_start = geometry->start;
-                partinfo->t_end = geometry->end;
-            } else {
-                partinfo->t_start = -1;
-                partinfo->t_end = -1;
-            }
-
-            /*---get if the partition is active---*/
-            partition_get_flags(partinfo, part);
-        }
-
-        showDebug("%s", "actionlist::update_listpartitions, get partition infos\n");
-
-        /*---compare if the partition has not committed... and if so update
-         *   some field (ie filesystem, and active flag, to reflect the change that
-         *   use made on listchart but that are not saved on the disk!---*/
-        get_partinfo(partinfo, part);
-
-        /*---if this is a virtual partition do not show how space fill the device---*/
-        if (partinfo->isVirtual()) {
-            partinfo->min_size = -1;
-        }
-
-        showDebug("%s", "actionlist::update_listpartitions, append the partition to partlist\n");
-        if (partinfo->type == QTParted::logical)
-             logilist.append(partinfo);
-        else partlist.append(partinfo);
+		QP_PartInfo *found = NULL;
+		
+		/*---if not freespace...*/
+		if (!(part->type & PED_PARTITION_FREESPACE)) {
+			/*---loop for all partition of the disk---*/
+			QP_PartInfo *p;
+			for (p = (QP_PartInfo*)orig_partlist.first(); p; p = (QP_PartInfo*)orig_partlist.next()) {
+				if (p->type != QTParted::extended) {
+					if ((p->_geometry.start == part->geom.start)
+					&&  (p->_geometry.end == part->geom.end)
+					&&  (p->_geometry.length == part->geom.length)) {
+						found = p;
+					}
+				} else {
+					QP_PartInfo *logi;
+					/*---loop for every logical partitions---*/
+					for (logi = (QP_PartInfo*)orig_logilist.first(); logi; logi = (QP_PartInfo*)orig_logilist.next()) {
+						if ((logi->_geometry.start == part->geom.start)
+						&&  (logi->_geometry.end == part->geom.end)
+						&&  (logi->_geometry.length == part->geom.length)) {
+							found = logi;
+						}
+					}
+				}
+			}
+		}
+
+		showDebug("%s", "actionlist::update_listpartitions, looked if partition was in orig_logilist\n");
+
+		QP_PartInfo *partinfo;
+		if (found) {
+			showDebug("%s", "actionlist::update_listpartitions, partition matched!\n");
+			partinfo = new QP_PartInfo();
+			partinfo->start = found->start;
+			partinfo->end = found->end;
+			partinfo->_geometry = found->_geometry;
+			partinfo->setDevice(found->device());
+			partinfo->min_size = found->min_size;
+			partinfo->_label = found->_label;
+			partinfo->_free = found->_free;
+			partinfo->_unknow = found->_unknow;
+			partinfo->_libparted = found->_libparted;
+			partinfo->_active = found->_active;
+			partinfo->_canBeActive = found->_canBeActive;
+			partinfo->_canBeHidden = found->_canBeHidden;
+			partinfo->_virtual = found->_virtual;
+			partinfo->fsspec = found->fsspec;
+		} else {
+			showDebug("%s", "actionlist::update_listpartitions, partition missmatched!\n");
+			partinfo = new QP_PartInfo();
+			partinfo->start = part->geom.start;
+			partinfo->end = part->geom.end;
+			partinfo->_geometry = part->geom;
+			partinfo->setDevice(_libparted->_qpdevice);
+			partinfo->min_size = -1;
+			partinfo->_label = QString::null;
+			partinfo->_free = _libparted->filesystem->free();
+			partinfo->_unknow = _libparted->filesystem->unknow();
+			partinfo->_libparted = _libparted;
+			partinfo->_active = false;
+			partinfo->_canBeActive = false;
+			partinfo->_canBeHidden = false;
+			partinfo->_virtual = false;
+
+
+			const char *part_filesystem = part->fs_type ? part->fs_type->name : "";
+			if (part->type & PED_PARTITION_FREESPACE) {
+				partinfo->fsspec = _libparted->filesystem->free();
+			} else {
+				partinfo->fsspec = _libparted->filesystem->nameToFSSpec(part_filesystem); //fat16, fat32 etc etc
+			}
+		}
+
+		//'cause the number can change use ALWAYS the right PedPartition number!
+		partinfo->num = part->num;
+		
+		if (part->type & PED_PARTITION_LOGICAL)
+			partinfo->type = QTParted::logical;
+		else if (part->type & PED_PARTITION_EXTENDED) {
+			partinfo->type = QTParted::extended;
+			_libparted->has_extended = true;
+		}
+		else partinfo->type = QTParted::primary;
+
+
+		showDebug("%s", "actionlist::update_listpartitions, get partitions flags\n");
+
+		//---get how much the partition can grow at left and at right
+		//---get also if the partiton is "active"
+		//---of course do all this stuff only if this is not freespace ;)
+		//FIXME: t_start/t_end if the partition is free? is right?
+		if (!partinfo->isFree()) {
+			constraint = ped_constraint_any(_libparted->dev);
+			PedGeometry *geometry = ped_disk_get_max_partition_geometry(disk(), part, constraint);
+			if (geometry != NULL) {
+				partinfo->t_start = geometry->start;
+				partinfo->t_end = geometry->end;
+			} else {
+				partinfo->t_start = -1;
+				partinfo->t_end = -1;
+			}
+
+			/*---get if the partition is active---*/
+			partition_get_flags(partinfo, part);
+		}
+
+		showDebug("%s", "actionlist::update_listpartitions, get partition infos\n");
+
+		/*---compare if the partition has not committed... and if so update
+		 *   some field (ie filesystem, and active flag, to reflect the change that
+		 *   use made on listchart but that are not saved on the disk!---*/
+		get_partinfo(partinfo, part);
+
+		/*---if this is a virtual partition do not show how space fill the device---*/
+		if (partinfo->isVirtual()) {
+			partinfo->min_size = -1;
+		}
+
+		showDebug("%s", "actionlist::update_listpartitions, append the partition to partlist\n");
+		if (partinfo->type == QTParted::logical)
+			 logilist.append(partinfo);
+		else partlist.append(partinfo);
 
-    }
+	}
 
 }
 
 void QP_ActionList::scan_partitions() {
-    showDebug("%s", "actionlist::scan_partitions\n");
+	showDebug("%s", "actionlist::scan_partitions\n");
 
-    /*---initialize active partition---*/
-    _partActive = NULL;
+	/*---initialize active partition---*/
+	_partActive = NULL;
 
-    orig_logilist.clear();
-    orig_partlist.clear();
+	orig_logilist.clear();
+	orig_partlist.clear();
 
-    PedConstraint *constraint = NULL;
+	PedConstraint *constraint = NULL;
 	PedPartition *part = NULL;
 	for (part = ped_disk_next_partition(disk(), NULL); part;
-	     part = ped_disk_next_partition(disk(), part)) {
+		 part = ped_disk_next_partition(disk(), part)) {
+
+		if (part->type & PED_PARTITION_METADATA)
+			continue;
+
+		showDebug("%s", "actionlist::scan_partitions, create a new partinfo\n");
+		QP_PartInfo *partinfo = new QP_PartInfo();
+		partinfo->start = part->geom.start;
+		partinfo->end = part->geom.end;
+		partinfo->_geometry = part->geom;
+		partinfo->num = part->num;
+		partinfo->setDevice(_libparted->_qpdevice);
+		partinfo->min_size = -1;
+		partinfo->_label = QString::null;
+		partinfo->_free = _libparted->filesystem->free();
+		partinfo->_unknow = _libparted->filesystem->unknow();
+		partinfo->_libparted = _libparted;
+		partinfo->_active = false;
+		partinfo->_canBeActive = false;
+		partinfo->_canBeHidden = false;
+		partinfo->_virtual = false;
+
+		if (part->type & PED_PARTITION_LOGICAL)
+			partinfo->type = QTParted::logical;
+		else if (part->type & PED_PARTITION_EXTENDED) {
+			partinfo->type = QTParted::extended;
+		}
+		else partinfo->type = QTParted::primary;
+						 
+		const char *part_filesystem = part->fs_type ? part->fs_type->name : "";
+
+		if (part->type & PED_PARTITION_FREESPACE) {
+			partinfo->fsspec = _libparted->filesystem->free();
+			partinfo->t_start = -1;
+			partinfo->t_end = -1;
+		} else {
+			showDebug("%s", "actionlist::scan_partitions, get partinfo flags\n");
+			/*---get if the partition is active---*/
+			partition_get_flags(partinfo, part);
+
+			showDebug("%s", "actionlist::scan_partitions, get partinfo fsspec\n");
+			partinfo->fsspec = _libparted->filesystem->nameToFSSpec(part_filesystem); //fat16, fat32 etc etc
+
+			//---get how much the partition can grow at left and at right, but only if the partition is not free space!
+			constraint = ped_constraint_any(_libparted->dev);
+			PedGeometry *geometry =
+				ped_disk_get_max_partition_geometry(disk(), part, constraint);
+			if (geometry != NULL) {
+				partinfo->t_start = geometry->start;
+				partinfo->t_end = geometry->end;
+			} else {
+				partinfo->t_start = -1;
+				partinfo->t_end = -1;
+			}
+		}
+
+		showDebug("%s", "actionlist::scan_partitions, append partinfo to orig_partlist\n");
+
+		if (partinfo->type == QTParted::logical)
+			 orig_logilist.append(partinfo);
+		else orig_partlist.append(partinfo);
+	}
+
 
-        if (part->type & PED_PARTITION_METADATA)
-            continue;
 
-        showDebug("%s", "actionlist::scan_partitions, create a new partinfo\n");
-        QP_PartInfo *partinfo = new QP_PartInfo();
-        partinfo->start = part->geom.start;
-        partinfo->end = part->geom.end;
-        partinfo->_geometry = part->geom;
-        partinfo->num = part->num;
-        partinfo->setDevice(_libparted->_qpdevice);
-        partinfo->min_size = -1;
-        partinfo->_label = QString::null;
-        partinfo->_free = _libparted->filesystem->free();
-        partinfo->_unknow = _libparted->filesystem->unknow();
-        partinfo->_libparted = _libparted;
-        partinfo->_active = false;
-        partinfo->_canBeActive = false;
-        partinfo->_canBeHidden = false;
-        partinfo->_virtual = false;
-
-        if (part->type & PED_PARTITION_LOGICAL)
-            partinfo->type = QTParted::logical;
-        else if (part->type & PED_PARTITION_EXTENDED) {
-            partinfo->type = QTParted::extended;
-        }
-        else partinfo->type = QTParted::primary;
-                         
-        const char *part_filesystem = part->fs_type ? part->fs_type->name : "";
-
-        if (part->type & PED_PARTITION_FREESPACE) {
-            partinfo->fsspec = _libparted->filesystem->free();
-            partinfo->t_start = -1;
-            partinfo->t_end = -1;
-        } else {
-            showDebug("%s", "actionlist::scan_partitions, get partinfo flags\n");
-            /*---get if the partition is active---*/
-            partition_get_flags(partinfo, part);
-
-            showDebug("%s", "actionlist::scan_partitions, get partinfo fsspec\n");
-            partinfo->fsspec = _libparted->filesystem->nameToFSSpec(part_filesystem); //fat16, fat32 etc etc
-
-            //---get how much the partition can grow at left and at right, but only if the partition is not free space!
-            constraint = ped_constraint_any(_libparted->dev);
-            PedGeometry *geometry =
-                ped_disk_get_max_partition_geometry(disk(), part, constraint);
-            if (geometry != NULL) {
-                partinfo->t_start = geometry->start;
-                partinfo->t_end = geometry->end;
-            } else {
-                partinfo->t_start = -1;
-                partinfo->t_end = -1;
-            }
-        }
-
-        showDebug("%s", "actionlist::scan_partitions, append partinfo to orig_partlist\n");
-
-        if (partinfo->type == QTParted::logical)
-             orig_logilist.append(partinfo);
-        else orig_partlist.append(partinfo);
-    }
-
-
-
-    /*---count how partition are in the disk---*/
-    int totPart = orig_partlist.count() + orig_logilist.count();
-
-    showDebug("%s", "actionlist::scan_partitions, loop into orig_partlist\n");
-
-    /*---loop for all partition of the disk---*/
-    QP_PartInfo *p;
-    int i = 0;
-    for (p = (QP_PartInfo*)orig_partlist.first(); p; p = (QP_PartInfo*)orig_partlist.next()) {
-        if (p->type != QTParted::extended) {
-            i++;
-            if (!p->isFree()) {
-                /*---emit a signal for update the progressbar---*/
-                _libparted->_message = QString(tr("Getting info about partition %1."))
-                                   .arg(p->partname());
-                _libparted->emitSigTimer(i*100/totPart, _libparted->message(), QString::null);
-
-                /*---get info about this primary partition---*/
-                part = ped_disk_get_partition(disk(), p->num);
-                if (part) get_partfilesystem_info(part, p);
-                else showDebug("%s", "actionlist::scan_partitions, get_partfilesystem_info ko\n");
-
-                /*---get the label of this primary partition---*/
-                if (part) get_partfilesystem_label(part, p);
-                else showDebug("%s", "actionlist::scan_partitions, get_partfilesystem_label ko\n");
-            }
-        } else {
-            QP_PartInfo *logi;
-            /*---loop for every logical partitions---*/
-            for (logi = (QP_PartInfo*)orig_logilist.first(); logi; logi = (QP_PartInfo*)orig_logilist.next()) {
-                i++;
-                if (!logi->isFree()) {
-                    /*---emit a signal for update the progressbar---*/
-                    _libparted->_message = QString(tr("Getting info about partition %1."))
-                                       .arg(logi->partname());
-                    _libparted->emitSigTimer(i*100/totPart, _libparted->message(), QString::null);
-                
-                    /*---get info about this logical partition---*/
-                    part = ped_disk_get_partition(disk(), logi->num);
-                    if (part) get_partfilesystem_info(part, logi);
-                    else showDebug("%s", "actionlist::scan_partitions, get_partfilesystem_info ko\n");
-
-                    /*---get the label of this logical partition---*/
-                    if (part) get_partfilesystem_label(part, logi);
-                    else showDebug("%s", "actionlist::scan_partitions, get_partfilesystem_label ko\n");
-                }
-            }
-        }
-    }
-    
-    _libparted->emitSigTimer(100, _libparted->message(), QString::null);
+	/*---count how partition are in the disk---*/
+	int totPart = orig_partlist.count() + orig_logilist.count();
+
+	showDebug("%s", "actionlist::scan_partitions, loop into orig_partlist\n");
+
+	/*---loop for all partition of the disk---*/
+	QP_PartInfo *p;
+	int i = 0;
+	for (p = (QP_PartInfo*)orig_partlist.first(); p; p = (QP_PartInfo*)orig_partlist.next()) {
+		if (p->type != QTParted::extended) {
+			i++;
+			if (!p->isFree()) {
+				/*---emit a signal for update the progressbar---*/
+				_libparted->_message = QString(tr("Getting info about partition %1."))
+								   .arg(p->partname());
+				_libparted->emitSigTimer(i*100/totPart, _libparted->message(), QString::null);
+
+				/*---get info about this primary partition---*/
+				part = ped_disk_get_partition(disk(), p->num);
+				if (part) get_partfilesystem_info(part, p);
+				else showDebug("%s", "actionlist::scan_partitions, get_partfilesystem_info ko\n");
+
+				/*---get the label of this primary partition---*/
+				if (part) get_partfilesystem_label(part, p);
+				else showDebug("%s", "actionlist::scan_partitions, get_partfilesystem_label ko\n");
+			}
+		} else {
+			QP_PartInfo *logi;
+			/*---loop for every logical partitions---*/
+			for (logi = (QP_PartInfo*)orig_logilist.first(); logi; logi = (QP_PartInfo*)orig_logilist.next()) {
+				i++;
+				if (!logi->isFree()) {
+					/*---emit a signal for update the progressbar---*/
+					_libparted->_message = QString(tr("Getting info about partition %1."))
+									   .arg(logi->partname());
+					_libparted->emitSigTimer(i*100/totPart, _libparted->message(), QString::null);
+				
+					/*---get info about this logical partition---*/
+					part = ped_disk_get_partition(disk(), logi->num);
+					if (part) get_partfilesystem_info(part, logi);
+					else showDebug("%s", "actionlist::scan_partitions, get_partfilesystem_info ko\n");
+
+					/*---get the label of this logical partition---*/
+					if (part) get_partfilesystem_label(part, logi);
+					else showDebug("%s", "actionlist::scan_partitions, get_partfilesystem_label ko\n");
+				}
+			}
+		}
+	}
+	
+	_libparted->emitSigTimer(100, _libparted->message(), QString::null);
 }
 
 bool QP_ActionList::get_partfilesystem_info(PedPartition *part, QP_PartInfo *partinfo) {
-    showDebug("%s", "actionlist::get_partfilesystem_info\n");
+	showDebug("%s", "actionlist::get_partfilesystem_info\n");
+
+	/*---if the partition is virtual (ie change not committed) we cannot determinate
+	 *   how much the filesystem is fill---*/
+	if (partinfo->_virtual) {
+		partinfo->min_size = -1;
+		return true;
+	}
 
-    /*---if the partition is virtual (ie change not committed) we cannot determinate
-     *   how much the filesystem is fill---*/
-    if (partinfo->_virtual) {
-        partinfo->min_size = -1;
-        return true;
-    }
-
-    /*---is the filesystem supported by parted?---*/
-    PedFileSystem *fs = ped_file_system_open(&part->geom);
-    if (!fs) {
-        /*---exist a wrapper for min_size?---*/
-        if (partinfo->fswrap() && partinfo->fsspec->fswrap()->wrap_min_size) {
-            /*---get the min_size from the wrapper---*/
-            partinfo->min_size = partinfo->fsspec->fswrap()->min_size(partinfo->partname());
-            if (partinfo->min_size > (partinfo->end-partinfo->start)) partinfo->min_size=partinfo->end-partinfo->start;
-	}
-        else
-            /*---get the min_size from space_stats (that is a "df" wrapper)---*/
-            partinfo->min_size = space_stats(partinfo);
-
-        return true;
-    }
-
-    /*---get the minimum filesystem size---*/
-    PedConstraint *resize_constraint = ped_file_system_get_resize_constraint(fs);
-    if (resize_constraint) {
-        partinfo->min_size = resize_constraint->min_size;
-        ped_constraint_destroy (resize_constraint);
-    }
+	/*---is the filesystem supported by parted?---*/
+	PedFileSystem *fs = ped_file_system_open(&part->geom);
+	if (!fs) {
+		/*---exist a wrapper for min_size?---*/
+		if (partinfo->fswrap() && partinfo->fsspec->fswrap()->wrap_min_size) {
+			/*---get the min_size from the wrapper---*/
+			partinfo->min_size = partinfo->fsspec->fswrap()->min_size(partinfo->partname());
+			if (partinfo->min_size > (partinfo->end-partinfo->start)) partinfo->min_size=partinfo->end-partinfo->start;
+	}
+		else
+			/*---get the min_size from space_stats (that is a "df" wrapper)---*/
+			partinfo->min_size = space_stats(partinfo);
 
-    ped_file_system_close(fs);
+		return true;
+	}
+
+	/*---get the minimum filesystem size---*/
+	PedConstraint *resize_constraint = ped_file_system_get_resize_constraint(fs);
+	if (resize_constraint) {
+		partinfo->min_size = resize_constraint->min_size;
+		ped_constraint_destroy (resize_constraint);
+	}
 
-    return true;
+	ped_file_system_close(fs);
+
+	return true;
 }
 
 bool QP_ActionList::get_partfilesystem_label(PedPartition *part, QP_PartInfo *partinfo) {
-    if (partinfo->_virtual)
-        return true;
+	if (partinfo->_virtual)
+		return true;
 
-    partinfo->_label = QP_FSWrap::get_label(part, partinfo->fsspec->name());
+	partinfo->_label = QP_FSWrap::get_label(part, partinfo->fsspec->name());
 
-    return true;
+	return true;
 }
 
 void QP_ActionList::ins_resize(int num,
-                               PedSector start,
-                               PedSector end,
-                               PedGeometry geom,
-                               PedPartitionType part_type) {
-    showDebug("%s", "actionlist::ins_resize\n");
-    
-    QP_ActListItem *actlistitem = new QP_ActListItem(QTParted::resize, num, start, end,
-                                                     geom, part_type);
-    actlist.append(actlistitem);
+							   PedSector start,
+							   PedSector end,
+							   PedGeometry geom,
+							   PedPartitionType part_type) {
+	showDebug("%s", "actionlist::ins_resize\n");
+	
+	QP_ActListItem *actlistitem = new QP_ActListItem(QTParted::resize, num, start, end,
+													 geom, part_type);
+	actlist.append(actlistitem);
 
-    ins_newdisk();
+	ins_newdisk();
 }
 
 void QP_ActionList::ins_move(int num,
-                             PedSector start,
-                             PedSector end,
-                             PedGeometry geom,
-                             PedPartitionType part_type) {
-    showDebug("%s", "actionlist::ins_move\n");
-    
-    QP_ActListItem *actlistitem = new QP_ActListItem(QTParted::move, num, start, end,
-                                                     geom, part_type);
-    actlist.append(actlistitem);
+							 PedSector start,
+							 PedSector end,
+							 PedGeometry geom,
+							 PedPartitionType part_type) {
+	showDebug("%s", "actionlist::ins_move\n");
+	
+	QP_ActListItem *actlistitem = new QP_ActListItem(QTParted::move, num, start, end,
+													 geom, part_type);
+	actlist.append(actlistitem);
 
-    ins_newdisk();
+	ins_newdisk();
 }
 
 void QP_ActionList::ins_rm(int num) {
-    showDebug("%s", "actionlist::ins_rm\n");
+	showDebug("%s", "actionlist::ins_rm\n");
 
-    QP_ActListItem *actlistitem = new QP_ActListItem(QTParted::rm, num);
-    actlist.append(actlistitem);
+	QP_ActListItem *actlistitem = new QP_ActListItem(QTParted::rm, num);
+	actlist.append(actlistitem);
 
-    ins_newdisk();
+	ins_newdisk();
 }
 
 void QP_ActionList::ins_mkfs(QP_FileSystemSpec *fsspec, int num, QString label, PedGeometry geom, PedPartitionType part_type) {
-    showDebug("%s", "actionlist::ins_mkfs\n");
+	showDebug("%s", "actionlist::ins_mkfs\n");
 
-    QP_ActListItem *actlistitem = new QP_ActListItem(QTParted::format, num, fsspec, label, geom, part_type);
-    actlist.append(actlistitem);
+	QP_ActListItem *actlistitem = new QP_ActListItem(QTParted::format, num, fsspec, label, geom, part_type);
+	actlist.append(actlistitem);
 
-    ins_newdisk();
+	ins_newdisk();
 }
 
 void QP_ActionList::ins_mkpart(QTParted::partType type,
-                               PedSector start,
-                               PedSector end,
-                               QP_FileSystemSpec *fsspec,
-                               QString label,
-                               PedGeometry geom,
-                               PedPartitionType part_type) {
-    showDebug("%s", "actionlist::ins_mkpart\n");
-
-    QP_ActListItem *actlistitem = new QP_ActListItem(QTParted::create, type,
-                                                     start, end, fsspec, label, geom, part_type);
-    actlist.append(actlistitem);
+							   PedSector start,
+							   PedSector end,
+							   QP_FileSystemSpec *fsspec,
+							   QString label,
+							   PedGeometry geom,
+							   PedPartitionType part_type) {
+	showDebug("%s", "actionlist::ins_mkpart\n");
+
+	QP_ActListItem *actlistitem = new QP_ActListItem(QTParted::create, type,
+													 start, end, fsspec, label, geom, part_type);
+	actlist.append(actlistitem);
 
-    ins_newdisk();
+	ins_newdisk();
 }
 
 void QP_ActionList::ins_active(int num, bool active) {
-    showDebug("%s", "actionlist::ins_active\n");
-    
-    QP_ActListItem *actlistitem = new QP_ActListItem(QTParted::active, num, active);
-    actlist.append(actlistitem);
+	showDebug("%s", "actionlist::ins_active\n");
+	
+	QP_ActListItem *actlistitem = new QP_ActListItem(QTParted::active, num, active);
+	actlist.append(actlistitem);
 
-    ins_newdisk();
+	ins_newdisk();
 }
 
 void QP_ActionList::ins_hidden(int num, bool hidden) {
-    showDebug("%s", "actionlist::ins_hidden\n");
-    
-    QP_ActListItem *actlistitem = new QP_ActListItem(QTParted::hidden, num, hidden);
-    actlist.append(actlistitem);
+	showDebug("%s", "actionlist::ins_hidden\n");
+	
+	QP_ActListItem *actlistitem = new QP_ActListItem(QTParted::hidden, num, hidden);
+	actlist.append(actlistitem);
 
-    ins_newdisk();
+	ins_newdisk();
 }
 
 void QP_ActionList::get_partinfo(QP_PartInfo *partinfo, PedPartition *part) {
-    showDebug("%s", "actionlist::get_partinfo\n");
+	showDebug("%s", "actionlist::get_partinfo\n");
 
-    /*---loop for every action saved---*/
-    QP_ActListItem *pl;
-    for (pl = (QP_ActListItem *)actlist.first(); pl; pl = (QP_ActListItem *)actlist.next()) {
-        /*---if you saved a mkpart (Create) and the geometry match... man: we have a virtual!---*/
-        if ((pl->_action == QTParted::create)
-        ||  (pl->_action == QTParted::resize)
-        ||  (pl->_action == QTParted::move)
-        ||  (pl->_action == QTParted::format)) {
-            if ((part->geom.start == pl->_geom.start)
-            &&  (part->geom.end == pl->_geom.end)
-            &&  (part->geom.length == pl->_geom.length)
-            &&  (part->type == pl->_part_type)) {
-                partinfo->_virtual = true;
-
-                if (pl->_action == QTParted::create) partinfo->fsspec = pl->_fsspec;
-                if (pl->_action == QTParted::format) partinfo->fsspec = pl->_fsspec;
-            }
-        }
-    }
+	/*---loop for every action saved---*/
+	QP_ActListItem *pl;
+	for (pl = (QP_ActListItem *)actlist.first(); pl; pl = (QP_ActListItem *)actlist.next()) {
+		/*---if you saved a mkpart (Create) and the geometry match... man: we have a virtual!---*/
+		if ((pl->_action == QTParted::create)
+		||  (pl->_action == QTParted::resize)
+		||  (pl->_action == QTParted::move)
+		||  (pl->_action == QTParted::format)) {
+			if ((part->geom.start == pl->_geom.start)
+			&&  (part->geom.end == pl->_geom.end)
+			&&  (part->geom.length == pl->_geom.length)
+			&&  (part->type == pl->_part_type)) {
+				partinfo->_virtual = true;
+
+				if (pl->_action == QTParted::create) partinfo->fsspec = pl->_fsspec;
+				if (pl->_action == QTParted::format) partinfo->fsspec = pl->_fsspec;
+			}
+		}
+	}
 }
 
 bool QP_ActionList::canUndo() {
-    return (listdisk.first() != listdisk.last());
+	return (listdisk.first() != listdisk.last());
 }
 
 void QP_ActionList::undo() {
-    showDebug("%s", "actionlist::undo\n");
+	showDebug("%s", "actionlist::undo\n");
 
-    /*---destroy the state of the disk in this moment---*/
-    ped_disk_destroy(_disk);
+	/*---destroy the state of the disk in this moment---*/
+	ped_disk_destroy(_disk);
 
-    /*---undo last operation---*/
-    PedDisk *disk = (PedDisk *)listdisk.last();
-    ped_disk_destroy(disk);
-    listdisk.removeLast();
+	/*---undo last operation---*/
+	PedDisk *disk = (PedDisk *)listdisk.last();
+	ped_disk_destroy(disk);
+	listdisk.removeLast();
 
-    /*---restore last state---*/
-    _disk = ped_disk_duplicate((PedDisk *)listdisk.last()); //FIXME: if !_disk :(
-    if (!_disk) showDebug("%s", "actionlist::undo, ped_disk_duplicate ko\n");
+	/*---restore last state---*/
+	_disk = ped_disk_duplicate((PedDisk *)listdisk.last()); //FIXME: if !_disk :(
+	if (!_disk) showDebug("%s", "actionlist::undo, ped_disk_duplicate ko\n");
 
-    /*---remove last operation---*/
-    actlist.removeLast();
+	/*---remove last operation---*/
+	actlist.removeLast();
 
-    /*---the state of the disk... is of course changed---*/
-    emit sigDiskChanged();
+	/*---the state of the disk... is of course changed---*/
+	emit sigDiskChanged();
 }
 
 void QP_ActionList::commit() {
-    showDebug("%s", "actionlist::commit\n");
+	showDebug("%s", "actionlist::commit\n");
+
+	//messageState, used to keep "error message" returned by libparted
+	QString messageState = QString::null;
+	
+	/*---undo all disk state---*/
+	while (listdisk.first() != listdisk.last()) {
+		PedDisk *disk = (PedDisk *)listdisk.last();
+		ped_disk_destroy(disk);
+		listdisk.removeLast();
+	}
+	_disk = ped_disk_duplicate((PedDisk *)listdisk.first());
+	if (!_disk) showDebug("%s", "actionlist::commit, ped_disk_duplicate ko\n");
+	
+	/*---commit the operations in "batch" mode---*/
+	_libparted->setWrite(true);
+
+	bool rc = true;
+	
+	//counter of how much operations are done!
+	int i = 0;
+	int iTotAct = actlist.count() + 1;
+		
+	QP_ActListItem *pl;
+	for (pl = (QP_ActListItem *)actlist.first(); pl; pl = (QP_ActListItem *)actlist.next()) {
+		showDebug("%s", "actionlist::commit, loop for commit\n");
+	
+		//---mkpart commit---
+		if (pl->_action == QTParted::create) {
+			showDebug("%s", "actionlist::commit, want to commit a create\n");
+			emit sigOperations(tr("Creating partition."), messageState, i++, iTotAct);
+			if (!_libparted->mkpartfs(pl->_type, pl->_fsspec, pl->_start, pl->_end, pl->_label)) {
+				messageState = _libparted->message();
+				rc = false;
+			}
+		}
+		//---rm commit---
+		else if (pl->_action == QTParted::rm) {
+			showDebug("%s", "actionlist::commit, want to commit a rm\n");
+			emit sigOperations(tr("Preparation for removing a partition."), messageState, i++, iTotAct);
+			scan_partitions();
+			_libparted->scan_orig_partitions();
+
+			emit sigOperations(tr("Removing a partition."), messageState, i, iTotAct);
+			if (!_libparted->rm(pl->_num)) {
+				messageState = _libparted->message();
+				rc = false;
+			}
+		}
+		//---resize commit---
+		else if (pl->_action == QTParted::resize) {
+			showDebug("%s", "actionlist::commit, want to commit a resize\n");
+			emit sigOperations(tr("Preparation for resizing a partition."), messageState, i++, iTotAct);
+			scan_partitions();
+			_libparted->scan_orig_partitions();
+
+			emit sigOperations(tr("Resizing a partition."), messageState, i, iTotAct);
+			if (!_libparted->resize(pl->_num, pl->_start, pl->_end)) {
+				messageState = _libparted->message();
+				rc = false;
+			}
+		}
+		//---move commit---
+		else if (pl->_action == QTParted::move) {
+			showDebug("%s", "actionlist::commit, want to commit a move\n");
+			emit sigOperations(tr("Preparation for moving a partition."), messageState, i++, iTotAct);
+			scan_partitions();
+			_libparted->scan_orig_partitions();
+
+			emit sigOperations(tr("Moving a partition."), messageState, i, iTotAct);
+			if (!_libparted->move(pl->_num, pl->_start, pl->_end)) {
+				messageState = _libparted->message();
+				rc = false;
+			}
+		}
+		//---active commit---
+		else if (pl->_action == QTParted::active) {
+			showDebug("%s", "actionlist::commit, want to commit an active\n");
+			emit sigOperations(tr("Preparation for activating a partition."), messageState, i++, iTotAct);
+			scan_partitions();
+			_libparted->scan_orig_partitions();
+
+			emit sigOperations(tr("Activating a partition."), messageState, i, iTotAct);
+			if (!_libparted->partition_set_flag_active(pl->_num, pl->_status)) {
+				messageState = _libparted->message();
+				rc = false;
+			}
+		}
+		//---active commit---
+		else if (pl->_action == QTParted::hidden) {
+			showDebug("%s", "actionlist::commit, want to commit an hidden\n");
+			emit sigOperations(tr("Preparation for hiding a partition."), messageState, i++, iTotAct);
+			scan_partitions();
+			_libparted->scan_orig_partitions();
+
+			emit sigOperations(tr("Hiding a partition."), messageState, i, iTotAct);
+			if (!_libparted->partition_set_flag_hidden(pl->_num, pl->_status)) {
+				messageState = _libparted->message();
+				rc = false;
+			}
+		}
+		//---active commit---
+		else if (pl->_action == QTParted::format) {
+			showDebug("%s", "actionlist::commit, want to commit a format\n");
+			emit sigOperations(tr("Preparation for formatting a partition."), messageState, i++, iTotAct);
+			scan_partitions();
+			_libparted->scan_orig_partitions();
+
+			emit sigOperations(tr("Formatting a partition."), messageState, i, iTotAct);
+			if (!_libparted->mkfs(pl->_num, pl->_fsspec, pl->_label)) {
+				messageState = _libparted->message();
+				rc = false;
+			}
+		}
+
+		/*---just update GUI---*/
+		qApp->processEvents();
+		
+		if (rc == false) {
+			break;
+		}
+	}
+
+	actlist.clear();
+
+	/*---return in test mode---*/
+	_libparted->setWrite(false);
+
+	/*---remove the disk used---*/
+	ped_disk_destroy(_disk);
+
+	/*---remove also the original disk---*/
+	ped_disk_destroy((PedDisk *)listdisk.first());
+	listdisk.clear();
 
-    //messageState, used to keep "error message" returned by libparted
-    QString messageState = QString::null;
-    
-    /*---undo all disk state---*/
-    while (listdisk.first() != listdisk.last()) {
-        PedDisk *disk = (PedDisk *)listdisk.last();
-        ped_disk_destroy(disk);
-        listdisk.removeLast();
-    }
-    _disk = ped_disk_duplicate((PedDisk *)listdisk.first());
-    if (!_disk) showDebug("%s", "actionlist::commit, ped_disk_duplicate ko\n");
-    
-    /*---commit the operations in "batch" mode---*/
-    _libparted->setWrite(true);
-
-    bool rc = true;
-    
-    //counter of how much operations are done!
-    int i = 0;
-    int iTotAct = actlist.count() + 1;
-        
-    QP_ActListItem *pl;
-    for (pl = (QP_ActListItem *)actlist.first(); pl; pl = (QP_ActListItem *)actlist.next()) {
-        showDebug("%s", "actionlist::commit, loop for commit\n");
-    
-        //---mkpart commit---
-        if (pl->_action == QTParted::create) {
-            showDebug("%s", "actionlist::commit, want to commit a create\n");
-            emit sigOperations(tr("Creating partition."), messageState, i++, iTotAct);
-            if (!_libparted->mkpartfs(pl->_type, pl->_fsspec, pl->_start, pl->_end, pl->_label)) {
-                messageState = _libparted->message();
-                rc = false;
-            }
-        }
-        //---rm commit---
-        else if (pl->_action == QTParted::rm) {
-            showDebug("%s", "actionlist::commit, want to commit a rm\n");
-            emit sigOperations(tr("Preparation for removing a partition."), messageState, i++, iTotAct);
-            scan_partitions();
-            _libparted->scan_orig_partitions();
-
-            emit sigOperations(tr("Removing a partition."), messageState, i, iTotAct);
-            if (!_libparted->rm(pl->_num)) {
-                messageState = _libparted->message();
-                rc = false;
-            }
-        }
-        //---resize commit---
-        else if (pl->_action == QTParted::resize) {
-            showDebug("%s", "actionlist::commit, want to commit a resize\n");
-            emit sigOperations(tr("Preparation for resizing a partition."), messageState, i++, iTotAct);
-            scan_partitions();
-            _libparted->scan_orig_partitions();
-
-            emit sigOperations(tr("Resizing a partition."), messageState, i, iTotAct);
-            if (!_libparted->resize(pl->_num, pl->_start, pl->_end)) {
-                messageState = _libparted->message();
-                rc = false;
-            }
-        }
-        //---move commit---
-        else if (pl->_action == QTParted::move) {
-            showDebug("%s", "actionlist::commit, want to commit a move\n");
-            emit sigOperations(tr("Preparation for moving a partition."), messageState, i++, iTotAct);
-            scan_partitions();
-            _libparted->scan_orig_partitions();
-
-            emit sigOperations(tr("Moving a partition."), messageState, i, iTotAct);
-            if (!_libparted->move(pl->_num, pl->_start, pl->_end)) {
-                messageState = _libparted->message();
-                rc = false;
-            }
-        }
-        //---active commit---
-        else if (pl->_action == QTParted::active) {
-            showDebug("%s", "actionlist::commit, want to commit an active\n");
-            emit sigOperations(tr("Preparation for activating a partition."), messageState, i++, iTotAct);
-            scan_partitions();
-            _libparted->scan_orig_partitions();
-
-            emit sigOperations(tr("Activating a partition."), messageState, i, iTotAct);
-            if (!_libparted->partition_set_flag_active(pl->_num, pl->_status)) {
-                messageState = _libparted->message();
-                rc = false;
-            }
-        }
-        //---active commit---
-        else if (pl->_action == QTParted::hidden) {
-            showDebug("%s", "actionlist::commit, want to commit an hidden\n");
-            emit sigOperations(tr("Preparation for hiding a partition."), messageState, i++, iTotAct);
-            scan_partitions();
-            _libparted->scan_orig_partitions();
-
-            emit sigOperations(tr("Hiding a partition."), messageState, i, iTotAct);
-            if (!_libparted->partition_set_flag_hidden(pl->_num, pl->_status)) {
-                messageState = _libparted->message();
-                rc = false;
-            }
-        }
-        //---active commit---
-        else if (pl->_action == QTParted::format) {
-            showDebug("%s", "actionlist::commit, want to commit a format\n");
-            emit sigOperations(tr("Preparation for formatting a partition."), messageState, i++, iTotAct);
-            scan_partitions();
-            _libparted->scan_orig_partitions();
-
-            emit sigOperations(tr("Formatting a partition."), messageState, i, iTotAct);
-            if (!_libparted->mkfs(pl->_num, pl->_fsspec, pl->_label)) {
-                messageState = _libparted->message();
-                rc = false;
-            }
-        }
-
-        /*---just update GUI---*/
-        qApp->processEvents();
-        
-        if (rc == false) {
-            break;
-        }
-    }
-
-    actlist.clear();
-
-    /*---return in test mode---*/
-    _libparted->setWrite(false);
-
-    /*---remove the disk used---*/
-    ped_disk_destroy(_disk);
-
-    /*---remove also the original disk---*/
-    ped_disk_destroy((PedDisk *)listdisk.first());
-    listdisk.clear();
-
-    /*---prepare the list and the _disk---*/
-    PedDisk *disk = ped_disk_new(_libparted->dev); //FIXME !disk
-    if (!disk) showDebug("%s", "actionlist::commit, ped_disk_new ko\n");
-    
-    listdisk.append(disk);
-    _disk = ped_disk_duplicate(disk); //FIXME !_disk
-    if (!_disk) showDebug("%s", "actionlist::commit, ped_disk_duplicate ko\n");
-
-    emit sigOperations(tr("Rescan of the disk."), messageState, i, iTotAct);
-    
-    showDebug("%s", "actionlist::commit, call scan_partitions\n");
+	/*---prepare the list and the _disk---*/
+	PedDisk *disk = ped_disk_new(_libparted->dev); //FIXME !disk
+	if (!disk) showDebug("%s", "actionlist::commit, ped_disk_new ko\n");
+	
+	listdisk.append(disk);
+	_disk = ped_disk_duplicate(disk); //FIXME !_disk
+	if (!_disk) showDebug("%s", "actionlist::commit, ped_disk_duplicate ko\n");
 
-    /*---make a new scan of the partitions---*/
-    scan_partitions();
+	emit sigOperations(tr("Rescan of the disk."), messageState, i, iTotAct);
+	
+	showDebug("%s", "actionlist::commit, call scan_partitions\n");
 
-    emit sigOperations(tr("All operations completed."), messageState, iTotAct, iTotAct);
+	/*---make a new scan of the partitions---*/
+	scan_partitions();
 
-    /*---the state of the disk... is of course changed---*/
-    emit sigDiskChanged();
+	emit sigOperations(tr("All operations completed."), messageState, iTotAct, iTotAct);
+
+	/*---the state of the disk... is of course changed---*/
+	emit sigDiskChanged();
 }
 
 PedDisk * QP_ActionList::disk() {
-    return _disk;
+	return _disk;
 }
 
 QP_PartInfo * QP_ActionList::partActive() {
-    return _partActive;
+	return _partActive;
 }
 
 /*---this will get if the partition has active flag (ie is bootable)---*/
 void QP_ActionList::partition_get_flags(QP_PartInfo *partinfo, PedPartition *part) {
-    if (ped_partition_is_flag_available(part, PED_PARTITION_BOOT)) {
-        partinfo->_canBeActive = true;
-        bool active = bool(ped_partition_get_flag(part, PED_PARTITION_BOOT));
-        partinfo->_active = active;
-        if (active) _partActive = partinfo;
-    }
-
-    if (ped_partition_is_flag_available(part, PED_PARTITION_HIDDEN)) {
-        partinfo->_canBeHidden = true;
-        bool hidden = bool(ped_partition_get_flag(part, PED_PARTITION_HIDDEN));
-        partinfo->_hidden = hidden;
-    }
+	if (ped_partition_is_flag_available(part, PED_PARTITION_BOOT)) {
+		partinfo->_canBeActive = true;
+		bool active = bool(ped_partition_get_flag(part, PED_PARTITION_BOOT));
+		partinfo->_active = active;
+		if (active) _partActive = partinfo;
+	}
+
+	if (ped_partition_is_flag_available(part, PED_PARTITION_HIDDEN)) {
+		partinfo->_canBeHidden = true;
+		bool hidden = bool(ped_partition_get_flag(part, PED_PARTITION_HIDDEN));
+		partinfo->_hidden = hidden;
+	}
 }
 
 void QP_ActionList::ins_newdisk() {
-    showDebug("%s", "actionlist::ins_newdisk\n");
+	showDebug("%s", "actionlist::ins_newdisk\n");
 
-    listdisk.append(_disk);
-    _disk = ped_disk_duplicate(_disk); //FIXME !_disk
-    if (!_disk) showDebug("%s", "actionlist::ins_newdisk, ped_disk_duplicate ko\n");
+	listdisk.append(_disk);
+	_disk = ped_disk_duplicate(_disk); //FIXME !_disk
+	if (!_disk) showDebug("%s", "actionlist::ins_newdisk, ped_disk_duplicate ko\n");
 
-    emit sigDiskChanged();
+	emit sigDiskChanged();
 }
diff -Naur qtparted-0.4.5.orig/src/qp_actlist.h qtparted-0.4.5/src/qp_actlist.h
--- qtparted-0.4.5.orig/src/qp_actlist.h	2004-04-12 16:09:07.000000000 +0200
+++ qtparted-0.4.5/src/qp_actlist.h	2005-10-15 12:35:30.000000000 +0200
@@ -1,22 +1,22 @@
 /*
-    qtparted - a frontend to libparted for manipulating disk partitions
-    Copyright (C) 2002-2003 Vanni Brutto
+	qtparted - a frontend to libparted for manipulating disk partitions
+	Copyright (C) 2002-2003 Vanni Brutto
 
-    Vanni Brutto <zanac (-at-) libero dot it>
+	Vanni Brutto <zanac (-at-) libero dot it>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
 /* About QP_ActList class
@@ -36,89 +36,87 @@
 
 /* move,   -> num, start, end
  * resize, -> num, start, end
- * rm,     -> num
+ * rm,	 -> num
  * create  -> start, end, tipo_estesa_logica, fsspec, label
  * */
 class QP_ActListItem {
 public:
-    /*---type (move+resize), num, start, end, geometry, parttype---*/
-    QP_ActListItem(QTParted::actType, int, PedSector, PedSector, PedGeometry, PedPartitionType);
+	/*---type (move+resize), num, start, end, geometry, parttype---*/
+	QP_ActListItem(QTParted::actType, int, PedSector, PedSector, PedGeometry, PedPartitionType);
 
-    /*---type, num (rm)---*/
-    QP_ActListItem(QTParted::actType, int);
+	/*---type, num (rm)---*/
+	QP_ActListItem(QTParted::actType, int);
 
-    /*---type (format), num, fsspec, label, geometry, parttype---*/
-    QP_ActListItem(QTParted::actType, int, QP_FileSystemSpec *, QString, PedGeometry, PedPartitionType);
+	/*---type (format), num, fsspec, label, geometry, parttype---*/
+	QP_ActListItem(QTParted::actType, int, QP_FileSystemSpec *, QString, PedGeometry, PedPartitionType);
 
-    /*---type, num, active---*/
-    QP_ActListItem(QTParted::actType, int, bool);
-
-    /*---type, logical/extended, start, end, typoFS, label, geometry, parttype---*/
-    QP_ActListItem(QTParted::actType,
-                   QTParted::partType,
-                   PedSector, PedSector,
-                   QP_FileSystemSpec *,
-                   QString,
-                   PedGeometry,
-                   PedPartitionType);
+	/*---type, num, active---*/
+	QP_ActListItem(QTParted::actType, int, bool);
+
+	/*---type, logical/extended, start, end, typoFS, label, geometry, parttype---*/
+	QP_ActListItem(QTParted::actType,
+				   QTParted::partType,
+				   PedSector, PedSector,
+				   QP_FileSystemSpec *,
+				   QString,
+				   PedGeometry,
+				   PedPartitionType);
 
 //private:
-    QTParted::actType _action;
-    PedSector _start;
-    PedSector _end;
-    int _num;
-    QTParted::partType _type;
-    QP_FileSystemSpec *_fsspec;
-    QString _label;
-    PedGeometry _geom;
-    PedPartitionType _part_type;
-    bool _status; //used for boot and hidden flags
+	QTParted::actType _action;
+	PedSector _start;
+	PedSector _end;
+	int _num;
+	QTParted::partType _type;
+	QP_FileSystemSpec *_fsspec;
+	QString _label;
+	PedGeometry _geom;
+	PedPartitionType _part_type;
+	bool _status; //used for boot and hidden flags
 };
 
 
 class QP_ActionList : public QObject {
-friend class QP_LibParted;
-friend class QP_PartInfo;
-Q_OBJECT
+	friend class QP_LibParted;
+	friend class QP_PartInfo;
+	Q_OBJECT
 public:
-    QP_ActionList(QP_LibParted *);
-    ~QP_ActionList();
-    void update_listpartitions();
-    void scan_partitions(); //scan for every partition
-    bool get_partfilesystem_info(PedPartition *, QP_PartInfo *);
-    bool get_partfilesystem_label(PedPartition *part, QP_PartInfo *partinfo);
-    void ins_resize(int, PedSector, PedSector, PedGeometry, PedPartitionType);
-    void ins_move(int, PedSector, PedSector, PedGeometry, PedPartitionType);
-    void ins_rm(int);
-    void ins_mkfs(QP_FileSystemSpec *, int, QString, PedGeometry, PedPartitionType);
-    void ins_mkpart(QTParted::partType, PedSector, PedSector, QP_FileSystemSpec *, QString, PedGeometry, PedPartitionType);
-    void ins_active(int, bool);
-    void ins_hidden(int, bool);
-    void get_partinfo(QP_PartInfo *, PedPartition *);
-    bool canUndo();  //Does the user can undo/commit?
-    void undo();     //undo last operation
-    void commit();   //commit all operations
-    PedDisk *disk(); //return the actual state of the disk
-    QP_PartInfo *partActive(); //return the partinfo that is bootable
-    QPtrList<QP_PartInfo> partlist;
-    QPtrList<QP_PartInfo> logilist;
+	QP_ActionList(QP_LibParted *);
+	~QP_ActionList();
+	void update_listpartitions();
+	void scan_partitions(); //scan for every partition
+	bool get_partfilesystem_info(PedPartition *, QP_PartInfo *);
+	bool get_partfilesystem_label(PedPartition *part, QP_PartInfo *partinfo);
+	void ins_resize(int, PedSector, PedSector, PedGeometry, PedPartitionType);
+	void ins_move(int, PedSector, PedSector, PedGeometry, PedPartitionType);
+	void ins_rm(int);
+	void ins_mkfs(QP_FileSystemSpec *, int, QString, PedGeometry, PedPartitionType);
+	void ins_mkpart(QTParted::partType, PedSector, PedSector, QP_FileSystemSpec *, QString, PedGeometry, PedPartitionType);
+	void ins_active(int, bool);
+	void ins_hidden(int, bool);
+	void get_partinfo(QP_PartInfo *, PedPartition *);
+	bool canUndo();  //Does the user can undo/commit?
+	void undo();	 //undo last operation
+	void commit();   //commit all operations
+	PedDisk *disk(); //return the actual state of the disk
+	QP_PartInfo *partActive(); //return the partinfo that is bootable
+	QPtrList<QP_PartInfo> partlist;
+	QPtrList<QP_PartInfo> logilist;
 
 private:
-    void partition_get_flags(QP_PartInfo *, PedPartition *); //will get the active flag
-    void ins_newdisk();
-    QPtrList<QP_ActListItem> actlist;
-    QPtrList<PedDisk> listdisk;
-    PedDisk *_disk;
-    QP_LibParted *_libparted;
-    QP_PartInfo *_partActive; //a pointer to the partinfo that is current active (ie bootable)
-    QPtrList<QP_PartInfo> orig_partlist;
-    QPtrList<QP_PartInfo> orig_logilist;
+	void partition_get_flags(QP_PartInfo *, PedPartition *); //will get the active flag
+	void ins_newdisk();
+	QPtrList<QP_ActListItem> actlist;
+	QPtrList<PedDisk> listdisk;
+	PedDisk *_disk;
+	QP_LibParted *_libparted;
+	QP_PartInfo *_partActive; //a pointer to the partinfo that is current active (ie bootable)
+	QPtrList<QP_PartInfo> orig_partlist;
+	QPtrList<QP_PartInfo> orig_logilist;
 
 signals:
-    /*---emitted when the state of the disk was changed---*/
-    void sigDiskChanged();
-    void sigOperations(QString, QString, int, int);
+	/*---emitted when the state of the disk was changed---*/
+	void sigDiskChanged();
+	void sigOperations(QString, QString, int, int);
 };
-
-
 #endif
diff -Naur qtparted-0.4.5.orig/src/qp_combospin.cpp qtparted-0.4.5/src/qp_combospin.cpp
--- qtparted-0.4.5.orig/src/qp_combospin.cpp	2003-08-27 18:13:18.000000000 +0200
+++ qtparted-0.4.5/src/qp_combospin.cpp	2005-10-15 13:13:01.000000000 +0200
@@ -24,50 +24,51 @@
 #include "qp_options.h"
 
 QP_ComboSpin::QP_ComboSpin(QWidget *parent, const char *name)
-    :QWidget(parent, name) {
-    layout = new QHBoxLayout(this); //, "layout");
-
-    spinbox = new QP_SpinBox(this, "spinbox");
-    spinbox->setSizePolicy(QSizePolicy((QSizePolicy::SizeType)7, (QSizePolicy::SizeType)0, 0, 0, spinbox->sizePolicy().hasHeightForWidth()));
-
-    layout->addWidget(spinbox);
-    connect(spinbox, SIGNAL(valueChanged(PedSector)),
-            this, SIGNAL(valueChanged(PedSector)));
-
-    combobox = new QComboBox(false, this, "combobox");
-    combobox->setSizePolicy(QSizePolicy( (QSizePolicy::SizeType)1, (QSizePolicy::SizeType)0, 0, 0, combobox->sizePolicy().hasHeightForWidth()));
-    connect(combobox, SIGNAL(activated(int)),
-            spinbox, SLOT(setFormat(int)));
-    layout->addWidget(combobox);
-
-    combobox->clear();
-    combobox->insertItem("MB");
-    combobox->insertItem("GB");
+	:QWidget(parent, name)
+{
+	layout = new QHBoxLayout(this); //, "layout");
+
+	spinbox = new QP_SpinBox(this, "spinbox");
+	spinbox->setSizePolicy(QSizePolicy((QSizePolicy::SizeType)7, (QSizePolicy::SizeType)0, 0, 0, spinbox->sizePolicy().hasHeightForWidth()));
+
+	layout->addWidget(spinbox);
+	connect(spinbox, SIGNAL(valueChanged(PedSector)),
+		this, SIGNAL(valueChanged(PedSector)));
+
+	combobox = new QComboBox(false, this, "combobox");
+	combobox->setSizePolicy(QSizePolicy( (QSizePolicy::SizeType)1, (QSizePolicy::SizeType)0, 0, 0, combobox->sizePolicy().hasHeightForWidth()));
+	connect(combobox, SIGNAL(activated(int)),
+		spinbox, SLOT(setFormat(int)));
+	layout->addWidget(combobox);
+
+	combobox->clear();
+	combobox->insertItem("MB");
+	combobox->insertItem("GB");
 }
 
 QP_ComboSpin::~QP_ComboSpin() {
 }
 
 void QP_ComboSpin::setRange(PedSector min, PedSector max) {
-    spinbox->setRange(min, max);
+	spinbox->setRange(min, max);
 }
 
 void QP_ComboSpin::setValue(PedSector val) {
-    spinbox->setValue(val);
+	spinbox->setValue(val);
 }
 
 void QP_ComboSpin::setMaxValue(PedSector max) {
-    spinbox->setMaxValue(max);
+	spinbox->setMaxValue(max);
 }
 
 void QP_ComboSpin::setMinValue(PedSector min) {
-    spinbox->setMinValue(min);
+	spinbox->setMinValue(min);
 }
 
 PedSector QP_ComboSpin::value() {
-    return spinbox->pedValue();
+	return spinbox->pedValue();
 }
 
 PedSector QP_ComboSpin::maxValue() {
-    return spinbox->pedMaxValue();
+	return spinbox->pedMaxValue();
 }
diff -Naur qtparted-0.4.5.orig/src/qp_combospin.h qtparted-0.4.5/src/qp_combospin.h
--- qtparted-0.4.5.orig/src/qp_combospin.h	2003-08-27 18:13:19.000000000 +0200
+++ qtparted-0.4.5/src/qp_combospin.h	2005-10-15 13:13:01.000000000 +0200
@@ -33,24 +33,23 @@
 #define QP_COMBOSPIN_H
 
 class QP_ComboSpin : public QWidget {
-Q_OBJECT
+	Q_OBJECT
 public:
-    QP_ComboSpin(QWidget *parent = 0L, const char *name = 0L);
-    ~QP_ComboSpin();
-    void setRange(PedSector, PedSector);
-    void setMaxValue(PedSector);
-    void setMinValue(PedSector);
-    void setValue(PedSector);
-    PedSector value();
-    PedSector maxValue();
+	QP_ComboSpin(QWidget *parent = 0L, const char *name = 0L);
+	~QP_ComboSpin();
+	void setRange(PedSector, PedSector);
+	void setMaxValue(PedSector);
+	void setMinValue(PedSector);
+	void setValue(PedSector);
+	PedSector value();
+	PedSector maxValue();
 
 signals:
-    void valueChanged(PedSector);
+	void valueChanged(PedSector);
 
 protected:
-    QHBoxLayout *layout;    
-    QComboBox *combobox;
-    QP_SpinBox *spinbox;
+	QHBoxLayout *layout;
+	QComboBox *combobox;
+	QP_SpinBox *spinbox;
 };
-
 #endif
diff -Naur qtparted-0.4.5.orig/src/qp_fswrap.cpp qtparted-0.4.5/src/qp_fswrap.cpp
--- qtparted-0.4.5.orig/src/qp_fswrap.cpp	2005-07-06 23:29:54.000000000 +0200
+++ qtparted-0.4.5/src/qp_fswrap.cpp	2006-04-05 01:45:50.000000000 +0200
@@ -1,10 +1,9 @@
 /*
     qtparted - a frontend to libparted for manipulating disk partitions
     Copyright (C) 2002-2003 Vanni Brutto
-
     Vanni Brutto <zanac (-at-) libero dot it>
 
-    Copyright (C) 2005 Bernhard Rosenkraenzer
+    Copyright (C) 2005-2006 Bernhard Rosenkraenzer
     bero (-at-) arklinux dot org
 
     This program is free software; you can redistribute it and/or modify
@@ -43,1108 +42,1161 @@
 
 #define my_min(a,b) ((a)<(b) ? (a):(b))
 
-bool QP_FSWrap::fs_open(QString cmdline) {
+bool QP_FSWrap::fs_open(QString cmdline, bool localized)
+{
+
+	/*---this force stderr to stdout and a parsable language---*/
+	QString dupcmdline = QString("%1 %2")
+	                     .arg(cmdline)
+	                     .arg(QString("2>&1"));
+
+	if (!localized)
+		dupcmdline = "LC_ALL=POSIX " + dupcmdline;
+
+	/*---open a pipe from the command line---*/
+	fp = popen(dupcmdline, "r");
+
+	if (fp)
+		return true;
+	else
+		return false;
+}
+
+char *QP_FSWrap::fs_getline()
+{
+	bool rc = fgets(line, sizeof line, fp);
+
+	if (rc)
+		return line;
+	else
+		return NULL;
+}
+
+int QP_FSWrap::fs_close()
+{
+	return fclose(fp);
+}
+
+QP_FSWrap *QP_FSWrap::fswrap(QString name)
+{
+	QP_FSWrap *fswrap;
+
+	if (name.compare("ntfs") == 0)
+		fswrap = new QP_FSNtfs();
+	else if (name.compare("jfs") == 0)
+		fswrap = new QP_FSJfs();
+	else if (name.compare("ext3") == 0)
+		fswrap = new QP_FSExt3();
+	else if (name.compare("xfs") == 0)
+		fswrap = new QP_FSXfs();
+	else
+		fswrap = 0;
 
-    /*---this force stderr to stdout---*/
-    QString dupcmdline = QString("%1 %2")
-                    .arg(cmdline)
-                    .arg(QString("2>&1"));
-
-    /*---open a pipe from the command line---*/
-    fp = popen(dupcmdline, "r");
-
-    if (fp)
-        return true;
-    else
-        return false;
-}
-
-char * QP_FSWrap::fs_getline() {
-    bool rc = fgets(line, sizeof line, fp);
-
-    if (rc) return line;
-    else    return NULL;
-}
-
-int QP_FSWrap::fs_close() {
-    return fclose(fp);
-}
-
-QP_FSWrap * QP_FSWrap::fswrap(QString name) {
-    if (name.compare("ntfs") == 0) {
-        QP_FSWrap *fswrap = new QP_FSNtfs();
-        return fswrap;
-    } else
-    if (name.compare("jfs") == 0) {
-        QP_FSWrap *fswrap = new QP_FSJfs();
-        return fswrap;
-    } else
-    if (name.compare("ext3") == 0) {
-        QP_FSWrap *fswrap = new QP_FSExt3();
-        return fswrap;
-    } else
-    if (name.compare("xfs") == 0) {
-        QP_FSWrap *fswrap = new QP_FSXfs();
-        return fswrap;
-    }
-    else
-        return NULL;
-}
-
-QString QP_FSWrap::get_label(PedPartition *part, QString name) {
-    if (name.compare("ntfs") == 0) {
-        return QP_FSNtfs::_get_label(part);
-    } else
-    if (name.compare("jfs") == 0) {
-        return QP_FSJfs::_get_label(part);
-    } else
-    if (name.compare("ext3") == 0) {
-        return QP_FSExt3::_get_label(part);
-    } else
-    if (name.compare("xfs") == 0) {
-        return QP_FSXfs::_get_label(part);
-    }
-    if (name.compare("fat16") == 0) {
-        return QP_FSFat16::_get_label(part);
-    }
-    if (name.compare("fat32") == 0) {
-        return QP_FSFat32::_get_label(part);
-    }
-    if (name.compare("ext2") == 0) {
-        return QP_FSExt2::_get_label(part);
-    }
-    if (name.compare("reiserfs") == 0) {
-        return QP_FSReiserFS::_get_label(part);
-    }
-    else
-        return QString::null;
-}
-
-bool QP_FSWrap::read_sector(PedPartition *part, PedSector offset, PedSector count, char *buffer) {
-    /*---open a new device, read a sector and close it---*/
-    if (!ped_device_open(part->geom.dev))
-        return false;
-
-    if (!ped_geometry_read(&part->geom, buffer, offset, count)) {
-        ped_device_close (part->geom.dev);
-        return false;
-    }
-    
-    if (!ped_device_close(part->geom.dev))
-        return false;
-
-    return true;
-}
-
-bool QP_FSWrap::qpMount(QString device) {
-    char szcmdline[200];
-    bool error = false;
-
-    /*---just to be sure! :)---*/
-    qpUMount(device);
-    
-    /*---mount the partition---*/
-    sprintf(szcmdline, "%s %s", device.latin1(), TMP_MOUNTPOINT);
-    QString cmdline = QString("%1 %2")
-            .arg(lstExternalTools->getPath(MOUNT))
-            .arg(szcmdline);
-    
-    if (!fs_open(cmdline)) {
-        _message = QString(NOTFOUND);
-        return false;
-    }
-
-    char *cline;
-    while ((cline = fs_getline())) {
-        QString line = QString(cline);
-
-        QRegExp rx;
-        rx = QRegExp("^mount: (.*)$");
-        if (rx.search(line) == 0) {
-            QString capError = rx.cap(1);
-            _message = capError;
-            error = true;
-        }
-    }
-    fs_close();
-    
-    return !error;
-}
-
-bool QP_FSWrap::qpUMount(QString device) {
-    int ret = umount(device.latin1());
-    if(ret) {
-	    _message = QString(strerror(errno));
-	    return false;
-    }
-    return true;
+	return fswrap;
+}
+
+QString QP_FSWrap::get_label(PedPartition * part, QString name)
+{
+	if (name.compare("ntfs") == 0)
+		return QP_FSNtfs::_get_label(part);
+	else if (name.compare("jfs") == 0)
+		return QP_FSJfs::_get_label(part);
+	else if (name.compare("ext3") == 0)
+		return QP_FSExt3::_get_label(part);
+	else if (name.compare("xfs") == 0)
+		return QP_FSXfs::_get_label(part);
+	else if (name.compare("fat16") == 0)
+		return QP_FSFat16::_get_label(part);
+	else if (name.compare("fat32") == 0)
+		return QP_FSFat32::_get_label(part);
+	else if (name.compare("ext2") == 0)
+		return QP_FSExt2::_get_label(part);
+	else if (name.compare("reiserfs") == 0)
+		return QP_FSReiserFS::_get_label(part);
+	else
+		return QString::null;
+}
+
+bool QP_FSWrap::read_sector(PedPartition * part, PedSector offset,
+			    PedSector count, char *buffer)
+{
+	/*---open a new device, read a sector and close it---*/
+	if (!ped_device_open(part->geom.dev))
+		return false;
+
+	if (!ped_geometry_read(&part->geom, buffer, offset, count)) {
+		ped_device_close(part->geom.dev);
+		return false;
+	}
+
+	if (!ped_device_close(part->geom.dev))
+		return false;
+
+	return true;
+}
+
+bool QP_FSWrap::qpMount(QString device)
+{
+	bool error = false;
+
+	/*---just to be sure! :)---*/
+	qpUMount(device);
+
+	/*---mount the partition---*/
+	QString cmdline = lstExternalTools->getPath(MOUNT) + " " + device + " " + TMP_MOUNTPOINT;
+
+	if (!fs_open(cmdline, true)) {
+		_message = QString(NOTFOUND);
+		return false;
+	}
+
+	char *cline;
+	while ((cline = fs_getline())) {
+		QString line = QString(cline);
+
+		QRegExp rx = QRegExp("^mount: (.*)$");
+		if (rx.search(line) == 0) {
+			QString capError = rx.cap(1);
+			_message = capError;
+			error = true;
+		}
+	}
+	fs_close();
+
+	return !error;
+}
+
+bool QP_FSWrap::qpUMount(QString device)
+{
+	int ret = umount(device.latin1());
+	if (ret) {
+		_message = QString(strerror(errno));
+		return false;
+	}
+	return true;
 }
 
 
 
 /*---NTFS WRAPPER-----------------------------------------------------------------*/
-QP_FSNtfs::QP_FSNtfs() {
-    wrap_resize = false;
-    wrap_move = false;
-    wrap_copy = false;
-    wrap_create = false;
-    wrap_min_size = false;
-
-    /*---check if the wrapper is installed---*/
-    QString cmdline = QString("which %1")
-                    .arg(lstExternalTools->getPath(MKNTFS));
-    fs_open(cmdline);
-    char *cline;
-    while ((cline = fs_getline()))
-        wrap_create = true;
-    fs_close();
-
-    /*---check if the wrapper is installed---*/
-    cmdline = QString("which %1")
-            .arg(lstExternalTools->getPath(NTFSRESIZE));
-    fs_open(cmdline);
-
-
-    while ((cline = fs_getline())) {
-        wrap_resize = RS_SHRINK | RS_ENLARGE;
-        wrap_min_size = true;
-    }
-    fs_close();
-}
-
-bool QP_FSNtfs::resize(QP_LibParted *_libparted, bool write, QP_PartInfo *partinfo, PedSector new_start, PedSector new_end) {
-    /*---pointer to libparted---*/
-    QP_LibParted *libparted = _libparted;
-    
+QP_FSNtfs::QP_FSNtfs()
+{
+	wrap_resize = false;
+	wrap_move = false;
+	wrap_copy = false;
+	wrap_create = false;
+	wrap_min_size = false;
+
+	/*---check if the wrapper is installed---*/
+	QString cmdline = "which " + lstExternalTools->getPath(MKNTFS);
+	fs_open(cmdline);
+	char *cline;
+	while ((cline = fs_getline()))
+		wrap_create = true;
+	fs_close();
+
+	/*---check if the wrapper is installed---*/
+	cmdline = "which " + lstExternalTools->getPath(NTFSRESIZE);
+	fs_open(cmdline);
+
+
+	while ((cline = fs_getline())) {
+		wrap_resize = RS_SHRINK | RS_ENLARGE;
+		wrap_min_size = true;
+	}
+	fs_close();
+}
+
+bool QP_FSNtfs::resize(QP_LibParted * _libparted, bool write,
+		       QP_PartInfo * partinfo, PedSector new_start,
+		       PedSector new_end)
+{
+	/*---pointer to libparted---*/
+	QP_LibParted *libparted = _libparted;
+
 	showDebug("%s", "Resizing a filesystem using a wrapper\n");
 
-    /*---the user want to shrink or enlarge the partition?---*/
-    /*---the user want to shrink!---*/
-    if (new_end < partinfo->end) {
-        /*---update the filesystem---*/
-	    showDebug("%s", "shrinking filesystem...\n");
-        if (!ntfsresize(write, partinfo->partname(), new_end - new_start - 4*MEGABYTE_SECTORS)) {
-	        showDebug("%s", "shrinking filesystem ko\n");
-            return false;
-        }
-
-        /*---and now update geometry of the partition---*/
-        showDebug("%s", "update geometry...\n");
-        if (!libparted->set_geometry(partinfo, new_start, new_end)) {
-            showDebug("%s", "update geometry ko\n");
-            _message = libparted->message();
-            return false;
-        } else {
-            /*---if you are NOT committing then add in the undo/commit list---*/
-            if (!write) {
-                showDebug("%s", "operation added to undo/commit list\n");
-                PedPartitionType parttype = libparted->type2parttype(partinfo->type);
-                PedGeometry geom = libparted->get_geometry(partinfo);
-                libparted->actlist->ins_resize(partinfo->num, new_start, new_end, geom, parttype);
-            }
-            return true;
-        }
-    /*---the user want to enlarge!---*/
-    } else {
-        /*---cannot enlarge if we cannot change disk geometry!---*/
-        if (partinfo->device()->isBusy()) {
-            showDebug("%s", "the device is busy, so you cannot enlarge it\n");
-            _message = tr("Cannot enlarge a partition if the disk device is busy");
-            return false;
-        }
-        
-        /*---first se the geometry of the partition---*/
-        showDebug("%s", "update geometry...\n");
-        if (!libparted->set_geometry(partinfo, new_start, new_end)) {
-            showDebug("%s", "update geometry ko\n");
-            _message = libparted->message();
-            return false;
-        } else {
-            /*---if you are NOT committing then add in the undo/commit list---*/
-            if (!write) {
-                showDebug("%s", "operation added to undo/commit list\n");
-                PedPartitionType parttype = libparted->type2parttype(partinfo->type);
-                PedGeometry geom = libparted->get_geometry(partinfo);
-                libparted->actlist->ins_resize(partinfo->num, new_start, new_end, geom, parttype);
-            }
-        }
-
-        if (write) {
-            /*---and now update the filesystem!---*/
-	        showDebug("%s", "enlarge filesystem...\n");
-            if (!ntfsresize(write, partinfo->partname(), new_end - new_start - 4*MEGABYTE_SECTORS)) {
-	            showDebug("%s", "enlarge filesystem ko\n");
-                return false;
-            } else {
-                return true;
-            }
-        } else {
-            return true;
-        }
-    }
-}
-
-bool QP_FSNtfs::ntfsresize(bool write, QString dev, PedSector newsize) {
-    char szcmdline[200];
-
-    /*---init of the error message---*/
-    _message = QString::null;
-
-    /*---calculate size of the partition in bytes---*/
-    PedSector size = (PedSector)((newsize-1)*512);
-
-    /*---read-only test---*/
-    sprintf(szcmdline, "-n -ff -s %lld %s", size, dev.latin1());
-    QString cmdline = QString("%1 %2")
-            .arg(lstExternalTools->getPath(NTFSRESIZE))
-            .arg(szcmdline);
-    
-    if (!fs_open(cmdline)) {
-        _message = QString(NOTFOUND);
-        return false;
-    }
-
-    bool error = false;
-    char *cline;
-    while ((cline = fs_getline())) {
-       QString line = QString(cline);
-
-       QRegExp rx;
-
-       if (!error) {
-           rx = QRegExp("^ERROR.*: (.*)");
-           if (rx.search(line) == 0) {
-               QString captured = rx.cap(1);
-               _message = QString(captured);
-               error = true;
-           }
-       }
-
-       if (!error) {
-           rx = QRegExp("^The volume end is fragmented.*");
-           if (rx.search(line) == 0) {
-               _message = QString("The partition is fragmented.");
-               error = true;
-           }
-       }
+	/*---the user want to shrink or enlarge the partition?---*/
+	/*---the user want to shrink!---*/
+	if (new_end < partinfo->end) {
+	/*---update the filesystem---*/
+		showDebug("%s", "shrinking filesystem...\n");
+		if (!ntfsresize
+		    (write, partinfo->partname(),
+		     new_end - new_start - 4 * MEGABYTE_SECTORS)) {
+			showDebug("%s", "shrinking filesystem ko\n");
+			return false;
+		}
+
+		/*---and now update geometry of the partition---*/
+		showDebug("%s", "update geometry...\n");
+		if (!libparted->set_geometry(partinfo, new_start, new_end)) {
+			showDebug("%s", "update geometry ko\n");
+			_message = libparted->message();
+			return false;
+		} else {
+			/*---if you are NOT committing then add in the undo/commit list---*/
+			if (!write) {
+				showDebug("%s",
+					  "operation added to undo/commit list\n");
+				PedPartitionType parttype =
+				    libparted->type2parttype(partinfo->
+							     type);
+				PedGeometry geom =
+				    libparted->get_geometry(partinfo);
+				libparted->actlist->ins_resize(partinfo->
+							       num,
+							       new_start,
+							       new_end,
+							       geom,
+							       parttype);
+			}
+			return true;
+		}
+		/*---the user wants to enlarge!---*/
+	} else {
+		/*---cannot enlarge if we cannot change disk geometry!---*/
+		if (partinfo->device()->isBusy()) {
+			showDebug("%s",
+				  "the device is busy, so you cannot enlarge it\n");
+			_message = tr(
+			    "Cannot enlarge a partition if the disk device is busy");
+			return false;
+		}
+
+		/*---first se the geometry of the partition---*/
+		showDebug("%s", "update geometry...\n");
+		if (!libparted->set_geometry(partinfo, new_start, new_end)) {
+			showDebug("%s", "update geometry ko\n");
+			_message = libparted->message();
+			return false;
+		} else {
+			/*---if you are NOT committing then add in the undo/commit list---*/
+			if (!write) {
+				showDebug("%s",
+					  "operation added to undo/commit list\n");
+				PedPartitionType parttype =
+				    libparted->type2parttype(partinfo->
+							     type);
+				PedGeometry geom =
+				    libparted->get_geometry(partinfo);
+				libparted->actlist->ins_resize(partinfo->
+							       num,
+							       new_start,
+							       new_end,
+							       geom,
+							       parttype);
+			}
+		}
+
+		if (write) {
+			/*---and now update the filesystem!---*/
+			showDebug("%s", "enlarge filesystem...\n");
+			if (!ntfsresize
+			    (write, partinfo->partname(),
+			     new_end - new_start - 4 * MEGABYTE_SECTORS)) {
+				showDebug("%s", "enlarge filesystem ko\n");
+				return false;
+			} else {
+				return true;
+			}
+		} else {
+			return true;
+		}
+	}
+}
+
+bool QP_FSNtfs::ntfsresize(bool write, QString dev, PedSector newsize)
+{
+	/*---init of the error message---*/
+	_message = QString::null;
+
+	/*---calculate size of the partition in bytes---*/
+	PedSector size = (PedSector) ((newsize - 1) * 512);
 
-       /*---progress bar!---*/
-       QString linesub = line;
+	/*---read-only test---*/
+	QString cmdline = lstExternalTools->getPath(NTFSRESIZE) + " " +
+	                  "-n -ff -s " + QString::number(size) + " " + dev;
+
+	if (!fs_open(cmdline)) {
+		_message = QString(NOTFOUND);
+		return false;
+	}
+
+	bool error = false;
+	char *cline;
+	while ((cline = fs_getline())) {
+		QString line = QString(cline);
+
+		QRegExp rx;
+
+		if (!error) {
+			rx = QRegExp("^ERROR.*: (.*)");
+			if (rx.search(line) == 0) {
+				QString captured = rx.cap(1);
+				_message = QString(captured);
+				error = true;
+			}
+		}
+
+		if (!error) {
+			rx = QRegExp("^The volume end is fragmented.*");
+			if (rx.search(line) == 0) {
+				_message =
+				    QString
+				    ("The partition is fragmented.");
+				error = true;
+			}
+		}
+
+		/*---progress bar!---*/
+		QString linesub = line;
 #ifdef QT30COMPATIBILITY
-       linesub.replace(QRegExp("\r"), " ");
+		linesub.replace(QRegExp("\r"), " ");
 #else
-       linesub.replace(QChar('\r'), " ");
+		linesub.replace(QChar('\r'), " ");
 #endif
-       //example: 34,72 percent completed
-       rx = QRegExp("^.* (\\d*),(\\d*) percent completed.*$");
-       if (rx.search(linesub) == 0) {
-           QString capIntPercent = rx.cap(1);
-           printf("letto: %s\n", capIntPercent.latin1());
-           //QString capFloatPercent = rx.cap(2);
-           
-           bool rc;
-           int iPerc = capIntPercent.toInt(&rc) - 1;
-           if (iPerc < 0) iPerc = 0; //the percente completed run many times, but i don't want it reach 100%
-           
-           emit sigTimer(iPerc, QString(tr("Resizing in progress.")), QString::null);
-       }
-
-       //BETA: change could with might with ntfsresize 1.9
-       //rx = QRegExp("^Now You could resize at \\d* bytes or (\\d*) .*");
-       rx = QRegExp("^.*You ..... resize at \\d* bytes or (\\d*) .*");
-       if (rx.search(line) == 0) {
-           QString captured = rx.cap(1);
-           _message = QString("The partition is fragmented. Try to defragment it, or resize to %1MB")
-                       .arg(captured);
-           error = true;
-       }
-    }
-    fs_close();
-
-    if (error) return false;
-
-    /*---if the user want to run a readonly test just return true---*/
-    if (!write) return true;
-
-
-    /*---ok, the readonly test seems ok... now we resize it!---*/
-    sprintf(szcmdline, "-ff -s %lld %s", size, dev.latin1());
-    cmdline = QString("%1 %2")
-            .arg(lstExternalTools->getPath(NTFSRESIZE))
-            .arg(szcmdline);
-    if (!fs_open(cmdline)) {
-        _message = QString(NOTFOUND);
-        return false;
-    }
-
-    bool success = false;
-    while ((cline = fs_getline())) {
-       QString line = QString(cline);
-       QRegExp rx;
-       
-       /*---progress bar!---*/
-       QString linesub = line;
+		//example: 34,72 percent completed
+		rx = QRegExp("^.* (\\d*),(\\d*) percent completed.*$");
+		if (rx.search(linesub) == 0) {
+			QString capIntPercent = rx.cap(1);
+			printf("letto: %s\n", capIntPercent.latin1());
+			//QString capFloatPercent = rx.cap(2);
+
+			bool rc;
+			int iPerc = capIntPercent.toInt(&rc) - 1;
+			if (iPerc < 0)
+				iPerc = 0;	//the percente completed run many times, but i don't want it reach 100%
+
+			emit sigTimer(iPerc,
+				      QString(tr("Resizing in progress.")),
+				      QString::null);
+		}
+		//BETA: change could with might with ntfsresize 1.9
+		//rx = QRegExp("^Now You could resize at \\d* bytes or (\\d*) .*");
+		rx = QRegExp("^.*You ..... resize at \\d* bytes or (\\d*) .*");
+		if (rx.search(line) == 0) {
+			QString captured = rx.cap(1);
+			_message = QString("The partition is fragmented. Try to defragment it, or resize to %1MB")
+			           .arg(captured);
+			error = true;
+		}
+	}
+	fs_close();
+
+	if (error)
+		return false;
+
+	/*---if the user want to run a readonly test just return true---*/
+	if (!write)
+		return true;
+
+
+	/*---ok, the readonly test seems ok... now we resize it!---*/
+	cmdline = lstExternalTools->getPath(NTFSRESIZE) + " -ff -s " + QString::number(size) + " " + dev;
+	if (!fs_open(cmdline)) {
+		_message = QString(NOTFOUND);
+		return false;
+	}
+
+	bool success = false;
+	while ((cline = fs_getline())) {
+		QString line = QString(cline);
+		QRegExp rx;
+
+		/*---progress bar!---*/
+		QString linesub = line;
 #ifdef QT30COMPATIBILITY
-       linesub.replace(QRegExp("\r"), " ");
+		linesub.replace(QRegExp("\r"), " ");
 #else
-       linesub.replace(QChar('\r'), " ");
+		linesub.replace(QChar('\r'), " ");
 #endif
-       //example: 34,72 percent completed
-       rx = QRegExp("^.* (\\d*),(\\d*) percent completed.*$");
-       if (rx.search(linesub) == 0) {
-           QString capIntPercent = rx.cap(1);
-           //QString capFloatPercent = rx.cap(2);
-           
-           bool rc;
-           int iPerc = capIntPercent.toInt(&rc) - 1;
-           if (iPerc < 0) iPerc = 0; //the percente completed run many times, but i don't want it reach 100%
-           
-           emit sigTimer(iPerc, QString(tr("Resizing in progress.")), QString::null);
-       }
-
-       //rx = QRegExp("^Successfully resized NTFS on device");
-       rx = QRegExp("^.*[Ss]uccessfully.*");
-       if (rx.search(line) == 0)
-           success = true;
-       rx = QRegExp("^Nothing to do: NTFS volume size is already OK.");
-       if (rx.search(line) == 0)
-           success = true;
-
-       rx = QRegExp("^Syncing device.*");
-       if (rx.search(line) == 0) {
-           emit sigTimer(99, QString(tr("Syncing device.")), QString::null);
-       }
-           
-       rx = QRegExp("^ERROR.*: (.*)");
-       if (rx.search(line) == 0) {
-           QString captured = rx.cap(1);
-           _message = QString(captured);
-       }
-    }
-    fs_close();
-
-    if (success) return true;
-    else {
-        if (_message.isNull()) _message = QString("An error occured! :(");
-        return false;
-    }
-}
-
-bool QP_FSNtfs::mkpartfs(QString dev, QString label) {
-    char szcmdline[200];
-    QString cmdline;
-
-    /*---init of the error message---*/
-    _message = QString::null;
-
-    /*---prepare the command line---*/
-    if (label.isEmpty())
-        sprintf(szcmdline, "-f -s 512 %s", dev.latin1());
-    else
-        sprintf(szcmdline, "-f -s 512 -L %s %s", label.latin1(), dev.latin1());
-    cmdline = QString("%1 %2")
-            .arg(lstExternalTools->getPath(MKNTFS))
-            .arg(szcmdline);
-
-    if (!fs_open(cmdline)) {
-        _message = QString(NOTFOUND);
-        return false;
-    }
-    
-
-    bool success = false;
-    char *cline;
-    while ((cline = fs_getline())) {
-       QString line = QString(cline);
-
-       QRegExp rx;
-       rx = QRegExp("^mkntfs completed successfully. Have a nice day.");
-       if (rx.search(line) == 0)
-           success = true;
-
-       rx = QRegExp("^ERROR.*: (.*)");
-       if (rx.search(line) == 0) {
-           QString captured = rx.cap(1);
-           _message = QString(captured);
-           success = false;
-       }
-    }
-    fs_close();
-
-    return success;
-}
-
-PedSector QP_FSNtfs::min_size(QString dev) {
-    char szcmdline[200];
-    QString cmdline;
-    PedSector size = -1;
-
-    /*---init of the error message---*/
-    _message = QString::null;
-
-    /*---prepare the command line---*/
-    sprintf(szcmdline, "-f -i %s", dev.latin1());
-    cmdline = QString("%1 %2")
-            .arg(lstExternalTools->getPath(NTFSRESIZE))
-            .arg(szcmdline);
-
-    if (!fs_open(cmdline)) {
-        _message = QString(NOTFOUND);
-        return false;
-    }
-    
-
-    bool success = false;
-    char *cline;
-    while ((cline = fs_getline())) {
-       QString line = QString(cline);
-
-       QRegExp rx;
-       rx = QRegExp("^.*You ..... resize at (\\d*) bytes or (\\d*) .*");
-       if (rx.search(line) == 0) {
-           QString captured = rx.cap(1);
-           sscanf(captured.latin1(), "%lld", &size);
-           size/=512;
-           size+=8*MEGABYTE_SECTORS;
-
-           success = true;
-       }
-    }
-    fs_close();
+		//example: 34,72 percent completed
+		rx = QRegExp("^.* (\\d*),(\\d*) percent completed.*$");
+		if (rx.search(linesub) == 0) {
+			QString capIntPercent = rx.cap(1);
+			//QString capFloatPercent = rx.cap(2);
+
+			bool rc;
+			int iPerc = capIntPercent.toInt(&rc) - 1;
+			if (iPerc < 0)
+				iPerc = 0;	//the percente completed run many times, but i don't want it reach 100%
+
+			emit sigTimer(iPerc,
+				      QString(tr("Resizing in progress.")),
+				      QString::null);
+		}
+		//rx = QRegExp("^Successfully resized NTFS on device");
+		rx = QRegExp("^.*[Ss]uccessfully.*");
+		if (rx.search(line) == 0)
+			success = true;
+		rx = QRegExp("^Nothing to do: NTFS volume size is already OK.");
+		if (rx.search(line) == 0)
+			success = true;
+
+		rx = QRegExp("^Syncing device.*");
+		if (rx.search(line) == 0) {
+			emit sigTimer(99, QString(tr("Syncing device.")),
+				      QString::null);
+		}
+
+		rx = QRegExp("^ERROR.*: (.*)");
+		if (rx.search(line) == 0) {
+			QString captured = rx.cap(1);
+			_message = QString(captured);
+		}
+	}
+	fs_close();
 
-    return size;
+	if (success)
+		return true;
+	else {
+		if (_message.isNull())
+			_message = QString("An error occured! :(");
+		return false;
+	}
 }
 
-QString QP_FSNtfs::fsname() {
-    return QString("ntfs");
+bool QP_FSNtfs::mkpartfs(QString dev, QString label)
+{
+	QString cmdline;
+
+	/*---init of the error message---*/
+	_message = QString::null;
+
+	/*---prepare the command line---*/
+	if (label.isEmpty())
+		cmdline = " -f -s 512 " + dev;
+	else
+		cmdline = " -f -s 512 -L " + label + " " + dev;
+	cmdline = lstExternalTools->getPath(MKNTFS) + cmdline;
+
+	if (!fs_open(cmdline)) {
+		_message = QString(NOTFOUND);
+		return false;
+	}
+
+
+	bool success = false;
+	char *cline;
+	while ((cline = fs_getline())) {
+		QString line = QString(cline);
+
+		QRegExp rx;
+		rx = QRegExp("^mkntfs completed successfully. Have a nice day.");
+		if (rx.search(line) == 0)
+			success = true;
+
+		rx = QRegExp("^ERROR.*: (.*)");
+		if (rx.search(line) == 0) {
+			QString captured = rx.cap(1);
+			_message = QString(captured);
+			success = false;
+		}
+	}
+	fs_close();
+
+	return success;
+}
+
+PedSector QP_FSNtfs::min_size(QString dev)
+{
+	PedSector size = -1;
+
+	/*---init of the error message---*/
+	_message = QString::null;
+
+	/*---prepare the command line---*/
+	QString cmdline = lstExternalTools->getPath(NTFSRESIZE) + " -f -i " + dev;
+
+	if (!fs_open(cmdline)) {
+		_message = QString(NOTFOUND);
+		return false;
+	}
+
+
+	bool success = false;
+	char *cline;
+	while ((cline = fs_getline())) {
+		QString line = QString(cline);
+
+		QRegExp rx;
+		rx = QRegExp("^.*You ..... resize at (\\d*) bytes or (\\d*) .*");
+		if (rx.search(line) == 0) {
+			QString captured = rx.cap(1);
+			sscanf(captured.latin1(), "%lld", &size);
+			size /= 512;
+			size += 8 * MEGABYTE_SECTORS;
+
+			success = true;
+		}
+	}
+	fs_close();
+
+	return size;
+}
+
+QString QP_FSNtfs::fsname()
+{
+	return QString("ntfs");
 }
 
 /*QString QP_FSNtfs::_get_label(PedPartition *) {
-    return QString::null;
+	return QString::null;
 }*/
 
 
 
 /*---JFS WRAPPER-----------------------------------------------------------------*/
-QP_FSJfs::QP_FSJfs() {
-    wrap_resize = RS_ENLARGE;
-    wrap_move = false;
-    wrap_copy = false;
-    wrap_create = false;
-    wrap_min_size = false;
-
-    /*---check if the wrapper is installed---*/
-    QString cmdline = QString("which %1")
-                    .arg(lstExternalTools->getPath(MKFS_JFS));
-    fs_open(cmdline);
-
-    char *cline;
-    while ((cline = fs_getline()))
-        wrap_create = true;
-    fs_close();
-    
-}
-
-bool QP_FSJfs::resize(QP_LibParted *_libparted, bool write, QP_PartInfo *partinfo, PedSector new_start, PedSector new_end) {
-    /*---pointer to libparted---*/
-    QP_LibParted *libparted = _libparted;
-    
-    showDebug("%s", "Resizing a filesystem using a wrapper\n");
-
-    /*---the user want to shrink or enlarge the partition?---*/
-    /*---the user want to shrink!---*/
-    if (new_end < partinfo->end) {
-        /*---update the filesystem---*/
-        showDebug("%s", "shrinking filesystem not supported with jfs...\n");
-        return false;
-    /*---the user want to enlarge!---*/
-    } else {
-        /*---cannot enlarge if we cannot change disk geometry!---*/
-        if (partinfo->device()->isBusy()) {
-            showDebug("%s", "the device is busy, so you cannot enlarge it\n");
-            _message = tr("Cannot enlarge a partition if the disk device is busy");
-            return false;
-        }
-        
-        /*---first se the geometry of the partition---*/
-        showDebug("%s", "update geometry...\n");
-        if (!libparted->set_geometry(partinfo, new_start, new_end)) {
-            showDebug("%s", "update geometry ko\n");
-            _message = libparted->message();
-            return false;
-        } else {
-            /*---if you are NOT committing then add in the undo/commit list---*/
-            if (!write) {
-                showDebug("%s", "operation added to undo/commit list\n");
-                PedPartitionType parttype = libparted->type2parttype(partinfo->type);
-                PedGeometry geom = libparted->get_geometry(partinfo);
-                libparted->actlist->ins_resize(partinfo->num, new_start, new_end, geom, parttype);
-            }
-        }
-
-        if (write) {
-            /*---and now update the filesystem!---*/
-            showDebug("%s", "enlarge filesystem...\n");
-            if (!jfsresize(write, partinfo, new_end - new_start)) {
-                showDebug("%s", "enlarge filesystem ko\n");
-                return false;
-            } else {
-                return true;
-            }
-        } else {
-            return true;
-        }
-    }
-}
-
-bool QP_FSJfs::jfsresize(bool write, QP_PartInfo *partinfo, PedSector) {
-    char szcmdline[200];
-    QString cmdline;
-
-    bool error = false;
-
-    if (!write) return true;
-
-    /*---init of the error message---*/
-    _message = QString::null;
-
-    if (!qpMount(partinfo->partname()))
-        return false;
-
-
-    /*---do the resize!---*/
-    sprintf(szcmdline, "-o remount,resize= %s", TMP_MOUNTPOINT);
-    cmdline = QString("%1 %2")
-            .arg(lstExternalTools->getPath(MOUNT))
-            .arg(szcmdline);
-    
-    if (!fs_open(cmdline)) {
-        _message = QString(NOTFOUND);
-        return false;
-    }
-
-    char *cline;
-    while ((cline = fs_getline())) {
-       QString line = QString(cline);
-
-       QRegExp rx;
-       rx = QRegExp("^mount: (.*)$");
-       if (rx.search(line) == 0) {
-           QString capError = rx.cap(1);
-           _message = capError;
-           error = true;
-       }
-    }
-    fs_close();
-
-    if (error) return false;
-    
-    if (!qpUMount(partinfo->partname()))
-        return false;
-
-    return true;
-    /*fino a qui*/
-}
-
-bool QP_FSJfs::mkpartfs(QString dev, QString label) {
-    char szcmdline[200];
-    QString cmdline;
-
-    /*---init of the error message---*/
-    _message = QString::null;
-
-    /*---prepare the command line---*/
-    if (label.isEmpty())
-        sprintf(szcmdline, "-q %s", dev.latin1());
-    else
-        sprintf(szcmdline, "-q -L %s %s", label.latin1(), dev.latin1());
-    cmdline = QString("%1 %2")
-            .arg(lstExternalTools->getPath(MKFS_JFS))
-            .arg(szcmdline);
-
-    if (!fs_open(cmdline)) {
-        _message = QString(NOTFOUND);
-        return false;
-    }
-    
-
-    bool success = false;
-    char *cline;
-    while ((cline = fs_getline())) {
-       QString line = QString(cline);
-
-       QRegExp rx;
-       rx = QRegExp("^Format completed successfully.");
-       if (rx.search(line) == 0)
-           success = true;
-    }
-    fs_close();
-
-    return success;
-}
-
-QString QP_FSJfs::fsname() {
-    return QString("jfs");
-}
-
-QString QP_FSJfs::_get_label(PedPartition *part) 
-{
-  char bootsect[2048];
-  char label[12];
-
-  if (!QP_FSWrap::read_sector(part, 64, 4, bootsect)) 
-     return QString::null;
-
-  memset(label, 0, sizeof(label));
-  strncpy(label, bootsect+101, 11);
-  
-  return QString(label);
+QP_FSJfs::QP_FSJfs()
+{
+	wrap_resize = RS_ENLARGE;
+	wrap_move = false;
+	wrap_copy = false;
+	wrap_create = false;
+	wrap_min_size = false;
+
+	/*---check if the wrapper is installed---*/
+	QString cmdline = "which " + lstExternalTools->getPath(MKFS_JFS);
+	fs_open(cmdline);
+
+	char *cline;
+	while ((cline = fs_getline()))
+		wrap_create = true;
+	fs_close();
+
+}
+
+bool QP_FSJfs::resize(QP_LibParted * _libparted, bool write,
+		      QP_PartInfo * partinfo, PedSector new_start,
+		      PedSector new_end)
+{
+	/*---pointer to libparted---*/
+	QP_LibParted *libparted = _libparted;
+
+	showDebug("%s", "Resizing a filesystem using a wrapper\n");
+
+	/*---the user wants to shrink or enlarge the partition?---*/
+	/*---the user wants to shrink!---*/
+	if (new_end < partinfo->end) {
+		/*---update the filesystem---*/
+		showDebug("%s",
+			  "shrinking filesystem not supported with jfs...\n");
+		return false;
+	/*---the user want to enlarge!---*/
+	} else {
+		/*---cannot enlarge if we cannot change disk geometry!---*/
+		if (partinfo->device()->isBusy()) {
+			showDebug("%s",
+				  "the device is busy, so you cannot enlarge it\n");
+			_message = tr("Cannot enlarge a partition if the disk device is busy");
+			return false;
+		}
+
+		/*---first se the geometry of the partition---*/
+		showDebug("%s", "update geometry...\n");
+		if (!libparted->set_geometry(partinfo, new_start, new_end)) {
+			showDebug("%s", "update geometry ko\n");
+			_message = libparted->message();
+			return false;
+		} else {
+			/*---if you are NOT committing then add in the undo/commit list---*/
+			if (!write) {
+				showDebug("%s",
+					  "operation added to undo/commit list\n");
+				PedPartitionType parttype =
+				    libparted->type2parttype(partinfo->
+							     type);
+				PedGeometry geom =
+				    libparted->get_geometry(partinfo);
+				libparted->actlist->ins_resize(partinfo->
+							       num,
+							       new_start,
+							       new_end,
+							       geom,
+							       parttype);
+			}
+		}
+
+		if (write) {
+			/*---and now update the filesystem!---*/
+			showDebug("%s", "enlarge filesystem...\n");
+			if (!jfsresize
+			    (write, partinfo, new_end - new_start)) {
+				showDebug("%s", "enlarge filesystem ko\n");
+				return false;
+			} else {
+				return true;
+			}
+		} else {
+			return true;
+		}
+	}
+}
+
+bool QP_FSJfs::jfsresize(bool write, QP_PartInfo * partinfo, PedSector)
+{
+	QString cmdline;
+
+	bool error = false;
+
+	if (!write)
+		return true;
+
+	/*---init of the error message---*/
+	_message = QString::null;
+
+	if (!qpMount(partinfo->partname()))
+		return false;
+
+
+	/*---do the resize!---*/
+	cmdline = lstExternalTools->getPath(MOUNT) + " -o remount,resize= " + TMP_MOUNTPOINT;
+
+	if (!fs_open(cmdline)) {
+		_message = QString(NOTFOUND);
+		return false;
+	}
+
+	char *cline;
+	while ((cline = fs_getline())) {
+		QString line = QString(cline);
+
+		QRegExp rx;
+		rx = QRegExp("^mount: (.*)$");
+		if (rx.search(line) == 0) {
+			QString capError = rx.cap(1);
+			_message = capError;
+			error = true;
+		}
+	}
+	fs_close();
+
+	if (error)
+		return false;
+
+	if (!qpUMount(partinfo->partname()))
+		return false;
+
+	return true;
+	/*fino a qui */
+}
+
+bool QP_FSJfs::mkpartfs(QString dev, QString label)
+{
+	QString cmdline;
+
+	/*---init of the error message---*/
+	_message = QString::null;
+
+	/*---prepare the command line---*/
+	if (label.isEmpty())
+		cmdline = " -q " + dev;
+	else
+		cmdline = " -q -L " + label + " " + dev;
+	cmdline = lstExternalTools->getPath(MKFS_JFS) + cmdline;
+
+	if (!fs_open(cmdline)) {
+		_message = QString(NOTFOUND);
+		return false;
+	}
+
+
+	bool success = false;
+	char *cline;
+	while ((cline = fs_getline())) {
+		QString line = QString(cline);
+
+		QRegExp rx;
+		rx = QRegExp("^Format completed successfully.");
+		if (rx.search(line) == 0)
+			success = true;
+	}
+	fs_close();
+
+	return success;
+}
+
+QString QP_FSJfs::fsname()
+{
+	return QString("jfs");
+}
+
+QString QP_FSJfs::_get_label(PedPartition * part)
+{
+	char bootsect[2048];
+	char label[12];
+
+	if (!QP_FSWrap::read_sector(part, 64, 4, bootsect))
+		return QString::null;
+
+	memset(label, 0, sizeof(label));
+	strncpy(label, bootsect + 101, 11);
+
+	return QString(label);
 }
 
 /*---EXT3 WRAPPER----------------------------------------------------------------*/
-QP_FSExt3::QP_FSExt3() {
-    wrap_min_size = false;
-    wrap_resize = false;
-    wrap_move = false;
-    wrap_copy = false;
-    wrap_create = false;
-
-    /*---check if the wrapper is installed---*/
-    QString cmdline = QString("which %1")
-                    .arg(lstExternalTools->getPath(MKFS_EXT3));
-    fs_open(cmdline);
-
-    char *cline;
-    while ((cline = fs_getline()))
-        wrap_create = true;
-    fs_close();
-    
-}
-
-bool QP_FSExt3::mkpartfs(QString dev, QString label) {
-    char szcmdline[200];
-    QString cmdline;
-
-    /*---init of the error message---*/
-    _message = QString::null;
-
-    /*---prepare the command line---*/
-    if (label.isEmpty())
-        sprintf(szcmdline, "%s", dev.latin1());
-    else
-        sprintf(szcmdline, "-L %s %s", label.latin1(), dev.latin1());
-    cmdline = QString("%1 %2")
-            .arg(lstExternalTools->getPath(MKFS_EXT3))
-            .arg(szcmdline);
-
-    if (!fs_open(cmdline)) {
-        _message = QString(NOTFOUND);
-        return false;
-    }
-    
-
-    bool writenode = false;
-    bool success = false;
-    char *cline;
-    while ((cline = fs_getline())) {
-       QString line = QString(cline);
-
-       QRegExp rx;
-       rx = QRegExp("^Writing inode tables");
-       if (rx.search(line) == 0) {
-           writenode = true;
-       }
-
-       rx = QRegExp("^Creating journal");
-       if (rx.search(line) == 0) {
-           writenode = false;
-           emit sigTimer(90, QString(tr("Writing superblocks and filesystem.")), QString::null);
-       }
+QP_FSExt3::QP_FSExt3()
+{
+	wrap_min_size = false;
+	wrap_resize = false;
+	wrap_move = false;
+	wrap_copy = false;
+	wrap_create = false;
+
+	/*---check if the wrapper is installed---*/
+	QString cmdline = "which " + lstExternalTools->getPath(MKFS_EXT3);
+	fs_open(cmdline);
+
+	char *cline;
+	while ((cline = fs_getline()))
+		wrap_create = true;
+	fs_close();
+
+}
+
+bool QP_FSExt3::mkpartfs(QString dev, QString label)
+{
+	QString cmdline;
+
+	/*---init of the error message---*/
+	_message = QString::null;
+
+	/*---prepare the command line---*/
+	if (!label.isEmpty())
+		cmdline = " -L " + label;
+	cmdline = lstExternalTools->getPath(MKFS_EXT3) + cmdline + " " + dev;
+
+	if (!fs_open(cmdline)) {
+		_message = QString(NOTFOUND);
+		return false;
+	}
 
-       if (writenode) {
-           QString linesub = line;
+
+	bool writenode = false;
+	bool success = false;
+	char *cline;
+	while ((cline = fs_getline())) {
+		QString line = QString(cline);
+
+		QRegExp rx;
+		rx = QRegExp("^Writing inode tables");
+		if (rx.search(line) == 0) {
+			writenode = true;
+		}
+
+		rx = QRegExp("^Creating journal");
+		if (rx.search(line) == 0) {
+			writenode = false;
+			emit sigTimer(90,
+				      QString(tr
+					      ("Writing superblocks and filesystem.")),
+				      QString::null);
+		}
+
+		if (writenode) {
+			QString linesub = line;
 
 #ifdef QT30COMPATIBILITY
-            linesub.replace(QRegExp("\b"), " ");
+			linesub.replace(QRegExp("\b"), " ");
 #else
-            linesub.replace(QChar('\b'), " ");
+			linesub.replace(QChar('\b'), " ");
 #endif
-           rx = QRegExp("^.* (\\d*)/(\\d*) .*$");
-           if (rx.search(linesub) == 0) {
-               QString capActual = rx.cap(1);
-               QString capTotal = rx.cap(2);
-               
-               bool rc;
-               int iActual = capActual.toInt(&rc);
-               int iTotal = capTotal.toInt(&rc);
+			rx = QRegExp("^.* (\\d*)/(\\d*) .*$");
+			if (rx.search(linesub) == 0) {
+				QString capActual = rx.cap(1);
+				QString capTotal = rx.cap(2);
+
+				bool rc;
+				int iActual = capActual.toInt(&rc);
+				int iTotal = capTotal.toInt(&rc);
+
+				int iPerc = iActual * 80 / iTotal;	//The percentual is calculated in 80% ;)
+				emit sigTimer(iPerc,
+					      QString(tr
+						      ("Writing inode tables.")),
+					      QString::null);
+			}
+		}
+
+		rx = QRegExp("^Writing superblocks and filesystem accounting information: done");
+		if (rx.search(line) == 0)
+			success = true;
+	}
+	fs_close();
 
-               int iPerc = iActual*80/iTotal; //The percentual is calculated in 80% ;)
-               emit sigTimer(iPerc, QString(tr("Writing inode tables.")), QString::null);
-           }
-       }
+	if (!success)
+		_message = QString(tr("There was a problem with mkfs.ext3."));
 
-       rx = QRegExp("^Writing superblocks and filesystem accounting information: done");
-       if (rx.search(line) == 0)
-           success = true;
-    }
-    fs_close();
+	return success;
+}
 
-    if (!success) _message = QString(tr("There was a problem with mkfs.ext3."));
+QString QP_FSExt3::fsname()
+{
+	return QString("ext3");
+}
 
-    return success;
+QString QP_FSExt3::_get_label(PedPartition * p)
+{
+	return QP_FSExt2::_get_label(p);
+	//return QString::null;
 }
 
-QString QP_FSExt3::fsname() {
-    return QString("ext3");
+/*---XFS WRAPPER-----------------------------------------------------------------*/
+QP_FSXfs::QP_FSXfs()
+{
+	wrap_min_size = false;
+	wrap_resize = false;
+	wrap_move = false;
+	wrap_copy = false;
+	wrap_create = false;
+
+	/*---check if the wrapper is installed---*/
+	QString cmdline = "which " + lstExternalTools->getPath(MKFS_XFS);
+	fs_open(cmdline);
+
+	char *cline;
+	while ((cline = fs_getline()))
+		wrap_create = true;
+	fs_close();
+
+
+	/*---check if the wrapper is installed---*/
+	cmdline = "which " + lstExternalTools->getPath(XFS_GROWFS);
+	fs_open(cmdline);
+
+	while ((cline = fs_getline()))
+		wrap_resize = RS_ENLARGE;
+	fs_close();
 }
 
-QString QP_FSExt3::_get_label(PedPartition *p) 
+bool QP_FSXfs::mkpartfs(QString dev, QString label)
 {
-    return QP_FSExt2::_get_label(p);
-    //return QString::null;
+	QString cmdline;
+
+	/*---init of the error message---*/
+	_message = QString::null;
+
+	/*---prepare the command line---*/
+	if (label.isEmpty())
+		cmdline = " -f " + dev;
+	else
+		cmdline = " -f -L " + label + " " + dev;
+	cmdline = lstExternalTools->getPath(MKFS_XFS) + cmdline;
+
+	if (!fs_open(cmdline)) {
+		_message = QString(NOTFOUND);
+		return false;
+	}
+
+	bool success = false;
+	char *cline;
+	while ((cline = fs_getline())) {
+		QString line = QString(cline);
+
+		QRegExp rx;
+		rx = QRegExp("^realtime =.*");
+		if (rx.search(line) == 0)
+			success = true;
+	}
+	fs_close();
+
+	if (!success)
+		_message = QString(tr("There was a problem with mkfs.xfs."));
+	return success;
 }
 
-/*---XFS WRAPPER-----------------------------------------------------------------*/
-QP_FSXfs::QP_FSXfs() {
-    wrap_min_size = false;
-    wrap_resize = false;
-    wrap_move = false;
-    wrap_copy = false;
-    wrap_create = false;
-
-    /*---check if the wrapper is installed---*/
-    QString cmdline = QString("which %1")
-                    .arg(lstExternalTools->getPath(MKFS_XFS));
-    fs_open(cmdline);
-
-    char *cline;
-    while ((cline = fs_getline()))
-        wrap_create = true;
-    fs_close();
-    
-
-    /*---check if the wrapper is installed---*/
-    cmdline = QString("which %1")
-                    .arg(lstExternalTools->getPath(XFS_GROWFS));
-    fs_open(cmdline);
-
-    while ((cline = fs_getline()))
-        wrap_resize = RS_ENLARGE;
-    fs_close();
-}
-
-bool QP_FSXfs::mkpartfs(QString dev, QString label) {
-    char szcmdline[200];
-    QString cmdline;
-
-    /*---init of the error message---*/
-    _message = QString::null;
-
-    /*---prepare the command line---*/
-    if (label.isEmpty())
-        sprintf(szcmdline, "-f %s", dev.latin1());
-    else
-        sprintf(szcmdline, "-f -L %s %s", label.latin1(), dev.latin1());
-    cmdline = QString("%1 %2")
-            .arg(lstExternalTools->getPath(MKFS_XFS))
-            .arg(szcmdline);
-
-    if (!fs_open(cmdline)) {
-        _message = QString(NOTFOUND);
-        return false;
-    }    
-
-    bool success = false;
-    char *cline;
-    while ((cline = fs_getline())) {
-       QString line = QString(cline);
-
-       QRegExp rx;
-       rx = QRegExp("^realtime =.*");
-       if (rx.search(line) == 0)
-           success = true;
-    }
-    fs_close();
-
-    if (!success) _message = QString(tr("There was a problem with mkfs.xfs."));
-    return success;
-}
-
-bool QP_FSXfs::resize(QP_LibParted *_libparted, bool write, QP_PartInfo *partinfo, PedSector new_start, PedSector new_end) {
-    /*---pointer to libparted---*/
-    QP_LibParted *libparted = _libparted;
-    
+bool QP_FSXfs::resize(QP_LibParted * _libparted, bool write,
+		      QP_PartInfo * partinfo, PedSector new_start,
+		      PedSector new_end)
+{
+	/*---pointer to libparted---*/
+	QP_LibParted *libparted = _libparted;
+
 	showDebug("%s", "Resizing a filesystem using a wrapper\n");
 
-    /*---the user want to shrink or enlarge the partition?---*/
-    /*---the user want to shrink!---*/
-    if (new_end < partinfo->end) {
-        /*---update the filesystem---*/
-	    showDebug("%s", "shrinking filesystem not supported with xfs...\n");
-        return false;
-    /*---the user want to enlarge!---*/
-    } else {
-        /*---cannot enlarge if we cannot change disk geometry!---*/
-        if (partinfo->device()->isBusy()) {
-            showDebug("%s", "the device is busy, so you cannot enlarge it\n");
-            _message = tr("Cannot enlarge a partition if the disk device is busy");
-            return false;
-        }
-        
-        /*---first se the geometry of the partition---*/
-        showDebug("%s", "update geometry...\n");
-        if (!libparted->set_geometry(partinfo, new_start, new_end)) {
-            showDebug("%s", "update geometry ko\n");
-            _message = libparted->message();
-            return false;
-        } else {
-            /*---if you are NOT committing then add in the undo/commit list---*/
-            if (!write) {
-                showDebug("%s", "operation added to undo/commit list\n");
-                PedPartitionType parttype = libparted->type2parttype(partinfo->type);
-                PedGeometry geom = libparted->get_geometry(partinfo);
-                libparted->actlist->ins_resize(partinfo->num, new_start, new_end, geom, parttype);
-            }
-        }
-
-        if (write) {
-            /*---and now update the filesystem!---*/
-	        showDebug("%s", "enlarge filesystem...\n");
-            if (!xfsresize(write, partinfo, new_end - new_start)) {
-	            showDebug("%s", "enlarge filesystem ko\n");
-                return false;
-            } else {
-                return true;
-            }
-        } else {
-            return true;
-        }
-    }
-}
-
-bool QP_FSXfs::xfsresize(bool write, QP_PartInfo *partinfo, PedSector) {
-    char szcmdline[200];
-    QString cmdline;
-
-    bool error = false;
-
-    if (!write) return true;
-
-    /*---init of the error message---*/
-    _message = QString::null;
-
-    if (!qpMount(partinfo->partname()))
-        return false;
-
-    /*---do the resize!---*/
-    sprintf(szcmdline, "%s", TMP_MOUNTPOINT);
-    cmdline = QString("%1 %2")
-            .arg(lstExternalTools->getPath(XFS_GROWFS))
-            .arg(szcmdline);
-    
-    if (!fs_open(cmdline)) {
-        _message = QString(NOTFOUND);
-        return false;
-    }
-
-    error = true;
-    char *cline;
-    while ((cline = fs_getline())) {
-       QString line = QString(cline);
-
-       QRegExp rx;
-       rx = QRegExp("^realtime =.*");
-       if (rx.search(line) == 0) {
-           error = false;
-       }
-    }
-    fs_close();
-
-    if (error) {
-        _message = QString(tr("Error during xfs_grow."));
-        return false;
-    }
-    
-    if (!qpUMount(partinfo->partname()))
-        return false;
-
-    return true;
-}
-
-QString QP_FSXfs::fsname() 
-{
-    return QString("xfs");
-}
-
-QString QP_FSXfs::_get_label(PedPartition *part) 
-{
-  char bootsect[2048];
-  char label[13];
-
-  if (!QP_FSWrap::read_sector(part, 0, 4, bootsect)) 
-     return QString::null;
-	
-  memset(label, 0, sizeof(label));
-  strncpy(label, bootsect+108, 12);
-  
-  //printf("returned buffer ntfs: [%s]\n", label);
+	/*---the user wants to shrink or enlarge the partition?---*/
+	/*---the user wants to shrink!---*/
+	if (new_end < partinfo->end) {
+		/*---update the filesystem---*/
+		showDebug("%s",
+			  "shrinking filesystem not supported with xfs...\n");
+		return false;
+	/*---the user want to enlarge!---*/
+	} else {
+		/*---cannot enlarge if we cannot change disk geometry!---*/
+		if (partinfo->device()->isBusy()) {
+			showDebug("%s",
+				  "the device is busy, so you cannot enlarge it\n");
+			_message =
+			    tr
+			    ("Cannot enlarge a partition if the disk device is busy");
+			return false;
+		}
+
+		/*---first se the geometry of the partition---*/
+		showDebug("%s", "update geometry...\n");
+		if (!libparted->set_geometry(partinfo, new_start, new_end)) {
+			showDebug("%s", "update geometry ko\n");
+			_message = libparted->message();
+			return false;
+		} else {
+			/*---if you are NOT committing then add in the undo/commit list---*/
+			if (!write) {
+				showDebug("%s",
+					  "operation added to undo/commit list\n");
+				PedPartitionType parttype =
+				    libparted->type2parttype(partinfo->
+							     type);
+				PedGeometry geom =
+				    libparted->get_geometry(partinfo);
+				libparted->actlist->ins_resize(partinfo->
+							       num,
+							       new_start,
+							       new_end,
+							       geom,
+							       parttype);
+			}
+		}
+
+		if (write) {
+			/*---and now update the filesystem!---*/
+			showDebug("%s", "enlarge filesystem...\n");
+			if (!xfsresize
+			    (write, partinfo, new_end - new_start)) {
+				showDebug("%s", "enlarge filesystem ko\n");
+				return false;
+			} else {
+				return true;
+			}
+		} else {
+			return true;
+		}
+	}
+}
+
+bool QP_FSXfs::xfsresize(bool write, QP_PartInfo * partinfo, PedSector)
+{
+	QString cmdline;
+
+	bool error = false;
+
+	if (!write)
+		return true;
+
+	/*---init of the error message---*/
+	_message = QString::null;
+
+	if (!qpMount(partinfo->partname()))
+		return false;
+
+	/*---do the resize!---*/
+	cmdline = lstExternalTools->getPath(XFS_GROWFS) + " " + TMP_MOUNTPOINT;
+
+	if (!fs_open(cmdline)) {
+		_message = QString(NOTFOUND);
+		return false;
+	}
+
+	error = true;
+	char *cline;
+	while ((cline = fs_getline())) {
+		QString line = QString(cline);
+
+		QRegExp rx;
+		rx = QRegExp("^realtime =.*");
+		if (rx.search(line) == 0) {
+			error = false;
+		}
+	}
+	fs_close();
+
+	if (error) {
+		_message = QString(tr("Error during xfs_grow."));
+		return false;
+	}
 
-  return QString(label);
+	if (!qpUMount(partinfo->partname()))
+		return false;
+
+	return true;
+}
+
+QString QP_FSXfs::fsname()
+{
+	return QString("xfs");
+}
+
+QString QP_FSXfs::_get_label(PedPartition * part)
+{
+	char bootsect[2048];
+	char label[13];
+
+	if (!QP_FSWrap::read_sector(part, 0, 4, bootsect))
+		return QString::null;
+
+	memset(label, 0, sizeof(label));
+	strncpy(label, bootsect + 108, 12);
+
+	//printf("returned buffer ntfs: [%s]\n", label);
+
+	return QString(label);
 }
 
 /*---FAT16 WRAPPER---------------------------------------------------------------*/
-QString QP_FSFat16::_get_label(PedPartition *) 
+QString QP_FSFat16::_get_label(PedPartition *)
 {
-    return QString::null;
+	return QString::null;
 }
 
 
 /*---FAT32 WRAPPER---------------------------------------------------------------*/
-QString QP_FSFat32::_get_label(PedPartition *part) 
+QString QP_FSFat32::_get_label(PedPartition * part)
 {
-    char buffer[PED_SECTOR_SIZE];
-    char label[12];
-    
-    if (!QP_FSWrap::read_sector(part, 0, 1, buffer)) 
-    {
-        return QString::null;
-    } 
-    else 
-    {   
-        memset(label, 0, sizeof(label));
-        memcpy(label, buffer+0x47, 11);
-        //printf("returned fat buffer: %s\n", label);
-        return QString(label);
-    }
+#ifdef PED_SECTOR_SIZE // PED_SECTOR_SIZE is gone in parted 1.7.x
+	char *buffer=new char[PED_SECTOR_SIZE];
+#else
+	char *buffer=new char[part->disk->dev->sector_size];
+#endif
+	char label[12];
+
+	if (!QP_FSWrap::read_sector(part, 0, 1, buffer)) {
+		delete[] buffer;
+		return QString::null;
+	}
+
+	memset(label, 0, sizeof(label));
+	memcpy(label, buffer + 0x47, 11);
+	//printf("returned fat buffer: %s\n", label);
+	delete[] buffer;
+	return QString(label);
 }
 
 /*---EXT2 WRAPPER----------------------------------------------------------------*/
-QString QP_FSExt2::_get_label(PedPartition *part) 
+QString QP_FSExt2::_get_label(PedPartition * part)
 {
-  char bootsect[2048]; // sector number 2 (offset 1024)
-  char label[16];
+	char bootsect[2048];	// sector number 2 (offset 1024)
+	char label[16];
 
-  if (!QP_FSWrap::read_sector(part, 2, 4, bootsect)) 
-     return QString::null;
-	
-  memset(label, 0, sizeof(label));
-  strncpy(label, bootsect+120, 16);
-  
-  //printf("returned buffer ext2/3: [%s]\n", label);
+	if (!QP_FSWrap::read_sector(part, 2, 4, bootsect))
+		return QString::null;
 
-  return QString(label);
+	memset(label, 0, sizeof(label));
+	strncpy(label, bootsect + 120, 16);
+
+	//printf("returned buffer ext2/3: [%s]\n", label);
+
+	return QString(label);
 }
 
 
 /*---REISERFS WRAPPER------------------------------------------------------------*/
-QString QP_FSReiserFS::_get_label(PedPartition *) 
+QString QP_FSReiserFS::_get_label(PedPartition *)
 {
-    //return QString::null;
-    return tr("No label");
+	//return QString::null;
+	return tr("No label");
 }
 
 
-QString QP_FSNtfs::_get_label(PedPartition *part) 
+QString QP_FSNtfs::_get_label(PedPartition * part)
 {
-  u8 bootsect[16384];
-  char label[32];
-  memset(label, 0, sizeof(label));
-  BYTE cFileRecord[8192+1]; // 1024 should be enough (dwFileRecordSize)
-
-  QWORD qwOffset;
-  WORD nOffsetSequenceAttribute;
-  BYTE *cData;
-  DWORD dwAttribType;
-  DWORD dwAttribLen;
-  bool bAttribResident;	
-  BYTE *cDataResident;
-  WORD nAttrSize;
-  u32 dwFileRecordSize;
-  QWORD i;
-
-  if (!QP_FSWrap::read_sector(part, 0, 32, (char*)bootsect)) 
-     return QString::null;
-	  
-  // 1. check partition has an ntfs file system
-  if (memcmp(bootsect+3, "NTFS", 4) != 0)
-  {
-     //printf ("NTFS-001: not an NTFS partition\n");
-     return QString::null;
-  }
-
-  u16 nBytesPerSector = NTFS_GETU16(bootsect+0xB);
-  u8 cSectorsPerCluster = NTFS_GETU8(bootsect+0xD);
-  u64 qwTotalSectorsCount = NTFS_GETU64(bootsect+0x28);
-  u64 qwLCNOfMftDataAttrib = NTFS_GETU64(bootsect+0x30);
-  s8 cClustersPerMftRecord = NTFS_GETS8(bootsect+0x40);
-  
-  // check informations validity
-  if (nBytesPerSector % 512 != 0)
-  {
-     //printf ("NTFS-002: invalid nBytesPerSector value\n");
-     return QString::null;
-  }
-  
-  // Calculate clusters and misc informations
-  u32 dwClusterSize = (DWORD)nBytesPerSector * cSectorsPerCluster;
-
-  
-  if (cClustersPerMftRecord > 0)
-    dwFileRecordSize = cClustersPerMftRecord * dwClusterSize;
-  else
-    dwFileRecordSize = 1 << (-cClustersPerMftRecord);
-  
-  // 1. read $Volume record
-  qwOffset = ((QWORD) qwLCNOfMftDataAttrib * dwClusterSize) + ((QWORD) (3 * dwFileRecordSize));
-  
-  u32 dwOffsetToRead = (u32) (qwOffset / ((u64)512));
-  u32 dwSectorCountToRead = (u32) dwFileRecordSize/512;
-  
-  if (!QP_FSWrap::read_sector(part, dwOffsetToRead, dwSectorCountToRead, (char*)cFileRecord)) 
-    {
-      //printf("readVolumeLabel(): failed in readData()\n");
-      return QString::null;
-    }
-    
-  // -------- decode the MFT File record
-  nOffsetSequenceAttribute = NTFS_GETU16(cFileRecord+0x14);
-  cData = cFileRecord + nOffsetSequenceAttribute;
-  
-  do
-    {
-      // szData points to the beginning of an attribute
-      dwAttribType = NTFS_GETU32(cData);
-      dwAttribLen = NTFS_GETU32(cData+4);
-      bAttribResident = (NTFS_GETU8(cData+8)==0);
-      
-      if(dwAttribType == 0x60) // "volume_name"
-	{
-	  if (bAttribResident == false)
-	    {
-	      //printf("readVolumeLabel(): failed: $volume_name attribute is not resident\n");
-	      return QString::null;
-	    }
-	  
-	  nAttrSize = NTFS_GETU16(cData+0x10);
-	  cDataResident = cData+NTFS_GETU16(cData+0x14);
-	  
-	  for (i=0; i < (DWORD)(nAttrSize/2); i++)
-	    label[i] = cDataResident[2*i];
-	}
-      /*if(dwAttribType == 0x70) // "volume_information"
-	{	
-	  int nNtfsVersion = 0;
-	  if (bAttribResident == true)
-	    {	
-	      nAttrSize = NTFS_GETU16(cData+0x10);
-	      cDataResident = cData+NTFS_GETU16(cData+0x14);
-	      nNtfsVersion = (((BYTE) cDataResident[8]) << 8) | ((BYTE) cDataResident[9]);
-	      printf("readVolumeLabel(): version is %d.%d\n", cDataResident[8], cDataResident[9]);
-	    }
-	}*/
-      
-      cData += dwAttribLen;
-    } while(dwAttribType != (DWORD)-1); // attribute list ends with type -1
+	u8 bootsect[16384];
+	char label[32];
+	memset(label, 0, sizeof(label));
+	BYTE cFileRecord[8192 + 1];	// 1024 should be enough (dwFileRecordSize)
+
+	QWORD qwOffset;
+	WORD nOffsetSequenceAttribute;
+	BYTE *cData;
+	DWORD dwAttribType;
+	DWORD dwAttribLen;
+	bool bAttribResident;
+	BYTE *cDataResident;
+	WORD nAttrSize;
+	u32 dwFileRecordSize;
+	QWORD i;
+
+	if (!QP_FSWrap::read_sector(part, 0, 32, (char *) bootsect))
+		return QString::null;
+
+	// 1. check partition has an ntfs file system
+	if (memcmp(bootsect + 3, "NTFS", 4) != 0) {
+		//printf ("NTFS-001: not an NTFS partition\n");
+		return QString::null;
+	}
+
+	u16 nBytesPerSector = NTFS_GETU16(bootsect + 0xB);
+	u8 cSectorsPerCluster = NTFS_GETU8(bootsect + 0xD);
+	u64 qwTotalSectorsCount = NTFS_GETU64(bootsect + 0x28);
+	u64 qwLCNOfMftDataAttrib = NTFS_GETU64(bootsect + 0x30);
+	s8 cClustersPerMftRecord = NTFS_GETS8(bootsect + 0x40);
+
+	// check informations validity
+	if (nBytesPerSector % 512 != 0) {
+		//printf ("NTFS-002: invalid nBytesPerSector value\n");
+		return QString::null;
+	}
+	// Calculate clusters and misc informations
+	u32 dwClusterSize = (DWORD) nBytesPerSector * cSectorsPerCluster;
+
+
+	if (cClustersPerMftRecord > 0)
+		dwFileRecordSize = cClustersPerMftRecord * dwClusterSize;
+	else
+		dwFileRecordSize = 1 << (-cClustersPerMftRecord);
+
+	// 1. read $Volume record
+	qwOffset =
+	    ((QWORD) qwLCNOfMftDataAttrib * dwClusterSize) +
+	    ((QWORD) (3 * dwFileRecordSize));
+
+	u32 dwOffsetToRead = (u32) (qwOffset / ((u64) 512));
+	u32 dwSectorCountToRead = (u32) dwFileRecordSize / 512;
+
+	if (!QP_FSWrap::
+	    read_sector(part, dwOffsetToRead, dwSectorCountToRead,
+			(char *) cFileRecord)) {
+		//printf("readVolumeLabel(): failed in readData()\n");
+		return QString::null;
+	}
+	// -------- decode the MFT File record
+	nOffsetSequenceAttribute = NTFS_GETU16(cFileRecord + 0x14);
+	cData = cFileRecord + nOffsetSequenceAttribute;
+
+	do {
+		// szData points to the beginning of an attribute
+		dwAttribType = NTFS_GETU32(cData);
+		dwAttribLen = NTFS_GETU32(cData + 4);
+		bAttribResident = (NTFS_GETU8(cData + 8) == 0);
+
+		if (dwAttribType == 0x60)	// "volume_name"
+		{
+			if (bAttribResident == false) {
+				//printf("readVolumeLabel(): failed: $volume_name attribute is not resident\n");
+				return QString::null;
+			}
+
+			nAttrSize = NTFS_GETU16(cData + 0x10);
+			cDataResident = cData + NTFS_GETU16(cData + 0x14);
+
+			for (i = 0; i < (DWORD) (nAttrSize / 2); i++)
+				label[i] = cDataResident[2 * i];
+		}
+		/*if(dwAttribType == 0x70) // "volume_information"
+		   {      
+		   int nNtfsVersion = 0;
+		   if (bAttribResident == true)
+		   {      
+		   nAttrSize = NTFS_GETU16(cData+0x10);
+		   cDataResident = cData+NTFS_GETU16(cData+0x14);
+		   nNtfsVersion = (((BYTE) cDataResident[8]) << 8) | ((BYTE) cDataResident[9]);
+		   printf("readVolumeLabel(): version is %d.%d\n", cDataResident[8], cDataResident[9]);
+		   }
+		   } */
+
+		cData += dwAttribLen;
+	} while (dwAttribType != (DWORD) - 1);	// attribute list ends with type -1
 
-  return QString(label);
+	return QString(label);
 }
diff -Naur qtparted-0.4.5.orig/src/qp_fswrap.h qtparted-0.4.5/src/qp_fswrap.h
--- qtparted-0.4.5.orig/src/qp_fswrap.h	2005-07-06 23:29:54.000000000 +0200
+++ qtparted-0.4.5/src/qp_fswrap.h	2006-01-16 01:43:30.000000000 +0100
@@ -161,7 +161,7 @@
 protected:
     bool qpMount(QString device);
     bool qpUMount(QString device);
-    bool fs_open(QString cmdline);
+    bool fs_open(QString cmdline, bool localized=false);
     char *fs_getline();
     int fs_close();
     QString _message;
diff -Naur qtparted-0.4.5.orig/src/qp_partition.cpp qtparted-0.4.5/src/qp_partition.cpp
--- qtparted-0.4.5.orig/src/qp_partition.cpp	2003-08-27 18:13:22.000000000 +0200
+++ qtparted-0.4.5/src/qp_partition.cpp	2005-10-15 13:13:01.000000000 +0200
@@ -22,8 +22,7 @@
 #include "qp_partition.h"
 #include "qp_options.h"
 
-QP_Partition::QP_Partition(QP_PartInfo *pinfo, QWidget *parent, const char *name, WFlags f) 
-    :QP_PartWidget(pinfo, parent, name, f) {
+QP_Partition::QP_Partition(QP_PartInfo *pinfo, QWidget *parent, const char *name, WFlags f):QP_PartWidget(pinfo, parent, name, f) {
 }
 
 QP_Partition::~QP_Partition() {
diff -Naur qtparted-0.4.5.orig/src/qp_partition.h qtparted-0.4.5/src/qp_partition.h
--- qtparted-0.4.5.orig/src/qp_partition.h	2003-08-27 18:13:19.000000000 +0200
+++ qtparted-0.4.5/src/qp_partition.h	2005-10-15 13:13:01.000000000 +0200
@@ -36,8 +36,8 @@
 Q_OBJECT
 
 public:
-    QP_Partition(QP_PartInfo *, QWidget *parent=0, const char *name=0, WFlags f = 0);
-    ~QP_Partition();
+	QP_Partition(QP_PartInfo *, QWidget *parent=0, const char *name=0, WFlags f = 0);
+	~QP_Partition();
 };
 
 #endif
diff -Naur qtparted-0.4.5.orig/src/qp_partlist.cpp qtparted-0.4.5/src/qp_partlist.cpp
--- qtparted-0.4.5.orig/src/qp_partlist.cpp	2003-08-27 18:13:19.000000000 +0200
+++ qtparted-0.4.5/src/qp_partlist.cpp	2005-10-15 12:58:31.000000000 +0200
@@ -23,29 +23,29 @@
 #include "qp_options.h"
 
 QP_PartList::QP_PartList(QWidget *parent, const char *name, WFlags f)
-    :QWidget(parent, name, f) {
+	:QWidget(parent, name, f) {
 }
 
 QP_PartList::~QP_PartList() {
 }
 
 QP_PartInfo *QP_PartList::selPartInfo() {
-    return _selPartInfo;
+	return _selPartInfo;
 }
 
 void QP_PartList::setselPartInfo(QP_PartInfo *partinfo) {
-    _selPartInfo = partinfo;
+	_selPartInfo = partinfo;
 }
 
 void QP_PartList::clear() {
 }
 
 QP_Device *QP_PartList::device() {
-    return _device;
+	return _device;
 }
 
 void QP_PartList::setDevice(QP_Device *device) {
-    _device = device;
+	_device = device;
 }
 
 void QP_PartList::addPrimary(QP_PartInfo *) {
@@ -58,9 +58,9 @@
 }
 
 float QP_PartList::mb_hdsize() {
-    return _mb_hdsize;
+	return _mb_hdsize;
 }
 
 void QP_PartList::set_mb_hdsize(float mb_hdsize) {
-    _mb_hdsize = mb_hdsize;
+	_mb_hdsize = mb_hdsize;
 }
diff -Naur qtparted-0.4.5.orig/src/qp_partlist.h qtparted-0.4.5/src/qp_partlist.h
--- qtparted-0.4.5.orig/src/qp_partlist.h	2003-08-27 18:13:22.000000000 +0200
+++ qtparted-0.4.5/src/qp_partlist.h	2005-10-15 12:58:31.000000000 +0200
@@ -34,33 +34,32 @@
 #include "qp_libparted.h"
 
 class QP_PartList : public QWidget {
-Q_OBJECT
-
+	Q_OBJECT
 public:
-    QP_PartList(QWidget *parent=0, const char *name=0, WFlags f = 0);
-    ~QP_PartList();
-    QP_PartInfo *selPartInfo();                  /*---return selected partition              ---*/
-    void setselPartInfo(QP_PartInfo *);          /*---change the selected partition          ---*/
-    void clear();                                /*---clear the chart                        ---*/
-    QP_Device *device();                         /*---return the device                      ---*/
-    void setDevice(QP_Device *);                 /*---set the Device                         ---*/
-    void addPrimary(QP_PartInfo *);              /*---add a Primary or Extended partition    ---*/
-    void addLogical(QP_PartInfo *);              /*---add a Logical partition                ---*/
-    void draw();                                 /*---repaint the widget                     ---*/
-    float mb_hdsize();                           /*---return the size of the hardisk         ---*/
-    void set_mb_hdsize(float);                   /*---set the size of the hardisk            ---*/
+	QP_PartList(QWidget *parent=0, const char *name=0, WFlags f = 0);
+	~QP_PartList();
+	QP_PartInfo *selPartInfo();		/*---return selected partition              ---*/
+	void setselPartInfo(QP_PartInfo *);	/*---change the selected partition          ---*/
+	void clear();				/*---clear the chart                        ---*/
+	QP_Device *device();			/*---return the device                      ---*/
+	void setDevice(QP_Device *);		/*---set the Device                         ---*/
+	void addPrimary(QP_PartInfo *);		/*---add a Primary or Extended partition    ---*/
+	void addLogical(QP_PartInfo *);		/*---add a Logical partition                ---*/
+	void draw();				/*---repaint the widget                     ---*/
+	float mb_hdsize();			/*---return the size of the hardisk         ---*/
+	void set_mb_hdsize(float);		/*---set the size of the hardisk            ---*/
 
 private:
-    float _mb_hdsize;                            /*---size of the harddisk in megabyte       ---*/
-    QP_Device *_device;                          /*---the device                             ---*/
+	float _mb_hdsize;			/*---size of the harddisk in megabyte       ---*/
+	QP_Device *_device;			/*---the device                             ---*/
 
 protected:
-    QP_PartInfo *_selPartInfo;                   /*---partition selected                     ---*/
+	QP_PartInfo *_selPartInfo;		/*---partition selected                     ---*/
 
 signals:
-    void sigSelectPart(QP_PartInfo *);           /*---emitted when you change the selection  ---*/
-    void sigDevicePopup(QPoint);                 /*---emitted when you want to popup (device)---*/
-    void sigPopup(QPoint);                       /*---emitted when you want to pop (partition)--*/
+	void sigSelectPart(QP_PartInfo *);	/*---emitted when you change the selection  ---*/
+	void sigDevicePopup(QPoint);		/*---emitted when you want to popup (device)---*/
+	void sigPopup(QPoint);			/*---emitted when you want to pop (partition)--*/
 };
 
 #endif
diff -Naur qtparted-0.4.5.orig/src/qp_spinbox.cpp qtparted-0.4.5/src/qp_spinbox.cpp
--- qtparted-0.4.5.orig/src/qp_spinbox.cpp	2003-08-27 18:13:19.000000000 +0200
+++ qtparted-0.4.5/src/qp_spinbox.cpp	2005-10-15 13:13:01.000000000 +0200
@@ -25,24 +25,22 @@
 #include "qp_options.h"
 
 QP_SpinBox::QP_SpinBox(QWidget *parent, const char *name)
-    :QSpinBox (parent, name) {
-    /*---initialization of the default value---*/
-    _floatminval = 0;
-    _floatmaxval = 0;
-    _pedminval = 0;
-    _pedmaxval = 0;
-    _pedvalue = 0;
-    step = 1;
-    _floatvalue = 0;
-    _format = 0;
-    _update = true;
-
-    /*---format of the displayed string (ie: 999.99)---*/
-    format = "%3.2f";
-    setValue((float)0);
-    setSteps(10, 10);
-    val = new QDoubleValidator(_floatminval, _floatmaxval, 2, this);
-    setValidator (val);
+	:QSpinBox (parent, name)
+	,_floatminval(0)
+	,_floatmaxval(0)
+	,_pedminval(0)
+	,_pedmaxval(0)
+	,step(1)
+	,_floatvalue(0)
+	,_format(0)
+	,_update(true)
+{
+	/*---format of the displayed string (ie: 999.99)---*/
+	format = "%3.2f";
+	setValue((float)0);
+	setSteps(10, 10);
+	val = new QDoubleValidator(_floatminval, _floatmaxval, 2, this);
+	setValidator (val);
 }
 
 
@@ -51,189 +49,204 @@
 
 
 void QP_SpinBox::setFormatString (const char *fmt) {
-    format = fmt;
+	format = fmt;
 }
 
 
 /*---change between mbyte and gbyte---*/
 void QP_SpinBox::setFormat(int format) {
-    _format = format;
-    float f_minvalue = 0;
-    float f_maxvalue = 0;
-    float f_value = 0;
-
-    if (_format == 0) { f_minvalue = float(_pedminval * 1.0 / MBYTE_SECTORS);
-                        f_maxvalue = float(_pedmaxval * 1.0 / MBYTE_SECTORS);
-                        f_value = float(_pedvalue * 1.0 / MBYTE_SECTORS);     } else
-    if (_format == 1) { f_minvalue = float(_pedminval * 1.0 / GBYTE_SECTORS);
-                        f_maxvalue = float(_pedmaxval * 1.0 / GBYTE_SECTORS);
-                        f_value = float(_pedvalue * 1.0 / GBYTE_SECTORS);     }
-
-    /*---don't update internal ped values!---*/
-    _update = false;
-    setRange(f_minvalue, f_maxvalue);
-    setValue(f_value);
-    _update = true;
+	_format = format;
+	float f_minvalue = 0;
+	float f_maxvalue = 0;
+	float f_value = 0;
+
+	if (_format == 0) {
+		f_minvalue = float(_pedminval * 1.0 / MBYTE_SECTORS);
+		f_maxvalue = float(_pedmaxval * 1.0 / MBYTE_SECTORS);
+		f_value = float(_pedvalue * 1.0 / MBYTE_SECTORS);
+	} else if (_format == 1) {
+		f_minvalue = float(_pedminval * 1.0 / GBYTE_SECTORS);
+		f_maxvalue = float(_pedmaxval * 1.0 / GBYTE_SECTORS);
+		f_value = float(_pedvalue * 1.0 / GBYTE_SECTORS);
+	}
+
+	/*---don't update internal ped values!---*/
+	_update = false;
+	setRange(f_minvalue, f_maxvalue);
+	setValue(f_value);
+	_update = true;
 }
 
-
 void QP_SpinBox::setValue(float value) {
-    char buf[20];
-    if (_floatminval <= value && value <= _floatmaxval) {
-        sprintf (buf, (const char *) format, value);
-        _floatvalue = value;
-        QSpinBox::setValue(int(value * 100.0));
-    }
+	char buf[20];
+	if (_floatminval <= value && value <= _floatmaxval) {
+		sprintf (buf, (const char *) format, value);
+		_floatvalue = value;
+		QSpinBox::setValue(int(value * 100.0));
+	}
 }
 
 
 void QP_SpinBox::setValue(PedSector value) {
-    if (_pedminval <= value && value <= _pedmaxval) {
-        float f_value = 0;
-
-        if (_format == 0) f_value = float(value * 1.0 / MBYTE_SECTORS); else
-        if (_format == 1) f_value = float(value * 1.0 / GBYTE_SECTORS);
-
-        _pedvalue = value;
+	if (_pedminval <= value && value <= _pedmaxval) {
+		float f_value = 0;
 
-        /*---don't update internal ped values!---*/
-        _update = false;
-        setValue(f_value);
-        _update = true;
-    }
+		if (_format == 0)
+			f_value = float(value * 1.0 / MBYTE_SECTORS); else
+		if (_format == 1)
+			f_value = float(value * 1.0 / GBYTE_SECTORS);
+
+		_pedvalue = value;
+
+		/*---don't update internal ped values!---*/
+		_update = false;
+		setValue(f_value);
+		_update = true;
+	}
 }
 
 
 void QP_SpinBox::setMaxValue(PedSector maxVal) {
-    float f_maxvalue = 0;
+	float f_maxvalue = 0;
 
-    _pedmaxval = maxVal;
+	_pedmaxval = maxVal;
 
-    if (_format == 0) {f_maxvalue = float(maxVal * 1.0 / MBYTE_SECTORS);} else
-    if (_format == 1) {f_maxvalue = float(maxVal * 1.0 / GBYTE_SECTORS);}
+	if (_format == 0)
+		f_maxvalue = float(maxVal * 1.0 / MBYTE_SECTORS);
+	else if (_format == 1)
+		f_maxvalue = float(maxVal * 1.0 / GBYTE_SECTORS);
 
-    setMaxValue(f_maxvalue);
+	setMaxValue(f_maxvalue);
 }
 
 
 void QP_SpinBox::setMinValue(PedSector minVal) {
-    float f_minvalue = 0;
+	float f_minvalue = 0;
 
-    _pedminval = minVal;
+	_pedminval = minVal;
 
-    if (_format == 0) {f_minvalue = float(minVal * 1.0 / MBYTE_SECTORS);} else
-    if (_format == 1) {f_minvalue = float(minVal * 1.0 / GBYTE_SECTORS);}
+	if (_format == 0)
+		f_minvalue = float(minVal * 1.0 / MBYTE_SECTORS);
+	else if (_format == 1)
+		f_minvalue = float(minVal * 1.0 / GBYTE_SECTORS);
 
-    setMinValue(f_minvalue);
+	setMinValue(f_minvalue);
 }
 
 
 void QP_SpinBox::setStep (float s) {
-    step = s;
-    setSteps ((int)(step * 10.0), (int)(step * 10.0));
+	step = s;
+	setSteps ((int)(step * 10.0), (int)(step * 10.0));
 }
 
-
 float QP_SpinBox::getStep() const {
-    return step;
+	return step;
 }
 
-
 void QP_SpinBox::setRange(float minVal, float maxVal) {
-    if (minVal <= maxVal) {
-        _floatminval = minVal;
-        _floatmaxval = maxVal;
-        QRangeControl::setRange(int(minVal * 100.0), int(maxVal * 100.0));
-        val->setRange(minVal, maxVal, 2);
-    }
+	if (minVal <= maxVal) {
+		_floatminval = minVal;
+		_floatmaxval = maxVal;
+		QRangeControl::setRange(int(minVal * 100.0), int(maxVal * 100.0));
+		val->setRange(minVal, maxVal, 2);
+	}
 }
 
 
 void QP_SpinBox::setRange(PedSector minVal, PedSector maxVal) {
-    float f_minvalue = 0;
-    float f_maxvalue = 0;
+	float f_minvalue = 0;
+	float f_maxvalue = 0;
 
-    _pedminval = minVal;
-    _pedmaxval = maxVal;
+	_pedminval = minVal;
+	_pedmaxval = maxVal;
 
-    if (_format == 0) { f_minvalue = float(minVal * 1.0 / MBYTE_SECTORS);
-                        f_maxvalue = float(maxVal * 1.0 / MBYTE_SECTORS); } else
-    if (_format == 1) { f_minvalue = float(minVal * 1.0 / GBYTE_SECTORS);
-                        f_maxvalue = float(maxVal * 1.0 / GBYTE_SECTORS); }
+	if (_format == 0) { f_minvalue = float(minVal * 1.0 / MBYTE_SECTORS);
+						f_maxvalue = float(maxVal * 1.0 / MBYTE_SECTORS); } else
+	if (_format == 1) { f_minvalue = float(minVal * 1.0 / GBYTE_SECTORS);
+						f_maxvalue = float(maxVal * 1.0 / GBYTE_SECTORS); }
 
-    setRange(f_minvalue, f_maxvalue);
+	setRange(f_minvalue, f_maxvalue);
 }
 
 
 void QP_SpinBox::getRange(float &minVal, float &maxVal) {
-    minVal = _floatminval;
-    maxVal = _floatmaxval;
+	minVal = _floatminval;
+	maxVal = _floatmaxval;
 }
 
 PedSector QP_SpinBox::pedValue() {
-    return _pedvalue;
+	return _pedvalue;
 }
 
 PedSector QP_SpinBox::pedMaxValue() {
-    return _pedmaxval;
+	return _pedmaxval;
 }
 
 void QP_SpinBox::stepUp() {
-    QSpinBox::stepUp();
+	QSpinBox::stepUp();
 
-    int diff = int(_floatmaxval * 100.0) - int(_floatvalue * 100.0);
-    if (diff <= 1) _pedvalue = _pedmaxval;
+	int diff = int(_floatmaxval * 100.0) - int(_floatvalue * 100.0);
+	if (diff <= 1) _pedvalue = _pedmaxval;
 }
 
 void QP_SpinBox::stepDown() {
-    QSpinBox::stepDown();
+	QSpinBox::stepDown();
 
-    int diff = int(_floatvalue * 100.0) - int(_floatminval * 100.0);
-    if (diff <= 1) _pedvalue = _pedminval;
+	int diff = int(_floatvalue * 100.0) - int(_floatminval * 100.0);
+	if (diff <= 1) _pedvalue = _pedminval;
 }
 
 void QP_SpinBox::setMaxValue(float maxvalue) {
-    _floatmaxval = maxvalue;
-    QSpinBox::setMaxValue(int(maxvalue * 100.0));
+	_floatmaxval = maxvalue;
+	QSpinBox::setMaxValue(int(maxvalue * 100.0));
 }
 
 void QP_SpinBox::setMinValue(float minvalue) {
-    _floatminval = minvalue;
-    QSpinBox::setMinValue(int(minvalue * 100.0));
+	_floatminval = minvalue;
+	QSpinBox::setMinValue(int(minvalue * 100.0));
 }
 
 void QP_SpinBox::valueChange() {
-    bool rc;
-    updateDisplay();
-    mapTextToValue(&rc);
-
-    /*---don't update internal ped values!---*/
-    if (_update)
-        if (_floatvalue == _floatminval) _pedvalue = _pedminval; else
-        if (_floatvalue == _floatmaxval) _pedvalue = _pedmaxval; else {
-            if (_format == 0) _pedvalue = PedSector(_floatvalue * MBYTE_SECTORS); else
-            if (_format == 1) _pedvalue = PedSector(_floatvalue * GBYTE_SECTORS);
-        }
-
-    /*---ped value should be beetween min and max---*/
-    if (_pedvalue < _pedminval) _pedvalue = _pedminval;
-    if (_pedvalue > _pedmaxval) _pedvalue = _pedmaxval;
+	bool rc;
+	updateDisplay();
+	mapTextToValue(&rc);
+
+	/*---don't update internal ped values!---*/
+	if (_update) {
+		if (_floatvalue == _floatminval)
+			_pedvalue = _pedminval;
+		else if (_floatvalue == _floatmaxval)
+			_pedvalue = _pedmaxval;
+		else {
+			if (_format == 0)
+				_pedvalue = PedSector(_floatvalue * MBYTE_SECTORS);
+			else if (_format == 1)
+				_pedvalue = PedSector(_floatvalue * GBYTE_SECTORS);
+		}
+	}
+
+	/*---ped value should be beetween min and max---*/
+	if (_pedvalue < _pedminval)
+		_pedvalue = _pedminval;
+
+	if (_pedvalue > _pedmaxval)
+		_pedvalue = _pedmaxval;
 
-    emit valueChanged(_pedvalue);
+	emit valueChanged(_pedvalue);
 }
 
 
 int QP_SpinBox::mapTextToValue(bool *ok) {
-    const char *txt = text();
-    _floatvalue = atof(txt);
-    *ok = true;
-    return int(_floatvalue * 100.0);
+	const char *txt = text();
+	_floatvalue = atof(txt);
+	*ok = true;
+	return int(_floatvalue * 100.0);
 }
 
 
 QString QP_SpinBox::mapValueToText(int v) {
-    float f = float(v) / 100.0;
-    QString buf;
-    buf.sprintf((const char *)format, f);
-    return buf;
+	float f = float(v) / 100.0;
+	QString buf;
+	buf.sprintf((const char *)format, f);
+	return buf;
 }
diff -Naur qtparted-0.4.5.orig/src/qp_spinbox.h qtparted-0.4.5/src/qp_spinbox.h
--- qtparted-0.4.5.orig/src/qp_spinbox.h	2003-08-27 18:13:18.000000000 +0200
+++ qtparted-0.4.5/src/qp_spinbox.h	2005-10-15 13:13:01.000000000 +0200
@@ -42,51 +42,50 @@
 typedef long long PedSector;
 
 class QP_SpinBox : public QSpinBox {
-    Q_OBJECT
+	Q_OBJECT
 public:
-    QP_SpinBox(QWidget *parent = 0L, const char *name = 0L);
-    ~QP_SpinBox();
+	QP_SpinBox(QWidget *parent = 0L, const char *name = 0L);
+	~QP_SpinBox();
 
-    void setFormatString(const char *fmt);
+	void setFormatString(const char *fmt);
 
-    void setValue(PedSector);
-    void setMaxValue(PedSector);
-    void setMinValue(PedSector);
-
-    void setStep(float step);
-    float getStep() const;
-
-    void setRange(PedSector minVal, PedSector maxVal);
-    void getRange(float &minVal, float &maxVal);
-    PedSector pedValue();
-    PedSector pedMaxValue();
+	void setValue(PedSector);
+	void setMaxValue(PedSector);
+	void setMinValue(PedSector);
+
+	void setStep(float step);
+	float getStep() const;
+
+	void setRange(PedSector minVal, PedSector maxVal);
+	void getRange(float &minVal, float &maxVal);
+	PedSector pedValue();
+	PedSector pedMaxValue();
 
 signals:
-    void valueChanged(PedSector);
+	void valueChanged(PedSector);
 
 public slots:
-    virtual void stepUp();
-    virtual void stepDown();
-    void setMaxValue(float);
-    void setMinValue(float);
-    void setFormat(int);
+	virtual void stepUp();
+	virtual void stepDown();
+	void setMaxValue(float);
+	void setMinValue(float);
+	void setFormat(int);
 
 protected:
-    int mapTextToValue(bool *ok);
-    QString mapValueToText(int v);
-    void valueChange();
+	int mapTextToValue(bool *ok);
+	QString mapValueToText(int v);
+	void valueChange();
 
 private:
-    void setRange(float minVal, float maxVal);
-    void setValue(float value);
-    float step, _floatminval, _floatmaxval, _floatvalue;
-    QString format;
-    QDoubleValidator *val;
-    PedSector _pedminval;
-    PedSector _pedmaxval;
-    PedSector _pedvalue;
-    int _format;
-    bool _update;
+	void setRange(float minVal, float maxVal);
+	void setValue(float value);
+	float step, _floatminval, _floatmaxval, _floatvalue;
+	QString format;
+	QDoubleValidator *val;
+	PedSector _pedminval;
+	PedSector _pedmaxval;
+	PedSector _pedvalue;
+	int _format;
+	bool _update;
 };
-
 #endif
diff -Naur qtparted-0.4.5.orig/src/qp_window.cpp qtparted-0.4.5/src/qp_window.cpp
--- qtparted-0.4.5.orig/src/qp_window.cpp	2005-08-10 13:05:37.000000000 +0200
+++ qtparted-0.4.5/src/qp_window.cpp	2005-10-15 12:44:39.000000000 +0200
@@ -93,14 +93,14 @@
 	/*---the window is so designed:
 	 *
 	 * .------------------------------.
-	 * |QSplitter	 |			   |
-	 * |			  |			   |
+	 * |QSplitter     |               |
+	 * |              |               |
 	 * | +----------+ | +-----------+ |
 	 * | |NavView   | | |DiskView   | |
-	 * | |		  | | |		   | |
-	 * | |		  | | |		   | |
+	 * | |	        | | |           | |
+	 * | |          | | |           | |
 	 * | +----------+ | +-----------+ |
-	 * |			  |			   |
+	 * |              |               |
 	 * `------------------------------'
 	 */
 
@@ -115,16 +115,16 @@
 	navSplit->setResizeMode(navview, QSplitter::KeepSize);
 	/*---connect the selected signal (when user, for example, select /dev/hda)---*/
 	connect(navview, SIGNAL(sigSelectDevice(QP_Device *)),
-			this, SLOT(slotSelectDevice(QP_Device *)));
+		this, SLOT(slotSelectDevice(QP_Device *)));
 
 	/*---add the DiskView widget---*/
 	diskview = new QP_DiskView(navSplit);
 	/*---emitted when you select a partition---*/
 	connect(diskview, SIGNAL(sigSelectPart(QP_PartInfo *)),
-			this, SLOT(slotSelectPart(QP_PartInfo *)));
+		this, SLOT(slotSelectPart(QP_PartInfo *)));
 	/*---emit when the user want to popup the context menu---*/
 	connect(diskview, SIGNAL(sigPopup(QPoint)),
-			this, SLOT(slotPopup(QPoint)));	
+		this, SLOT(slotPopup(QPoint)));	
 	connect(diskview, SIGNAL(sigDevicePopup(QPoint)),
 	        this, SLOT(slotDevicePopup(QPoint)));	
 	/*---connect the sigTimer used for dlgprogress during "update progressbar"---*/
diff -Naur qtparted-0.4.5.orig/src/qp_window.h qtparted-0.4.5/src/qp_window.h
--- qtparted-0.4.5.orig/src/qp_window.h	2004-04-12 12:30:13.000000000 +0200
+++ qtparted-0.4.5/src/qp_window.h	2005-10-15 12:44:39.000000000 +0200
@@ -49,89 +49,87 @@
 
 
 class QP_MainWindow : public QMainWindow {
-Q_OBJECT
-
+	Q_OBJECT
 public:
-    QP_MainWindow(QP_Settings *, QWidget *parent, const char *name);
-    ~QP_MainWindow();
-    void init();                       /*---init the mainwindow        ---*/
-    void refreshDiskView();
-    void setpopupmenu(QPopupMenu *);
-    QPopupMenu *popupmenu();
-    QPopupMenu *mnuDisks;
-    QPopupMenu *mnuDevice;
-    QAction *actUndo;
-    QAction *actCommit;
-    QAction *actQuit;
-    QAction *actProperty;
-    QAction *actCreate;
-    QAction *actFormat;
-    QAction *actResize;
-    QAction *actMove;
-    QAction *actDelete;
-    QAction *actConfig;
-    QAction *actWhatThis;
-    QAction *actAbout;
-    QAction *actAboutQT;
-    QAction *actNavProperty;
-    QAction *actNavPartTable;
-    QP_DiskView *diskview;
-    QP_dlgCreate *dlgcreate;            /*---the create dialog         ---*/
-    QP_dlgFormat *dlgformat;            /*---the format dialog         ---*/
-    QP_dlgResize *dlgresize;            /*---the resize dialog         ---*/
-    QP_dlgProgress *dlgprogress;        /*---the progress dialog       ---*/
-    QP_dlgConfig *dlgconfig;            /*---the configuration dialog  ---*/
-    QP_dlgDevProperty *dlgdevprop;      /*---the device property dialog---*/
-    QP_NavView *navview;                /*---the disk navigation widget---*/
-    QP_Settings *settings;
-
+	QP_MainWindow(QP_Settings *, QWidget *parent, const char *name);
+	~QP_MainWindow();
+	void init();		   /*---init the mainwindow		---*/
+	void refreshDiskView();
+	void setpopupmenu(QPopupMenu *);
 
 protected:
-    void createAction();
-    void addMenuBar();
-    void addStatusBar();
-    void addToolBar();
-    void buildDisksMenu();
-    void loadSettings();
-    void ShowMoveResizeDialog(QTParted::actType moveresize);
-    void InitMenu();
-    void InitProgressDialog();
-    void DoneProgressDialog();
+	QPopupMenu *popupmenu();
+	QPopupMenu *mnuDisks;
+	QPopupMenu *mnuDevice;
+	QAction *actUndo;
+	QAction *actCommit;
+	QAction *actQuit;
+	QAction *actProperty;
+	QAction *actCreate;
+	QAction *actFormat;
+	QAction *actResize;
+	QAction *actMove;
+	QAction *actDelete;
+	QAction *actConfig;
+	QAction *actWhatThis;
+	QAction *actAbout;
+	QAction *actAboutQT;
+	QAction *actNavProperty;
+	QAction *actNavPartTable;
+	QP_DiskView *diskview;
+	QP_dlgCreate *dlgcreate;	/*---the create dialog		 ---*/
+	QP_dlgFormat *dlgformat;	/*---the format dialog		 ---*/
+	QP_dlgResize *dlgresize;	/*---the resize dialog		 ---*/
+	QP_dlgProgress *dlgprogress;	/*---the progress dialog	   ---*/
+	QP_dlgConfig *dlgconfig;	/*---the configuration dialog  ---*/
+	QP_dlgDevProperty *dlgdevprop;	/*---the device property dialog---*/
+	QP_NavView *navview;		/*---the disk navigation widget---*/
+	QP_Settings *settings;
 
+protected:
+	void createAction();
+	void addMenuBar();
+	void addStatusBar();
+	void addToolBar();
+	void buildDisksMenu();
+	void loadSettings();
+	void ShowMoveResizeDialog(QTParted::actType moveresize);
+	void InitMenu();
+	void InitProgressDialog();
+	void DoneProgressDialog();
 
 private:
-    QVBox *central;
-    QPopupMenu* _popupmenu;
-    QPopupMenu* _navpopupmenu;
-    QPopupMenu *mnuOperations;
-    int mnuSetActiveID;
-    int mnuSetHiddenID;
+	QVBox *central;
+	QPopupMenu* _popupmenu;
+	QPopupMenu* _navpopupmenu;
+	QPopupMenu *mnuOperations;
+	int mnuSetActiveID;
+	int mnuSetHiddenID;
 
 protected slots:
-    void slotCreate();
-    void slotFormat();
-    void slotResize();
-    void slotMove();
-    void slotDelete();
-    void slotConfig();
-    void slotProperty();
-    void slotWhatsThis();
-    void slotAbout();
-    void slotAboutQT();
-    void slotNavProperty();
-    void slotNavPartTable();
-    void slotSelectPart(QP_PartInfo *);
-    void slotDevicePopup(QPoint pos);
-    void slotPopup(QPoint pos);
-    void slotSelectDevice(QP_Device *);
-    void slotSetActive();
-    void slotSetHidden();
-    void slotUndo();
-    void slotCommit();
-    void slotDiskChanged();
+	void slotCreate();
+	void slotFormat();
+	void slotResize();
+	void slotMove();
+	void slotDelete();
+	void slotConfig();
+	void slotProperty();
+	void slotWhatsThis();
+	void slotAbout();
+	void slotAboutQT();
+	void slotNavProperty();
+	void slotNavPartTable();
+	void slotSelectPart(QP_PartInfo *);
+	void slotDevicePopup(QPoint pos);
+	void slotPopup(QPoint pos);
+	void slotSelectDevice(QP_Device *);
+	void slotSetActive();
+	void slotSetHidden();
+	void slotUndo();
+	void slotCommit();
+	void slotDiskChanged();
 
 signals:
-    void sigSplashInfo(const QString &);
+	void sigSplashInfo(const QString &);
 };
-
 #endif
diff -Naur qtparted-0.4.5.orig/src/runprog.cpp qtparted-0.4.5/src/runprog.cpp
--- qtparted-0.4.5.orig/src/runprog.cpp	2003-08-27 18:13:20.000000000 +0200
+++ qtparted-0.4.5/src/runprog.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,160 +0,0 @@
-/***************************************************************************
-                         runprog.cpp  -  description
-                             -------------------
-    begin                : Wed Sep  4 19:21:54 UTC 2002
-    copyright            : (C) 2002 by Francois Dupoux
-    email                : fdupoux@partimage.org
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <unistd.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdlib.h>
-
-#include "runprog.h"
-#include "qp_options.h"
-
-//------------------------------------------------
-/*int doesFileExists2(char *szPath)
-{
-#ifdef HAVE_FSTAT64
-  struct stat64 fStat;
-#else
-  struct stat fStat;
-#endif
-  int nFd;
-  int nRes;
-
-  errno = 0;
-#ifdef HAVE_OPEN64
-  nFd = open64(szPath, O_RDONLY | O_NOFOLLOW | O_LARGEFILE);
-#else
-  nFd = open(szPath, O_RDONLY | O_NOFOLLOW | O_LARGEFILE);
-#endif
-  //fStream = fopen(szPath, "rb");
-  //if (!fStream) // error
-  if (nFd == -1)
-    {
-      return (errno != ENOENT);
-    }
-  else // success
-    {
-#ifdef HAVE_FSTAT64
-      nRes = fstat64(nFd, &fStat);
-#else
-      nRes = fstat(nFd, &fStat);
-#endif
-
-      if (nRes == -1)
-	return true; // for large files
-      //fclose(fStream);
-      ::close(nFd);
-      return (S_ISREG(fStat.st_mode));
-    }
-}
-
-//------------------------------------------------
-int locateProgram(char *szResultPath, int nPathLen, char *szBin)
-{
-   long i;
-   char *szLocations[] = {"/sbin", "/usr/sbin", "/usr/local/sbin", "/bin", "/usr/bin", "/usr/local/bin", ""};
-   char szTemp[2048];
-
-   for (i=0; *(szLocations[i]); i++)
-   {
-      snprintf(szTemp, sizeof(szTemp), "%s/%s", szLocations[i], szBin);
-      //pi_printf ("--> pgm=%s/%s\n", szLocations[i], szBin);
-      if (doesFileExists2(szTemp))
-      {
-	 snprintf(szResultPath, nPathLen, "%s/%s", szLocations[i], szBin);
-	 return 0; // okay
-      }
-   }
-
-   return -1; // error
-}
-*/
-
-//------------------------------------------------
-int execProgram(char *szProgram, char *argv[], char *szOutput, int nMaxOutput)
-{
-   int nFd[2];
-   int nRes;
-   pid_t pid;
-
-   // init
-   memset(szOutput, 0, nMaxOutput);
-   if (pipe(nFd) < 0)
-      return -1;
-
-   pid = fork();
-   switch (pid)
-   {
-      case -1: // error
-	 perror ("fork() in execProgram");
-	 return -1;
-
-      case 0: // child
- 	 dup2(nFd[1], STDOUT_FILENO); // stdout --> parent process
- 	 dup2(nFd[1], STDERR_FILENO); // stdout --> parent process
-	 nRes = execve(szProgram, argv, NULL);
-	 exit(0);
-	 break;
-
-      default: // parent
-	 read(nFd[0], szOutput, nMaxOutput);
-	 //pi_printf ("\n\n\n[[[[[[[%s]]]]]]]\n\n\n", szString);
-	 waitpid(pid, NULL, 0);
-	 sleep(1);
-	 break;
-   };
-
-   return 0;
-}
-
-//------------------------------------------------
-//---------------------- USAGE -------------------
-//------------------------------------------------
-/*
-   nRes = locateProgram(szFullPath, sizeof(szFullPath), g_fs[nFs].szCmdMkfsName);
-   if (nRes == -1)
-      return CResult("Can't find program %s which is required <br>to format the partition.<br>"
-		     "Please, install %s. <br>You can search on http://www.freshmeat.net.", 
-		     g_fs[nFs].szCmdMkfsName, g_fs[nFs].szFsTools);
-
-   if (szLabel && *szLabel) // not empty
-      snprintf (szFullLabel, sizeof(szFullLabel), "%s", szLabel);
-   else
-      snprintf (szFullLabel, sizeof(szFullLabel), "none");
-
-   argv[0] = g_fs[nFs].szCmdMkfsOpts;
-   argv[1] = g_fs[nFs].szCmdMkfsLabelOpts;
-   argv[2] = szFullLabel;
-   argv[3] = g_fs[nFs].szCmdMkfsOpts;
-   argv[4] = szDevice;
-   argv[5] = NULL;
-
-   // pi_printf debug
-   pi_printf ("FORMATTING: path=[%s]\n", szFullPath);
-   for (int j=0; j < 4; j++)
-      pi_printf ("argv[%d]=%s\n", j, argv[j]);
-
-   execProgram(szFullPath, argv, szOutput, sizeof(szOutput));
-*/
-
diff -Naur qtparted-0.4.5.orig/src/runprog.h qtparted-0.4.5/src/runprog.h
--- qtparted-0.4.5.orig/src/runprog.h	2003-08-27 18:13:21.000000000 +0200
+++ qtparted-0.4.5/src/runprog.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,20 +0,0 @@
-/***************************************************************************
-                          runprog.h  -  description
-                             -------------------
-    begin                : Wed Sep  4 19:21:54 UTC 2002
-    copyright            : (C) 2002 by Francois Dupoux
-    email                : fdupoux@partimage.org
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-//int doesFileExists2(char *szPath);
-//int locateProgram(char *szResultPath, int nPathLen, char *szBin);
-int execProgram(char *szProgram, char *argv[], char *szOutput, int nMaxOutput);
diff -Naur qtparted-0.4.5.orig/src/statistics.cpp qtparted-0.4.5/src/statistics.cpp
--- qtparted-0.4.5.orig/src/statistics.cpp	2005-08-10 13:05:37.000000000 +0200
+++ qtparted-0.4.5/src/statistics.cpp	2005-10-15 12:35:30.000000000 +0200
@@ -1,16 +1,16 @@
 /***************************************************************************
-                         statistics.cpp  -  description
-                             -------------------
-    begin                : Wed Sep  4 19:21:54 UTC 2002
-    copyright            : (C) 2002 by Francois Dupoux
-    email                : fdupoux@partimage.org
+	statistics.cpp  -  description
+	-------------------
+	begin				: Wed Sep  4 19:21:54 UTC 2002
+	copyright			: (C) 2002 by Francois Dupoux
+	email				: fdupoux@partimage.org
  ***************************************************************************/
 
 /***************************************************************************
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
+ *   the Free Software Foundation; either version 2 of the License, or	   *
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
@@ -45,8 +45,8 @@
 	a = getFsUsedKiloBytes(partinfo);
 
 	/*printf ("device(%s)=%lu KB used\n", partinfo->partname().latin1(), a);*/
-    if (a == 0) return -1;
-    else return a * KBYTE_SECTORS;
+	if (a == 0) return -1;
+	else return a * KBYTE_SECTORS;
 }
 
 //------------------------------------------------
@@ -54,117 +54,76 @@
 	// security: if already mounted
 	umount(szMountPoint);
 
-	int nRes;
+	char type[255];
 
-    char type[255];
-
-    if (((partinfo->fsspec->name().compare("fat32") == 0)
-      || (partinfo->fsspec->name().compare("fat16") == 0))) {
-        strcpy(type, "vfat");
-    } else {
-        strcpy(type, partinfo->fsspec->name().latin1());
-    }
-	nRes=mount(partinfo->partname().latin1(),
-               szMountPoint, type, MS_NOATIME | MS_RDONLY, NULL);
-	/*fprintf (stderr, "debug: try mount %s as %s --> %d\n", partinfo->partname().latin1(), 
-            type, nRes);*/
-	if (nRes == 0) // if success
-		return 0; // success
-
-	return -1; // failure
+	if (((partinfo->fsspec->name().compare("fat32") == 0)
+	  || (partinfo->fsspec->name().compare("fat16") == 0))) {
+		strcpy(type, "vfat");
+	} else {
+		strcpy(type, partinfo->fsspec->name().latin1());
+	}
+	return mount(partinfo->partname().latin1(),
+	             szMountPoint, type, MS_NOATIME | MS_RDONLY, NULL);
 }
 
-//------------------------------------------------
-int isMounted(QP_PartInfo *partinfo, char *szMountPoint) {
-    FILE *f;
-    struct mntent *mnt;
-    bool bMounted;
-    char szBuf1 [MAXPATHLEN+1];
-    char szBuf2 [MAXPATHLEN+1];
-
-    // init
-    bMounted = false;
-    memset(szBuf1, 0, MAXPATHLEN);
-    memset(szBuf2, 0, MAXPATHLEN);
-
-    if ((f = setmntent (MOUNTED, "r")) == 0)
-      return (-1);
-
-    // loop: compare device with each mounted device
-    while (((mnt = getmntent (f)) != 0) && (!bMounted)) {
-
-        /*---try to see if the shortname match---*/
-        if ((partinfo->shortname().compare(mnt->mnt_fsname) == 0)) {
-            bMounted = true;
-            strcpy(szMountPoint, mnt->mnt_dir);
-        }
-        
-        /*---if there is devfs try to see if the longname match---*/
-        if (isDevfsEnabled()) {
-            if ((partinfo->longname().compare(mnt->mnt_fsname) == 0)) {
-                bMounted = true;
-                strcpy(szMountPoint, mnt->mnt_dir);
-            }
-        }
-    }
-
-    endmntent (f);
-
-    return bMounted;
+//---------------------------------------
+QString mountPoint(QP_PartInfo *partinfo) {
+	FILE *f;
+	struct mntent *mnt;
+
+	if ((f = setmntent (MOUNTED, "r")) == 0)
+		return QString::null;
+
+	// loop: compare device with each mounted device
+	while (((mnt = getmntent (f)) != 0)) {
+		if ((partinfo->shortname().compare(mnt->mnt_fsname) == 0) || (isDevfsEnabled() && (partinfo->longname().compare(mnt->mnt_fsname) == 0))) {
+			endmntent(f);
+			return mnt->mnt_dir;
+		}
+	}
+	endmntent(f);
+	return QString::null;
 }
 
 //------------------------------------------------
 unsigned long getFsUsedKiloBytes(QP_PartInfo *partinfo) {
-    struct statfs sfs;
-    char szMountPoint[MAXPATHLEN+1];
-    unsigned long long a, b, c;
-    int bMounted;
-    int bToBeUnmounted;
-    int nRes;
-    unsigned long lResult = 0; // to be returned
-
-    // init
-    memset(szMountPoint, 0, MAXPATHLEN+1);
-    bToBeUnmounted = false;
-
-    bMounted = isMounted(partinfo, szMountPoint);
-    
-    /*---if not mounted -> mount it---*/
-    if (!bMounted) {
-        mkdir (TMP_MOUNTPOINT, 755);
-        memset(szMountPoint, 0, sizeof(szMountPoint)-1);
-        snprintf(szMountPoint, sizeof(szMountPoint)-1, "%s", TMP_MOUNTPOINT);
-        nRes = my_mount(partinfo, TMP_MOUNTPOINT);
-        /*if (nRes != 0)
-            fprintf (stderr, "debug: cannot mount device %s\n", partinfo->partname().latin1());*/
-        bToBeUnmounted = (nRes == 0);
-        bMounted =(nRes == 0);
-    }
-
-    // if the partition is mounted (naturally or not)
-    if (bMounted) {
-        if (statfs(szMountPoint, &sfs) != -1) {
-            a = (sfs.f_blocks - sfs.f_bavail); // used blocks count
-            b = a * sfs.f_bsize; // used bytes count
-            c = b / 1024LL; // user KiloBytes count
-            lResult = c;
-        } /*else {
-            fprintf (stderr, "debug: statfs error on device %s\n", partinfo->partname().latin1());
-        }*/
-
-        if (bToBeUnmounted) {
-            nRes = umount(szMountPoint);
-            if (nRes != 0) {
-                QString label = QString(QObject::tr("Cannot umount partition device: %1."
-                                       "Please do it by hand first to commit the changes!"))
-                                .arg(partinfo->partname());
-                QMessageBox::information(NULL, PROG_NAME, label);
-            }
-        }
-
-        return lResult; // success
-    } else {
-      // error -> partition not mounted
-      return 0L; // failure
-    }
+	struct statfs sfs;
+	unsigned long long a, b, c;
+	bool bToBeUnmounted;
+	unsigned long lResult = 0; // to be returned
+	QString mnt;
+
+	// init
+	bToBeUnmounted = false;
+
+	mnt = mountPoint(partinfo);
+	
+	/*---if not mounted -> mount it---*/
+	if (mnt.isEmpty()) {
+		mkdir (TMP_MOUNTPOINT, 755);
+		int nRes = my_mount(partinfo, TMP_MOUNTPOINT);
+		if(nRes != 0) // Can't mount --> can't get statistics
+			return 0L;
+		bToBeUnmounted = (nRes == 0);
+		mnt = TMP_MOUNTPOINT;
+	}
+
+	if (statfs(mnt, &sfs) != -1) {
+		a = (sfs.f_blocks - sfs.f_bavail); // used blocks count
+		b = a * sfs.f_bsize; // used bytes count
+		c = b / 1024LL; // user KiloBytes count
+		lResult = c;
+	}
+
+	if (bToBeUnmounted) {
+		int nRes = umount(mnt);
+		if (nRes != 0) {
+			QString label = QObject::tr("Cannot umount partition device: %1."
+			                "Please do it by hand first to commit the changes!")
+			                .arg(partinfo->partname());
+			QMessageBox::information(NULL, PROG_NAME, label);
+		}
+	}
+
+	return lResult; // success
 }
diff -Naur qtparted-0.4.5.orig/src/statistics.h qtparted-0.4.5/src/statistics.h
--- qtparted-0.4.5.orig/src/statistics.h	2003-08-27 18:13:21.000000000 +0200
+++ qtparted-0.4.5/src/statistics.h	2005-10-15 12:06:06.000000000 +0200
@@ -3,7 +3,9 @@
                              -------------------
     begin                : Wed Sep  4 19:21:54 UTC 2002
     copyright            : (C) 2002 by Francois Dupoux
+                           (C) 2005 by Bernhard Rosenkraenzer
     email                : fdupoux@partimage.org
+                           bero@arklinux.org
  ***************************************************************************/
 
 /***************************************************************************
@@ -17,7 +19,7 @@
 
 #include "qp_libparted.h"
 
-int isMounted(QP_PartInfo *, char *szMountPoint);
+QString mountPoint(QP_PartInfo *);
 unsigned long getFsUsedKiloBytes(QP_PartInfo *);
 int my_mount(QP_PartInfo *, char *szMountPoint);
 PedSector space_stats(QP_PartInfo *);

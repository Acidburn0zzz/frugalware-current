diff -Naur connman-1.31/AUTHORS connman-1.31-fix/AUTHORS
--- connman-1.31/AUTHORS	2015-12-28 04:05:49.000000000 +0100
+++ connman-1.31-fix/AUTHORS	2016-03-06 22:39:57.376747303 +0100
@@ -101,3 +101,8 @@
 Abtin Keshavarzian <abtink@nestlabs.com>
 Naveen Singh <naveensingh0977@gmail.com>
 Myl√®ne Josserand <josserand.mylene@gmail.com>
+John Ernberg <john.ernberg@actia.se>
+Niraj Kumar Goit <niraj.g@samsung.com>
+Wu Zheng <wu.zheng@intel.com>
+Milind Ramesh Murhekar <m.murhekar@samsung.com>
+Nishant Chaprana <n.chaprana@samsung.com>
diff -Naur connman-1.31/client/commands.c connman-1.31-fix/client/commands.c
--- connman-1.31/client/commands.c	2015-08-31 17:50:11.000000000 +0200
+++ connman-1.31-fix/client/commands.c	2016-03-06 22:39:57.378747353 +0100
@@ -266,6 +266,33 @@
 			state_print, NULL, NULL, NULL);
 }
 
+static int clock_print(DBusMessageIter *iter, const char *error,
+		void *user_data)
+{
+	DBusMessageIter entry;
+
+	if (error) {
+		fprintf(stderr, "Error: %s", error);
+		return 0;
+	}
+
+	dbus_message_iter_recurse(iter, &entry);
+	__connmanctl_dbus_print(&entry, "  ", " = ", "\n");
+	fprintf(stdout, "\n");
+
+	return 0;
+}
+
+static int cmd_clock(char *args[], int num, struct connman_option *options)
+{
+	if (num > 1)
+		return -E2BIG;
+
+	return __connmanctl_dbus_method_call(connection, CONNMAN_SERVICE,
+			CONNMAN_PATH, "net.connman.Clock", "GetProperties",
+			clock_print, NULL, NULL, NULL);
+}
+
 static int services_list(DBusMessageIter *iter, const char *error,
 		void *user_data)
 {
@@ -768,7 +795,7 @@
 		struct connman_option *options)
 {
 	const char *iface = "net.connman.Service";
-	struct move_service *services = g_new(struct move_service, 1);
+	struct move_service *services;
 
 	if (num > 3)
 		return -E2BIG;
@@ -779,6 +806,8 @@
 	if (check_dbus_name(args[1]) == false)
 		return -EINVAL;
 
+	services = g_new(struct move_service, 1);
+
 	services->service = g_strdup_printf("/net/connman/service/%s", args[1]);
 	services->target = g_strdup_printf("/net/connman/service/%s", args[2]);
 
@@ -826,7 +855,7 @@
 		struct connman_option *options)
 {
 	const char *iface = "net.connman.Service";
-	struct move_service *services = g_new(struct move_service, 1);
+	struct move_service *services;
 
 	if (num > 3)
 		return -E2BIG;
@@ -837,6 +866,8 @@
 	if (check_dbus_name(args[1]) == false)
 		return -EINVAL;
 
+	services = g_new(struct move_service, 1);
+
 	services->service = g_strdup_printf("/net/connman/service/%s", args[1]);
 	services->target = g_strdup_printf("/net/connman/service/%s", args[2]);
 
@@ -2507,6 +2538,8 @@
 	  "Shows if the system is online or offline", NULL },
 	{ "technologies", NULL,           NULL,            cmd_technologies,
 	  "Display technologies", NULL },
+	{ "clock",        NULL,           NULL,            cmd_clock,
+	  "Get System Clock Properties", NULL },
 	{ "enable",       "<technology>|offline", NULL,    cmd_enable,
 	  "Enables given technology or offline mode",
 	  lookup_technology_offline },
diff -Naur connman-1.31/client/dbus_helpers.c connman-1.31-fix/client/dbus_helpers.c
--- connman-1.31/client/dbus_helpers.c	2015-08-31 17:50:11.000000000 +0200
+++ connman-1.31-fix/client/dbus_helpers.c	2016-03-06 22:39:57.378747353 +0100
@@ -38,6 +38,7 @@
 	dbus_uint16_t u16;
 	dbus_uint32_t u;
 	dbus_int32_t i;
+	dbus_uint64_t u64;
 	double d;
 
 	char *str;
@@ -113,6 +114,11 @@
 			fprintf(stdout, "%d", i);
 			break;
 
+		case DBUS_TYPE_UINT64:
+			dbus_message_iter_get_basic(iter, &u64);
+			fprintf(stdout, "%lu", u64);
+			break;
+
 		case DBUS_TYPE_DOUBLE:
 			dbus_message_iter_get_basic(iter, &d);
 			fprintf(stdout, "%f", d);
diff -Naur connman-1.31/configure.ac connman-1.31-fix/configure.ac
--- connman-1.31/configure.ac	2015-12-28 04:05:49.000000000 +0100
+++ connman-1.31-fix/configure.ac	2016-03-06 22:39:57.378747353 +0100
@@ -182,6 +182,9 @@
 		AC_MSG_ERROR(resolver library support is required))
 ])
 
+AC_CHECK_HEADERS([execinfo.h])
+AM_CONDITIONAL([BACKTRACE], [test "${ac_cv_header_execinfo_h}" = "yes"])
+
 AC_CHECK_FUNC(signalfd, dummy=yes,
 			AC_MSG_ERROR(signalfd support is required))
 
diff -Naur connman-1.31/doc/overview-api.txt connman-1.31-fix/doc/overview-api.txt
--- connman-1.31/doc/overview-api.txt	2015-12-28 04:05:49.000000000 +0100
+++ connman-1.31-fix/doc/overview-api.txt	2016-03-06 22:39:57.378747353 +0100
@@ -302,7 +302,7 @@
 		      |                                          |
 		      +------------------------------------------+
 
-The different states should no be used by the user interface to trigger
+The different states should not be used by the user interface to trigger
 advanced actions. The state transitions are provided for the sole purpose
 to give the user feedback on what is currently going on. Especially in
 cases where networks are flaky or DHCP servers take a long time these
diff -Naur connman-1.31/gdhcp/client.c connman-1.31-fix/gdhcp/client.c
--- connman-1.31/gdhcp/client.c	2015-12-28 04:05:49.000000000 +0100
+++ connman-1.31-fix/gdhcp/client.c	2016-03-06 22:39:57.379747378 +0100
@@ -2681,6 +2681,7 @@
 		dhcp_client->ipv4ll_available_cb(dhcp_client,
 					dhcp_client->ipv4ll_available_data);
 	dhcp_client->conflicts = 0;
+	dhcp_client->timeout = 0;
 
 	return FALSE;
 }
@@ -2713,6 +2714,8 @@
 	uint32_t addr;
 	uint64_t rand;
 
+	remove_timeouts(dhcp_client);
+
 	if (dhcp_client->type == G_DHCP_IPV6) {
 		if (dhcp_client->information_req_cb) {
 			dhcp_client->state = INFORMATION_REQ;
@@ -2829,7 +2832,8 @@
 		addr = 0;
 	} else {
 		addr = ntohl(inet_addr(last_address));
-		if (addr == 0xFFFFFFFF) {
+		if (addr == 0xFFFFFFFF || ((addr & LINKLOCAL_ADDR) ==
+					LINKLOCAL_ADDR)) {
 			addr = 0;
 		} else if (dhcp_client->last_address != last_address) {
 			g_free(dhcp_client->last_address);
diff -Naur connman-1.31/gsupplicant/supplicant.c connman-1.31-fix/gsupplicant/supplicant.c
--- connman-1.31/gsupplicant/supplicant.c	2015-12-28 04:05:49.000000000 +0100
+++ connman-1.31-fix/gsupplicant/supplicant.c	2016-03-06 22:39:57.380747404 +0100
@@ -249,6 +249,47 @@
 	GSList *members;
 };
 
+struct interface_data {
+	GSupplicantInterface *interface;
+	char *path; /* Interface path cannot be taken from interface (above) as
+		     * it might have been freed already.
+		     */
+	GSupplicantInterfaceCallback callback;
+	void *user_data;
+	bool network_remove_in_progress;
+	GSupplicantSSID *ssid;
+};
+
+struct interface_create_data {
+	char *ifname;
+	char *driver;
+	char *bridge;
+	GSupplicantInterface *interface;
+	GSupplicantInterfaceCallback callback;
+	void *user_data;
+};
+
+struct interface_connect_data {
+	GSupplicantInterface *interface;
+	char *path;
+	GSupplicantInterfaceCallback callback;
+	void *user_data;
+	union {
+		GSupplicantSSID *ssid;
+		GSupplicantPeerParams *peer;
+	};
+};
+
+struct interface_scan_data {
+	GSupplicantInterface *interface;
+	char *path;
+	GSupplicantInterfaceCallback callback;
+	GSupplicantScanParams *scan_params;
+	void *user_data;
+};
+
+static int network_remove(struct interface_data *data);
+
 static inline void debug(const char *format, ...)
 {
 	char str[256];
@@ -3476,43 +3517,6 @@
 	return peer;
 }
 
-struct interface_data {
-	GSupplicantInterface *interface;
-	char *path; /* Interface path cannot be taken from interface (above) as
-		     * it might have been freed already.
-		     */
-	GSupplicantInterfaceCallback callback;
-	void *user_data;
-};
-
-struct interface_create_data {
-	char *ifname;
-	char *driver;
-	char *bridge;
-	GSupplicantInterface *interface;
-	GSupplicantInterfaceCallback callback;
-	void *user_data;
-};
-
-struct interface_connect_data {
-	GSupplicantInterface *interface;
-	char *path;
-	GSupplicantInterfaceCallback callback;
-	union {
-		GSupplicantSSID *ssid;
-		GSupplicantPeerParams *peer;
-	};
-	void *user_data;
-};
-
-struct interface_scan_data {
-	GSupplicantInterface *interface;
-	char *path;
-	GSupplicantInterfaceCallback callback;
-	GSupplicantScanParams *scan_params;
-	void *user_data;
-};
-
 static void interface_create_data_free(struct interface_create_data *data)
 {
 	g_free(data->ifname);
@@ -4105,7 +4109,6 @@
 
 	SUPPLICANT_DBG("PATH: %s", path);
 
-	g_free(interface->network_path);
 	interface->network_path = g_strdup(path);
 
 	supplicant_dbus_method_call(data->interface->path,
@@ -4656,7 +4659,8 @@
 							void *user_data)
 {
 	struct interface_connect_data *data;
-	int ret;
+	struct interface_data *intf_data;
+	int ret = 0;
 
 	if (!interface)
 		return -EINVAL;
@@ -4685,12 +4689,44 @@
 			SUPPLICANT_INTERFACE ".Interface.WPS",
 			"ProcessCredentials", DBUS_TYPE_BOOLEAN_AS_STRING,
 			wps_process_credentials, wps_start, data, interface);
-	} else
-		ret = supplicant_dbus_method_call(interface->path,
-			SUPPLICANT_INTERFACE ".Interface", "AddNetwork",
-			interface_add_network_params,
-			interface_add_network_result, data,
-			interface);
+	} else {
+		/* By the time there is a request for connect and the network
+		 * path is not NULL it means that connman has not removed the
+		 * previous network pointer. This can happen in the case AP
+		 * deauthenticated client and connman does not remove the
+		 * previously connected network pointer. This causes supplicant
+		 * to reallocate the memory for struct wpa_ssid again even if it
+		 * is the same SSID. This causes memory usage of wpa_supplicnat
+		 * to go high. The idea here is that if the previously connected
+		 * network is not removed at the time of next connection attempt
+		 * check if the network path is not NULL. In case it is non-NULL
+		 * first remove the network and then once removal is successful, add
+		 * the network.
+		 */
+
+		if (interface->network_path != NULL) {
+			g_free(data->path);
+			dbus_free(data);
+
+			intf_data = dbus_malloc0(sizeof(*intf_data));
+			if (!intf_data)
+				return -ENOMEM;
+
+			intf_data->interface = interface;
+			intf_data->path = g_strdup(interface->path);
+			intf_data->callback = callback;
+			intf_data->ssid = ssid;
+			intf_data->user_data = user_data;
+			intf_data->network_remove_in_progress = TRUE;
+			network_remove(intf_data);
+		} else {
+			ret = supplicant_dbus_method_call(interface->path,
+					SUPPLICANT_INTERFACE ".Interface", "AddNetwork",
+					interface_add_network_params,
+					interface_add_network_result, data,
+					interface);
+		}
+        }
 
 	if (ret < 0) {
 		g_free(data->path);
@@ -4705,6 +4741,7 @@
 				DBusMessageIter *iter, void *user_data)
 {
 	struct interface_data *data = user_data;
+	struct interface_connect_data *connect_data;
 	int result = 0;
 
 	SUPPLICANT_DBG("");
@@ -4716,11 +4753,31 @@
 			result = -ECONNABORTED;
 	}
 
-	g_free(data->path);
+        g_free(data->interface->network_path);
+        data->interface->network_path = NULL;
 
-	if (data->callback)
-		data->callback(result, data->interface, data->user_data);
+	if (data->network_remove_in_progress == TRUE) {
+		data->network_remove_in_progress = FALSE;
+		connect_data = dbus_malloc0(sizeof(*connect_data));
+		if (!connect_data)
+			return;
+
+		connect_data->interface = data->interface;
+		connect_data->path = g_strdup(data->path);
+		connect_data->callback = data->callback;
+		connect_data->ssid = data->ssid;
+		connect_data->user_data = data->user_data;
 
+		supplicant_dbus_method_call(data->interface->path,
+			SUPPLICANT_INTERFACE ".Interface", "AddNetwork",
+			interface_add_network_params,
+			interface_add_network_result, connect_data,
+			connect_data->interface);
+	} else {
+		if (data->callback)
+			data->callback(result, data->interface, data->user_data);
+	}
+	g_free(data->path);
 	dbus_free(data);
 }
 
diff -Naur connman-1.31/include/backtrace.h connman-1.31-fix/include/backtrace.h
--- connman-1.31/include/backtrace.h	1970-01-01 01:00:00.000000000 +0100
+++ connman-1.31-fix/include/backtrace.h	2016-03-06 22:39:57.381747429 +0100
@@ -0,0 +1,32 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2016  Yann E. MORIN <yann.morin.1998@free.fr>. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __CONNMAN_BACKTRACE_H
+#define __CONNMAN_BACKTRACE_H
+
+#ifdef HAVE_EXECINFO_H
+void print_backtrace(const char* program_path, const char* program_exec,
+		unsigned int offset);
+#else
+#define print_backtrace(P,E,O)
+#endif
+
+#endif /* __CONNMAN_BACKTRACE_H */
diff -Naur connman-1.31/Makefile.am connman-1.31-fix/Makefile.am
--- connman-1.31/Makefile.am	2015-12-28 04:05:49.000000000 +0100
+++ connman-1.31-fix/Makefile.am	2016-03-06 22:39:57.377747328 +0100
@@ -19,7 +19,8 @@
 			include/dbus.h include/option.h \
 			include/provider.h include/vpn-dbus.h \
 			include/utsname.h include/timeserver.h include/proxy.h \
-			include/technology.h include/setting.h
+			include/technology.h include/setting.h \
+			include/backtrace.h
 
 local_headers = $(foreach file,$(include_HEADERS) $(nodist_include_HEADERS) \
 			$(noinst_HEADERS), include/connman/$(notdir $(file)))
@@ -42,6 +43,10 @@
 gweb_sources += gweb/giognutls.h gweb/gionotls.c
 endif
 
+if BACKTRACE
+backtrace_sources = src/backtrace.c
+endif
+
 shared_sources = src/shared/util.h src/shared/util.c \
 		src/shared/netlink.h src/shared/netlink.c
 
@@ -101,7 +106,7 @@
 
 sbin_PROGRAMS = src/connmand src/connmand-wait-online
 
-src_connmand_SOURCES = $(gdhcp_sources) $(gweb_sources) \
+src_connmand_SOURCES = $(gdhcp_sources) $(gweb_sources) $(backtrace_sources) \
 			$(builtin_sources) $(shared_sources) src/connman.ver \
 			src/main.c src/connman.h src/log.c \
 			src/error.c src/plugin.c src/task.c \
@@ -144,7 +149,7 @@
 
 sbin_PROGRAMS += vpn/connman-vpnd
 
-vpn_connman_vpnd_SOURCES = $(builtin_vpn_sources) \
+vpn_connman_vpnd_SOURCES = $(builtin_vpn_sources) $(backtrace_sources) \
 			$(gweb_sources) vpn/vpn.ver vpn/main.c vpn/vpn.h \
 			src/log.c src/error.c src/plugin.c src/task.c \
 			vpn/vpn-manager.c vpn/vpn-provider.c \
@@ -273,8 +278,8 @@
 
 noinst_PROGRAMS += unit/test-ippool
 
-unit_test_ippool_SOURCES = src/log.c src/dbus.c src/error.c \
-					src/ippool.c unit/test-ippool.c
+unit_test_ippool_SOURCES = $(backtrace_sources) src/log.c src/dbus.c \
+					src/error.c src/ippool.c unit/test-ippool.c
 unit_test_ippool_LDADD = gdbus/libgdbus-internal.la \
 				@GLIB_LIBS@ @DBUS_LIBS@ -ldl
 
@@ -325,12 +330,12 @@
 
 tools_polkit_test_LDADD = @DBUS_LIBS@
 
-tools_iptables_test_SOURCES = src/log.c src/iptables.c tools/iptables-test.c
+tools_iptables_test_SOURCES = $(backtrace_sources) src/log.c src/iptables.c tools/iptables-test.c
 tools_iptables_test_LDADD = @GLIB_LIBS@ @XTABLES_LIBS@ -ldl
 
 tools_private_network_test_LDADD = @GLIB_LIBS@ @DBUS_LIBS@
 
-tools_session_test_SOURCES = src/log.c src/dbus.c src/error.c \
+tools_session_test_SOURCES = $(backtrace_sources) src/log.c src/dbus.c src/error.c \
 		tools/session-test.c tools/session-utils.c tools/manager-api.c \
 		tools/session-api.c tools/session-test.h
 tools_session_test_LDADD = gdbus/libgdbus-internal.la \
@@ -338,7 +343,7 @@
 
 tools_iptables_unit_CFLAGS = @DBUS_CFLAGS@ @GLIB_CFLAGS@ @XTABLES_CFLAGS@ \
 		-DIPTABLES_SAVE=\""${IPTABLES_SAVE}"\"
-tools_iptables_unit_SOURCES = src/log.c \
+tools_iptables_unit_SOURCES = $(backtrace_sources) src/log.c \
 		 src/iptables.c src/firewall.c src/nat.c tools/iptables-unit.c
 tools_iptables_unit_LDADD = gdbus/libgdbus-internal.la \
 				@GLIB_LIBS@ @DBUS_LIBS@ @XTABLES_LIBS@ -ldl
diff -Naur connman-1.31/plugins/bluetooth.c connman-1.31-fix/plugins/bluetooth.c
--- connman-1.31/plugins/bluetooth.c	2015-12-28 04:05:49.000000000 +0100
+++ connman-1.31-fix/plugins/bluetooth.c	2016-03-06 22:39:57.381747429 +0100
@@ -718,12 +718,16 @@
 
 	DBG("path %s bridge %s", path, bridge);
 
-	if (!bridge)
+	if (!bridge) {
+		g_free(tethering);
 		return -EINVAL;
+	}
 
 	proxy = g_dbus_proxy_new(client, path, "org.bluez.NetworkServer1");
-	if (!proxy)
+	if (!proxy) {
+		g_free(tethering);
 		return false;
+	}
 
 	tethering->technology = technology;
 	tethering->bridge = g_strdup(bridge);
diff -Naur connman-1.31/plugins/neard.c connman-1.31-fix/plugins/neard.c
--- connman-1.31/plugins/neard.c	2013-08-19 18:57:25.000000000 +0200
+++ connman-1.31-fix/plugins/neard.c	2016-03-06 22:39:57.381747429 +0100
@@ -534,10 +534,8 @@
 			&path, DBUS_TYPE_STRING, &type, DBUS_TYPE_INVALID);
 
 	if (!dbus_connection_send_with_reply(connection, message,
-						&register_call, TIMEOUT)) {
-		dbus_message_unref(message);
+						&register_call, TIMEOUT))
 		goto out;
-	}
 
 	if (!dbus_pending_call_set_notify(register_call,
 						register_agent_cb, NULL, NULL))
diff -Naur connman-1.31/plugins/ofono.c connman-1.31-fix/plugins/ofono.c
--- connman-1.31/plugins/ofono.c	2015-12-28 04:05:49.000000000 +0100
+++ connman-1.31-fix/plugins/ofono.c	2016-03-06 22:39:57.382747454 +0100
@@ -284,7 +284,7 @@
 	connman_ipaddress_free(context->ipv6_address);
 	g_free(context->ipv6_nameservers);
 
-	free(context);
+	g_free(context);
 }
 
 static void set_connected(struct modem_data *modem,
@@ -361,19 +361,17 @@
 	if (context->network)
 		connman_network_set_connected(context->network, false);
 
-	if (context) {
-		g_free(context->ipv4_nameservers);
-		context->ipv4_nameservers = NULL;
-		if (context->ipv4_method != CONNMAN_IPCONFIG_METHOD_OFF)
-			context->ipv4_method =
-					CONNMAN_IPCONFIG_METHOD_UNKNOWN;
-
-		g_free(context->ipv6_nameservers);
-		context->ipv6_nameservers = NULL;
-		if (context->ipv6_method != CONNMAN_IPCONFIG_METHOD_OFF)
-			context->ipv6_method =
-					CONNMAN_IPCONFIG_METHOD_UNKNOWN;
-	}
+	g_free(context->ipv4_nameservers);
+	context->ipv4_nameservers = NULL;
+	if (context->ipv4_method != CONNMAN_IPCONFIG_METHOD_OFF)
+		context->ipv4_method =
+			CONNMAN_IPCONFIG_METHOD_UNKNOWN;
+
+	g_free(context->ipv6_nameservers);
+	context->ipv6_nameservers = NULL;
+	if (context->ipv6_method != CONNMAN_IPCONFIG_METHOD_OFF)
+		context->ipv6_method =
+			CONNMAN_IPCONFIG_METHOD_UNKNOWN;
 }
 
 typedef void (*set_property_cb)(struct modem_data *data,
diff -Naur connman-1.31/plugins/wifi.c connman-1.31-fix/plugins/wifi.c
--- connman-1.31/plugins/wifi.c	2015-12-28 04:05:49.000000000 +0100
+++ connman-1.31-fix/plugins/wifi.c	2016-03-06 22:39:57.383747479 +0100
@@ -140,7 +140,7 @@
 	unsigned int p2p_find_timeout;
 	unsigned int p2p_connection_timeout;
 	struct connman_peer *pending_peer;
-	GSupplicantPeer *peer;
+	GSList *peers;
 	bool p2p_connecting;
 	bool p2p_device;
 	int servicing;
@@ -245,8 +245,6 @@
 		connman_peer_unref(wifi->pending_peer);
 		wifi->pending_peer = NULL;
 	}
-
-	wifi->peer = NULL;
 }
 
 static gboolean peer_connect_timeout(gpointer data)
@@ -257,8 +255,11 @@
 
 	if (wifi->p2p_connecting) {
 		enum connman_peer_state state = CONNMAN_PEER_STATE_FAILURE;
+		GSupplicantPeer *gs_peer =
+			g_supplicant_interface_peer_lookup(wifi->interface,
+				connman_peer_get_identifier(wifi->pending_peer));
 
-		if (g_supplicant_peer_has_requested_connection(wifi->peer))
+		if (g_supplicant_peer_has_requested_connection(gs_peer))
 			state = CONNMAN_PEER_STATE_IDLE;
 
 		connman_peer_set_state(wifi->pending_peer, state);
@@ -309,14 +310,12 @@
 		return -ENODEV;
 
 	wifi = connman_device_get_data(device);
-	if (!wifi)
+	if (!wifi || !wifi->interface)
 		return -ENODEV;
 
 	if (wifi->p2p_connecting)
 		return -EBUSY;
 
-	wifi->peer = NULL;
-
 	gs_peer = g_supplicant_interface_peer_lookup(wifi->interface,
 					connman_peer_get_identifier(peer));
 	if (!gs_peer)
@@ -355,7 +354,6 @@
 						peer_connect_callback, wifi);
 	if (ret == -EINPROGRESS) {
 		wifi->pending_peer = connman_peer_ref(peer);
-		wifi->peer = gs_peer;
 		wifi->p2p_connecting = true;
 	} else if (ret < 0) {
 		g_free(peer_params->path);
@@ -794,6 +792,21 @@
 	wifi->networks = NULL;
 }
 
+static void remove_peers(struct wifi_data *wifi)
+{
+	GSList *list;
+
+	for (list = wifi->peers; list; list = list->next) {
+		struct connman_peer *peer = list->data;
+
+		connman_peer_unregister(peer);
+		connman_peer_unref(peer);
+	}
+
+	g_slist_free(wifi->peers);
+	wifi->peers = NULL;
+}
+
 static void reset_autoscan(struct connman_device *device)
 {
 	struct wifi_data *wifi = connman_device_get_data(device);
@@ -877,6 +890,7 @@
 		g_source_remove(wifi->p2p_connection_timeout);
 
 	remove_networks(device, wifi);
+	remove_peers(wifi);
 
 	connman_device_set_powered(device, false);
 	connman_device_set_data(device, NULL);
@@ -1524,6 +1538,7 @@
 	}
 
 	remove_networks(device, wifi);
+	remove_peers(wifi);
 
 	ret = g_supplicant_interface_remove(wifi->interface, NULL, NULL);
 	if (ret < 0)
@@ -1678,11 +1693,13 @@
 
 	DBG("");
 
-	wifi->p2p_find_timeout = 0;
+	if (wifi) {
+		wifi->p2p_find_timeout = 0;
 
-	connman_device_set_scanning(device, CONNMAN_SERVICE_TYPE_P2P, false);
+		g_supplicant_interface_p2p_stop_find(wifi->interface);
+	}
 
-	g_supplicant_interface_p2p_stop_find(wifi->interface);
+	connman_device_set_scanning(device, CONNMAN_SERVICE_TYPE_P2P, false);
 
 	connman_device_unref(device);
 	reset_autoscan(device);
@@ -1698,6 +1715,9 @@
 
 	DBG("result %d wifi %p", result, wifi);
 
+	if (!wifi)
+		goto error;
+
 	if (wifi->p2p_find_timeout) {
 		g_source_remove(wifi->p2p_find_timeout);
 		wifi->p2p_find_timeout = 0;
@@ -2512,6 +2532,9 @@
 
 	DBG("");
 
+	if (!interface)
+		return;
+
 	if (!g_supplicant_interface_has_p2p(interface))
 		return;
 
@@ -2775,6 +2798,8 @@
 	ret = connman_peer_register(connman_peer);
 	if (ret < 0 && ret != -EALREADY)
 		connman_peer_unref(connman_peer);
+	else
+		wifi->peers = g_slist_prepend(wifi->peers, connman_peer);
 }
 
 static void peer_lost(GSupplicantPeer *peer)
@@ -2800,6 +2825,8 @@
 		connman_peer_unregister(connman_peer);
 		connman_peer_unref(connman_peer);
 	}
+
+	wifi->peers = g_slist_remove(wifi->peers, connman_peer);
 }
 
 static void peer_changed(GSupplicantPeer *peer, GSupplicantPeerState state)
@@ -2814,6 +2841,9 @@
 
 	DBG("ident: %s", identifier);
 
+	if (!wifi)
+		return;
+
 	connman_peer = connman_peer_get(wifi->device, identifier);
 	if (!connman_peer)
 		return;
diff -Naur connman-1.31/src/agent.c connman-1.31-fix/src/agent.c
--- connman-1.31/src/agent.c	2015-12-28 04:05:49.000000000 +0100
+++ connman-1.31-fix/src/agent.c	2016-03-06 22:39:57.383747479 +0100
@@ -586,7 +586,7 @@
 
 	message = dbus_message_new_method_call(agent->owner, agent->path,
 						interface, "Release");
-	if (message == NULL) {
+	if (!message) {
 		connman_error("Couldn't allocate D-Bus message");
 		return;
 	}
diff -Naur connman-1.31/src/backtrace.c connman-1.31-fix/src/backtrace.c
--- connman-1.31/src/backtrace.c	1970-01-01 01:00:00.000000000 +0100
+++ connman-1.31-fix/src/backtrace.c	2016-03-06 22:39:57.383747479 +0100
@@ -0,0 +1,138 @@
+/*
+ *
+ *  Connection Manager
+ *
+ *  Copyright (C) 2007-2013  Intel Corporation. All rights reserved.
+ *  Copyright (C) 2016  Yann E. MORIN <yann.morin.1998@free.fr>. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <execinfo.h>
+#include <dlfcn.h>
+
+#include "connman.h"
+
+void print_backtrace(const char* program_path, const char* program_exec,
+		unsigned int offset)
+{
+	void *frames[99];
+	size_t n_ptrs;
+	unsigned int i;
+	int outfd[2], infd[2];
+	int pathlen;
+	pid_t pid;
+
+	if (!program_exec)
+		return;
+
+	pathlen = strlen(program_path);
+
+	n_ptrs = backtrace(frames, G_N_ELEMENTS(frames));
+	if (n_ptrs < offset)
+		return;
+
+	if (pipe(outfd) < 0)
+		return;
+
+	if (pipe(infd) < 0) {
+		close(outfd[0]);
+		close(outfd[1]);
+		return;
+	}
+
+	pid = fork();
+	if (pid < 0) {
+		close(outfd[0]);
+		close(outfd[1]);
+		close(infd[0]);
+		close(infd[1]);
+		return;
+	}
+
+	if (pid == 0) {
+		close(outfd[1]);
+		close(infd[0]);
+
+		dup2(outfd[0], STDIN_FILENO);
+		dup2(infd[1], STDOUT_FILENO);
+
+		execlp("addr2line", "-C", "-f", "-e", program_exec, NULL);
+
+		exit(EXIT_FAILURE);
+	}
+
+	close(outfd[0]);
+	close(infd[1]);
+
+	connman_error("++++++++ backtrace ++++++++");
+
+	for (i = offset; i < n_ptrs - 1; i++) {
+		Dl_info info;
+		char addr[20], buf[PATH_MAX * 2];
+		int len, written;
+		char *ptr, *pos;
+
+		dladdr(frames[i], &info);
+
+		len = snprintf(addr, sizeof(addr), "%p\n", frames[i]);
+		if (len < 0)
+			break;
+
+		written = write(outfd[1], addr, len);
+		if (written < 0)
+			break;
+
+		len = read(infd[0], buf, sizeof(buf) - 1);
+		if (len < 0)
+			break;
+
+		buf[len] = '\0';
+
+		pos = strchr(buf, '\n');
+		*pos++ = '\0';
+
+		if (strcmp(buf, "??") == 0) {
+			connman_error("#%-2u %p in %s", i - offset,
+						frames[i], info.dli_fname);
+			continue;
+		}
+
+		ptr = strchr(pos, '\n');
+		*ptr++ = '\0';
+
+		if (strncmp(pos, program_path, pathlen) == 0)
+			pos += pathlen + 1;
+
+		connman_error("#%-2u %p in %s() at %s", i - offset,
+						frames[i], buf, pos);
+	}
+
+	connman_error("+++++++++++++++++++++++++++");
+
+	kill(pid, SIGTERM);
+
+	close(outfd[1]);
+	close(infd[0]);
+}
diff -Naur connman-1.31/src/bridge.c connman-1.31-fix/src/bridge.c
--- connman-1.31/src/bridge.c	2014-08-18 14:20:06.000000000 +0200
+++ connman-1.31-fix/src/bridge.c	2016-03-06 22:39:57.383747479 +0100
@@ -56,7 +56,7 @@
 	if (!f)
 		return -errno;
 
-	fprintf(f, "%d", delay);
+	fprintf(f, "%u", delay);
 
 	fclose(f);
 
diff -Naur connman-1.31/src/config.c connman-1.31-fix/src/config.c
--- connman-1.31/src/config.c	2015-08-31 17:50:11.000000000 +0200
+++ connman-1.31-fix/src/config.c	2016-03-06 22:39:57.384747504 +0100
@@ -1550,13 +1550,16 @@
 	g_hash_table_iter_init(&iter_file, config_table);
 	while (g_hash_table_iter_next(&iter_file, &key, &value)) {
 		struct connman_config *config_file = value;
+		struct connman_config_entry **tmp_entries = entries;
 
 		count = g_hash_table_size(config_file->service_table);
 
 		entries = g_try_realloc(entries, (i + count + 1) *
 					sizeof(struct connman_config_entry *));
-		if (!entries)
+		if (!entries) {
+			g_free(tmp_entries);
 			return NULL;
+		}
 
 		g_hash_table_iter_init(&iter_config,
 						config_file->service_table);
@@ -1589,10 +1592,14 @@
 	}
 
 	if (entries) {
+		struct connman_config_entry **tmp_entries = entries;
+
 		entries = g_try_realloc(entries, (i + 1) *
 					sizeof(struct connman_config_entry *));
-		if (!entries)
+		if (!entries) {
+			g_free(tmp_entries);
 			return NULL;
+		}
 
 		entries[i] = NULL;
 
diff -Naur connman-1.31/src/connection.c connman-1.31-fix/src/connection.c
--- connman-1.31/src/connection.c	2015-02-01 18:42:36.000000000 +0100
+++ connman-1.31-fix/src/connection.c	2016-03-06 22:39:57.384747504 +0100
@@ -46,7 +46,6 @@
 struct gateway_data {
 	int index;
 	struct connman_service *service;
-	unsigned int order;
 	struct gateway_config *ipv4_gateway;
 	struct gateway_config *ipv6_gateway;
 	bool default_checked;
@@ -381,8 +380,6 @@
 
 	data->service = service;
 
-	data->order = __connman_service_get_order(service);
-
 	/*
 	 * If the service is already in the hash, then we
 	 * must not replace it blindly but disable the gateway
@@ -558,25 +555,13 @@
 
 static struct gateway_data *find_default_gateway(void)
 {
-	struct gateway_data *found = NULL;
-	unsigned int order = 0;
-	GHashTableIter iter;
-	gpointer value, key;
-
-	g_hash_table_iter_init(&iter, gateway_hash);
-
-	while (g_hash_table_iter_next(&iter, &key, &value)) {
-		struct gateway_data *data = value;
-
-		if (!found || data->order > order) {
-			found = data;
-			order = data->order;
+	struct connman_service *service;
 
-			DBG("default %p order %d", found, order);
-		}
-	}
+	service = __connman_service_get_default();
+	if (!service)
+		return NULL;
 
-	return found;
+	return g_hash_table_lookup(gateway_hash, service);
 }
 
 static bool choose_default_gateway(struct gateway_data *data,
@@ -589,37 +574,35 @@
 	 * this one as default. If the other one is already active
 	 * we mark this one as non default.
 	 */
-	if (data->ipv4_gateway) {
-		if (candidate->ipv4_gateway &&
-				!candidate->ipv4_gateway->active) {
+	if (data->ipv4_gateway && candidate->ipv4_gateway) {
+
+		if (!candidate->ipv4_gateway->active) {
 			DBG("ipv4 downgrading %p", candidate);
 			unset_default_gateway(candidate,
 						CONNMAN_IPCONFIG_TYPE_IPV4);
 		}
-		if (candidate->ipv4_gateway &&
-				candidate->ipv4_gateway->active &&
-				candidate->order > data->order) {
+
+		if (candidate->ipv4_gateway->active &&
+				__connman_service_compare(candidate->service,
+							data->service) < 0) {
 			DBG("ipv4 downgrading this %p", data);
-			unset_default_gateway(data,
-						CONNMAN_IPCONFIG_TYPE_IPV4);
+			unset_default_gateway(data, CONNMAN_IPCONFIG_TYPE_IPV4);
 			downgraded = true;
 		}
 	}
 
-	if (data->ipv6_gateway) {
-		if (candidate->ipv6_gateway &&
-				!candidate->ipv6_gateway->active) {
+	if (data->ipv6_gateway && candidate->ipv6_gateway) {
+		if (!candidate->ipv6_gateway->active) {
 			DBG("ipv6 downgrading %p", candidate);
 			unset_default_gateway(candidate,
 						CONNMAN_IPCONFIG_TYPE_IPV6);
 		}
 
-		if (candidate->ipv6_gateway &&
-				candidate->ipv6_gateway->active &&
-				candidate->order > data->order) {
+		if (candidate->ipv6_gateway->active &&
+			__connman_service_compare(candidate->service,
+						data->service) < 0) {
 			DBG("ipv6 downgrading this %p", data);
-			unset_default_gateway(data,
-						CONNMAN_IPCONFIG_TYPE_IPV6);
+			unset_default_gateway(data, CONNMAN_IPCONFIG_TYPE_IPV6);
 			downgraded = true;
 		}
 	}
@@ -755,40 +738,6 @@
 	return NULL;
 }
 
-static void update_order(void)
-{
-	GHashTableIter iter;
-	gpointer value, key;
-
-	DBG("");
-
-	g_hash_table_iter_init(&iter, gateway_hash);
-
-	while (g_hash_table_iter_next(&iter, &key, &value)) {
-		struct gateway_data *data = value;
-
-		data->order = __connman_service_get_order(data->service);
-	}
-}
-
-void __connman_connection_gateway_activate(struct connman_service *service,
-					enum connman_ipconfig_type type)
-{
-	struct gateway_data *data = NULL;
-
-	data = g_hash_table_lookup(gateway_hash, service);
-	if (!data)
-		return;
-
-	DBG("gateway %p/%p type %d", data->ipv4_gateway,
-					data->ipv6_gateway, type);
-
-	if (type == CONNMAN_IPCONFIG_TYPE_IPV4)
-		data->ipv4_gateway->active = true;
-	else if (type == CONNMAN_IPCONFIG_TYPE_IPV6)
-		data->ipv6_gateway->active = true;
-}
-
 static void add_host_route(int family, int index, const char *gateway,
 			enum connman_service_type service_type)
 {
@@ -1026,12 +975,8 @@
 	if (!gateway_hash)
 		return updated;
 
-	update_order();
-
 	default_gateway = find_default_gateway();
 
-	__connman_service_update_ordering();
-
 	DBG("default %p", default_gateway);
 
 	/*
diff -Naur connman-1.31/src/connman.h connman-1.31-fix/src/connman.h
--- connman-1.31/src/connman.h	2015-08-31 17:50:11.000000000 +0200
+++ connman-1.31-fix/src/connman.h	2016-03-06 22:39:57.385747529 +0100
@@ -135,6 +135,8 @@
 void __connman_log_enable(struct connman_debug_desc *start,
 					struct connman_debug_desc *stop);
 
+#include <connman/backtrace.h>
+
 #include <connman/option.h>
 
 #include <connman/setting.h>
@@ -491,8 +493,6 @@
 int __connman_connection_get_vpn_index(int phy_index);
 
 bool __connman_connection_update_gateway(void);
-void __connman_connection_gateway_activate(struct connman_service *service,
-					enum connman_ipconfig_type type);
 
 int __connman_ntp_start(char *server);
 void __connman_ntp_stop();
@@ -656,6 +656,9 @@
 
 void __connman_service_list_struct(DBusMessageIter *iter);
 
+int __connman_service_compare(const struct connman_service *a,
+					const struct connman_service *b);
+
 struct connman_service *__connman_service_lookup_from_index(int index);
 struct connman_service *__connman_service_lookup_from_ident(const char *identifier);
 struct connman_service *__connman_service_create_from_network(struct connman_network *network);
@@ -680,7 +683,6 @@
 const char *__connman_service_get_name(struct connman_service *service);
 unsigned int __connman_service_get_order(struct connman_service *service);
 enum connman_service_state __connman_service_get_state(struct connman_service *service);
-void __connman_service_update_ordering(void);
 struct connman_network *__connman_service_get_network(struct connman_service *service);
 enum connman_service_security __connman_service_get_security(struct connman_service *service);
 const char *__connman_service_get_phase2(struct connman_service *service);
diff -Naur connman-1.31/src/dhcp.c connman-1.31-fix/src/dhcp.c
--- connman-1.31/src/dhcp.c	2015-12-28 04:05:49.000000000 +0100
+++ connman-1.31-fix/src/dhcp.c	2016-03-06 22:39:57.385747529 +0100
@@ -108,12 +108,16 @@
 			__connman_service_timeserver_remove(service,
 							dhcp->timeservers[i]);
 		}
+		g_strfreev(dhcp->timeservers);
+		dhcp->timeservers = NULL;
 	}
 	if (dhcp->nameservers) {
 		for (i = 0; dhcp->nameservers[i]; i++) {
 			__connman_service_nameserver_remove(service,
 						dhcp->nameservers[i], false);
 		}
+		g_strfreev(dhcp->nameservers);
+		dhcp->nameservers = NULL;
 	}
 
 	return true;
diff -Naur connman-1.31/src/dhcpv6.c connman-1.31-fix/src/dhcpv6.c
--- connman-1.31/src/dhcpv6.c	2015-08-31 17:50:11.000000000 +0200
+++ connman-1.31-fix/src/dhcpv6.c	2016-03-06 22:39:57.385747529 +0100
@@ -447,7 +447,6 @@
 		if (!slash)
 			continue;
 
-		prefix = g_strndup(prefix, slash - prefix);
 		len = strtol(slash + 1, NULL, 10);
 		if (len < 3 || len > 128)
 			break;
@@ -458,6 +457,7 @@
 		left = plen % 8;
 		i = 16 - count;
 
+		prefix = g_strndup(prefix, slash - prefix);
 		inet_pton(AF_INET6, prefix, &addr_prefix);
 		inet_pton(AF_INET6, address, &addr);
 
diff -Naur connman-1.31/src/dnsproxy.c connman-1.31-fix/src/dnsproxy.c
--- connman-1.31/src/dnsproxy.c	2015-12-28 04:05:49.000000000 +0100
+++ connman-1.31-fix/src/dnsproxy.c	2016-03-06 22:39:57.386747554 +0100
@@ -2050,21 +2050,21 @@
 						(char *)reply + offset, eom,
 						ptr, uncompressed, NS_MAXDNAME,
 						&uptr);
-				if (ptr == NULL)
+				if (!ptr)
 					goto out;
 
 				ptr = uncompress(ntohs(hdr->nscount),
 						(char *)reply + offset, eom,
 						ptr, uncompressed, NS_MAXDNAME,
 						&uptr);
-				if (ptr == NULL)
+				if (!ptr)
 					goto out;
 
 				ptr = uncompress(ntohs(hdr->arcount),
 						(char *)reply + offset, eom,
 						ptr, uncompressed, NS_MAXDNAME,
 						&uptr);
-				if (ptr == NULL)
+				if (!ptr)
 					goto out;
 
 				/*
@@ -2259,9 +2259,11 @@
 		g_free(server->incoming_reply);
 		server->incoming_reply = NULL;
 
-		for (list = request_list; list; list = list->next) {
+		list = request_list;
+		while (list) {
 			struct request_data *req = list->data;
 			struct domain_hdr *hdr;
+			list = list->next;
 
 			if (req->protocol == IPPROTO_UDP)
 				continue;
diff -Naur connman-1.31/src/iptables.c connman-1.31-fix/src/iptables.c
--- connman-1.31/src/iptables.c	2015-08-31 17:50:11.000000000 +0200
+++ connman-1.31-fix/src/iptables.c	2016-03-06 22:39:57.387747580 +0100
@@ -1566,6 +1566,9 @@
 	.option_offset = 0,
 	.opts = iptables_opts,
 	.orig_opts = iptables_opts,
+#if XTABLES_VERSION_CODE > 10
+	.compat_rev = xtables_compatible_revision,
+#endif
 };
 
 static struct xtables_target *prepare_target(struct connman_iptables *table,
@@ -2423,8 +2426,10 @@
 	struct connman_iptables *table;
 
 	table = get_table(table_name);
-	if (!table)
+	if (!table) {
+		g_free(cbd);
 		return -EINVAL;
+	}
 
 	iterate_entries(table->blob_entries->entrytable,
 			table->info->valid_hooks,
diff -Naur connman-1.31/src/log.c connman-1.31-fix/src/log.c
--- connman-1.31/src/log.c	2014-04-04 14:12:07.000000000 +0200
+++ connman-1.31-fix/src/log.c	2016-03-06 22:39:57.387747580 +0100
@@ -30,7 +30,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <syslog.h>
-#include <execinfo.h>
 #include <dlfcn.h>
 
 #include "connman.h"
@@ -110,113 +109,11 @@
 	va_end(ap);
 }
 
-static void print_backtrace(unsigned int offset)
-{
-	void *frames[99];
-	size_t n_ptrs;
-	unsigned int i;
-	int outfd[2], infd[2];
-	int pathlen;
-	pid_t pid;
-
-	if (!program_exec)
-		return;
-
-	pathlen = strlen(program_path);
-
-	n_ptrs = backtrace(frames, G_N_ELEMENTS(frames));
-	if (n_ptrs < offset)
-		return;
-
-	if (pipe(outfd) < 0)
-		return;
-
-	if (pipe(infd) < 0) {
-		close(outfd[0]);
-		close(outfd[1]);
-		return;
-	}
-
-	pid = fork();
-	if (pid < 0) {
-		close(outfd[0]);
-		close(outfd[1]);
-		close(infd[0]);
-		close(infd[1]);
-		return;
-	}
-
-	if (pid == 0) {
-		close(outfd[1]);
-		close(infd[0]);
-
-		dup2(outfd[0], STDIN_FILENO);
-		dup2(infd[1], STDOUT_FILENO);
-
-		execlp("addr2line", "-C", "-f", "-e", program_exec, NULL);
-
-		exit(EXIT_FAILURE);
-	}
-
-	close(outfd[0]);
-	close(infd[1]);
-
-	connman_error("++++++++ backtrace ++++++++");
-
-	for (i = offset; i < n_ptrs - 1; i++) {
-		Dl_info info;
-		char addr[20], buf[PATH_MAX * 2];
-		int len, written;
-		char *ptr, *pos;
-
-		dladdr(frames[i], &info);
-
-		len = snprintf(addr, sizeof(addr), "%p\n", frames[i]);
-		if (len < 0)
-			break;
-
-		written = write(outfd[1], addr, len);
-		if (written < 0)
-			break;
-
-		len = read(infd[0], buf, sizeof(buf) - 1);
-		if (len < 0)
-			break;
-
-		buf[len] = '\0';
-
-		pos = strchr(buf, '\n');
-		*pos++ = '\0';
-
-		if (strcmp(buf, "??") == 0) {
-			connman_error("#%-2u %p in %s", i - offset,
-						frames[i], info.dli_fname);
-			continue;
-		}
-
-		ptr = strchr(pos, '\n');
-		*ptr++ = '\0';
-
-		if (strncmp(pos, program_path, pathlen) == 0)
-			pos += pathlen + 1;
-
-		connman_error("#%-2u %p in %s() at %s", i - offset,
-						frames[i], buf, pos);
-	}
-
-	connman_error("+++++++++++++++++++++++++++");
-
-	kill(pid, SIGTERM);
-
-	close(outfd[1]);
-	close(infd[0]);
-}
-
 static void signal_handler(int signo)
 {
 	connman_error("Aborting (signal %d) [%s]", signo, program_exec);
 
-	print_backtrace(2);
+	print_backtrace(program_path, program_exec, 2);
 
 	exit(EXIT_FAILURE);
 }
diff -Naur connman-1.31/src/network.c connman-1.31-fix/src/network.c
--- connman-1.31/src/network.c	2015-12-28 04:05:49.000000000 +0100
+++ connman-1.31-fix/src/network.c	2016-03-06 22:39:57.388747605 +0100
@@ -285,9 +285,6 @@
 	if (err < 0)
 		return err;
 
-	__connman_connection_gateway_activate(service,
-						CONNMAN_IPCONFIG_TYPE_IPV6);
-
 	__connman_device_set_network(network->device, network);
 
 	connman_network_set_associating(network, false);
diff -Naur connman-1.31/src/service.c connman-1.31-fix/src/service.c
--- connman-1.31/src/service.c	2015-12-28 04:05:49.000000000 +0100
+++ connman-1.31-fix/src/service.c	2016-03-06 22:39:57.389747630 +0100
@@ -347,6 +347,19 @@
 		return CONNMAN_SERVICE_PROXY_METHOD_UNKNOWN;
 }
 
+static void set_split_routing(struct connman_service *service, bool value)
+{
+	if (service->type != CONNMAN_SERVICE_TYPE_VPN)
+		return;
+
+	service->do_split_routing = value;
+
+	if (service->do_split_routing)
+		service->order = 0;
+	else
+		service->order = 10;
+}
+
 int __connman_service_load_modifiable(struct connman_service *service)
 {
 	GKeyFile *keyfile;
@@ -367,8 +380,10 @@
 	case CONNMAN_SERVICE_TYPE_P2P:
 		break;
 	case CONNMAN_SERVICE_TYPE_VPN:
-		service->do_split_routing = g_key_file_get_boolean(keyfile,
-				service->identifier, "SplitRouting", NULL);
+		set_split_routing(service, g_key_file_get_boolean(keyfile,
+							service->identifier,
+							"SplitRouting", NULL));
+
 		/* fall through */
 	case CONNMAN_SERVICE_TYPE_WIFI:
 	case CONNMAN_SERVICE_TYPE_GADGET:
@@ -421,8 +436,10 @@
 	case CONNMAN_SERVICE_TYPE_P2P:
 		break;
 	case CONNMAN_SERVICE_TYPE_VPN:
-		service->do_split_routing = g_key_file_get_boolean(keyfile,
-				service->identifier, "SplitRouting", NULL);
+		set_split_routing(service, g_key_file_get_boolean(keyfile,
+							service->identifier,
+							"SplitRouting", NULL));
+
 		autoconnect = g_key_file_get_boolean(keyfile,
 				service->identifier, "AutoConnect", &error);
 		if (!error)
@@ -3636,7 +3653,7 @@
 	else
 		active_count--;
 
-	while (list != NULL) {
+	while (list) {
 		enum connman_service_type type = GPOINTER_TO_INT(list->data);
 
 		switch (type) {
@@ -4223,11 +4240,11 @@
 			return __connman_error_invalid_service(msg);
 		}
 
-		target->do_split_routing = true;
+		set_split_routing(target, true);
 	} else
-		target->do_split_routing = false;
+		set_split_routing(target, false);
 
-	service->do_split_routing = false;
+	set_split_routing(service, false);
 
 	target4 = __connman_ipconfig_get_method(target->ipconfig_ipv4);
 	target6 = __connman_ipconfig_get_method(target->ipconfig_ipv6);
@@ -4785,6 +4802,12 @@
 	}
 }
 
+int __connman_service_compare(const struct connman_service *a,
+					const struct connman_service *b)
+{
+	return service_compare(a, b);
+}
+
 /**
  * connman_service_get_type:
  * @service: service structure
@@ -6600,12 +6623,6 @@
 	return order;
 }
 
-void __connman_service_update_ordering(void)
-{
-	if (service_list && service_list->next)
-		service_list = g_list_sort(service_list, service_compare);
-}
-
 static enum connman_service_type convert_network_type(struct connman_network *network)
 {
 	enum connman_network_type type = connman_network_get_type(network);
diff -Naur connman-1.31/TODO connman-1.31-fix/TODO
--- connman-1.31/TODO	2015-12-28 04:05:49.000000000 +0100
+++ connman-1.31-fix/TODO	2016-03-06 22:39:57.377747328 +0100
@@ -85,17 +85,6 @@
    utilize the information already provided by netlink in src/device.c.
 
 
-- Simplify gateway selection code
-
-   Priority: Low
-   Complexity: C4
-
-   The service list is always sorted according to preference with the
-   first service always owning the default route. See if update_order and
-   find_default_gateway in src/connection.c can be modified to use the
-   sorted service list instead of walking through the gateway_hash.
-
-
 - Support D-Bus ObjectManager
 
    Priority: Medium

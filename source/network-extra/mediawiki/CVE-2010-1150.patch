Subject: Fixes login CSRF vulnerability. Fix includes a breaking change to the
API login action. Any clients using it will need to be updated.
Origin: http://svn.wikimedia.org/viewvc/mediawiki?view=rev&revision=64680
Index: b/includes/User.php
===================================================================
--- a/includes/User.php	2009-05-01 08:24:09.000000000 +0200
+++ b/includes/User.php	2010-04-07 09:54:25.000000000 +0200
@@ -2771,7 +2771,7 @@
 			return EDIT_TOKEN_SUFFIX;
 		} else {
 			if( !isset( $_SESSION['wsEditToken'] ) ) {
-				$token = $this->generateToken();
+				$token = self::generateToken();
 				$_SESSION['wsEditToken'] = $token;
 			} else {
 				$token = $_SESSION['wsEditToken'];
@@ -2789,7 +2789,7 @@
 	 * @param $salt \string Optional salt value
 	 * @return \string The new random token
 	 */
-	function generateToken( $salt = '' ) {
+	public static function generateToken( $salt = '' ) {
 		$token = dechex( mt_rand() ) . dechex( mt_rand() );
 		return md5( $token . $salt );
 	}
@@ -2884,7 +2884,7 @@
 		$now = time();
 		$expires = $now + 7 * 24 * 60 * 60;
 		$expiration = wfTimestamp( TS_MW, $expires );
-		$token = $this->generateToken( $this->mId . $this->mEmail . $expires );
+		$token = self::generateToken( $this->mId . $this->mEmail . $expires );
 		$hash = md5( $token );
 		$this->load();
 		$this->mEmailToken = $hash;
Index: b/includes/api/ApiLogin.php
===================================================================
--- a/includes/api/ApiLogin.php	2009-03-06 14:49:44.000000000 +0100
+++ b/includes/api/ApiLogin.php	2010-04-07 09:54:25.000000000 +0200
@@ -60,6 +60,7 @@
 			'wpName' => $params['name'],
 			'wpPassword' => $params['password'],
 			'wpDomain' => $params['domain'],
+			'wpLoginToken' => $params['token'],
 			'wpRemember' => ''
 		));
 
@@ -88,6 +89,15 @@
 				$result['cookieprefix'] = $wgCookiePrefix;
 				$result['sessionid'] = session_id();
 				break;
+			
+			case LoginForm::NEED_TOKEN:
+				$result['result'] = 'NeedToken';
+				$result['token'] = $loginForm->getLoginToken();
+				break;
+			
+			case LoginForm::WRONG_TOKEN:
+				$result['result'] = 'WrongToken';
+				break;
 
 			case LoginForm :: NO_NAME :
 				$result['result'] = 'NoName';
@@ -133,7 +143,8 @@
 		return array (
 			'name' => null,
 			'password' => null,
-			'domain' => null
+			'domain' => null,
+			'token' => null,
 		);
 	}
 
@@ -141,7 +152,8 @@
 		return array (
 			'name' => 'User Name',
 			'password' => 'Password',
-			'domain' => 'Domain (optional)'
+			'domain' => 'Domain (optional)',
+			'token' => 'Login token obtained in first request',
 		);
 	}
 
Index: b/includes/specials/SpecialUserlogin.php
===================================================================
--- a/includes/specials/SpecialUserlogin.php	2009-03-25 03:27:30.000000000 +0100
+++ b/includes/specials/SpecialUserlogin.php	2010-04-07 09:54:25.000000000 +0200
@@ -34,10 +34,14 @@
 	const ABORTED = 8;
 	const CREATE_BLOCKED = 9;
 	const THROTTLED = 10;
+	const USER_BLOCKED = 11;
+ 	const NEED_TOKEN = 12;
+ 	const WRONG_TOKEN = 13;
 
 	var $mName, $mPassword, $mRetype, $mReturnTo, $mCookieCheck, $mPosted;
 	var $mAction, $mCreateaccount, $mCreateaccountMail, $mMailmypassword;
 	var $mLoginattempt, $mRemember, $mEmail, $mDomain, $mLanguage, $mSkipCookieCheck;
+	var $mToken;
 
 	/**
 	 * Constructor
@@ -65,6 +69,7 @@
 		$this->mRemember = $request->getCheck( 'wpRemember' );
 		$this->mLanguage = $request->getText( 'uselang' );
 		$this->mSkipCookieCheck = $request->getCheck( 'wpSkipCookieCheck' );
+		$this->mToken = $request->getVal( 'wpLoginToken' );
 
 		if ( $wgRedirectOnLogin ) {
 			$this->mReturnTo = $wgRedirectOnLogin;
@@ -382,7 +387,22 @@
 		if ( '' == $this->mName ) {
 			return self::NO_NAME;
 		}
+
+		// We require a login token to prevent login CSRF
+		// Handle part of this before incrementing the throttle so
+		// token-less login attempts don't count towards the throttle
+		// but wrong-token attempts do.
 		
+		// If the user doesn't have a login token yet, set one.
+		if ( !self::getLoginToken() ) {
+			self::setLoginToken();
+			return self::NEED_TOKEN;
+		}
+		// If the user didn't pass a login token, tell them we need one
+		if ( !$this->mToken ) {
+			return self::NEED_TOKEN;
+		}
+
 		global $wgPasswordAttemptThrottle;
 
 		$throttleCount=0;
@@ -401,6 +421,11 @@
 				return self::THROTTLED;
 			}
 		}
+		
+		// Validate the login token
+		if ( $this->mToken !== self::getLoginToken() ) {
+			return self::WRONG_TOKEN;
+		}
 
 		// Load $wgUser now, and check to see if we're logging in as the same
 		// name. This is necessary because loading $wgUser (say by calling
@@ -532,6 +557,7 @@
 					$wgUser->invalidateCache();
 				}
 				$wgUser->setCookies();
+				self::clearLoginToken();
 
 				// Reset the throttle
 				$key = wfMemcKey( 'password-throttle', wfGetIP(), md5( $this->mName ) );
@@ -550,7 +576,11 @@
 					return $this->cookieRedirectCheck( 'login' );
 				}
 				break;
-
+			
+			case self::NEED_TOKEN:
+			case self::WRONG_TOKEN:
+				$this->mainLoginForm( wfMsg( 'sessionfailure' ) );
+				break;
 			case self::NO_NAME:
 			case self::ILLEGAL:
 				$this->mainLoginForm( wfMsg( 'noname' ) );
@@ -881,6 +911,11 @@
 		$template->set( 'canremember', ( $wgCookieExpiration > 0 ) );
 		$template->set( 'remember', $wgUser->getOption( 'rememberpassword' ) or $this->mRemember  );
 
+		if ( !self::getLoginToken() ) {
+			self::setLoginToken();
+		}
+		$template->set( 'token', self::getLoginToken() );
+
 		# Prepare language selection links as needed
 		if( $wgLoginLanguageSelector ) {
 			$template->set( 'languages', $this->makeLanguageSelector() );
@@ -929,6 +964,32 @@
 		global $wgDisableCookieCheck, $wgRequest;
 		return $wgDisableCookieCheck ? true : $wgRequest->checkSessionCookie();
 	}
+	
+	/**
+	 * Get the login token from the current session
+	 */
+	public static function getLoginToken() {
+		global $wgRequest;
+		return $wgRequest->getSessionData( 'wsLoginToken' );
+	}
+	
+	/**
+	 * Generate a new login token and attach it to the current session
+	 */
+	public static function setLoginToken() {
+		global $wgRequest;
+		// Use User::generateToken() instead of $user->editToken()
+		// because the latter reuses $_SESSION['wsEditToken']
+		$wgRequest->setSessionData( 'wsLoginToken', User::generateToken() );
+	}
+	
+	/**
+	 * Remove any login token attached to the current session
+	 */
+	public static  function clearLoginToken() {
+		global $wgRequest;
+		$wgRequest->setSessionData( 'wsLoginToken', null );
+	}
 
 	/**
 	 * @private
Index: b/includes/templates/Userlogin.php
===================================================================
--- a/includes/templates/Userlogin.php	2009-01-17 00:04:13.000000000 +0100
+++ b/includes/templates/Userlogin.php	2010-04-07 09:54:25.000000000 +0200
@@ -87,6 +87,7 @@
 		</tr>
 	</table>
 <?php if( @$this->haveData( 'uselang' ) ) { ?><input type="hidden" name="uselang" value="<?php $this->text( 'uselang' ); ?>" /><?php } ?>
+<?php if( @$this->haveData( 'token' ) ) { ?><input type="hidden" name="wpLoginToken" value="<?php $this->text( 'token' ); ?>" /><?php } ?>
 </form>
 </div>
 <div id="loginend"><?php $this->msgWiki( 'loginend' ); ?></div>

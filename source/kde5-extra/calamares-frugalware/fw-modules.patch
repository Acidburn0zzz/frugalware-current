diff -Naur calamares-3.1/src/modules/fw_bootloader/fw_bootloader.conf calamares-3.1-p/src/modules/fw_bootloader/fw_bootloader.conf
--- calamares-3.1/src/modules/fw_bootloader/fw_bootloader.conf	1970-01-01 01:00:00.000000000 +0100
+++ calamares-3.1-p/src/modules/fw_bootloader/fw_bootloader.conf	2017-05-30 04:25:58.190250921 +0200
@@ -0,0 +1,21 @@
+---
+# Define which bootloader you want to use for EFI installations
+# Possible option is 'grub'
+efiBootLoader: "grub"
+
+# Optionally set the menu entry name and kernel name
+# If not specified here, these settings will be taken from branding.desc.
+# bootloaderEntryName: "Generic GNU/Linux"
+# kernelLine: ", with Stable-Kernel"
+
+# GRUB 2 binary names and boot directory
+# Some distributions (e.g. Fedora) use grub2-* (resp. /boot/grub2/) names.
+grubInstall: "grub-install"
+grubMkconfig: "grub-mkconfig"
+grubCfg: "/boot/grub/grub.cfg"
+
+# Optionally set the --bootloader-id to use for EFI. If not set, this defaults
+# to the bootloaderEntryName from branding.desc with problematic characters
+# replaced. If an efiBootloaderId is specified here, it is taken to already be a
+# valid directory name, so no such postprocessing is done in this case.
+# efiBootloaderId: "dirname"
diff -Naur calamares-3.1/src/modules/fw_bootloader/main.py calamares-3.1-p/src/modules/fw_bootloader/main.py
--- calamares-3.1/src/modules/fw_bootloader/main.py	1970-01-01 01:00:00.000000000 +0100
+++ calamares-3.1-p/src/modules/fw_bootloader/main.py	2017-05-30 04:25:58.190250921 +0200
@@ -0,0 +1,215 @@
+#!/usr/bin/env python3
+# -*- coding: utf-8 -*-
+#
+# === This file is part of Calamares - <http://github.com/calamares> ===
+#
+#   Copyright 2014, Aurélien Gâteau <agateau@kde.org>
+#   Copyright 2014, Anke Boersma <demm@kaosx.us>
+#   Copyright 2014, Daniel Hillenbrand <codeworkx@bbqlinux.org>
+#   Copyright 2014, Benjamin Vaudour <benjamin.vaudour@yahoo.fr>
+#   Copyright 2014, Kevin Kofler <kevin.kofler@chello.at>
+#   Copyright 2015, Philip Mueller <philm@manjaro.org>
+#   Copyright 2016-2017, Teo Mrnjavac <teo@kde.org>
+#   Copyright 2017, Alf Gaida <agaida@siduction.org>
+#
+#   Calamares is free software: you can redistribute it and/or modify
+#   it under the terms of the GNU General Public License as published by
+#   the Free Software Foundation, either version 3 of the License, or
+#   (at your option) any later version.
+#
+#   Calamares is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#   GNU General Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License
+#   along with Calamares. If not, see <http://www.gnu.org/licenses/>.
+
+import os
+import shutil
+import subprocess
+
+import libcalamares
+
+from libcalamares.utils import check_target_env_call
+
+
+def get_uuid():
+    """
+    Checks and passes 'uuid' to other routine.
+
+    :return:
+    """
+    root_mount_point = libcalamares.globalstorage.value("rootMountPoint")
+    print("Root mount point: \"{!s}\"".format(root_mount_point))
+    partitions = libcalamares.globalstorage.value("partitions")
+    print("Partitions: \"{!s}\"".format(partitions))
+
+    for partition in partitions:
+        if partition["mountPoint"] == "/":
+            print("Root partition uuid: \"{!s}\"".format(partition["uuid"]))
+            return partition["uuid"]
+
+    return ""
+
+
+def get_bootloader_entry_name():
+    """
+    Passes 'bootloader_entry_name' to other routine based
+    on configuration file.
+
+    :return:
+    """
+    if "bootloaderEntryName" in libcalamares.job.configuration:
+        return libcalamares.job.configuration["bootloaderEntryName"]
+    else:
+        branding = libcalamares.globalstorage.value("branding")
+        return branding["bootloaderEntryName"]
+
+
+def get_kernel_line(kernel_type):
+    """
+    Passes 'kernel_line' to other routine based on configuration file.
+
+    :param kernel_type:
+    :return:
+    """
+    if "kernelLine" in libcalamares.job.configuration:
+        return libcalamares.job.configuration["kernelLine"]
+    else:
+        return ""
+
+def install_grub(efi_directory, fw_type):
+    """
+    Installs grub as bootloader, either in pc or efi mode.
+
+    :param efi_directory:
+    :param fw_type:
+    """
+    if fw_type == "efi":
+        print("Bootloader: grub (efi)")
+        install_path = libcalamares.globalstorage.value("rootMountPoint")
+        install_efi_directory = install_path + efi_directory
+
+        if not os.path.isdir(install_efi_directory):
+            os.makedirs(install_efi_directory)
+
+        if "efiBootloaderId" in libcalamares.job.configuration:
+            efi_bootloader_id = libcalamares.job.configuration[
+                                    "efiBootloaderId"]
+        else:
+            branding = libcalamares.globalstorage.value("branding")
+            distribution = branding["bootloaderEntryName"]
+            file_name_sanitizer = str.maketrans(" /", "_-")
+            efi_bootloader_id = distribution.translate(file_name_sanitizer)
+        # get bitness of the underlying UEFI
+        try:
+            sysfile = open("/sys/firmware/efi/fw_platform_size", "r")
+            efi_bitness = sysfile.read(2)
+        except Exception:
+            # if the kernel is older than 4.0, the UEFI bitness likely isn't
+            # exposed to the userspace so we assume a 64 bit UEFI here
+            efi_bitness = "64"
+        bitness_translate = {"32": "--target=i386-efi",
+                             "64": "--target=x86_64-efi"}
+        check_target_env_call([libcalamares.job.configuration["grubInstall"],
+                               bitness_translate[efi_bitness],
+                               "--efi-directory=" + efi_directory,
+                               "--bootloader-id=" + efi_bootloader_id,
+                               "--force"])
+
+        # VFAT is weird, see issue CAL-385
+        install_efi_directory_firmware = (vfat_correct_case(
+                                              install_efi_directory,
+                                              "EFI"))
+        if not os.path.exists(install_efi_directory_firmware):
+            os.makedirs(install_efi_directory_firmware)
+
+        # there might be several values for the boot directory
+        # most usual they are boot, Boot, BOOT
+
+        install_efi_boot_directory = (vfat_correct_case(
+                                          install_efi_directory_firmware,
+                                          "boot"))
+        if not os.path.exists(install_efi_boot_directory):
+            os.makedirs(install_efi_boot_directory)
+
+        # Workaround for some UEFI firmwares
+        efi_file_source = {"32": os.path.join(install_efi_directory_firmware,
+                                              efi_bootloader_id,
+                                              "grubia32.efi"),
+                           "64": os.path.join(install_efi_directory_firmware,
+                                              efi_bootloader_id,
+                                              "grubx64.efi")}
+        shutil.copy2(efi_file_source[efi_bitness], install_efi_boot_directory)
+    else:
+        print("Bootloader: grub (bios)")
+        if libcalamares.globalstorage.value("bootLoader") is None:
+            return
+
+        boot_loader = libcalamares.globalstorage.value("bootLoader")
+        if boot_loader["installPath"] is None:
+            return
+
+        check_target_env_call([libcalamares.job.configuration["grubInstall"],
+                               "--target=i386-pc",
+                               "--recheck",
+                               "--force",
+                               boot_loader["installPath"]])
+
+    # The file specified in grubCfg should already be filled out
+    # by the grubcfg job module.
+    check_target_env_call([libcalamares.job.configuration["grubMkconfig"],
+                           "-o", libcalamares.job.configuration["grubCfg"]])
+
+
+def vfat_correct_case(parent, name):
+    for candidate in os.listdir(parent):
+        if name.lower() == candidate.lower():
+            return os.path.join(parent, candidate)
+    return os.path.join(parent, name)
+
+
+def prepare_bootloader(fw_type):
+    """
+    Prepares bootloader.
+    Based on value 'efi_boot_loader', calls grub to be installed.
+
+    :param fw_type:
+    :return:
+    """
+    efi_boot_loader = libcalamares.job.configuration["efiBootLoader"]
+    efi_directory = libcalamares.globalstorage.value("efiSystemPartition")
+
+    install_grub(efi_directory, fw_type)
+
+
+def run():
+    """
+    Starts procedure and passes 'fw_type' to other routine.
+
+    :return:
+    """
+
+    fw_type = libcalamares.globalstorage.value("firmwareType")
+
+    if (libcalamares.globalstorage.value("bootLoader") is None
+            and fw_type != "efi"):
+        return None
+
+    partitions = libcalamares.globalstorage.value("partitions")
+
+    if fw_type == "efi":
+        esp_found = False
+
+        for partition in partitions:
+            if (partition["mountPoint"] ==
+                    libcalamares.globalstorage.value("efiSystemPartition")):
+                esp_found = True
+
+        if not esp_found:
+            return None
+
+    prepare_bootloader(fw_type)
+
+    return None
diff -Naur calamares-3.1/src/modules/fw_bootloader/module.desc calamares-3.1-p/src/modules/fw_bootloader/module.desc
--- calamares-3.1/src/modules/fw_bootloader/module.desc	1970-01-01 01:00:00.000000000 +0100
+++ calamares-3.1-p/src/modules/fw_bootloader/module.desc	2017-05-30 04:25:58.190250921 +0200
@@ -0,0 +1,5 @@
+---
+type:       "job"
+name:       "fw_bootloader"
+interface:  "python"
+script:     "main.py"
diff -Naur calamares-3.1/src/modules/fw_bootloader/test.yaml calamares-3.1-p/src/modules/fw_bootloader/test.yaml
--- calamares-3.1/src/modules/fw_bootloader/test.yaml	1970-01-01 01:00:00.000000000 +0100
+++ calamares-3.1-p/src/modules/fw_bootloader/test.yaml	2017-05-30 04:25:58.190250921 +0200
@@ -0,0 +1,5 @@
+rootMountPoint: /tmp/mount
+bootLoader:
+    installPath: /dev/sdb
+branding:
+    shortProductName: "Generic Distro"
diff -Naur calamares-3.1/src/modules/fw_fstab/fw_fstab.conf calamares-3.1-p/src/modules/fw_fstab/fw_fstab.conf
--- calamares-3.1/src/modules/fw_fstab/fw_fstab.conf	1970-01-01 01:00:00.000000000 +0100
+++ calamares-3.1-p/src/modules/fw_fstab/fw_fstab.conf	2017-05-30 04:25:58.191250948 +0200
@@ -0,0 +1,13 @@
+---
+mountOptions:
+    default: defaults,noatime
+    btrfs: defaults,noatime,space_cache,autodefrag
+ssdExtraMountOptions:
+    ext4: discard
+    jfs: discard
+    xfs: discard
+    swap: discard
+    btrfs: discard,compress=lzo
+crypttabOptions: luks
+# For Debian and Debian-based distributions, change the above line to:
+# crypttabOptions: luks,keyscript=/bin/cat
diff -Naur calamares-3.1/src/modules/fw_fstab/main.py calamares-3.1-p/src/modules/fw_fstab/main.py
--- calamares-3.1/src/modules/fw_fstab/main.py	1970-01-01 01:00:00.000000000 +0100
+++ calamares-3.1-p/src/modules/fw_fstab/main.py	2017-05-30 04:25:58.191250948 +0200
@@ -0,0 +1,318 @@
+#!/usr/bin/env python3
+# -*- coding: utf-8 -*-
+#
+# === This file is part of Calamares - <http://github.com/calamares> ===
+#
+#   Copyright 2014, Aurélien Gâteau <agateau@kde.org>
+#   Copyright 2016, Teo Mrnjavac <teo@kde.org>
+#
+#   Calamares is free software: you can redistribute it and/or modify
+#   it under the terms of the GNU General Public License as published by
+#   the Free Software Foundation, either version 3 of the License, or
+#   (at your option) any later version.
+#
+#   Calamares is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#   GNU General Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License
+#   along with Calamares. If not, see <http://www.gnu.org/licenses/>.
+
+import os
+import re
+import subprocess
+
+import libcalamares
+
+
+FSTAB_HEADER = """# /etc/fstab: static file system information.
+#
+# Use 'blkid' to print the universally unique identifier for a device; this may
+# be used with UUID= as a more robust way to name devices that works even if
+# disks are added and removed. See fstab(5).
+#
+# <file system>                           <mount point>  <type>  <options>  <dump>  <pass>"""
+
+CRYPTTAB_HEADER = """# /etc/crypttab: mappings for encrypted partitions.
+#
+# Each mapped device will be created in /dev/mapper, so your /etc/fstab
+# should use the /dev/mapper/<name> paths for encrypted devices.
+#
+# See crypttab(5) for the supported syntax.
+#
+# NOTE: Do not list your root (/) partition here, it must be set up
+#       beforehand by the initramfs (/etc/mkinitcpio.conf). The same applies
+#       to encrypted swap, which should be set up with mkinitcpio-openswap
+#       for resume support.
+#
+# <name>               <device>                                     <password> <options>"""
+
+# Turn Parted filesystem names into fstab names
+FS_MAP = {
+    "fat16": "vfat",
+    "fat32": "vfat",
+    "linuxswap": "swap",
+}
+
+
+def mkdir_p(path):
+    """ Create directory.
+
+    :param path:
+    """
+    if not os.path.exists(path):
+        os.makedirs(path)
+
+
+def is_ssd_disk(disk_name):
+    """ Checks if given disk is actually a ssd disk.
+
+    :param disk_name:
+    :return:
+    """
+    filename = os.path.join("/sys/block", disk_name, "queue/rotational")
+
+    if not os.path.exists(filename):
+        # Should not happen unless sysfs changes, but better safe than sorry
+        return False
+
+    with open(filename) as sysfile:
+        return sysfile.read() == "0\n"
+
+
+def disk_name_for_partition(partition):
+    """ Returns disk name for each found partition.
+
+    :param partition:
+    :return:
+    """
+    name = os.path.basename(partition["device"])
+
+    if name.startswith("/dev/mmcblk") or name.startswith("/dev/nvme"):
+        return re.sub("p[0-9]+$", "", name)
+
+    return re.sub("[0-9]+$", "", name)
+
+
+class FstabGenerator(object):
+    """ Class header
+
+    :param partitions:
+    :param root_mount_point:
+    :param mount_options:
+    :param ssd_extra_mount_options:
+    """
+    def __init__(self, partitions, root_mount_point, mount_options,
+                 ssd_extra_mount_options, crypttab_options):
+        self.partitions = partitions
+        self.root_mount_point = root_mount_point
+        self.mount_options = mount_options
+        self.ssd_extra_mount_options = ssd_extra_mount_options
+        self.crypttab_options = crypttab_options
+        self.ssd_disks = set()
+        self.root_is_ssd = False
+
+    def run(self):
+        """ Calls needed sub routines.
+
+        :return:
+        """
+        self.find_ssd_disks()
+        self.generate_fstab()
+        self.generate_crypttab()
+        self.create_mount_points()
+
+        return None
+
+    def find_ssd_disks(self):
+        """ Checks for ssd disks """
+        disks = {disk_name_for_partition(x) for x in self.partitions}
+        self.ssd_disks = {x for x in disks if is_ssd_disk(x)}
+
+    def generate_crypttab(self):
+        """ Create crypttab. """
+        mkdir_p(os.path.join(self.root_mount_point, "etc"))
+        crypttab_path = os.path.join(self.root_mount_point, "etc", "crypttab")
+
+        with open(crypttab_path, "w") as crypttab_file:
+            print(CRYPTTAB_HEADER, file=crypttab_file)
+
+            for partition in self.partitions:
+                dct = self.generate_crypttab_line_info(partition)
+
+                if dct:
+                    self.print_crypttab_line(dct, file=crypttab_file)
+
+    def generate_crypttab_line_info(self, partition):
+        """ Generates information for each crypttab entry. """
+
+        if "luksMapperName" not in partition or "luksUuid" not in partition:
+            return None
+
+        mapper_name = partition["luksMapperName"]
+        mount_point = partition["mountPoint"]
+        luks_uuid = partition["luksUuid"]
+        if not mapper_name or not luks_uuid:
+            return None
+
+        return dict(
+                name=mapper_name,
+                device="UUID=" + luks_uuid,
+                password="/crypto_keyfile.bin",
+                options=self.crypttab_options,
+        )
+
+    def print_crypttab_line(self, dct, file=None):
+        """ Prints line to '/etc/crypttab' file. """
+        line = "{:21} {:<45} {} {}".format(dct["name"],
+                                           dct["device"],
+                                           dct["password"],
+                                           dct["options"],
+                                          )
+
+        print(line, file=file)
+
+    def generate_fstab(self):
+        """ Create fstab. """
+        mkdir_p(os.path.join(self.root_mount_point, "etc"))
+        fstab_path = os.path.join(self.root_mount_point, "etc", "fstab")
+
+        with open(fstab_path, "w") as fstab_file:
+            print(FSTAB_HEADER, file=fstab_file)
+
+            for partition in self.partitions:
+                # Special treatment for a btrfs root with @ and @home subvolumes
+                if partition["fs"] == "btrfs" and partition["mountPoint"] == "/":
+                    output = subprocess.check_output(['btrfs',
+                                                      'subvolume',
+                                                      'list',
+                                                      self.root_mount_point])
+                    output_lines = output.splitlines()
+                    for line in output_lines:
+                        if line.endswith(b'path @'):
+                            root_entry = partition
+                            root_entry["subvol"] = "@"
+                            dct = self.generate_fstab_line_info(root_entry)
+                            if dct:
+                                self.print_fstab_line(dct, file=fstab_file)
+                        elif line.endswith(b'path @home'):
+                            home_entry = partition
+                            home_entry["mountPoint"] = "/home"
+                            home_entry["subvol"] = "@home"
+                            dct = self.generate_fstab_line_info(home_entry)
+                            if dct:
+                                self.print_fstab_line(dct, file=fstab_file)
+
+                else:
+                    dct = self.generate_fstab_line_info(partition)
+
+                    if dct:
+                        self.print_fstab_line(dct, file=fstab_file)
+
+            if self.root_is_ssd:
+                # Mount /tmp on a tmpfs
+                dct = dict(device="tmpfs",
+                           mount_point="/tmp",
+                           fs="tmpfs",
+                           options="defaults,noatime,mode=1777",
+                           check=0,
+                          )
+                self.print_fstab_line(dct, file=fstab_file)
+
+    def generate_fstab_line_info(self, partition):
+        """ Generates information for each fstab entry. """
+        filesystem = partition["fs"]
+        mount_point = partition["mountPoint"]
+        disk_name = disk_name_for_partition(partition)
+        is_ssd = disk_name in self.ssd_disks
+        filesystem = FS_MAP.get(filesystem, filesystem)
+
+        if not mount_point and not filesystem == "swap":
+            return None
+
+        options = self.mount_options.get(filesystem,
+                                         self.mount_options["default"])
+        if is_ssd:
+            extra = self.ssd_extra_mount_options.get(filesystem)
+
+            if extra:
+                options += "," + extra
+
+        if mount_point == "/":
+            check = 1
+        elif mount_point:
+            check = 2
+        else:
+            check = 0
+
+        if mount_point == "/":
+            self.root_is_ssd = is_ssd
+
+        if filesystem == "btrfs" and "subvol" in partition:
+            return dict(device="UUID=" + partition["uuid"],
+                        mount_point=mount_point,
+                        fs=filesystem,
+                        options=",".join(["subvol={}".format(partition["subvol"]),
+                                          options]),
+                        check=check,
+                        )
+        ## what a f**** mess
+        if filesystem == "swap" and "luksMapperName" in partition:
+            return dict(device="/dev/mapper/" + partition["luksMapperName"],
+                        mount_point=mount_point or "swap",
+                        fs=filesystem,
+                        options=options,
+                        check=check,
+                        )
+        else:
+            return dict(device="UUID=" + partition["uuid"],
+                        mount_point=mount_point or "swap",
+                        fs=filesystem,
+                        options=options,
+                        check=check,
+                        )
+
+        return dict(device="UUID=" + partition["uuid"],
+                    mount_point=mount_point,
+                    fs=filesystem,
+                    options=options,
+                    check=check,
+                    )
+
+    def print_fstab_line(self, dct, file=None):
+        """ Prints line to '/etc/fstab' file. """
+        line = "{:41} {:<14} {:<7} {:<10} 0       {}".format(dct["device"],
+                                                             dct["mount_point"],
+                                                             dct["fs"],
+                                                             dct["options"],
+                                                             dct["check"],
+                                                            )
+        print(line, file=file)
+
+    def create_mount_points(self):
+        """ Creates mount points """
+        for partition in self.partitions:
+            if partition["mountPoint"]:
+                mkdir_p(self.root_mount_point + partition["mountPoint"])
+
+
+def run():
+    """ Configures fstab.
+
+    :return:
+    """
+    global_storage = libcalamares.globalstorage
+    conf = libcalamares.job.configuration
+    partitions = global_storage.value("partitions")
+    root_mount_point = global_storage.value("rootMountPoint")
+    mount_options = conf["mountOptions"]
+    ssd_extra_mount_options = conf.get("ssdExtraMountOptions", {})
+    crypttab_options = conf.get("crypttabOptions", "luks")
+    generator = FstabGenerator(partitions,
+                               root_mount_point,
+                               mount_options,
+                               ssd_extra_mount_options,
+                               crypttab_options)
+
+    return generator.run()
diff -Naur calamares-3.1/src/modules/fw_fstab/module.desc calamares-3.1-p/src/modules/fw_fstab/module.desc
--- calamares-3.1/src/modules/fw_fstab/module.desc	1970-01-01 01:00:00.000000000 +0100
+++ calamares-3.1-p/src/modules/fw_fstab/module.desc	2017-05-30 04:25:58.191250948 +0200
@@ -0,0 +1,5 @@
+---
+type:       "job"
+name:       "fw_fstab"
+interface:  "python"
+script:     "main.py"
diff -Naur calamares-3.1/src/modules/fw_fstab/test.yaml calamares-3.1-p/src/modules/fw_fstab/test.yaml
--- calamares-3.1/src/modules/fw_fstab/test.yaml	1970-01-01 01:00:00.000000000 +0100
+++ calamares-3.1-p/src/modules/fw_fstab/test.yaml	2017-05-30 04:25:58.191250948 +0200
@@ -0,0 +1,14 @@
+rootMountPoint: /tmp/mount
+partitions:
+    - device: /dev/sda1
+      fs: ext4
+      mountPoint: /
+      uuid: 2a00f1d5-1217-49a7-bedd-b55c85764732
+    - device: /dev/sda2
+      fs: swap
+      uuid: 59406569-446f-4730-a874-9f6b4b44fee3
+      mountPoint:
+    - device: /dev/sdb1
+      fs: btrfs
+      mountPoint: /home
+      uuid: 59406569-abcd-1234-a874-9f6b4b44fee3
diff -Naur calamares-3.1/src/modules/fw_grubcfg/fw_grubcfg.conf calamares-3.1-p/src/modules/fw_grubcfg/fw_grubcfg.conf
--- calamares-3.1/src/modules/fw_grubcfg/fw_grubcfg.conf	1970-01-01 01:00:00.000000000 +0100
+++ calamares-3.1-p/src/modules/fw_grubcfg/fw_grubcfg.conf	2017-05-30 04:25:58.191250948 +0200
@@ -0,0 +1,13 @@
+---
+# If set to true, always creates /etc/default/grub from scratch even if the file
+# already existed. If set to false, edits the existing file instead.
+overwrite: false
+# Default entries to write to /etc/default/grub if it does not exist yet or if
+# we are overwriting it. Note that in addition, GRUB_CMDLINE_LINUX_DEFAULT and
+# GRUB_DISTRIBUTOR will always be written, with automatically detected values.
+defaults:
+    GRUB_TIMEOUT: 5
+    GRUB_DEFAULT: "saved"
+    GRUB_DISABLE_SUBMENU: true
+    GRUB_TERMINAL_OUTPUT: "console"
+    GRUB_DISABLE_RECOVERY: true
diff -Naur calamares-3.1/src/modules/fw_grubcfg/main.py calamares-3.1-p/src/modules/fw_grubcfg/main.py
--- calamares-3.1/src/modules/fw_grubcfg/main.py	1970-01-01 01:00:00.000000000 +0100
+++ calamares-3.1-p/src/modules/fw_grubcfg/main.py	2017-05-30 04:25:58.191250948 +0200
@@ -0,0 +1,167 @@
+#!/usr/bin/env python3
+# -*- coding: utf-8 -*-
+#
+# === This file is part of Calamares - <http://github.com/calamares> ===
+#
+#   Copyright 2014-2015, Philip Müller <philm@manjaro.org>
+#   Copyright 2015-2017, Teo Mrnjavac <teo@kde.org>
+#
+#   Calamares is free software: you can redistribute it and/or modify
+#   it under the terms of the GNU General Public License as published by
+#   the Free Software Foundation, either version 3 of the License, or
+#   (at your option) any later version.
+#
+#   Calamares is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#   GNU General Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License
+#   along with Calamares. If not, see <http://www.gnu.org/licenses/>.
+
+import libcalamares
+import os
+import re
+
+
+def modify_grub_default(partitions, root_mount_point, distributor):
+    """ Configures '/etc/default/grub' for hibernation.
+
+    :param partitions:
+    :param root_mount_point:
+    :param distributor:
+    :return:
+    """
+    default_dir = os.path.join(root_mount_point, "etc/default")
+    default_grub = os.path.join(default_dir, "grub")
+    distributor_replace = distributor.replace("'", "'\\''")
+    swap_uuid = ""
+    swap_outer_uuid = ""
+
+    cryptdevice_params = []
+
+    for partition in partitions:
+        if partition["fs"] == "linuxswap" and "luksMapperName" in partition:
+            swap_outer_uuid = partition["luksUuid"]
+        else:
+            swap_uuid = partition["uuid"]
+
+        if partition["mountPoint"] == "/" and "luksMapperName" in partition:
+            cryptdevice_params = ["rd.luks.uuid={!s}".format(partition["luksUuid"])]
+
+    kernel_params = ["quiet"]
+
+    if cryptdevice_params:
+        kernel_params.extend(cryptdevice_params)
+
+    if swap_uuid:
+        kernel_params.append("resume=UUID={!s}".format(swap_uuid))
+    ## fixme that's all broken
+    if swap_outer_uuid:
+        kernel_params.append("resume=/dev/mapper/{!s}".format(partition["luksMapperName"]))
+        kernel_params.append("rd.luks.uuid={!s}".format(swap_outer_uuid))
+
+    distributor_line = "GRUB_DISTRIBUTOR='{!s}'".format(distributor_replace)
+
+    if not os.path.exists(default_dir):
+        os.mkdir(default_dir)
+
+    have_kernel_cmd = False
+    have_distributor_line = False
+
+    if "overwrite" in libcalamares.job.configuration:
+        overwrite = libcalamares.job.configuration["overwrite"]
+    else:
+        overwrite = False
+
+    if os.path.exists(default_grub) and not overwrite:
+        with open(default_grub, 'r') as grub_file:
+            lines = [x.strip() for x in grub_file.readlines()]
+
+        for i in range(len(lines)):
+            if lines[i].startswith("#GRUB_CMDLINE_LINUX_DEFAULT"):
+                kernel_cmd = "GRUB_CMDLINE_LINUX_DEFAULT=\"{!s}\"".format(" ".join(kernel_params))
+                lines[i] = kernel_cmd
+                have_kernel_cmd = True
+            elif lines[i].startswith("GRUB_CMDLINE_LINUX_DEFAULT"):
+                regex = re.compile(r"^GRUB_CMDLINE_LINUX_DEFAULT\s*=\s*")
+                line = regex.sub("", lines[i])
+                line = line.lstrip()
+                line = line.lstrip("\"")
+                line = line.lstrip("'")
+                line = line.rstrip()
+                line = line.rstrip("\"")
+                line = line.rstrip("'")
+                existing_params = line.split()
+
+                for existing_param in existing_params:
+                    existing_param_name = existing_param.split("=")[0]
+
+                    if existing_param_name not in ["quiet", "resume"]:  # the only ones we ever add
+                        kernel_params.append(existing_param)
+
+                kernel_cmd = "GRUB_CMDLINE_LINUX_DEFAULT=\"{!s}\"".format(" ".join(kernel_params))
+                lines[i] = kernel_cmd
+                have_kernel_cmd = True
+            elif lines[i].startswith("#GRUB_DISTRIBUTOR") or lines[i].startswith("GRUB_DISTRIBUTOR"):
+                lines[i] = distributor_line
+                have_distributor_line = True
+    else:
+        lines = []
+
+        if "defaults" in libcalamares.job.configuration:
+            for key, value in libcalamares.job.configuration["defaults"].items():
+                if value.__class__.__name__ == "bool":
+                    if value:
+                        escaped_value = "true"
+                    else:
+                        escaped_value = "false"
+                else:
+                    escaped_value = str(value).replace("'", "'\\''")
+
+                lines.append("{!s}='{!s}'".format(key, escaped_value))
+
+    if not have_kernel_cmd:
+        kernel_cmd = "GRUB_CMDLINE_LINUX_DEFAULT=\"{!s}\"".format(" ".join(kernel_params))
+        lines.append(kernel_cmd)
+
+    if not have_distributor_line:
+        lines.append(distributor_line)
+
+    if cryptdevice_params:
+        lines.append("GRUB_ENABLE_CRYPTODISK=y")
+
+    with open(default_grub, 'w') as grub_file:
+        grub_file.write("\n".join(lines) + "\n")
+
+    return None
+
+
+def run():
+    """ Calls routine with given parameters to modify '/etc/default/grub'.
+
+    :return:
+    """
+
+    fw_type = libcalamares.globalstorage.value("firmwareType")
+
+    if libcalamares.globalstorage.value("bootLoader") is None and fw_type != "efi":
+        return None
+
+    partitions = libcalamares.globalstorage.value("partitions")
+
+    if fw_type == "efi":
+        esp_found = False
+
+        for partition in partitions:
+            if partition["mountPoint"] == libcalamares.globalstorage.value("efiSystemPartition"):
+                esp_found = True
+
+        if not esp_found:
+            return None
+
+    root_mount_point = libcalamares.globalstorage.value("rootMountPoint")
+    branding = libcalamares.globalstorage.value("branding")
+    distributor = branding["bootloaderEntryName"]
+
+    return modify_grub_default(partitions, root_mount_point, distributor)
diff -Naur calamares-3.1/src/modules/fw_grubcfg/module.desc calamares-3.1-p/src/modules/fw_grubcfg/module.desc
--- calamares-3.1/src/modules/fw_grubcfg/module.desc	1970-01-01 01:00:00.000000000 +0100
+++ calamares-3.1-p/src/modules/fw_grubcfg/module.desc	2017-05-30 04:25:58.191250948 +0200
@@ -0,0 +1,5 @@
+---
+type:       "job"
+name:       "fw_grubcfg"
+interface:  "python"
+script:     "main.py"

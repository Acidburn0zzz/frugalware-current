diff -Naur jam-2.5/Jam.html jam-2.5-p/Jam.html
--- jam-2.5/Jam.html	2003-04-23 06:45:49.000000000 +0200
+++ jam-2.5-p/Jam.html	2007-08-19 22:36:55.000000000 +0200
@@ -169,11 +169,16 @@
 	In the parsing phase, <b>jam</b> reads and executes the Jambase
 	file, by default the built-in one.  It is written in the <b>jam</b>
 	language.  See <a href="#language"> Language</a> below.  The
-	last action of the Jambase is to read (via the "include" rule)
+	last action of the builtin Jambase is to read (via the "include" rule)
 	a user-provided file called "Jamfile".
 
 	<P>
 
+	On Debian systems, the builtin Jambase is available for
+	reference as <tt>/usr/share/doc/jam/Jambase.gz</tt>.
+
+	<P>
+
 	Collectively, the purpose of the Jambase and the Jamfile is to
 	name built target and source files, construct the dependency
 	graph among them, and associate build actions with targets.
@@ -273,7 +278,7 @@
 
 <DT> <P> <H3> Overview </H3> <DD>
 
-	<B>Jam</b> has a interpreted, procedural language with a few
+	<B>Jam</b> has an interpreted, procedural language with a few
 	select features to effect program construction.  Statements in
 	<b>jam</b> are rule (procedure) definitions, rule invocations,
 	updating action definitions, flow-of-control structures, variable
@@ -339,7 +344,7 @@
 
 	<P>
 
-	When an rule with updating actions is invoked, those actions are
+	When a rule with updating actions is invoked, those actions are
 	added to those associated with its built targets ($(1)) before
 	the rule's procedure is run.  Later, to build the targets in the
 	updating phase, the actions are passed to the OS command shell,
@@ -365,7 +370,7 @@
 	    <P><DD> Invoke a rule.  A rule is invoked with values in
 	    <I>field1</I> through <I>fieldN</I> (9 max).  They may be
 	    referenced in the procedure's <I>statements</I> as $(1)
-	    through $(<9>N</I>).  $(&lt;) and $(&gt;) are synonymous
+	    through $(<I>N</I>).  $(&lt;) and $(&gt;) are synonymous
 	    with $(1) and $(2).
 
 	    <P>
@@ -851,7 +856,7 @@
 
 	<DD> Builds a direct dependency: makes each of <I>targets1</I>
 	depend on each of <I>targets2</I>.  Generally, <I>targets1</I>
-	will be rebuilt if <I>targets2</I> are themselves rebuilt are
+	will be rebuilt if <I>targets2</I> are themselves rebuilt
 	or are newer than <I>targets1</I>.
 
 	<P><DT><CODE>
@@ -1069,7 +1074,7 @@
 
 	<P>
 
-	These two variable control header file scanning.  $(HDRSCAN) is
+	These two variables control header file scanning.  $(HDRSCAN) is
 	an <b>egrep</b>(1) pattern, with ()'s surrounding the file name,
 	used to find file inclusion statements in source files.  Jambase
 	uses $(HDRPATTERN) as the pattern for $(HDRSCAN).  $(HDRRULE)
diff -Naur jam-2.5/Jambase jam-2.5-p/Jambase
--- jam-2.5/Jambase	2003-04-23 06:45:49.000000000 +0200
+++ jam-2.5-p/Jambase	2007-08-19 22:36:55.000000000 +0200
@@ -541,7 +541,7 @@
 	CRELIB		?= ;
 	DOT		?= . ;
 	DOTDOT		?= .. ;
-	EXEMODE		?= 711 ;
+	EXEMODE		?= 755 ;
 	FILEMODE	?= 644 ;
 	FORTRAN		?= f77 ;
 	FORTRANFLAGS	?= ;
@@ -1129,7 +1129,7 @@
 
 rule Setuid
 {
-	MODE on [ FAppendSuffix $(<) : $(SUFEXE) ] = 4711 ;
+	MODE on [ FAppendSuffix $(<) : $(SUFEXE) ] = 4755 ;
 }
 
 rule Shell
@@ -1420,7 +1420,7 @@
 
 rule UserObject
 {
-	Exit "Unknown suffix on" $(>) "- see UserObject rule in Jamfile(5)." ;
+	Exit "Unknown suffix on" $(>) "- see UserObject rule in /usr/share/doc/jam/Jamfile.html." ;
 }
 
 rule Yacc
diff -Naur jam-2.5/Jamfile.html jam-2.5-p/Jamfile.html
--- jam-2.5/Jamfile.html	2003-04-23 06:45:50.000000000 +0200
+++ jam-2.5-p/Jamfile.html	2007-08-19 22:36:55.000000000 +0200
@@ -290,7 +290,7 @@
               for automatic customizing with autoconf(GNU).
 <P>
 	<LI> 	Optionally, set an environment variable pointing
-		to the root directory of the srouce tree. The
+		to the root directory of the source tree. The
 		variable's name is left up to you, but in these
 		examples, we use TOP.
 </OL>
diff -Naur jam-2.5/jambase.c jam-2.5-p/jambase.c
--- jam-2.5/jambase.c	2004-08-19 20:19:35.000000000 +0200
+++ jam-2.5-p/jambase.c	2007-08-19 22:36:55.000000000 +0200
@@ -333,7 +333,7 @@
 "CRELIB		?= ;\n",
 "DOT		?= . ;\n",
 "DOTDOT		?= .. ;\n",
-"EXEMODE		?= 711 ;\n",
+"EXEMODE		?= 755 ;\n",
 "FILEMODE	?= 644 ;\n",
 "FORTRAN		?= f77 ;\n",
 "FORTRANFLAGS	?= ;\n",
@@ -702,7 +702,7 @@
 "}\n",
 "rule Setuid\n",
 "{\n",
-"MODE on [ FAppendSuffix $(<) : $(SUFEXE) ] = 4711 ;\n",
+"MODE on [ FAppendSuffix $(<) : $(SUFEXE) ] = 4755 ;\n",
 "}\n",
 "rule Shell\n",
 "{\n",
@@ -816,7 +816,7 @@
 "}\n",
 "rule UserObject\n",
 "{\n",
-"Exit \"Unknown suffix on\" $(>) \"- see UserObject rule in Jamfile(5).\" ;\n",
+"Exit \"Unknown suffix on\" $(>) \"- see UserObject rule in /usr/share/doc/jam/Jamfile.html.\" ;\n",
 "}\n",
 "rule Yacc\n",
 "{\n",
diff -Naur jam-2.5/jamgram.c jam-2.5-p/jamgram.c
--- jam-2.5/jamgram.c	2004-08-19 20:19:34.000000000 +0200
+++ jam-2.5-p/jamgram.c	2007-08-19 22:36:56.000000000 +0200
@@ -1,23 +1,161 @@
-#ifndef lint
-static char const 
-yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28.2.1 2001/07/19 05:46:39 peter Exp $";
-#endif
-#include <stdlib.h>
-#define YYBYACC 1
-#define YYMAJOR 1
-#define YYMINOR 9
-#define YYLEX yylex()
-#define YYEMPTY -1
-#define yyclearin (yychar=(YYEMPTY))
-#define yyerrok (yyerrflag=0)
-#define YYRECOVERING() (yyerrflag!=0)
-#if defined(__cplusplus) || __STDC__
-static int yygrowstack(void);
-#else
-static int yygrowstack();
-#endif
-#define YYPREFIX "yy"
-#line 85 "jamgram.y"
+/* A Bison parser, made by GNU Bison 1.875a.  */
+
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* Written by Richard Stallman by simplifying the original so called
+   ``semantic'' parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     _LANGLE_t = 258,
+     _LANGLE_EQUALS_t = 259,
+     _EQUALS_t = 260,
+     _RANGLE_t = 261,
+     _RANGLE_EQUALS_t = 262,
+     _BAR_t = 263,
+     _BARBAR_t = 264,
+     _SEMIC_t = 265,
+     _COLON_t = 266,
+     _BANG_t = 267,
+     _BANG_EQUALS_t = 268,
+     _QUESTION_EQUALS_t = 269,
+     _LPAREN_t = 270,
+     _RPAREN_t = 271,
+     _LBRACKET_t = 272,
+     _RBRACKET_t = 273,
+     _LBRACE_t = 274,
+     _RBRACE_t = 275,
+     _AMPER_t = 276,
+     _AMPERAMPER_t = 277,
+     _PLUS_EQUALS_t = 278,
+     ACTIONS_t = 279,
+     BIND_t = 280,
+     BREAK_t = 281,
+     CASE_t = 282,
+     CONTINUE_t = 283,
+     DEFAULT_t = 284,
+     ELSE_t = 285,
+     EXISTING_t = 286,
+     FOR_t = 287,
+     IF_t = 288,
+     IGNORE_t = 289,
+     IN_t = 290,
+     INCLUDE_t = 291,
+     LOCAL_t = 292,
+     MAXLINE_t = 293,
+     ON_t = 294,
+     PIECEMEAL_t = 295,
+     QUIETLY_t = 296,
+     RETURN_t = 297,
+     RULE_t = 298,
+     SWITCH_t = 299,
+     TOGETHER_t = 300,
+     UPDATED_t = 301,
+     WHILE_t = 302,
+     ARG = 303,
+     STRING = 304
+   };
+#endif
+#define _LANGLE_t 258
+#define _LANGLE_EQUALS_t 259
+#define _EQUALS_t 260
+#define _RANGLE_t 261
+#define _RANGLE_EQUALS_t 262
+#define _BAR_t 263
+#define _BARBAR_t 264
+#define _SEMIC_t 265
+#define _COLON_t 266
+#define _BANG_t 267
+#define _BANG_EQUALS_t 268
+#define _QUESTION_EQUALS_t 269
+#define _LPAREN_t 270
+#define _RPAREN_t 271
+#define _LBRACKET_t 272
+#define _RBRACKET_t 273
+#define _LBRACE_t 274
+#define _RBRACE_t 275
+#define _AMPER_t 276
+#define _AMPERAMPER_t 277
+#define _PLUS_EQUALS_t 278
+#define ACTIONS_t 279
+#define BIND_t 280
+#define BREAK_t 281
+#define CASE_t 282
+#define CONTINUE_t 283
+#define DEFAULT_t 284
+#define ELSE_t 285
+#define EXISTING_t 286
+#define FOR_t 287
+#define IF_t 288
+#define IGNORE_t 289
+#define IN_t 290
+#define INCLUDE_t 291
+#define LOCAL_t 292
+#define MAXLINE_t 293
+#define ON_t 294
+#define PIECEMEAL_t 295
+#define QUIETLY_t 296
+#define RETURN_t 297
+#define RULE_t 298
+#define SWITCH_t 299
+#define TOGETHER_t 300
+#define UPDATED_t 301
+#define WHILE_t 302
+#define ARG 303
+#define STRING 304
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 84 "jamgram.y"
+
 #include "jam.h"
 
 #include "lists.h"
@@ -56,877 +194,1614 @@
 # define pnode( l,r )    	parse_make( F0,l,r,P0,S0,S0,0 )
 # define psnode( s,l )     	parse_make( F0,l,P0,P0,s,S0,0 )
 
-#line 60 "y.tab.c"
-#define YYERRCODE 256
-#define _BANG_t 257
-#define _BANG_EQUALS_t 258
-#define _AMPER_t 259
-#define _AMPERAMPER_t 260
-#define _LPAREN_t 261
-#define _RPAREN_t 262
-#define _PLUS_EQUALS_t 263
-#define _COLON_t 264
-#define _SEMIC_t 265
-#define _LANGLE_t 266
-#define _LANGLE_EQUALS_t 267
-#define _EQUALS_t 268
-#define _RANGLE_t 269
-#define _RANGLE_EQUALS_t 270
-#define _QUESTION_EQUALS_t 271
-#define _LBRACKET_t 272
-#define _RBRACKET_t 273
-#define ACTIONS_t 274
-#define BIND_t 275
-#define BREAK_t 276
-#define CASE_t 277
-#define CONTINUE_t 278
-#define DEFAULT_t 279
-#define ELSE_t 280
-#define EXISTING_t 281
-#define FOR_t 282
-#define IF_t 283
-#define IGNORE_t 284
-#define IN_t 285
-#define INCLUDE_t 286
-#define LOCAL_t 287
-#define MAXLINE_t 288
-#define ON_t 289
-#define PIECEMEAL_t 290
-#define QUIETLY_t 291
-#define RETURN_t 292
-#define RULE_t 293
-#define SWITCH_t 294
-#define TOGETHER_t 295
-#define UPDATED_t 296
-#define WHILE_t 297
-#define _LBRACE_t 298
-#define _BAR_t 299
-#define _BARBAR_t 300
-#define _RBRACE_t 301
-#define ARG 302
-#define STRING 303
-const short yylhs[] = {                                        -1,
-    0,    0,    2,    2,    1,    1,    1,    1,    3,    3,
-    3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-    3,    3,    3,   13,   14,    3,    7,    7,    7,    7,
-    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
-    9,    9,    9,    9,    8,    8,   15,   10,   10,   10,
-    6,    6,    4,   16,   16,    5,   18,    5,   17,   17,
-   17,   11,   11,   19,   19,   19,   19,   19,   19,   19,
-   12,   12,
-};
-const short yylen[] = {                                         2,
-    0,    1,    0,    1,    1,    2,    4,    6,    3,    3,
-    3,    4,    6,    3,    3,    3,    7,    5,    5,    7,
-    5,    6,    3,    0,    0,    9,    1,    1,    1,    2,
-    1,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-    3,    3,    2,    3,    0,    2,    4,    0,    3,    1,
-    1,    3,    1,    0,    2,    1,    0,    4,    2,    4,
-    4,    0,    2,    1,    1,    1,    1,    1,    1,    2,
-    0,    2,
-};
-const short yydefred[] = {                                      0,
-   57,   62,   54,   54,    0,    0,   54,   54,    0,   54,
-    0,   54,    0,    0,   56,    0,    2,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    4,    0,    6,   28,
-   27,   29,    0,   54,    0,    0,   54,    0,   54,    0,
-   69,   66,    0,   68,   67,   65,   64,    0,   63,   14,
-   55,   15,   54,   43,    0,   54,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,   10,    0,   54,
-   23,   16,    0,    0,    0,    0,    9,   30,    0,   54,
-   11,    0,    0,   59,   58,   70,   54,    0,    0,   44,
-   42,    0,    0,    0,   34,   35,    0,   36,   37,    0,
-    0,    0,    7,    0,    0,    0,    0,    0,    0,    0,
-   54,   52,   12,   54,   54,   72,   24,    0,    0,    0,
-   49,    0,    0,   18,   46,   21,    0,   61,   60,    0,
-    0,    0,    8,   22,    0,   13,   25,   17,   20,   47,
-    0,   26,
-};
-const short yydgoto[] = {                                      16,
-   37,   38,   18,   45,   28,   46,   47,  118,   29,   84,
-   21,   98,  140,  151,  119,   23,   50,   20,   59,
-};
-const short yysindex[] = {                                    -40,
-    0,    0,    0,    0, -295, -233,    0,    0, -240,    0,
- -284,    0, -233,  -40,    0,    0,    0,  -40,   -7, -241,
-   49, -242, -240, -232, -239, -233, -233, -231,  -75, -220,
- -195,   34, -210, -243, -226,  -59,    0, -223,    0,    0,
-    0,    0, -174,    0, -165, -164,    0, -240,    0, -173,
-    0,    0, -199,    0,    0,    0,    0, -166,    0,    0,
-    0,    0,    0,    0, -154,    0, -233, -233, -233, -233,
- -233, -233, -233, -233,  -40, -233, -233,    0,  -40,    0,
-    0,    0, -153, -179, -157,  -40,    0,    0,  -42,    0,
-    0, -144, -185,    0,    0,    0,    0, -171, -170,    0,
-    0,  -54,   94,   94,    0,    0,  -54,    0,    0, -160,
-   88,   88,    0, -140, -243,  -40, -151, -139, -157, -134,
-    0,    0,    0,    0,    0,    0,    0,  -40, -149,  -40,
-    0, -131,  -93,    0,    0,    0,  -85,    0,    0, -121,
- -115,   34,    0,    0,  -40,    0,    0,    0,    0,    0,
- -105,    0,
-};
-const short yyrindex[] = {                                    197,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0, -103,    0,    0,    0,    3, -235,    0,
-    0,    0, -110,    0,    0,    0,    0,  -94,    0,    0,
-    0,    0,    0,  -96,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0, -246,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,  -95,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0, -103,    0,    0,    0,    4,    0,
-    0,    0,  -84,    0,  -79, -103,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0, -202, -224, -176,    0,    0,  -81,    0,    0,    0,
- -257, -209,    0,    0,  -96, -103,    0,    0,  -79,    0,
-    0,    0,    0,    0,    0,    0,    0, -103,    1,    4,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0, -237,    0,    0,    0,    0,    0,
-    0,    0,
-};
-const short yygindex[] = {                                      0,
-   26,  -65,  -32,    5,    2,  -43,  131,  108,   66,  113,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,
-};
-#define YYTABLESIZE 364
-const short yytable[] = {                                      81,
-   19,   19,    5,    3,   40,   94,   25,   22,   24,  110,
-   32,   30,   31,  113,   33,   19,   35,   34,   51,   19,
-  120,   49,   60,   26,   61,   17,   51,   27,   54,   54,
-    1,    1,   62,   19,   38,   38,   54,   38,    1,    3,
-   40,   40,   40,   39,   78,   63,  122,   48,   89,   93,
-  132,   92,   41,   66,   82,   33,   33,   33,   83,   33,
-   15,   15,  141,    3,  143,   33,   54,   99,   15,   79,
-  101,   85,   80,   38,   38,   38,   19,   87,   36,  150,
-   19,  139,   39,   39,  114,   39,    1,   19,   41,   41,
-   41,   64,   65,   88,  125,   33,   33,   33,   90,   95,
-   91,  126,   96,   67,   68,   69,  124,  100,   97,  149,
-  115,   70,   71,   72,   73,   74,   15,   19,  116,  117,
-  123,   39,   39,   39,  130,  137,  127,  128,  138,   19,
-  142,   19,  102,  103,  104,  105,  106,  107,  108,  109,
-  129,  111,  112,   19,   76,   77,   19,   53,   53,   53,
-  133,   53,   53,   53,   53,   53,   53,   53,   53,   53,
-   53,  134,   53,   31,   31,   31,  136,   31,   53,  144,
-  145,   31,   31,   31,   31,   31,   32,   32,   32,  146,
-   32,  147,   67,   68,   69,  148,   32,   53,   53,   53,
-   70,   71,   72,   73,   74,  152,    1,    3,   67,   68,
-   69,   48,   71,   31,   31,   31,   70,   71,   72,   73,
-   74,   70,   71,   50,   73,   74,   32,   32,   32,  121,
-   40,   45,   75,   76,   77,   41,  135,  131,   42,    0,
-    0,    1,    0,    2,    0,    3,   43,    4,   86,   76,
-   77,    5,    6,    0,    0,    7,    8,    0,    9,    0,
-    0,   10,   11,   12,    0,   40,   13,   14,    0,    0,
-   41,   15,    0,   42,    0,    0,    0,    0,    0,    0,
-    0,   43,   19,    0,   19,    0,   19,   19,   19,    5,
-    3,   44,   19,   19,    0,    0,   19,   19,    0,   19,
-    0,    0,   19,   19,   19,    0,    0,   19,   19,    0,
-    0,   19,   19,    5,    3,    1,    0,    2,    0,    3,
-    0,    4,    0,    0,    0,    5,    6,    0,    0,    7,
-    0,    0,    9,    0,    0,   10,   11,   12,    0,   51,
-   13,   14,   52,    0,    0,   15,   53,    0,   54,   55,
-    0,    0,    0,   56,   57,   67,   68,   69,    0,    0,
-   58,   67,    0,   70,   71,   72,   73,   74,    0,   70,
-   71,   72,   73,   74,
-};
-const short yycheck[] = {                                      32,
-    0,    0,    0,    0,  262,   49,  302,    3,    4,   75,
-    9,    7,    8,   79,   10,   14,   12,  302,  265,   18,
-   86,   20,  265,  257,   23,    0,  273,  261,  264,  265,
-  272,  272,  265,   32,  259,  260,  272,  262,  272,  277,
-  298,  299,  300,   18,  265,  285,   90,  289,   44,   48,
-  116,   47,  262,  285,  265,  258,  259,  260,  302,  262,
-  302,  302,  128,  301,  130,  268,  302,   63,  302,  265,
-   66,  298,  268,  298,  299,  300,   75,  301,   13,  145,
-   79,  125,  259,  260,   80,  262,  272,   86,  298,  299,
-  300,   26,   27,  268,   93,  298,  299,  300,  264,  273,
-  265,   97,  302,  258,  259,  260,  292,  262,  275,  142,
-  264,  266,  267,  268,  269,  270,  302,  116,  298,  277,
-  265,  298,  299,  300,  265,  121,  298,  298,  124,  128,
-  280,  130,   67,   68,   69,   70,   71,   72,   73,   74,
-  301,   76,   77,  142,  299,  300,  145,  258,  259,  260,
-  302,  262,  263,  264,  265,  266,  267,  268,  269,  270,
-  271,  301,  273,  258,  259,  260,  301,  262,  279,  301,
-  264,  266,  267,  268,  269,  270,  258,  259,  260,  265,
-  262,  303,  258,  259,  260,  301,  268,  298,  299,  300,
-  266,  267,  268,  269,  270,  301,    0,  301,  258,  259,
-  260,  298,  298,  298,  299,  300,  266,  267,  268,  269,
-  270,  266,  267,  298,  269,  270,  298,  299,  300,   89,
-  263,  301,  298,  299,  300,  268,  119,  115,  271,   -1,
-   -1,  272,   -1,  274,   -1,  276,  279,  278,  298,  299,
-  300,  282,  283,   -1,   -1,  286,  287,   -1,  289,   -1,
-   -1,  292,  293,  294,   -1,  263,  297,  298,   -1,   -1,
-  268,  302,   -1,  271,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,  279,  272,   -1,  274,   -1,  276,  277,  278,  277,
-  277,  289,  282,  283,   -1,   -1,  286,  287,   -1,  289,
-   -1,   -1,  292,  293,  294,   -1,   -1,  297,  298,   -1,
-   -1,  301,  302,  301,  301,  272,   -1,  274,   -1,  276,
-   -1,  278,   -1,   -1,   -1,  282,  283,   -1,   -1,  286,
-   -1,   -1,  289,   -1,   -1,  292,  293,  294,   -1,  281,
-  297,  298,  284,   -1,   -1,  302,  288,   -1,  290,  291,
-   -1,   -1,   -1,  295,  296,  258,  259,  260,   -1,   -1,
-  302,  258,   -1,  266,  267,  268,  269,  270,   -1,  266,
-  267,  268,  269,  270,
-};
-#define YYFINAL 16
+
+
+/* Enabling traces.  */
 #ifndef YYDEBUG
-#define YYDEBUG 0
+# define YYDEBUG 0
 #endif
-#define YYMAXTOKEN 303
-#if YYDEBUG
-const char * const yyname[] = {
-"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"_BANG_t","_BANG_EQUALS_t",
-"_AMPER_t","_AMPERAMPER_t","_LPAREN_t","_RPAREN_t","_PLUS_EQUALS_t","_COLON_t",
-"_SEMIC_t","_LANGLE_t","_LANGLE_EQUALS_t","_EQUALS_t","_RANGLE_t",
-"_RANGLE_EQUALS_t","_QUESTION_EQUALS_t","_LBRACKET_t","_RBRACKET_t","ACTIONS_t",
-"BIND_t","BREAK_t","CASE_t","CONTINUE_t","DEFAULT_t","ELSE_t","EXISTING_t",
-"FOR_t","IF_t","IGNORE_t","IN_t","INCLUDE_t","LOCAL_t","MAXLINE_t","ON_t",
-"PIECEMEAL_t","QUIETLY_t","RETURN_t","RULE_t","SWITCH_t","TOGETHER_t",
-"UPDATED_t","WHILE_t","_LBRACE_t","_BAR_t","_BARBAR_t","_RBRACE_t","ARG",
-"STRING",
-};
-const char * const yyrule[] = {
-"$accept : run",
-"run :",
-"run : rules",
-"block :",
-"block : rules",
-"rules : rule",
-"rules : rule rules",
-"rules : LOCAL_t list _SEMIC_t block",
-"rules : LOCAL_t list _EQUALS_t list _SEMIC_t block",
-"rule : _LBRACE_t block _RBRACE_t",
-"rule : INCLUDE_t list _SEMIC_t",
-"rule : arg lol _SEMIC_t",
-"rule : arg assign list _SEMIC_t",
-"rule : arg ON_t list assign list _SEMIC_t",
-"rule : BREAK_t list _SEMIC_t",
-"rule : CONTINUE_t list _SEMIC_t",
-"rule : RETURN_t list _SEMIC_t",
-"rule : FOR_t ARG IN_t list _LBRACE_t block _RBRACE_t",
-"rule : SWITCH_t list _LBRACE_t cases _RBRACE_t",
-"rule : IF_t expr _LBRACE_t block _RBRACE_t",
-"rule : IF_t expr _LBRACE_t block _RBRACE_t ELSE_t rule",
-"rule : WHILE_t expr _LBRACE_t block _RBRACE_t",
-"rule : RULE_t ARG params _LBRACE_t block _RBRACE_t",
-"rule : ON_t arg rule",
-"$$1 :",
-"$$2 :",
-"rule : ACTIONS_t eflags ARG bindlist _LBRACE_t $$1 STRING $$2 _RBRACE_t",
-"assign : _EQUALS_t",
-"assign : _PLUS_EQUALS_t",
-"assign : _QUESTION_EQUALS_t",
-"assign : DEFAULT_t _EQUALS_t",
-"expr : arg",
-"expr : expr _EQUALS_t expr",
-"expr : expr _BANG_EQUALS_t expr",
-"expr : expr _LANGLE_t expr",
-"expr : expr _LANGLE_EQUALS_t expr",
-"expr : expr _RANGLE_t expr",
-"expr : expr _RANGLE_EQUALS_t expr",
-"expr : expr _AMPER_t expr",
-"expr : expr _AMPERAMPER_t expr",
-"expr : expr _BAR_t expr",
-"expr : expr _BARBAR_t expr",
-"expr : arg IN_t list",
-"expr : _BANG_t expr",
-"expr : _LPAREN_t expr _RPAREN_t",
-"cases :",
-"cases : case cases",
-"case : CASE_t ARG _COLON_t block",
-"params :",
-"params : ARG _COLON_t params",
-"params : ARG",
-"lol : list",
-"lol : list _COLON_t lol",
-"list : listp",
-"listp :",
-"listp : listp arg",
-"arg : ARG",
-"$$3 :",
-"arg : _LBRACKET_t $$3 func _RBRACKET_t",
-"func : arg lol",
-"func : ON_t arg arg lol",
-"func : ON_t arg RETURN_t list",
-"eflags :",
-"eflags : eflags eflag",
-"eflag : UPDATED_t",
-"eflag : TOGETHER_t",
-"eflag : IGNORE_t",
-"eflag : QUIETLY_t",
-"eflag : PIECEMEAL_t",
-"eflag : EXISTING_t",
-"eflag : MAXLINE_t ARG",
-"bindlist :",
-"bindlist : BIND_t list",
-};
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
 #endif
-#ifndef YYSTYPE
+
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
 typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
 #endif
+
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 214 of yacc.c.  */
+#line 226 "y.tab.c"
+
+#if ! defined (yyoverflow) || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# if YYSTACK_USE_ALLOCA
+#  define YYSTACK_ALLOC alloca
+# else
+#  ifndef YYSTACK_USE_ALLOCA
+#   if defined (alloca) || defined (_ALLOCA_H)
+#    define YYSTACK_ALLOC alloca
+#   else
+#    ifdef __GNUC__
+#     define YYSTACK_ALLOC __builtin_alloca
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning. */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+# else
+#  if defined (__STDC__) || defined (__cplusplus)
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   define YYSIZE_T size_t
+#  endif
+#  define YYSTACK_ALLOC malloc
+#  define YYSTACK_FREE free
+# endif
+#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+
+
+#if (! defined (yyoverflow) \
+     && (! defined (__cplusplus) \
+	 || (YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  short yyss;
+  YYSTYPE yyvs;
+  };
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  register YYSIZE_T yyi;		\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (0)
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (0)
+
+#endif
+
+#if defined (__STDC__) || defined (__cplusplus)
+   typedef signed char yysigned_char;
+#else
+   typedef short yysigned_char;
+#endif
+
+/* YYFINAL -- State number of the termination state. */
+#define YYFINAL  39
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   250
+
+/* YYNTOKENS -- Number of terminals. */
+#define YYNTOKENS  50
+/* YYNNTS -- Number of nonterminals. */
+#define YYNNTS  21
+/* YYNRULES -- Number of rules. */
+#define YYNRULES  73
+/* YYNRULES -- Number of states. */
+#define YYNSTATES  154
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   304
+
+#define YYTRANSLATE(YYX) 						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const unsigned char yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49
+};
+
 #if YYDEBUG
-#include <stdio.h>
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const unsigned char yyprhs[] =
+{
+       0,     0,     3,     4,     6,     7,     9,    11,    14,    19,
+      26,    30,    34,    38,    43,    50,    54,    58,    62,    70,
+      76,    82,    90,    96,   103,   107,   108,   109,   119,   121,
+     123,   125,   128,   130,   134,   138,   142,   146,   150,   154,
+     158,   162,   166,   170,   174,   177,   181,   182,   185,   190,
+     191,   195,   197,   199,   203,   205,   206,   209,   211,   212,
+     217,   220,   225,   230,   231,   234,   236,   238,   240,   242,
+     244,   246,   249,   250
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS. */
+static const yysigned_char yyrhs[] =
+{
+      51,     0,    -1,    -1,    53,    -1,    -1,    53,    -1,    54,
+      -1,    54,    53,    -1,    37,    63,    10,    52,    -1,    37,
+      63,     5,    63,    10,    52,    -1,    19,    52,    20,    -1,
+      36,    63,    10,    -1,    65,    62,    10,    -1,    65,    57,
+      63,    10,    -1,    65,    39,    63,    57,    63,    10,    -1,
+      26,    63,    10,    -1,    28,    63,    10,    -1,    42,    63,
+      10,    -1,    32,    48,    35,    63,    19,    52,    20,    -1,
+      44,    63,    19,    59,    20,    -1,    33,    58,    19,    52,
+      20,    -1,    33,    58,    19,    52,    20,    30,    54,    -1,
+      47,    58,    19,    52,    20,    -1,    43,    48,    61,    19,
+      52,    20,    -1,    39,    65,    54,    -1,    -1,    -1,    24,
+      68,    48,    70,    19,    55,    49,    56,    20,    -1,     5,
+      -1,    23,    -1,    14,    -1,    29,     5,    -1,    65,    -1,
+      58,     5,    58,    -1,    58,    13,    58,    -1,    58,     3,
+      58,    -1,    58,     4,    58,    -1,    58,     6,    58,    -1,
+      58,     7,    58,    -1,    58,    21,    58,    -1,    58,    22,
+      58,    -1,    58,     8,    58,    -1,    58,     9,    58,    -1,
+      65,    35,    63,    -1,    12,    58,    -1,    15,    58,    16,
+      -1,    -1,    60,    59,    -1,    27,    48,    11,    52,    -1,
+      -1,    48,    11,    61,    -1,    48,    -1,    63,    -1,    63,
+      11,    62,    -1,    64,    -1,    -1,    64,    65,    -1,    48,
+      -1,    -1,    17,    66,    67,    18,    -1,    65,    62,    -1,
+      39,    65,    65,    62,    -1,    39,    65,    42,    63,    -1,
+      -1,    68,    69,    -1,    46,    -1,    45,    -1,    34,    -1,
+      41,    -1,    40,    -1,    31,    -1,    38,    48,    -1,    -1,
+      25,    63,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const unsigned short yyrline[] =
+{
+       0,   127,   127,   129,   141,   142,   146,   148,   150,   152,
+     156,   158,   160,   162,   164,   166,   168,   170,   172,   174,
+     176,   178,   180,   182,   184,   187,   189,   186,   198,   200,
+     202,   204,   212,   214,   216,   218,   220,   222,   224,   226,
+     228,   230,   232,   234,   236,   238,   249,   250,   254,   264,
+     265,   267,   276,   278,   288,   293,   294,   298,   300,   300,
+     309,   311,   313,   323,   324,   328,   330,   332,   334,   336,
+     338,   340,   350,   351
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE
+/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "_LANGLE_t", "_LANGLE_EQUALS_t", 
+  "_EQUALS_t", "_RANGLE_t", "_RANGLE_EQUALS_t", "_BAR_t", "_BARBAR_t", 
+  "_SEMIC_t", "_COLON_t", "_BANG_t", "_BANG_EQUALS_t", 
+  "_QUESTION_EQUALS_t", "_LPAREN_t", "_RPAREN_t", "_LBRACKET_t", 
+  "_RBRACKET_t", "_LBRACE_t", "_RBRACE_t", "_AMPER_t", "_AMPERAMPER_t", 
+  "_PLUS_EQUALS_t", "ACTIONS_t", "BIND_t", "BREAK_t", "CASE_t", 
+  "CONTINUE_t", "DEFAULT_t", "ELSE_t", "EXISTING_t", "FOR_t", "IF_t", 
+  "IGNORE_t", "IN_t", "INCLUDE_t", "LOCAL_t", "MAXLINE_t", "ON_t", 
+  "PIECEMEAL_t", "QUIETLY_t", "RETURN_t", "RULE_t", "SWITCH_t", 
+  "TOGETHER_t", "UPDATED_t", "WHILE_t", "ARG", "STRING", "$accept", "run", 
+  "block", "rules", "rule", "@1", "@2", "assign", "expr", "cases", "case", 
+  "params", "lol", "list", "listp", "arg", "@3", "func", "eflags", 
+  "eflag", "bindlist", 0
+};
 #endif
-#ifdef YYSTACKSIZE
-#undef YYMAXDEPTH
-#define YYMAXDEPTH YYSTACKSIZE
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const unsigned short yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   304
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const unsigned char yyr1[] =
+{
+       0,    50,    51,    51,    52,    52,    53,    53,    53,    53,
+      54,    54,    54,    54,    54,    54,    54,    54,    54,    54,
+      54,    54,    54,    54,    54,    55,    56,    54,    57,    57,
+      57,    57,    58,    58,    58,    58,    58,    58,    58,    58,
+      58,    58,    58,    58,    58,    58,    59,    59,    60,    61,
+      61,    61,    62,    62,    63,    64,    64,    65,    66,    65,
+      67,    67,    67,    68,    68,    69,    69,    69,    69,    69,
+      69,    69,    70,    70
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const unsigned char yyr2[] =
+{
+       0,     2,     0,     1,     0,     1,     1,     2,     4,     6,
+       3,     3,     3,     4,     6,     3,     3,     3,     7,     5,
+       5,     7,     5,     6,     3,     0,     0,     9,     1,     1,
+       1,     2,     1,     3,     3,     3,     3,     3,     3,     3,
+       3,     3,     3,     3,     2,     3,     0,     2,     4,     0,
+       3,     1,     1,     3,     1,     0,     2,     1,     0,     4,
+       2,     4,     4,     0,     2,     1,     1,     1,     1,     1,
+       1,     2,     0,     2
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const unsigned char yydefact[] =
+{
+       2,    58,     4,    63,    55,    55,     0,     0,    55,    55,
+       0,    55,     0,    55,     0,    57,     0,     3,     6,    55,
+       0,     0,     5,     0,     0,    54,     0,     0,     0,     0,
+       0,    32,     0,     0,     0,     0,    49,     0,     0,     1,
+       7,    28,    30,    29,     0,    55,    55,     0,    52,     0,
+      55,     0,    10,    70,    67,     0,    69,    68,    66,    65,
+      72,    64,    15,    56,    16,    55,    44,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     4,     0,     0,    55,
+      11,    55,     4,    24,    17,    51,     0,    46,     4,    31,
+       0,     0,    12,    55,     0,    60,    59,    71,    55,     0,
+       0,    45,    35,    36,    33,    37,    38,    41,    42,    34,
+       0,    39,    40,    43,     0,     8,    49,     4,     0,     0,
+      46,     0,    55,    13,    53,    55,    55,    73,    25,     4,
+      20,     4,    50,     0,     0,    19,    47,    22,     0,    62,
+      61,     0,     0,     0,     9,    23,     4,    14,    26,    18,
+      21,    48,     0,    27
+};
+
+/* YYDEFGOTO[NTERM-NUM]. */
+static const short yydefgoto[] =
+{
+      -1,    16,    21,    22,    18,   141,   152,    46,    30,   119,
+     120,    86,    47,    48,    25,    31,    20,    51,    23,    61,
+      99
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -48
+static const short yypact[] =
+{
+     130,   -48,   130,   -48,   -48,   -48,   -43,    -8,   -48,   -48,
+       7,   -48,   -17,   -48,    -8,   -48,    15,   -48,   130,     9,
+     -11,    23,   -48,   151,    31,     7,    35,    12,    -8,    -8,
+      53,    16,    42,    17,   162,    59,    22,    44,   208,   -48,
+     -48,   -48,   -48,   -48,    72,   -48,   -48,    68,    69,     7,
+     -48,    66,   -48,   -48,   -48,    38,   -48,   -48,   -48,   -48,
+      65,   -48,   -48,   -48,   -48,   -48,   -48,   228,    -8,    -8,
+      -8,    -8,    -8,    -8,    -8,    -8,   130,    -8,    -8,   -48,
+     -48,   -48,   130,   -48,   -48,    80,    73,    70,   130,   -48,
+      21,    83,   -48,   -48,    -9,   -48,   -48,   -48,   -48,    79,
+      88,   -48,   -48,   -48,    61,   -48,   -48,    98,    98,    61,
+      89,   109,   109,   -48,   108,   -48,    22,   130,    51,   101,
+      70,   103,   -48,   -48,   -48,   -48,   -48,   -48,   -48,   130,
+      78,   130,   -48,   104,   114,   -48,   -48,   -48,   116,   -48,
+     -48,    85,   107,   162,   -48,   -48,   130,   -48,   -48,   -48,
+     -48,   -48,   112,   -48
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yysigned_char yypgoto[] =
+{
+     -48,   -48,   -46,    11,   -33,   -48,   -48,    58,    67,    30,
+     -48,    36,   -47,     8,   -48,     0,   -48,   -48,   -48,   -48,
+     -48
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -1
+static const unsigned char yytable[] =
+{
+      19,    83,    19,    95,    28,    27,     1,    29,     1,     1,
+      34,    17,    24,    26,    41,    39,    32,    33,    19,    35,
+      50,    37,    81,    42,     1,    63,    41,    82,    49,    40,
+     110,    36,    43,   125,    19,    42,   115,    15,    44,    15,
+      15,    62,   121,    52,    43,    64,   124,    65,    45,    94,
+      44,    79,    80,    90,    91,    15,    68,    69,    70,    71,
+      72,    73,    74,    87,    68,    69,    75,    71,    72,    84,
+      85,   133,    76,   100,    77,    78,    19,    89,    92,   140,
+      93,    38,    19,   142,    96,   144,    97,   113,    19,   114,
+      98,   116,   117,   123,   126,    66,    67,   118,   128,   134,
+     151,    68,    69,    70,    71,    72,   127,   129,   143,   130,
+     150,    75,    68,    69,    70,    71,    72,    19,   131,    77,
+      78,   135,    75,   137,   145,   146,   147,   149,     0,    19,
+     138,    19,   153,   139,   148,   102,   103,   104,   105,   106,
+     107,   108,   109,    19,   111,   112,    19,     1,   122,     2,
+     136,     0,   132,     0,     3,     0,     4,     0,     5,     0,
+       0,     0,     6,     7,     0,     0,     8,     9,     0,    10,
+       0,     0,    11,    12,    13,     0,     0,    14,    15,     1,
+       0,     2,    53,     0,     0,    54,     3,     0,     4,    55,
+       5,    56,    57,     0,     6,     7,    58,    59,     8,    60,
+       0,    10,     0,     0,    11,    12,    13,     0,     0,    14,
+      15,    68,    69,    70,    71,    72,    73,    74,     0,     0,
+       0,    75,     0,     0,     0,     0,     0,    88,     0,    77,
+      78,    68,    69,    70,    71,    72,    73,    74,     0,     0,
+       0,    75,     0,     0,   101,     0,     0,     0,     0,    77,
+      78
+};
+
+static const short yycheck[] =
+{
+       0,    34,     2,    50,    12,    48,    17,    15,    17,    17,
+      10,     0,     4,     5,     5,     0,     8,     9,    18,    11,
+      20,    13,     5,    14,    17,    25,     5,    10,    39,    18,
+      76,    48,    23,    42,    34,    14,    82,    48,    29,    48,
+      48,    10,    88,    20,    23,    10,    93,    35,    39,    49,
+      29,    35,    10,    45,    46,    48,     3,     4,     5,     6,
+       7,     8,     9,    19,     3,     4,    13,     6,     7,    10,
+      48,   117,    19,    65,    21,    22,    76,     5,    10,   126,
+      11,    14,    82,   129,    18,   131,    48,    79,    88,    81,
+      25,    11,    19,    10,    94,    28,    29,    27,    19,    48,
+     146,     3,     4,     5,     6,     7,    98,    19,    30,    20,
+     143,    13,     3,     4,     5,     6,     7,   117,    10,    21,
+      22,    20,    13,    20,    20,    11,    10,    20,    -1,   129,
+     122,   131,    20,   125,    49,    68,    69,    70,    71,    72,
+      73,    74,    75,   143,    77,    78,   146,    17,    90,    19,
+     120,    -1,   116,    -1,    24,    -1,    26,    -1,    28,    -1,
+      -1,    -1,    32,    33,    -1,    -1,    36,    37,    -1,    39,
+      -1,    -1,    42,    43,    44,    -1,    -1,    47,    48,    17,
+      -1,    19,    31,    -1,    -1,    34,    24,    -1,    26,    38,
+      28,    40,    41,    -1,    32,    33,    45,    46,    36,    48,
+      -1,    39,    -1,    -1,    42,    43,    44,    -1,    -1,    47,
+      48,     3,     4,     5,     6,     7,     8,     9,    -1,    -1,
+      -1,    13,    -1,    -1,    -1,    -1,    -1,    19,    -1,    21,
+      22,     3,     4,     5,     6,     7,     8,     9,    -1,    -1,
+      -1,    13,    -1,    -1,    16,    -1,    -1,    -1,    -1,    21,
+      22
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const unsigned char yystos[] =
+{
+       0,    17,    19,    24,    26,    28,    32,    33,    36,    37,
+      39,    42,    43,    44,    47,    48,    51,    53,    54,    65,
+      66,    52,    53,    68,    63,    64,    63,    48,    12,    15,
+      58,    65,    63,    63,    65,    63,    48,    63,    58,     0,
+      53,     5,    14,    23,    29,    39,    57,    62,    63,    39,
+      65,    67,    20,    31,    34,    38,    40,    41,    45,    46,
+      48,    69,    10,    65,    10,    35,    58,    58,     3,     4,
+       5,     6,     7,     8,     9,    13,    19,    21,    22,    35,
+      10,     5,    10,    54,    10,    48,    61,    19,    19,     5,
+      63,    63,    10,    11,    65,    62,    18,    48,    25,    70,
+      63,    16,    58,    58,    58,    58,    58,    58,    58,    58,
+      52,    58,    58,    63,    63,    52,    11,    19,    27,    59,
+      60,    52,    57,    10,    62,    42,    65,    63,    19,    19,
+      20,    10,    61,    52,    48,    20,    59,    20,    63,    63,
+      62,    55,    52,    30,    52,    20,    11,    10,    49,    20,
+      54,    52,    56,    20
+};
+
+#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
+# define YYSIZE_T __SIZE_TYPE__
+#endif
+#if ! defined (YYSIZE_T) && defined (size_t)
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T)
+# if defined (__STDC__) || defined (__cplusplus)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# endif
+#endif
+#if ! defined (YYSIZE_T)
+# define YYSIZE_T unsigned int
+#endif
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrlab1
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    { 								\
+      yyerror ("syntax error: cannot back up");\
+      YYERROR;							\
+    }								\
+while (0)
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+/* YYLLOC_DEFAULT -- Compute the default location (before the actions
+   are run).  */
+
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)         \
+  Current.first_line   = Rhs[1].first_line;      \
+  Current.first_column = Rhs[1].first_column;    \
+  Current.last_line    = Rhs[N].last_line;       \
+  Current.last_column  = Rhs[N].last_column;
+#endif
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
 #else
-#ifdef YYMAXDEPTH
-#define YYSTACKSIZE YYMAXDEPTH
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (0)
+
+# define YYDSYMPRINT(Args)			\
+do {						\
+  if (yydebug)					\
+    yysymprint Args;				\
+} while (0)
+
+# define YYDSYMPRINTF(Title, Token, Value, Location)		\
+do {								\
+  if (yydebug)							\
+    {								\
+      YYFPRINTF (stderr, "%s ", Title);				\
+      yysymprint (stderr, 					\
+                  Token, Value);	\
+      YYFPRINTF (stderr, "\n");					\
+    }								\
+} while (0)
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (cinluded).                                                   |
+`------------------------------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yy_stack_print (short *bottom, short *top)
 #else
-#define YYSTACKSIZE 10000
-#define YYMAXDEPTH 10000
+static void
+yy_stack_print (bottom, top)
+    short *bottom;
+    short *top;
 #endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (/* Nothing. */; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yy_reduce_print (int yyrule)
+#else
+static void
+yy_reduce_print (yyrule)
+    int yyrule;
 #endif
-#define YYINITSTACKSIZE 200
+{
+  int yyi;
+  unsigned int yylineno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
+             yyrule - 1, yylineno);
+  /* Print the symbols being reduced, and their result.  */
+  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
+    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
+  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (Rule);		\
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
 int yydebug;
-int yynerrs;
-int yyerrflag;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YYDSYMPRINT(Args)
+# define YYDSYMPRINTF(Title, Token, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#if YYMAXDEPTH == 0
+# undef YYMAXDEPTH
+#endif
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined (__GLIBC__) && defined (_STRING_H)
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+#   if defined (__STDC__) || defined (__cplusplus)
+yystrlen (const char *yystr)
+#   else
+yystrlen (yystr)
+     const char *yystr;
+#   endif
+{
+  register const char *yys = yystr;
+
+  while (*yys++ != '\0')
+    continue;
+
+  return yys - yystr - 1;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+#   if defined (__STDC__) || defined (__cplusplus)
+yystpcpy (char *yydest, const char *yysrc)
+#   else
+yystpcpy (yydest, yysrc)
+     char *yydest;
+     const char *yysrc;
+#   endif
+{
+  register char *yyd = yydest;
+  register const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+#endif /* !YYERROR_VERBOSE */
+
+
+
+#if YYDEBUG
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yysymprint (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
+
+  if (yytype < YYNTOKENS)
+    {
+      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+# ifdef YYPRINT
+      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+    }
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  switch (yytype)
+    {
+      default:
+        break;
+    }
+  YYFPRINTF (yyoutput, ")");
+}
+
+#endif /* ! YYDEBUG */
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yydestruct (int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yytype, yyvaluep)
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
+
+  switch (yytype)
+    {
+
+      default:
+        break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+
+#ifdef YYPARSE_PARAM
+# if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void *YYPARSE_PARAM);
+# else
+int yyparse ();
+# endif
+#else /* ! YYPARSE_PARAM */
+#if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+
+/* The lookahead symbol.  */
 int yychar;
-short *yyssp;
-YYSTYPE *yyvsp;
-YYSTYPE yyval;
+
+/* The semantic value of the lookahead symbol.  */
 YYSTYPE yylval;
-short *yyss;
-short *yysslim;
-YYSTYPE *yyvs;
-int yystacksize;
-/* allocate initial stack or double stack size, up to YYMAXDEPTH */
-static int yygrowstack()
-{
-    int newsize, i;
-    short *newss;
-    YYSTYPE *newvs;
-
-    if ((newsize = yystacksize) == 0)
-        newsize = YYINITSTACKSIZE;
-    else if (newsize >= YYMAXDEPTH)
-        return -1;
-    else if ((newsize *= 2) > YYMAXDEPTH)
-        newsize = YYMAXDEPTH;
-    i = yyssp - yyss;
-    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :
-      (short *)malloc(newsize * sizeof *newss);
-    if (newss == NULL)
-        return -1;
-    yyss = newss;
-    yyssp = newss + i;
-    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :
-      (YYSTYPE *)malloc(newsize * sizeof *newvs);
-    if (newvs == NULL)
-        return -1;
-    yyvs = newvs;
-    yyvsp = newvs + i;
-    yystacksize = newsize;
-    yysslim = yyss + newsize - 1;
-    return 0;
-}
 
-#define YYABORT goto yyabort
-#define YYREJECT goto yyabort
-#define YYACCEPT goto yyaccept
-#define YYERROR goto yyerrlab
-
-#ifndef YYPARSE_PARAM
-#if defined(__cplusplus) || __STDC__
-#define YYPARSE_PARAM_ARG void
-#define YYPARSE_PARAM_DECL
-#else	/* ! ANSI-C/C++ */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif	/* ANSI-C/C++ */
-#else	/* YYPARSE_PARAM */
-#ifndef YYPARSE_PARAM_TYPE
-#define YYPARSE_PARAM_TYPE void *
-#endif
-#if defined(__cplusplus) || __STDC__
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else	/* ! ANSI-C/C++ */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
-#endif	/* ANSI-C/C++ */
-#endif	/* ! YYPARSE_PARAM */
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
 
+#ifdef YYPARSE_PARAM
+# if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void *YYPARSE_PARAM)
+# else
+int yyparse (YYPARSE_PARAM)
+  void *YYPARSE_PARAM;
+# endif
+#else /* ! YYPARSE_PARAM */
+#if defined (__STDC__) || defined (__cplusplus)
 int
-yyparse (YYPARSE_PARAM_ARG)
-    YYPARSE_PARAM_DECL
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
 {
-    register int yym, yyn, yystate;
-#if YYDEBUG
-    register const char *yys;
+  
+  register int yystate;
+  register int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  short	yyssa[YYINITDEPTH];
+  short *yyss = yyssa;
+  register short *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  register YYSTYPE *yyvsp;
+
+
+
+#define YYPOPSTACK   (yyvsp--, yyssp--)
 
-    if ((yys = getenv("YYDEBUG")))
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
+  /* When reducing, the number of symbols on the RHS of the reduced
+     rule.  */
+  int yylen;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed. so pushing a state here evens the stacks.
+     */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
     {
-        yyn = *yys;
-        if (yyn >= '0' && yyn <= '9')
-            yydebug = yyn - '0';
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack. Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	short *yyss1 = yyss;
+
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow ("parser stack overflow",
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyoverflowlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyoverflowlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	short *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyoverflowlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
     }
-#endif
 
-    yynerrs = 0;
-    yyerrflag = 0;
-    yychar = (-1);
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a lookahead token if we need one and don't already have one.  */
+/* yyresume: */
 
-    if (yyss == NULL && yygrowstack()) goto yyoverflow;
-    yyssp = yyss;
-    yyvsp = yyvs;
-    *yyssp = yystate = 0;
+  /* First try to decide what to do without reference to lookahead token.  */
 
-yyloop:
-    if ((yyn = yydefred[yystate])) goto yyreduce;
-    if (yychar < 0)
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
     {
-        if ((yychar = yylex()) < 0) yychar = 0;
-#if YYDEBUG
-        if (yydebug)
-        {
-            yys = 0;
-            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-            if (!yys) yys = "illegal-symbol";
-            printf("%sdebug: state %d, reading %d (%s)\n",
-                    YYPREFIX, yystate, yychar, yys);
-        }
-#endif
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
     }
-    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
+
+  if (yychar <= YYEOF)
     {
-#if YYDEBUG
-        if (yydebug)
-            printf("%sdebug: state %d, shifting to state %d\n",
-                    YYPREFIX, yystate, yytable[yyn]);
-#endif
-        if (yyssp >= yysslim && yygrowstack())
-        {
-            goto yyoverflow;
-        }
-        *++yyssp = yystate = yytable[yyn];
-        *++yyvsp = yylval;
-        yychar = (-1);
-        if (yyerrflag > 0)  --yyerrflag;
-        goto yyloop;
-    }
-    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
-    {
-        yyn = yytable[yyn];
-        goto yyreduce;
-    }
-    if (yyerrflag) goto yyinrecovery;
-#if defined(lint) || defined(__GNUC__)
-    goto yynewerror;
-#endif
-yynewerror:
-    yyerror("syntax error");
-#if defined(lint) || defined(__GNUC__)
-    goto yyerrlab;
-#endif
-yyerrlab:
-    ++yynerrs;
-yyinrecovery:
-    if (yyerrflag < 3)
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
     {
-        yyerrflag = 3;
-        for (;;)
-        {
-            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
-                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
-            {
-#if YYDEBUG
-                if (yydebug)
-                    printf("%sdebug: state %d, error recovery shifting\
- to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
-#endif
-                if (yyssp >= yysslim && yygrowstack())
-                {
-                    goto yyoverflow;
-                }
-                *++yyssp = yystate = yytable[yyn];
-                *++yyvsp = yylval;
-                goto yyloop;
-            }
-            else
-            {
-#if YYDEBUG
-                if (yydebug)
-                    printf("%sdebug: error recovery discarding state %d\n",
-                            YYPREFIX, *yyssp);
-#endif
-                if (yyssp <= yyss) goto yyabort;
-                --yyssp;
-                --yyvsp;
-            }
-        }
+      yytoken = YYTRANSLATE (yychar);
+      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
     }
-    else
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
     {
-        if (yychar == 0) goto yyabort;
-#if YYDEBUG
-        if (yydebug)
-        {
-            yys = 0;
-            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-            if (!yys) yys = "illegal-symbol";
-            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
-                    YYPREFIX, yystate, yychar, yys);
-        }
-#endif
-        yychar = (-1);
-        goto yyloop;
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
     }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the lookahead token.  */
+  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  *++yyvsp = yylval;
+
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
 yyreduce:
-#if YYDEBUG
-    if (yydebug)
-        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
-                YYPREFIX, yystate, yyn, yyrule[yyn]);
-#endif
-    yym = yylen[yyn];
-    yyval = yyvsp[1-yym];
-    switch (yyn)
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
     {
-case 2:
+        case 3:
 #line 130 "jamgram.y"
-{ parse_save( yyvsp[0].parse ); }
-break;
-case 3:
+    { parse_save( yyvsp[0].parse ); }
+    break;
+
+  case 4:
 #line 141 "jamgram.y"
-{ yyval.parse = pnull(); }
-break;
-case 4:
+    { yyval.parse = pnull(); }
+    break;
+
+  case 5:
 #line 143 "jamgram.y"
-{ yyval.parse = yyvsp[0].parse; }
-break;
-case 5:
+    { yyval.parse = yyvsp[0].parse; }
+    break;
+
+  case 6:
 #line 147 "jamgram.y"
-{ yyval.parse = yyvsp[0].parse; }
-break;
-case 6:
+    { yyval.parse = yyvsp[0].parse; }
+    break;
+
+  case 7:
 #line 149 "jamgram.y"
-{ yyval.parse = prules( yyvsp[-1].parse, yyvsp[0].parse ); }
-break;
-case 7:
+    { yyval.parse = prules( yyvsp[-1].parse, yyvsp[0].parse ); }
+    break;
+
+  case 8:
 #line 151 "jamgram.y"
-{ yyval.parse = plocal( yyvsp[-2].parse, pnull(), yyvsp[0].parse ); }
-break;
-case 8:
+    { yyval.parse = plocal( yyvsp[-2].parse, pnull(), yyvsp[0].parse ); }
+    break;
+
+  case 9:
 #line 153 "jamgram.y"
-{ yyval.parse = plocal( yyvsp[-4].parse, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 9:
+    { yyval.parse = plocal( yyvsp[-4].parse, yyvsp[-2].parse, yyvsp[0].parse ); }
+    break;
+
+  case 10:
 #line 157 "jamgram.y"
-{ yyval.parse = yyvsp[-1].parse; }
-break;
-case 10:
+    { yyval.parse = yyvsp[-1].parse; }
+    break;
+
+  case 11:
 #line 159 "jamgram.y"
-{ yyval.parse = pincl( yyvsp[-1].parse ); }
-break;
-case 11:
+    { yyval.parse = pincl( yyvsp[-1].parse ); }
+    break;
+
+  case 12:
 #line 161 "jamgram.y"
-{ yyval.parse = prule( yyvsp[-2].parse, yyvsp[-1].parse ); }
-break;
-case 12:
+    { yyval.parse = prule( yyvsp[-2].parse, yyvsp[-1].parse ); }
+    break;
+
+  case 13:
 #line 163 "jamgram.y"
-{ yyval.parse = pset( yyvsp[-3].parse, yyvsp[-1].parse, yyvsp[-2].number ); }
-break;
-case 13:
+    { yyval.parse = pset( yyvsp[-3].parse, yyvsp[-1].parse, yyvsp[-2].number ); }
+    break;
+
+  case 14:
 #line 165 "jamgram.y"
-{ yyval.parse = pset1( yyvsp[-5].parse, yyvsp[-3].parse, yyvsp[-1].parse, yyvsp[-2].number ); }
-break;
-case 14:
+    { yyval.parse = pset1( yyvsp[-5].parse, yyvsp[-3].parse, yyvsp[-1].parse, yyvsp[-2].number ); }
+    break;
+
+  case 15:
 #line 167 "jamgram.y"
-{ yyval.parse = pbreak( yyvsp[-1].parse, JMP_BREAK ); }
-break;
-case 15:
+    { yyval.parse = pbreak( yyvsp[-1].parse, JMP_BREAK ); }
+    break;
+
+  case 16:
 #line 169 "jamgram.y"
-{ yyval.parse = pbreak( yyvsp[-1].parse, JMP_CONTINUE ); }
-break;
-case 16:
+    { yyval.parse = pbreak( yyvsp[-1].parse, JMP_CONTINUE ); }
+    break;
+
+  case 17:
 #line 171 "jamgram.y"
-{ yyval.parse = pbreak( yyvsp[-1].parse, JMP_RETURN ); }
-break;
-case 17:
+    { yyval.parse = pbreak( yyvsp[-1].parse, JMP_RETURN ); }
+    break;
+
+  case 18:
 #line 173 "jamgram.y"
-{ yyval.parse = pfor( yyvsp[-5].string, yyvsp[-3].parse, yyvsp[-1].parse ); }
-break;
-case 18:
+    { yyval.parse = pfor( yyvsp[-5].string, yyvsp[-3].parse, yyvsp[-1].parse ); }
+    break;
+
+  case 19:
 #line 175 "jamgram.y"
-{ yyval.parse = pswitch( yyvsp[-3].parse, yyvsp[-1].parse ); }
-break;
-case 19:
+    { yyval.parse = pswitch( yyvsp[-3].parse, yyvsp[-1].parse ); }
+    break;
+
+  case 20:
 #line 177 "jamgram.y"
-{ yyval.parse = pif( yyvsp[-3].parse, yyvsp[-1].parse, pnull() ); }
-break;
-case 20:
+    { yyval.parse = pif( yyvsp[-3].parse, yyvsp[-1].parse, pnull() ); }
+    break;
+
+  case 21:
 #line 179 "jamgram.y"
-{ yyval.parse = pif( yyvsp[-5].parse, yyvsp[-3].parse, yyvsp[0].parse ); }
-break;
-case 21:
+    { yyval.parse = pif( yyvsp[-5].parse, yyvsp[-3].parse, yyvsp[0].parse ); }
+    break;
+
+  case 22:
 #line 181 "jamgram.y"
-{ yyval.parse = pwhile( yyvsp[-3].parse, yyvsp[-1].parse ); }
-break;
-case 22:
+    { yyval.parse = pwhile( yyvsp[-3].parse, yyvsp[-1].parse ); }
+    break;
+
+  case 23:
 #line 183 "jamgram.y"
-{ yyval.parse = psetc( yyvsp[-4].string, yyvsp[-3].parse, yyvsp[-1].parse ); }
-break;
-case 23:
+    { yyval.parse = psetc( yyvsp[-4].string, yyvsp[-3].parse, yyvsp[-1].parse ); }
+    break;
+
+  case 24:
 #line 185 "jamgram.y"
-{ yyval.parse = pon( yyvsp[-1].parse, yyvsp[0].parse ); }
-break;
-case 24:
+    { yyval.parse = pon( yyvsp[-1].parse, yyvsp[0].parse ); }
+    break;
+
+  case 25:
 #line 187 "jamgram.y"
-{ yymode( SCAN_STRING ); }
-break;
-case 25:
+    { yymode( SCAN_STRING ); }
+    break;
+
+  case 26:
 #line 189 "jamgram.y"
-{ yymode( SCAN_NORMAL ); }
-break;
-case 26:
+    { yymode( SCAN_NORMAL ); }
+    break;
+
+  case 27:
 #line 191 "jamgram.y"
-{ yyval.parse = psete( yyvsp[-6].string,yyvsp[-5].parse,yyvsp[-2].string,yyvsp[-7].number ); }
-break;
-case 27:
+    { yyval.parse = psete( yyvsp[-6].string,yyvsp[-5].parse,yyvsp[-2].string,yyvsp[-7].number ); }
+    break;
+
+  case 28:
 #line 199 "jamgram.y"
-{ yyval.number = VAR_SET; }
-break;
-case 28:
+    { yyval.number = VAR_SET; }
+    break;
+
+  case 29:
 #line 201 "jamgram.y"
-{ yyval.number = VAR_APPEND; }
-break;
-case 29:
+    { yyval.number = VAR_APPEND; }
+    break;
+
+  case 30:
 #line 203 "jamgram.y"
-{ yyval.number = VAR_DEFAULT; }
-break;
-case 30:
+    { yyval.number = VAR_DEFAULT; }
+    break;
+
+  case 31:
 #line 205 "jamgram.y"
-{ yyval.number = VAR_DEFAULT; }
-break;
-case 31:
+    { yyval.number = VAR_DEFAULT; }
+    break;
+
+  case 32:
 #line 213 "jamgram.y"
-{ yyval.parse = peval( EXPR_EXISTS, yyvsp[0].parse, pnull() ); }
-break;
-case 32:
+    { yyval.parse = peval( EXPR_EXISTS, yyvsp[0].parse, pnull() ); }
+    break;
+
+  case 33:
 #line 215 "jamgram.y"
-{ yyval.parse = peval( EXPR_EQUALS, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 33:
+    { yyval.parse = peval( EXPR_EQUALS, yyvsp[-2].parse, yyvsp[0].parse ); }
+    break;
+
+  case 34:
 #line 217 "jamgram.y"
-{ yyval.parse = peval( EXPR_NOTEQ, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 34:
+    { yyval.parse = peval( EXPR_NOTEQ, yyvsp[-2].parse, yyvsp[0].parse ); }
+    break;
+
+  case 35:
 #line 219 "jamgram.y"
-{ yyval.parse = peval( EXPR_LESS, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 35:
+    { yyval.parse = peval( EXPR_LESS, yyvsp[-2].parse, yyvsp[0].parse ); }
+    break;
+
+  case 36:
 #line 221 "jamgram.y"
-{ yyval.parse = peval( EXPR_LESSEQ, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 36:
+    { yyval.parse = peval( EXPR_LESSEQ, yyvsp[-2].parse, yyvsp[0].parse ); }
+    break;
+
+  case 37:
 #line 223 "jamgram.y"
-{ yyval.parse = peval( EXPR_MORE, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 37:
+    { yyval.parse = peval( EXPR_MORE, yyvsp[-2].parse, yyvsp[0].parse ); }
+    break;
+
+  case 38:
 #line 225 "jamgram.y"
-{ yyval.parse = peval( EXPR_MOREEQ, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 38:
+    { yyval.parse = peval( EXPR_MOREEQ, yyvsp[-2].parse, yyvsp[0].parse ); }
+    break;
+
+  case 39:
 #line 227 "jamgram.y"
-{ yyval.parse = peval( EXPR_AND, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 39:
+    { yyval.parse = peval( EXPR_AND, yyvsp[-2].parse, yyvsp[0].parse ); }
+    break;
+
+  case 40:
 #line 229 "jamgram.y"
-{ yyval.parse = peval( EXPR_AND, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 40:
+    { yyval.parse = peval( EXPR_AND, yyvsp[-2].parse, yyvsp[0].parse ); }
+    break;
+
+  case 41:
 #line 231 "jamgram.y"
-{ yyval.parse = peval( EXPR_OR, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 41:
+    { yyval.parse = peval( EXPR_OR, yyvsp[-2].parse, yyvsp[0].parse ); }
+    break;
+
+  case 42:
 #line 233 "jamgram.y"
-{ yyval.parse = peval( EXPR_OR, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 42:
+    { yyval.parse = peval( EXPR_OR, yyvsp[-2].parse, yyvsp[0].parse ); }
+    break;
+
+  case 43:
 #line 235 "jamgram.y"
-{ yyval.parse = peval( EXPR_IN, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 43:
+    { yyval.parse = peval( EXPR_IN, yyvsp[-2].parse, yyvsp[0].parse ); }
+    break;
+
+  case 44:
 #line 237 "jamgram.y"
-{ yyval.parse = peval( EXPR_NOT, yyvsp[0].parse, pnull() ); }
-break;
-case 44:
+    { yyval.parse = peval( EXPR_NOT, yyvsp[0].parse, pnull() ); }
+    break;
+
+  case 45:
 #line 239 "jamgram.y"
-{ yyval.parse = yyvsp[-1].parse; }
-break;
-case 45:
+    { yyval.parse = yyvsp[-1].parse; }
+    break;
+
+  case 46:
 #line 249 "jamgram.y"
-{ yyval.parse = P0; }
-break;
-case 46:
+    { yyval.parse = P0; }
+    break;
+
+  case 47:
 #line 251 "jamgram.y"
-{ yyval.parse = pnode( yyvsp[-1].parse, yyvsp[0].parse ); }
-break;
-case 47:
+    { yyval.parse = pnode( yyvsp[-1].parse, yyvsp[0].parse ); }
+    break;
+
+  case 48:
 #line 255 "jamgram.y"
-{ yyval.parse = psnode( yyvsp[-2].string, yyvsp[0].parse ); }
-break;
-case 48:
+    { yyval.parse = psnode( yyvsp[-2].string, yyvsp[0].parse ); }
+    break;
+
+  case 49:
 #line 264 "jamgram.y"
-{ yyval.parse = P0; }
-break;
-case 49:
+    { yyval.parse = P0; }
+    break;
+
+  case 50:
 #line 266 "jamgram.y"
-{ yyval.parse = psnode( yyvsp[-2].string, yyvsp[0].parse ); }
-break;
-case 50:
+    { yyval.parse = psnode( yyvsp[-2].string, yyvsp[0].parse ); }
+    break;
+
+  case 51:
 #line 268 "jamgram.y"
-{ yyval.parse = psnode( yyvsp[0].string, P0 ); }
-break;
-case 51:
+    { yyval.parse = psnode( yyvsp[0].string, P0 ); }
+    break;
+
+  case 52:
 #line 277 "jamgram.y"
-{ yyval.parse = pnode( P0, yyvsp[0].parse ); }
-break;
-case 52:
+    { yyval.parse = pnode( P0, yyvsp[0].parse ); }
+    break;
+
+  case 53:
 #line 279 "jamgram.y"
-{ yyval.parse = pnode( yyvsp[0].parse, yyvsp[-2].parse ); }
-break;
-case 53:
+    { yyval.parse = pnode( yyvsp[0].parse, yyvsp[-2].parse ); }
+    break;
+
+  case 54:
 #line 289 "jamgram.y"
-{ yyval.parse = yyvsp[0].parse; yymode( SCAN_NORMAL ); }
-break;
-case 54:
+    { yyval.parse = yyvsp[0].parse; yymode( SCAN_NORMAL ); }
+    break;
+
+  case 55:
 #line 293 "jamgram.y"
-{ yyval.parse = pnull(); yymode( SCAN_PUNCT ); }
-break;
-case 55:
+    { yyval.parse = pnull(); yymode( SCAN_PUNCT ); }
+    break;
+
+  case 56:
 #line 295 "jamgram.y"
-{ yyval.parse = pappend( yyvsp[-1].parse, yyvsp[0].parse ); }
-break;
-case 56:
+    { yyval.parse = pappend( yyvsp[-1].parse, yyvsp[0].parse ); }
+    break;
+
+  case 57:
 #line 299 "jamgram.y"
-{ yyval.parse = plist( yyvsp[0].string ); }
-break;
-case 57:
+    { yyval.parse = plist( yyvsp[0].string ); }
+    break;
+
+  case 58:
 #line 300 "jamgram.y"
-{ yymode( SCAN_NORMAL ); }
-break;
-case 58:
+    { yymode( SCAN_NORMAL ); }
+    break;
+
+  case 59:
 #line 301 "jamgram.y"
-{ yyval.parse = yyvsp[-1].parse; }
-break;
-case 59:
+    { yyval.parse = yyvsp[-1].parse; }
+    break;
+
+  case 60:
 #line 310 "jamgram.y"
-{ yyval.parse = prule( yyvsp[-1].parse, yyvsp[0].parse ); }
-break;
-case 60:
+    { yyval.parse = prule( yyvsp[-1].parse, yyvsp[0].parse ); }
+    break;
+
+  case 61:
 #line 312 "jamgram.y"
-{ yyval.parse = pon( yyvsp[-2].parse, prule( yyvsp[-1].parse, yyvsp[0].parse ) ); }
-break;
-case 61:
+    { yyval.parse = pon( yyvsp[-2].parse, prule( yyvsp[-1].parse, yyvsp[0].parse ) ); }
+    break;
+
+  case 62:
 #line 314 "jamgram.y"
-{ yyval.parse = pon( yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 62:
+    { yyval.parse = pon( yyvsp[-2].parse, yyvsp[0].parse ); }
+    break;
+
+  case 63:
 #line 323 "jamgram.y"
-{ yyval.number = 0; }
-break;
-case 63:
+    { yyval.number = 0; }
+    break;
+
+  case 64:
 #line 325 "jamgram.y"
-{ yyval.number = yyvsp[-1].number | yyvsp[0].number; }
-break;
-case 64:
+    { yyval.number = yyvsp[-1].number | yyvsp[0].number; }
+    break;
+
+  case 65:
 #line 329 "jamgram.y"
-{ yyval.number = RULE_UPDATED; }
-break;
-case 65:
+    { yyval.number = RULE_UPDATED; }
+    break;
+
+  case 66:
 #line 331 "jamgram.y"
-{ yyval.number = RULE_TOGETHER; }
-break;
-case 66:
+    { yyval.number = RULE_TOGETHER; }
+    break;
+
+  case 67:
 #line 333 "jamgram.y"
-{ yyval.number = RULE_IGNORE; }
-break;
-case 67:
+    { yyval.number = RULE_IGNORE; }
+    break;
+
+  case 68:
 #line 335 "jamgram.y"
-{ yyval.number = RULE_QUIETLY; }
-break;
-case 68:
+    { yyval.number = RULE_QUIETLY; }
+    break;
+
+  case 69:
 #line 337 "jamgram.y"
-{ yyval.number = RULE_PIECEMEAL; }
-break;
-case 69:
+    { yyval.number = RULE_PIECEMEAL; }
+    break;
+
+  case 70:
 #line 339 "jamgram.y"
-{ yyval.number = RULE_EXISTING; }
-break;
-case 70:
+    { yyval.number = RULE_EXISTING; }
+    break;
+
+  case 71:
 #line 341 "jamgram.y"
-{ yyval.number = atoi( yyvsp[0].string ) * RULE_MAXLINE; }
-break;
-case 71:
+    { yyval.number = atoi( yyvsp[0].string ) * RULE_MAXLINE; }
+    break;
+
+  case 72:
 #line 350 "jamgram.y"
-{ yyval.parse = pnull(); }
-break;
-case 72:
+    { yyval.parse = pnull(); }
+    break;
+
+  case 73:
 #line 352 "jamgram.y"
-{ yyval.parse = yyvsp[0].parse; }
-break;
-#line 877 "y.tab.c"
-    }
-    yyssp -= yym;
-    yystate = *yyssp;
-    yyvsp -= yym;
-    yym = yylhs[yyn];
-    if (yystate == 0 && yym == 0)
+    { yyval.parse = yyvsp[0].parse; }
+    break;
+
+
+    }
+
+/* Line 999 of yacc.c.  */
+#line 1614 "y.tab.c"
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+
+
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
     {
-#if YYDEBUG
-        if (yydebug)
-            printf("%sdebug: after reduction, shifting from state 0 to\
- state %d\n", YYPREFIX, YYFINAL);
-#endif
-        yystate = YYFINAL;
-        *++yyssp = YYFINAL;
-        *++yyvsp = yyval;
-        if (yychar < 0)
+      ++yynerrs;
+#if YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (YYPACT_NINF < yyn && yyn < YYLAST)
+	{
+	  YYSIZE_T yysize = 0;
+	  int yytype = YYTRANSLATE (yychar);
+	  char *yymsg;
+	  int yyx, yycount;
+
+	  yycount = 0;
+	  /* Start YYX at -YYN if negative to avoid negative indexes in
+	     YYCHECK.  */
+	  for (yyx = yyn < 0 ? -yyn : 0;
+	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
+	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
+	  yysize += yystrlen ("syntax error, unexpected ") + 1;
+	  yysize += yystrlen (yytname[yytype]);
+	  yymsg = (char *) YYSTACK_ALLOC (yysize);
+	  if (yymsg != 0)
+	    {
+	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
+	      yyp = yystpcpy (yyp, yytname[yytype]);
+
+	      if (yycount < 5)
+		{
+		  yycount = 0;
+		  for (yyx = yyn < 0 ? -yyn : 0;
+		       yyx < (int) (sizeof (yytname) / sizeof (char *));
+		       yyx++)
+		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+		      {
+			const char *yyq = ! yycount ? ", expecting " : " or ";
+			yyp = yystpcpy (yyp, yyq);
+			yyp = yystpcpy (yyp, yytname[yyx]);
+			yycount++;
+		      }
+		}
+	      yyerror (yymsg);
+	      YYSTACK_FREE (yymsg);
+	    }
+	  else
+	    yyerror ("syntax error; also virtual memory exhausted");
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	yyerror ("syntax error");
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      /* Return failure if at end of input.  */
+      if (yychar == YYEOF)
         {
-            if ((yychar = yylex()) < 0) yychar = 0;
-#if YYDEBUG
-            if (yydebug)
-            {
-                yys = 0;
-                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-                if (!yys) yys = "illegal-symbol";
-                printf("%sdebug: state %d, reading %d (%s)\n",
-                        YYPREFIX, YYFINAL, yychar, yys);
-            }
-#endif
+	  /* Pop the error token.  */
+          YYPOPSTACK;
+	  /* Pop the rest of the stack.  */
+	  while (yyss < yyssp)
+	    {
+	      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
+	      yydestruct (yystos[*yyssp], yyvsp);
+	      YYPOPSTACK;
+	    }
+	  YYABORT;
         }
-        if (yychar == 0) goto yyaccept;
-        goto yyloop;
+
+      YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
+      yydestruct (yytoken, &yylval);
+      yychar = YYEMPTY;
+
     }
-    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
-        yystate = yytable[yyn];
-    else
-        yystate = yydgoto[yym];
-#if YYDEBUG
-    if (yydebug)
-        printf("%sdebug: after reduction, shifting from state %d \
-to state %d\n", YYPREFIX, *yyssp, yystate);
-#endif
-    if (yyssp >= yysslim && yygrowstack())
-    {
-        goto yyoverflow;
-    }
-    *++yyssp = yystate;
-    *++yyvsp = yyval;
-    goto yyloop;
-yyoverflow:
-    yyerror("yacc stack overflow");
-yyabort:
-    return (1);
-yyaccept:
-    return (0);
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*----------------------------------------------------.
+| yyerrlab1 -- error raised explicitly by an action.  |
+`----------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
+      yydestruct (yystos[yystate], yyvsp);
+      yyvsp--;
+      yystate = *--yyssp;
+
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  YYDPRINTF ((stderr, "Shifting error token, "));
+
+  *++yyvsp = yylval;
+
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*----------------------------------------------.
+| yyoverflowlab -- parser overflow comes here.  |
+`----------------------------------------------*/
+yyoverflowlab:
+  yyerror ("parser stack overflow");
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+  return yyresult;
 }
+
+
+
diff -Naur jam-2.5/jamgram.h jam-2.5-p/jamgram.h
--- jam-2.5/jamgram.h	2004-08-19 20:19:34.000000000 +0200
+++ jam-2.5-p/jamgram.h	2007-08-19 22:36:55.000000000 +0200
@@ -1,51 +1,142 @@
-#ifndef YYERRCODE
-#define YYERRCODE 256
-#endif
+/* A Bison parser, made by GNU Bison 1.875a.  */
+
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
 
-#define _BANG_t 257
-#define _BANG_EQUALS_t 258
-#define _AMPER_t 259
-#define _AMPERAMPER_t 260
-#define _LPAREN_t 261
-#define _RPAREN_t 262
-#define _PLUS_EQUALS_t 263
-#define _COLON_t 264
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     _LANGLE_t = 258,
+     _LANGLE_EQUALS_t = 259,
+     _EQUALS_t = 260,
+     _RANGLE_t = 261,
+     _RANGLE_EQUALS_t = 262,
+     _BAR_t = 263,
+     _BARBAR_t = 264,
+     _SEMIC_t = 265,
+     _COLON_t = 266,
+     _BANG_t = 267,
+     _BANG_EQUALS_t = 268,
+     _QUESTION_EQUALS_t = 269,
+     _LPAREN_t = 270,
+     _RPAREN_t = 271,
+     _LBRACKET_t = 272,
+     _RBRACKET_t = 273,
+     _LBRACE_t = 274,
+     _RBRACE_t = 275,
+     _AMPER_t = 276,
+     _AMPERAMPER_t = 277,
+     _PLUS_EQUALS_t = 278,
+     ACTIONS_t = 279,
+     BIND_t = 280,
+     BREAK_t = 281,
+     CASE_t = 282,
+     CONTINUE_t = 283,
+     DEFAULT_t = 284,
+     ELSE_t = 285,
+     EXISTING_t = 286,
+     FOR_t = 287,
+     IF_t = 288,
+     IGNORE_t = 289,
+     IN_t = 290,
+     INCLUDE_t = 291,
+     LOCAL_t = 292,
+     MAXLINE_t = 293,
+     ON_t = 294,
+     PIECEMEAL_t = 295,
+     QUIETLY_t = 296,
+     RETURN_t = 297,
+     RULE_t = 298,
+     SWITCH_t = 299,
+     TOGETHER_t = 300,
+     UPDATED_t = 301,
+     WHILE_t = 302,
+     ARG = 303,
+     STRING = 304
+   };
+#endif
+#define _LANGLE_t 258
+#define _LANGLE_EQUALS_t 259
+#define _EQUALS_t 260
+#define _RANGLE_t 261
+#define _RANGLE_EQUALS_t 262
+#define _BAR_t 263
+#define _BARBAR_t 264
 #define _SEMIC_t 265
-#define _LANGLE_t 266
-#define _LANGLE_EQUALS_t 267
-#define _EQUALS_t 268
-#define _RANGLE_t 269
-#define _RANGLE_EQUALS_t 270
-#define _QUESTION_EQUALS_t 271
+#define _COLON_t 266
+#define _BANG_t 267
+#define _BANG_EQUALS_t 268
+#define _QUESTION_EQUALS_t 269
+#define _LPAREN_t 270
+#define _RPAREN_t 271
 #define _LBRACKET_t 272
 #define _RBRACKET_t 273
-#define ACTIONS_t 274
-#define BIND_t 275
-#define BREAK_t 276
-#define CASE_t 277
-#define CONTINUE_t 278
-#define DEFAULT_t 279
-#define ELSE_t 280
-#define EXISTING_t 281
-#define FOR_t 282
-#define IF_t 283
-#define IGNORE_t 284
-#define IN_t 285
-#define INCLUDE_t 286
-#define LOCAL_t 287
-#define MAXLINE_t 288
-#define ON_t 289
-#define PIECEMEAL_t 290
-#define QUIETLY_t 291
-#define RETURN_t 292
-#define RULE_t 293
-#define SWITCH_t 294
-#define TOGETHER_t 295
-#define UPDATED_t 296
-#define WHILE_t 297
-#define _LBRACE_t 298
-#define _BAR_t 299
-#define _BARBAR_t 300
-#define _RBRACE_t 301
-#define ARG 302
-#define STRING 303
+#define _LBRACE_t 274
+#define _RBRACE_t 275
+#define _AMPER_t 276
+#define _AMPERAMPER_t 277
+#define _PLUS_EQUALS_t 278
+#define ACTIONS_t 279
+#define BIND_t 280
+#define BREAK_t 281
+#define CASE_t 282
+#define CONTINUE_t 283
+#define DEFAULT_t 284
+#define ELSE_t 285
+#define EXISTING_t 286
+#define FOR_t 287
+#define IF_t 288
+#define IGNORE_t 289
+#define IN_t 290
+#define INCLUDE_t 291
+#define LOCAL_t 292
+#define MAXLINE_t 293
+#define ON_t 294
+#define PIECEMEAL_t 295
+#define QUIETLY_t 296
+#define RETURN_t 297
+#define RULE_t 298
+#define SWITCH_t 299
+#define TOGETHER_t 300
+#define UPDATED_t 301
+#define WHILE_t 302
+#define ARG 303
+#define STRING 304
+
+
+
+
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+extern YYSTYPE yylval;
+
+
+
diff -Naur jam-2.5/jamgram.y jam-2.5-p/jamgram.y
--- jam-2.5/jamgram.y	2003-04-23 06:57:07.000000000 +0200
+++ jam-2.5-p/jamgram.y	2007-08-19 22:36:55.000000000 +0200
@@ -1,20 +1,24 @@
-%token _BANG_t
-%token _BANG_EQUALS_t
-%token _AMPER_t
-%token _AMPERAMPER_t
-%token _LPAREN_t
-%token _RPAREN_t
-%token _PLUS_EQUALS_t
-%token _COLON_t
-%token _SEMIC_t
 %token _LANGLE_t
 %token _LANGLE_EQUALS_t
 %token _EQUALS_t
 %token _RANGLE_t
 %token _RANGLE_EQUALS_t
+%token _BAR_t
+%token _BARBAR_t
+%token _SEMIC_t
+%token _COLON_t
+%token _BANG_t
+%token _BANG_EQUALS_t
 %token _QUESTION_EQUALS_t
+%token _LPAREN_t
+%token _RPAREN_t
 %token _LBRACKET_t
 %token _RBRACKET_t
+%token _LBRACE_t
+%token _RBRACE_t
+%token _AMPER_t
+%token _AMPERAMPER_t
+%token _PLUS_EQUALS_t
 %token ACTIONS_t
 %token BIND_t
 %token BREAK_t
@@ -39,10 +43,6 @@
 %token TOGETHER_t
 %token UPDATED_t
 %token WHILE_t
-%token _LBRACE_t
-%token _BAR_t
-%token _BARBAR_t
-%token _RBRACE_t
 /*
  * Copyright 1993-2002 Christopher Seiwald and Perforce Software, Inc.
  *
diff -Naur jam-2.5/jamgramtab.h jam-2.5-p/jamgramtab.h
--- jam-2.5/jamgramtab.h	2003-04-23 06:57:07.000000000 +0200
+++ jam-2.5-p/jamgramtab.h	2007-08-19 22:36:55.000000000 +0200
@@ -1,20 +1,24 @@
-	{ "!", _BANG_t },
-	{ "!=", _BANG_EQUALS_t },
-	{ "&", _AMPER_t },
-	{ "&&", _AMPERAMPER_t },
-	{ "(", _LPAREN_t },
-	{ ")", _RPAREN_t },
-	{ "+=", _PLUS_EQUALS_t },
-	{ ":", _COLON_t },
-	{ ";", _SEMIC_t },
 	{ "<", _LANGLE_t },
 	{ "<=", _LANGLE_EQUALS_t },
 	{ "=", _EQUALS_t },
 	{ ">", _RANGLE_t },
 	{ ">=", _RANGLE_EQUALS_t },
+	{ "|", _BAR_t },
+	{ "||", _BARBAR_t },
+	{ ";", _SEMIC_t },
+	{ ":", _COLON_t },
+	{ "!", _BANG_t },
+	{ "!=", _BANG_EQUALS_t },
 	{ "?=", _QUESTION_EQUALS_t },
+	{ "(", _LPAREN_t },
+	{ ")", _RPAREN_t },
 	{ "[", _LBRACKET_t },
 	{ "]", _RBRACKET_t },
+	{ "{", _LBRACE_t },
+	{ "}", _RBRACE_t },
+	{ "&", _AMPER_t },
+	{ "&&", _AMPERAMPER_t },
+	{ "+=", _PLUS_EQUALS_t },
 	{ "actions", ACTIONS_t },
 	{ "bind", BIND_t },
 	{ "break", BREAK_t },
@@ -39,7 +43,3 @@
 	{ "together", TOGETHER_t },
 	{ "updated", UPDATED_t },
 	{ "while", WHILE_t },
-	{ "{", _LBRACE_t },
-	{ "|", _BAR_t },
-	{ "||", _BARBAR_t },
-	{ "}", _RBRACE_t },

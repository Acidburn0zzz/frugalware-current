From 003cfbe17c819cade65ed79bbe049dfb1974d226 Mon Sep 17 00:00:00 2001
From: Julien Puydt <jpuydt@gnome.org>
Date: Fri, 29 May 2009 12:22:32 +0000
Subject: Removed the use of exceptions from the forms... hence from ekiga (bug #583744)

---
diff --git a/lib/engine/components/evolution/evolution-book.cpp b/lib/engine/components/evolution/evolution-book.cpp
index 9054ef3..f957bf0 100644
--- a/lib/engine/components/evolution/evolution-book.cpp
+++ b/lib/engine/components/evolution/evolution-book.cpp
@@ -224,8 +224,8 @@ Evolution::Book::on_book_opened (EBookStatus _status)
     if (search_filter.empty ())
       query = e_book_query_field_exists (E_CONTACT_FULL_NAME);
     else
-      query = e_book_query_field_test (E_CONTACT_FULL_NAME, 
-                                       E_BOOK_QUERY_CONTAINS, 
+      query = e_book_query_field_test (E_CONTACT_FULL_NAME,
+                                       E_BOOK_QUERY_CONTAINS,
                                        search_filter.c_str ());
 
     (void)e_book_async_get_book_view (book, query, NULL, 100,
@@ -233,7 +233,7 @@ Evolution::Book::on_book_opened (EBookStatus _status)
 
     e_book_query_unref (query);
 
-  } 
+  }
   else {
 
     book = NULL;
@@ -304,9 +304,9 @@ Evolution::Book::refresh ()
   remove_all_objects ();
 
   /* we go */
-  if (e_book_is_opened (book)) 
+  if (e_book_is_opened (book))
     on_book_opened_c (book, E_BOOK_ERROR_OK, this);
-  else 
+  else
     e_book_async_open (book, TRUE,
                        on_book_opened_c, this);
 }
@@ -360,39 +360,30 @@ Evolution::Book::on_new_contact_form_submitted (bool submitted,
   if ( !submitted)
     return;
 
-  try {
-    EContact *econtact = NULL;
-
-
-    /* first check we have everything before using */
-    std::string name = result.text ("name");
-    std::string home = result.text ("home");
-    std::string cell = result.text ("cell");
-    std::string work = result.text ("work");
-    std::string pager = result.text ("pager");
-    std::string video = result.text ("video");
-
-    econtact = e_contact_new ();
-    e_contact_set (econtact, E_CONTACT_FULL_NAME, (gpointer)name.c_str ());
-    if ( !home.empty ())
-      set_econtact_attribute_value (econtact, "HOME", home);
-    if ( !cell.empty ())
-      set_econtact_attribute_value (econtact, "CELL", cell);
-    if ( !work.empty ())
-      set_econtact_attribute_value (econtact, "WORK", work);
-    if ( !pager.empty ())
-      set_econtact_attribute_value (econtact, "PAGER", pager);
-    if ( !video.empty ())
-      set_econtact_attribute_value (econtact, "VIDEO", video);
-
-    e_book_add_contact (book, econtact, NULL);
-    g_object_unref (econtact);
-
-  } catch (Ekiga::Form::not_found) {
-#ifdef __GNUC__
-    std::cerr << "Invalid result form submitted to "
-	      << __PRETTY_FUNCTION__
-	      << std::endl;
-#endif
-  }
+  EContact *econtact = NULL;
+
+
+  /* first check we have everything before using */
+  std::string name = result.text ("name");
+  std::string home = result.text ("home");
+  std::string cell = result.text ("cell");
+  std::string work = result.text ("work");
+  std::string pager = result.text ("pager");
+  std::string video = result.text ("video");
+
+  econtact = e_contact_new ();
+  e_contact_set (econtact, E_CONTACT_FULL_NAME, (gpointer)name.c_str ());
+  if ( !home.empty ())
+    set_econtact_attribute_value (econtact, "HOME", home);
+  if ( !cell.empty ())
+    set_econtact_attribute_value (econtact, "CELL", cell);
+  if ( !work.empty ())
+    set_econtact_attribute_value (econtact, "WORK", work);
+  if ( !pager.empty ())
+    set_econtact_attribute_value (econtact, "PAGER", pager);
+  if ( !video.empty ())
+    set_econtact_attribute_value (econtact, "VIDEO", video);
+
+  e_book_add_contact (book, econtact, NULL);
+  g_object_unref (econtact);
 }
diff --git a/lib/engine/components/evolution/evolution-contact.cpp b/lib/engine/components/evolution/evolution-contact.cpp
index ef18fcf..5e8dc52 100644
--- a/lib/engine/components/evolution/evolution-contact.cpp
+++ b/lib/engine/components/evolution/evolution-contact.cpp
@@ -359,29 +359,22 @@ Evolution::Contact::on_edit_form_submitted (bool submitted,
   if (!submitted)
     return;
 
-  try {
-
-    std::string name = result.text ("name");
-    std::string home = result.text ("home");
-    std::string cell = result.text ("cell");
-    std::string work = result.text ("work");
-    std::string pager = result.text ("pager");
-    std::string video = result.text ("video");
-
-    set_attribute_value (ATTR_HOME, home);
-    set_attribute_value (ATTR_CELL, cell);
-    set_attribute_value (ATTR_WORK, work);
-    set_attribute_value (ATTR_PAGER, pager);
-    set_attribute_value (ATTR_VIDEO, video);
-
-    e_contact_set (econtact, E_CONTACT_FULL_NAME, (gpointer)name.c_str ());
-
-    e_book_commit_contact (book, econtact, NULL);
-
-  } catch (Ekiga::Form::not_found) {
-
-    std::cerr << "Invalid result form" << std::endl; // FIXME: do better
-  }
+  std::string name = result.text ("name");
+  std::string home = result.text ("home");
+  std::string cell = result.text ("cell");
+  std::string work = result.text ("work");
+  std::string pager = result.text ("pager");
+  std::string video = result.text ("video");
+
+  set_attribute_value (ATTR_HOME, home);
+  set_attribute_value (ATTR_CELL, cell);
+  set_attribute_value (ATTR_WORK, work);
+  set_attribute_value (ATTR_PAGER, pager);
+  set_attribute_value (ATTR_VIDEO, video);
+
+  e_contact_set (econtact, E_CONTACT_FULL_NAME, (gpointer)name.c_str ());
+
+  e_book_commit_contact (book, econtact, NULL);
 }
 
 void
diff --git a/lib/engine/components/ldap/ldap-book.cpp b/lib/engine/components/ldap/ldap-book.cpp
index 8f36532..6beff70 100644
--- a/lib/engine/components/ldap/ldap-book.cpp
+++ b/lib/engine/components/ldap/ldap-book.cpp
@@ -98,13 +98,13 @@ OPENLDAP::Book::parse_result (LDAPMessage* message)
         if (!strcasecmp(bv.bv_val,attributes[i]) && bvals && bvals[0].bv_val ) {
 	  call_addresses[attributes[i]] =
 	    /* FIXME: next line is annoying */
-	  	std::string ("sip:") +
-		  std::string (bvals[0].bv_val, bvals[0].bv_len);
+	    std::string ("sip:") +
+	    std::string (bvals[0].bv_val, bvals[0].bv_len);
         }
       }
     }
     if (bvals) ber_memfree(bvals);
-    }
+  }
 
   ber_free (ber, 0);
 
@@ -306,28 +306,28 @@ OPENLDAP::Book::Book (Ekiga::ServiceCore &_core,
     }
     if (hostname_node) {
 
-	xmlUnlinkNode (hostname_node);
-        xmlFreeNode (hostname_node);
+      xmlUnlinkNode (hostname_node);
+      xmlFreeNode (hostname_node);
     }
     if (port_node) {
 
-	xmlUnlinkNode (port_node);
-        xmlFreeNode (port_node);
+      xmlUnlinkNode (port_node);
+      xmlFreeNode (port_node);
     }
     if (base_node) {
 
-	xmlUnlinkNode (base_node);
-        xmlFreeNode (base_node);
+      xmlUnlinkNode (base_node);
+      xmlFreeNode (base_node);
     }
     if (scope_node) {
 
-	xmlUnlinkNode (scope_node);
-        xmlFreeNode (scope_node);
+      xmlUnlinkNode (scope_node);
+      xmlFreeNode (scope_node);
     }
     if (call_attribute_node) {
 
-	xmlUnlinkNode (call_attribute_node);
-        xmlFreeNode (call_attribute_node);
+      xmlUnlinkNode (call_attribute_node);
+      xmlFreeNode (call_attribute_node);
     }
     trigger_saving.emit ();
   }
@@ -351,14 +351,14 @@ OPENLDAP::Book::Book (Ekiga::ServiceCore &_core,
 						      bookinfo.name).c_str ());
 
   uri_node = xmlNewChild (node, NULL,
-			       BAD_CAST "uri",
-			       BAD_CAST robust_xmlEscape (node->doc,
-							  bookinfo.uri).c_str ());
+			  BAD_CAST "uri",
+			  BAD_CAST robust_xmlEscape (node->doc,
+						     bookinfo.uri).c_str ());
 
   authcID_node = xmlNewChild (node, NULL,
-			       BAD_CAST "authcID",
-			       BAD_CAST robust_xmlEscape (node->doc,
-			       		bookinfo.authcID).c_str ());
+			      BAD_CAST "authcID",
+			      BAD_CAST robust_xmlEscape (node->doc,
+							 bookinfo.authcID).c_str ());
 
   password_node = xmlNewChild (node, NULL,
 			       BAD_CAST "password",
@@ -471,182 +471,182 @@ OPENLDAP::Book::on_sasl_form_submitted (bool submitted,
 
 extern "C" {
 
-typedef struct interctx {
-  OPENLDAP::Book *book;
-  std::string authcID;
-  std::string password;
-  std::list<std::string> results;
-} interctx;
+  typedef struct interctx {
+    OPENLDAP::Book *book;
+    std::string authcID;
+    std::string password;
+    std::list<std::string> results;
+  } interctx;
 
-static int
-book_saslinter(LDAP *ld, unsigned flags __attribute__((unused)),
-  void *def, void *inter)
-{
-  sasl_interact_t *in = (sasl_interact_t *)inter;
-  interctx *ctx = (interctx *)def;
-  struct berval p;
-  int i, nprompts = 0;
-
-  /* Fill in the prompts we have info for; count
-   * how many we're missing.
-   */
-  for (;in->id != SASL_CB_LIST_END;in++)
+  static int
+  book_saslinter(LDAP *ld, unsigned flags __attribute__((unused)),
+		 void *def, void *inter)
   {
-    p.bv_val = NULL;
-    switch(in->id)
-    {
-      case SASL_CB_GETREALM:
-        ldap_get_option(ld, LDAP_OPT_X_SASL_REALM, &p.bv_val);
-        if (p.bv_val) p.bv_len = strlen(p.bv_val);
-        break;
-      case SASL_CB_AUTHNAME:
-	p.bv_len = ctx->authcID.length();
-	if (p.bv_len)
-          p.bv_val = (char *)ctx->authcID.c_str();
-        break;
-      case SASL_CB_USER:
-        /* If there was a default authcID, just ignore the authzID */
-        if (ctx->authcID.length()) {
-	  p.bv_val = (char *)"";
-	  p.bv_len = 0;
-	}
-	break;
-      case SASL_CB_PASS:
-	p.bv_len = ctx->password.length();
-	if (p.bv_len)
-          p.bv_val = (char *)ctx->password.c_str();
-        break;
-      default:
-        break;
-    }
-    if (p.bv_val)
-    {
-      in->result = p.bv_val;
-      in->len = p.bv_len;
-    } else
-    {
-      nprompts++;
-      in->result = NULL;
-    }
-  }
-
-  /* If there are missing items, try to get them all in one dialog */
-  if (nprompts) {
-    Ekiga::FormRequestSimple request(sigc::mem_fun (ctx->book, &OPENLDAP::Book::on_sasl_form_submitted));
-    Ekiga::FormBuilder result;
-    std::string prompt;
-    std::string ctxt = "";
-    char resbuf[32];
-
-    request.title (_("LDAP SASL Interaction"));
-
-    for (i=0, in = (sasl_interact_t *)inter;
-      in->id != SASL_CB_LIST_END;in++)
-    {
-      bool noecho = false, challenge = false;
-
-      if (in->result) continue;
-
-      /* Give each dialog item a unique name */
-      sprintf(resbuf, "res%02x", i);
-      i++;
-
-      /* Check for prompts that need special handling */
-      switch(in->id)
+    sasl_interact_t *in = (sasl_interact_t *)inter;
+    interctx *ctx = (interctx *)def;
+    struct berval p;
+    int i, nprompts = 0;
+
+    /* Fill in the prompts we have info for; count
+     * how many we're missing.
+     */
+    for (;in->id != SASL_CB_LIST_END;in++)
       {
-      case SASL_CB_PASS:
-        noecho = true;
-	break;
-      case SASL_CB_NOECHOPROMPT:
-        noecho = true;
-        challenge = true;
-	break;
-      case SASL_CB_ECHOPROMPT:
-        challenge = true;
-	break;
-      default:
-        break;
+	p.bv_val = NULL;
+	switch(in->id)
+	  {
+	  case SASL_CB_GETREALM:
+	    ldap_get_option(ld, LDAP_OPT_X_SASL_REALM, &p.bv_val);
+	    if (p.bv_val) p.bv_len = strlen(p.bv_val);
+	    break;
+	  case SASL_CB_AUTHNAME:
+	    p.bv_len = ctx->authcID.length();
+	    if (p.bv_len)
+	      p.bv_val = (char *)ctx->authcID.c_str();
+	    break;
+	  case SASL_CB_USER:
+	    /* If there was a default authcID, just ignore the authzID */
+	    if (ctx->authcID.length()) {
+	      p.bv_val = (char *)"";
+	      p.bv_len = 0;
+	    }
+	    break;
+	  case SASL_CB_PASS:
+	    p.bv_len = ctx->password.length();
+	    if (p.bv_len)
+	      p.bv_val = (char *)ctx->password.c_str();
+	    break;
+	  default:
+	    break;
+	  }
+	if (p.bv_val)
+	  {
+	    in->result = p.bv_val;
+	    in->len = p.bv_len;
+	  } else
+	  {
+	    nprompts++;
+	    in->result = NULL;
+	  }
       }
 
-      /* accumulate any challenge strings */
-      if (challenge && in->challenge) {
-
-	/* Translators, Howard explained : "Challenge" is a generic term
-	 * in authentication. It's a prompt from the authentication mechanism
-	 * for some type of credential. Exactly what kind of challenge and
-	 * what kind of credential depends on the specific authentication
-	 * mechanism. Since SASL is a generic interface, and can dynamically
-	 * load arbitrary mechanisms, there's not much more specific you can
-	 * say about it. You might google for "challenge response
-	 * authentication" if you'd like more background context.
-	 */
-        ctxt += std::string (_("Challenge: ")) +
-	  std::string (in->challenge) +"\n";
-      }
-
-      /* use the provided prompt text, or our default? */
-      if (in->prompt)
-        prompt = std::string (in->prompt);
-      else
-        prompt = std::string (_("Interact"));
-
-      /* private text or not? */
-      if (noecho) {
-        request.private_text (std::string (resbuf), prompt, "");
-      } else {
-        std::string dflt;
-	if (in->defresult)
-	  dflt = std::string (in->defresult);
-	else
-	  dflt = "";
-	request.text (std::string(resbuf), prompt, dflt);
-      }
-    }
-
-    /* If we had any challenge text, set it now */
-    if (!ctxt.empty())
-      request.instructions (ctxt);
-
-    /* Save a pointer for storing the form result */
-    ctx->book->saslform = &result;
-    if (!ctx->book->questions.handle_request (&request)) {
-      return LDAP_LOCAL_ERROR;
-    }
-
-    /* Extract answers from the result form */
-    for (i=0, in = (sasl_interact_t *)inter;
-      in->id != SASL_CB_LIST_END;in++)
-    {
-      bool noecho = false;
+    /* If there are missing items, try to get them all in one dialog */
+    if (nprompts) {
+      Ekiga::FormRequestSimple request(sigc::mem_fun (ctx->book, &OPENLDAP::Book::on_sasl_form_submitted));
+      Ekiga::FormBuilder result;
+      std::string prompt;
+      std::string ctxt = "";
+      char resbuf[32];
+
+      request.title (_("LDAP SASL Interaction"));
+
+      for (i=0, in = (sasl_interact_t *)inter;
+	   in->id != SASL_CB_LIST_END;in++)
+	{
+	  bool noecho = false, challenge = false;
+
+	  if (in->result) continue;
+
+	  /* Give each dialog item a unique name */
+	  sprintf(resbuf, "res%02x", i);
+	  i++;
+
+	  /* Check for prompts that need special handling */
+	  switch(in->id)
+	    {
+	    case SASL_CB_PASS:
+	      noecho = true;
+	      break;
+	    case SASL_CB_NOECHOPROMPT:
+	      noecho = true;
+	      challenge = true;
+	      break;
+	    case SASL_CB_ECHOPROMPT:
+	      challenge = true;
+	      break;
+	    default:
+	      break;
+	    }
+
+	  /* accumulate any challenge strings */
+	  if (challenge && in->challenge) {
+
+	    /* Translators, Howard explained : "Challenge" is a generic term
+	     * in authentication. It's a prompt from the authentication mechanism
+	     * for some type of credential. Exactly what kind of challenge and
+	     * what kind of credential depends on the specific authentication
+	     * mechanism. Since SASL is a generic interface, and can dynamically
+	     * load arbitrary mechanisms, there's not much more specific you can
+	     * say about it. You might google for "challenge response
+	     * authentication" if you'd like more background context.
+	     */
+	    ctxt += std::string (_("Challenge: ")) +
+	      std::string (in->challenge) +"\n";
+	  }
+
+	  /* use the provided prompt text, or our default? */
+	  if (in->prompt)
+	    prompt = std::string (in->prompt);
+	  else
+	    prompt = std::string (_("Interact"));
+
+	  /* private text or not? */
+	  if (noecho) {
+	    request.private_text (std::string (resbuf), prompt, "");
+	  } else {
+	    std::string dflt;
+	    if (in->defresult)
+	      dflt = std::string (in->defresult);
+	    else
+	      dflt = "";
+	    request.text (std::string(resbuf), prompt, dflt);
+	  }
+	}
 
-      if (in->result) continue;
+      /* If we had any challenge text, set it now */
+      if (!ctxt.empty())
+	request.instructions (ctxt);
 
-      sprintf(resbuf, "res%02x", i);
-      i++;
-      switch(in->id)
-      {
-      case SASL_CB_PASS:
-      case SASL_CB_NOECHOPROMPT:
-        noecho = true;
-	break;
-      default:
-        break;
+      /* Save a pointer for storing the form result */
+      ctx->book->saslform = &result;
+      if (!ctx->book->questions.handle_request (&request)) {
+	return LDAP_LOCAL_ERROR;
       }
-      if (noecho)
-        prompt = result.private_text (std::string (resbuf));
-      else
-        prompt = result.text (std::string (resbuf));
-
-      /* Save the answers so they don't disappear before our
-       * caller can see them; return the saved copies.
-       */
-      ctx->results.push_back (prompt);
-      in->result = ctx->results.back().c_str();
-      in->len = ctx->results.back().length();
+
+      /* Extract answers from the result form */
+      for (i=0, in = (sasl_interact_t *)inter;
+	   in->id != SASL_CB_LIST_END;in++)
+	{
+	  bool noecho = false;
+
+	  if (in->result) continue;
+
+	  sprintf(resbuf, "res%02x", i);
+	  i++;
+	  switch(in->id)
+	    {
+	    case SASL_CB_PASS:
+	    case SASL_CB_NOECHOPROMPT:
+	      noecho = true;
+	      break;
+	    default:
+	      break;
+	    }
+	  if (noecho)
+	    prompt = result.private_text (std::string (resbuf));
+	  else
+	    prompt = result.text (std::string (resbuf));
+
+	  /* Save the answers so they don't disappear before our
+	   * caller can see them; return the saved copies.
+	   */
+	  ctx->results.push_back (prompt);
+	  in->result = ctx->results.back().c_str();
+	  in->len = ctx->results.back().length();
+	}
     }
+    return LDAP_SUCCESS;
   }
-  return LDAP_SUCCESS;
-}
 
 } /* extern "C" */
 
@@ -693,8 +693,8 @@ OPENLDAP::Book::refresh_start ()
     ctx.authcID = bookinfo.authcID;
     ctx.password = bookinfo.password;
     result = ldap_sasl_interactive_bind_s (ldap_context, NULL,
-      bookinfo.saslMech.c_str(), NULL, NULL, LDAP_SASL_QUIET,
-      book_saslinter, &ctx);
+					   bookinfo.saslMech.c_str(), NULL, NULL, LDAP_SASL_QUIET,
+					   book_saslinter, &ctx);
 
   } else {
     /* Simple Bind */
@@ -784,7 +784,7 @@ OPENLDAP::Book::refresh_bound ()
   }
   (void) ldap_msgfree (msg_entry);
 
-sasl_bound:
+ sasl_bound:
   if (!search_filter.empty ()) {
     if (search_filter[0] == '(' &&
         search_filter[search_filter.length()-1] == ')') {
@@ -806,7 +806,7 @@ sasl_bound:
   }
   fstr = filter.c_str();
 
-do_search:
+ do_search:
   msgid = ldap_search_ext (ldap_context,
 			   bookinfo.urld->lud_dn,
 			   bookinfo.urld->lud_scope,
@@ -854,17 +854,17 @@ OPENLDAP::Book::refresh_result ()
 
       patience--;
       Ekiga::Runtime::run_in_main (sigc::mem_fun (this, &OPENLDAP::Book::refresh_result),
-			    12);
+				   12);
     } else if (patience == 2) {
 
       patience--;
       Ekiga::Runtime::run_in_main (sigc::mem_fun (this, &OPENLDAP::Book::refresh_result),
-			    21);
+				   21);
     } else if (patience == 1) {
 
       patience--;
       Ekiga::Runtime::run_in_main (sigc::mem_fun (this, &OPENLDAP::Book::refresh_result),
-			    30);
+				   30);
     } else { // patience == 0
 
       status = std::string (_("Could not search"));
@@ -929,7 +929,7 @@ OPENLDAP::BookForm (Ekiga::FormRequestSimple &request,
     choices["sub"] = _("Subtree");
     choices["onelevel"] = _("Single Level");
     request.single_choice ("scope", _("_Search Scope"),
-      scopes[info.urld->lud_scope], choices);
+			   scopes[info.urld->lud_scope], choices);
   }
 
   /* attrs[0] is the name attribute */
@@ -962,7 +962,7 @@ OPENLDAP::BookForm (Ekiga::FormRequestSimple &request,
       }
     }
     request.single_choice ("saslMech", _("SASL _Mechanism"),
-      info.saslMech, mechs);
+			   info.saslMech, mechs);
   }
 }
 
@@ -1084,37 +1084,31 @@ OPENLDAP::Book::on_edit_form_submitted (bool submitted,
   if (!submitted)
     return;
 
-  try {
-    std::string errmsg;
-    if (OPENLDAP::BookFormInfo (result, bookinfo, errmsg)) {
-      Ekiga::FormRequestSimple request(sigc::mem_fun (this, &OPENLDAP::Book::on_edit_form_submitted));
+  std::string errmsg;
+  if (OPENLDAP::BookFormInfo (result, bookinfo, errmsg)) {
+    Ekiga::FormRequestSimple request(sigc::mem_fun (this, &OPENLDAP::Book::on_edit_form_submitted));
 
-      result.visit (request);
-      request.error (errmsg);
+    result.visit (request);
+    request.error (errmsg);
 
-      if (!questions.handle_request (&request)) {
+    if (!questions.handle_request (&request)) {
 
-        // FIXME: better error reporting
+      // FIXME: better error reporting
 #ifdef __GNUC__
-        std::cout << "Unhandled form request in "
-	          << __PRETTY_FUNCTION__ << std::endl;
+      std::cout << "Unhandled form request in "
+		<< __PRETTY_FUNCTION__ << std::endl;
 #endif
-      }
-      return;
     }
+    return;
+  }
 
-    robust_xmlNodeSetContent (node, &name_node, "name", bookinfo.name);
-
-    robust_xmlNodeSetContent (node, &uri_node, "uri", bookinfo.uri);
-
-    robust_xmlNodeSetContent (node, &authcID_node, "authcID", bookinfo.authcID);
+  robust_xmlNodeSetContent (node, &name_node, "name", bookinfo.name);
 
-    robust_xmlNodeSetContent (node, &password_node, "password", bookinfo.password);
-    updated.emit ();
-    trigger_saving.emit ();
+  robust_xmlNodeSetContent (node, &uri_node, "uri", bookinfo.uri);
 
-  } catch (Ekiga::Form::not_found) {
+  robust_xmlNodeSetContent (node, &authcID_node, "authcID", bookinfo.authcID);
 
-    std::cerr << "Invalid result form" << std::endl; // FIXME: do better
-  }
+  robust_xmlNodeSetContent (node, &password_node, "password", bookinfo.password);
+  updated.emit ();
+  trigger_saving.emit ();
 }
diff --git a/lib/engine/components/ldap/ldap-source.cpp b/lib/engine/components/ldap/ldap-source.cpp
index a29e249..69d3aa4 100644
--- a/lib/engine/components/ldap/ldap-source.cpp
+++ b/lib/engine/components/ldap/ldap-source.cpp
@@ -141,7 +141,7 @@ OPENLDAP::Source::new_book ()
 
   bookinfo.name = "";
   bookinfo.uri = "ldap://localhost/dc=net?cn,telephoneNumber?sub?(cn=$)",
-  bookinfo.authcID = "";
+    bookinfo.authcID = "";
   bookinfo.password = "";
   bookinfo.saslMech = "";
   bookinfo.urld = NULL;
@@ -185,33 +185,27 @@ OPENLDAP::Source::on_new_book_form_submitted (bool submitted,
   if (!submitted)
     return;
 
-  try {
-    std::string errmsg;
+  std::string errmsg;
 
-    if (OPENLDAP::BookFormInfo (result, bookinfo, errmsg)) {
-      Ekiga::FormRequestSimple request(sigc::mem_fun (this, &OPENLDAP::Source::on_new_book_form_submitted));
+  if (OPENLDAP::BookFormInfo (result, bookinfo, errmsg)) {
+    Ekiga::FormRequestSimple request(sigc::mem_fun (this, &OPENLDAP::Source::on_new_book_form_submitted));
 
-      result.visit (request);
-      request.error (errmsg);
+    result.visit (request);
+    request.error (errmsg);
 
-      if (!questions.handle_request (&request)) {
+    if (!questions.handle_request (&request)) {
 
-        // FIXME: better error reporting
+      // FIXME: better error reporting
 #ifdef __GNUC__
-        std::cout << "Unhandled form request in "
-	          << __PRETTY_FUNCTION__ << std::endl;
+      std::cout << "Unhandled form request in "
+		<< __PRETTY_FUNCTION__ << std::endl;
 #endif
-      }
-      return;
     }
-
-    add ();
-    save ();
-
-  } catch (Ekiga::Form::not_found) {
-
-    std::cerr << "Invalid result form" << std::endl; // FIXME: do better
+    return;
   }
+
+  add ();
+  save ();
 }
 
 void
diff --git a/lib/engine/components/local-roster/local-heap.cpp b/lib/engine/components/local-roster/local-heap.cpp
index 63984bd..dc8d8a9 100644
--- a/lib/engine/components/local-roster/local-heap.cpp
+++ b/lib/engine/components/local-roster/local-heap.cpp
@@ -189,9 +189,24 @@ Local::Heap::existing_groups ()
 
   result.insert (_("Family"));
   result.insert (_("Friend"));
+  /* Translator: http://www.ietf.org/rfc/rfc4480.txt proposes several
+     relationships between you and your contact; associate means
+     someone who is at the same "level" than you.
+  */
   result.insert (_("Associate"));
+  /* Translator: http://www.ietf.org/rfc/rfc4480.txt proposes several
+     relationships between you and your contact; assistant means
+     someone who is at a lower "level" than you.
+  */
   result.insert (_("Assistant"));
+  /* Translator: http://www.ietf.org/rfc/rfc4480.txt proposes several
+     relationships between you and your contact; supervisor means
+     someone who is at a higher "level" than you.
+  */
   result.insert (_("Supervisor"));
+  /* Translator: http://www.ietf.org/rfc/rfc4480.txt proposes several
+     relationships between you and your contact; self means yourself.
+  */
   result.insert (_("Self"));
 
   return result;
@@ -231,7 +246,7 @@ Local::Heap::new_presentity (const std::string name,
 
     if (!questions.handle_request (&request)) {
 
-    // FIXME: better error reporting
+      // FIXME: better error reporting
 #ifdef __GNUC__
       std::cout << "Unhandled form request in "
 		<< __PRETTY_FUNCTION__ << std::endl;
@@ -273,8 +288,8 @@ Local::Heap::push_presence (const std::string uri,
 struct push_status_helper
 {
   push_status_helper (const std::string uri_,
-			const std::string status_): uri(uri_),
-						    status(status_)
+		      const std::string status_): uri(uri_),
+						  status(status_)
   {}
 
   bool test (Local::PresentityPtr presentity)
@@ -368,52 +383,43 @@ Local::Heap::new_presentity_form_submitted (bool submitted,
   if (!submitted)
     return;
 
-  try {
+  gmref_ptr<Ekiga::PresenceCore> presence_core = core.get ("presence-core");
+  const std::string name = result.text ("name");
+  const std::string good_uri = result.hidden ("good-uri");
+  std::string uri;
+  const std::set<std::string> groups = result.editable_set ("groups");
+
+  if (good_uri == "yes")
+    uri = result.hidden ("uri");
+  else
+    uri = result.text ("uri");
+
+  size_t pos = uri.find_first_of (' ');
+  if (pos != std::string::npos)
+    uri = uri.substr (0, pos);
+  if (presence_core->is_supported_uri (uri)
+      && !has_presentity_with_uri (uri)) {
+
+    add (name, uri, groups);
+    save ();
+  } else {
 
-    gmref_ptr<Ekiga::PresenceCore> presence_core = core.get ("presence-core");
-    const std::string name = result.text ("name");
-    const std::string good_uri = result.hidden ("good-uri");
-    std::string uri;
-    const std::set<std::string> groups = result.editable_set ("groups");
+    Ekiga::FormRequestSimple request(sigc::mem_fun (this, &Local::Heap::new_presentity_form_submitted));
 
-    if (good_uri == "yes")
-      uri = result.hidden ("uri");
+    result.visit (request);
+    if (!presence_core->is_supported_uri (uri))
+      request.error (_("You supplied an unsupported address"));
     else
-      uri = result.text ("uri");
-
-    size_t pos = uri.find_first_of (' ');
-    if (pos != std::string::npos)
-      uri = uri.substr (0, pos);
-    if (presence_core->is_supported_uri (uri)
-	&& !has_presentity_with_uri (uri)) {
+      request.error (_("You already have a contact with this address!"));
 
-      add (name, uri, groups);
-      save ();
-    } else {
-
-      Ekiga::FormRequestSimple request(sigc::mem_fun (this, &Local::Heap::new_presentity_form_submitted));
-
-      result.visit (request);
-      if (!presence_core->is_supported_uri (uri))
-	request.error (_("You supplied an unsupported address"));
-      else
-	request.error (_("You already have a contact with this address!"));
-
-      if (!questions.handle_request (&request)) {
+    if (!questions.handle_request (&request)) {
 
-	// FIXME: better error handling
+      // FIXME: better error handling
 #ifdef __GNUC__
-	std::cout << "Unhandled form request in "
-		  << __PRETTY_FUNCTION__ << std::endl;
+      std::cout << "Unhandled form request in "
+		<< __PRETTY_FUNCTION__ << std::endl;
 #endif
-      }
     }
-  } catch (Ekiga::Form::not_found) {
-
-#ifdef __GNUC__
-    std::cerr << "Invalid form submitted to "
-	      << __PRETTY_FUNCTION__ << std::endl;
-#endif
   }
 }
 
@@ -462,19 +468,11 @@ Local::Heap::rename_group_form_submitted (std::string old_name,
   if (!submitted)
     return;
 
-  try {
-    const std::string new_name = result.text ("name");
+  const std::string new_name = result.text ("name");
 
-    if ( !new_name.empty () && new_name != old_name) {
+  if ( !new_name.empty () && new_name != old_name) {
 
-      rename_group_form_submitted_helper helper (old_name, new_name);
-      visit_presentities (sigc::mem_fun (helper, &rename_group_form_submitted_helper::rename_group));
-    }
-  } catch (Ekiga::Form::not_found) {
-
-#ifdef __GNUC__
-    std::cerr << "Invalid form submitted to "
-	      << __PRETTY_FUNCTION__ << std::endl;
-#endif
+    rename_group_form_submitted_helper helper (old_name, new_name);
+    visit_presentities (sigc::mem_fun (helper, &rename_group_form_submitted_helper::rename_group));
   }
 }
diff --git a/lib/engine/components/local-roster/local-presentity.cpp b/lib/engine/components/local-roster/local-presentity.cpp
index bf2cf3d..482d4b5 100644
--- a/lib/engine/components/local-roster/local-presentity.cpp
+++ b/lib/engine/components/local-roster/local-presentity.cpp
@@ -247,70 +247,60 @@ Local::Presentity::edit_presentity_form_submitted (bool submitted,
   if (!submitted)
     return;
 
-  try {
-
-    /* we first fetch all data before making any change, so if there's
-     * a problem, we don't do anything */
-    const std::string new_name = result.text ("name");
-    const std::set<std::string> new_groups = result.editable_set ("groups");
-    std::string new_uri = result.text ("uri");
-    std::map<std::string, xmlNodePtr> future_group_nodes;
-    size_t pos = new_uri.find_first_of (' ');
-    if (pos != std::string::npos)
-      new_uri = new_uri.substr (0, pos);
-
-    name = new_name;
-    if (uri != new_uri) {
-
-      gmref_ptr<Ekiga::PresenceCore> presence_core = core.get ("presence-core");
-      presence_core->unfetch_presence (uri);
-      uri = new_uri;
-      presence = "unknown";
-      presence_core->fetch_presence (uri);
-      xmlSetProp (node, (const xmlChar*)"uri", (const xmlChar*)uri.c_str ());
-    }
+  const std::string new_name = result.text ("name");
+  const std::set<std::string> new_groups = result.editable_set ("groups");
+  std::string new_uri = result.text ("uri");
+  std::map<std::string, xmlNodePtr> future_group_nodes;
+  size_t pos = new_uri.find_first_of (' ');
+  if (pos != std::string::npos)
+    new_uri = new_uri.substr (0, pos);
+
+  name = new_name;
+  if (uri != new_uri) {
+
+    gmref_ptr<Ekiga::PresenceCore> presence_core = core.get ("presence-core");
+    presence_core->unfetch_presence (uri);
+    uri = new_uri;
+    presence = "unknown";
+    presence_core->fetch_presence (uri);
+    xmlSetProp (node, (const xmlChar*)"uri", (const xmlChar*)uri.c_str ());
+  }
 
-    robust_xmlNodeSetContent (node, &name_node, "name", name);
+  robust_xmlNodeSetContent (node, &name_node, "name", name);
 
-    // the first loop looks at groups we were in : are we still in ?
-    for (std::map<std::string, xmlNodePtr>::const_iterator iter
-	   = group_nodes.begin ();
-	 iter != group_nodes.end () ;
-	 iter++) {
+  // the first loop looks at groups we were in : are we still in ?
+  for (std::map<std::string, xmlNodePtr>::const_iterator iter
+	 = group_nodes.begin ();
+       iter != group_nodes.end () ;
+       iter++) {
 
-      if (new_groups.find (iter->first) == new_groups.end ()) {
+    if (new_groups.find (iter->first) == new_groups.end ()) {
 
-	xmlUnlinkNode (iter->second);
-	xmlFreeNode (iter->second);
-      } 
-      else {
-	future_group_nodes[iter->first] = iter->second;
-      }
+      xmlUnlinkNode (iter->second);
+      xmlFreeNode (iter->second);
     }
-
-    // the second loop looking for groups we weren't in but are now
-    for (std::set<std::string>::const_iterator iter = new_groups.begin ();
-	 iter != new_groups.end ();
-	 iter++) {
-
-      if (std::find (groups.begin (), groups.end (), *iter) == groups.end ())
-	future_group_nodes[*iter] = xmlNewChild (node, NULL,
-						 BAD_CAST "group",
-						 BAD_CAST robust_xmlEscape (node->doc, *iter).c_str ());
+    else {
+      future_group_nodes[iter->first] = iter->second;
     }
+  }
 
-    // ok, now we know our groups
-    group_nodes = future_group_nodes;
-    groups = new_groups;
+  // the second loop looking for groups we weren't in but are now
+  for (std::set<std::string>::const_iterator iter = new_groups.begin ();
+       iter != new_groups.end ();
+       iter++) {
 
-    updated.emit ();
-    trigger_saving.emit ();
-  } catch (Ekiga::Form::not_found) {
-#ifdef __GNUC__
-    std::cerr << "Invalid form submitted to "
-	      << __PRETTY_FUNCTION__ << std::endl;
-#endif
+    if (std::find (groups.begin (), groups.end (), *iter) == groups.end ())
+      future_group_nodes[*iter] = xmlNewChild (node, NULL,
+					       BAD_CAST "group",
+					       BAD_CAST robust_xmlEscape (node->doc, *iter).c_str ());
   }
+
+  // ok, now we know our groups
+  group_nodes = future_group_nodes;
+  groups = new_groups;
+
+  updated.emit ();
+  trigger_saving.emit ();
 }
 
 
diff --git a/lib/engine/components/opal/opal-account.cpp b/lib/engine/components/opal/opal-account.cpp
index 0691361..9b62123 100644
--- a/lib/engine/components/opal/opal-account.cpp
+++ b/lib/engine/components/opal/opal-account.cpp
@@ -53,7 +53,7 @@
 
 Opal::Account::Account (Ekiga::ServiceCore & _core,
                         const std::string & account)
-: core (_core)
+  : core (_core)
 {
   dead = false;
   active = false;
@@ -119,7 +119,7 @@ Opal::Account::Account (Ekiga::ServiceCore & _core,
     type = Account::DiamondCard;
   else if (protocol_name == "SIP")
     type = Account::SIP;
-  else 
+  else
     type = Account::H323;
 
   registration_event.connect (sigc::mem_fun (this, &Opal::Account::on_registration_event));
@@ -128,14 +128,14 @@ Opal::Account::Account (Ekiga::ServiceCore & _core,
 
 Opal::Account::Account (Ekiga::ServiceCore & _core,
                         Type t,
-                        std::string _name, 
+                        std::string _name,
                         std::string _host,
                         std::string _username,
                         std::string _auth_username,
                         std::string _password,
                         bool _enabled,
                         unsigned _timeout)
-: core (_core)
+  : core (_core)
 {
   dead = false;
   active = false;
@@ -169,16 +169,16 @@ const std::string Opal::Account::as_string () const
 
   std::stringstream str;
 
-  str << enabled << "|1|" 
-      << aid << "|" 
-      << name << "|" 
-      << protocol_name << "|" 
-      << host << "|" 
-      << host << "|" 
-      << username << "|" 
-      << auth_username << "|" 
-      << (password.empty () ? " " : password) << "|" 
-      << timeout; 
+  str << enabled << "|1|"
+      << aid << "|"
+      << name << "|"
+      << protocol_name << "|"
+      << host << "|"
+      << host << "|"
+      << username << "|"
+      << auth_username << "|"
+      << (password.empty () ? " " : password) << "|"
+      << timeout;
 
   return str.str ();
 }
@@ -314,23 +314,23 @@ bool Opal::Account::populate_menu (Ekiga::MenuBuilder &builder)
 
     std::stringstream str;
     std::stringstream url;
-    str << "https://www.diamondcard.us/exec/voip-login?accId=" << get_username () << "&pinCode=" << get_password () << "&spo=ekiga"; 
+    str << "https://www.diamondcard.us/exec/voip-login?accId=" << get_username () << "&pinCode=" << get_password () << "&spo=ekiga";
 
     builder.add_separator ();
 
     url.str ("");
     url << str.str () << "&act=rch";
     builder.add_action ("recharge",
-			 _("Recharge the account"),
+			_("Recharge the account"),
                         sigc::bind (sigc::mem_fun (this, &Opal::Account::on_consult), url.str ()));
     url.str ("");
     url << str.str () << "&act=bh";
-    builder.add_action ("balance", 
+    builder.add_action ("balance",
                         _("Consult the balance history"),
                         sigc::bind (sigc::mem_fun (this, &Opal::Account::on_consult), url.str ()));
     url.str ("");
     url << str.str () << "&act=ch";
-    builder.add_action ("history", 
+    builder.add_action ("history",
                         _("Consult the call history"),
                         sigc::bind (sigc::mem_fun (this, &Opal::Account::on_consult), url.str ()));
   }
@@ -345,7 +345,7 @@ void Opal::Account::edit ()
   std::stringstream str;
 
   str << get_timeout ();
-  
+
   request.title (_("Edit account"));
 
   request.instructions (_("Please update the following fields:"));
@@ -382,62 +382,55 @@ void Opal::Account::on_edit_form_submitted (bool submitted,
   if (!submitted)
     return;
 
-  try {
-
-    std::string new_name = result.text ("name");
-    std::string new_host = result.text ("host");
-    std::string new_user = result.text ("user");
-    std::string new_authentication_user;
-    if (get_protocol_name () == "SIP")
-      new_authentication_user = result.text ("authentication_user");
-    if (new_authentication_user.empty ())
-      new_authentication_user = new_user;
-    std::string new_password = result.private_text ("password");
-    bool new_enabled = result.boolean ("enabled");
-    unsigned new_timeout = atoi (result.text ("timeout").c_str ());
-    std::string error;
-
-    if (new_name.empty ()) 
-      error = _("You did not supply a name for that account.");
-    else if (new_host.empty ()) 
-      error = _("You did not supply a host to register to.");
-    else if (new_user.empty ())
-      error = _("You did not supply a user name for that account.");
-    else if (new_timeout < 10)
-      error = _("The timeout should have a bigger value.");
-
-    if (!error.empty ()) {
-
-      Ekiga::FormRequestSimple request(sigc::mem_fun (this, &Opal::Account::on_edit_form_submitted));
-      result.visit (request);
-      request.error (error);
-
-      if (!questions.handle_request (&request)) {
+  std::string new_name = result.text ("name");
+  std::string new_host = result.text ("host");
+  std::string new_user = result.text ("user");
+  std::string new_authentication_user;
+  if (get_protocol_name () == "SIP")
+    new_authentication_user = result.text ("authentication_user");
+  if (new_authentication_user.empty ())
+    new_authentication_user = new_user;
+  std::string new_password = result.private_text ("password");
+  bool new_enabled = result.boolean ("enabled");
+  unsigned new_timeout = atoi (result.text ("timeout").c_str ());
+  std::string error;
+
+  if (new_name.empty ())
+    error = _("You did not supply a name for that account.");
+  else if (new_host.empty ())
+    error = _("You did not supply a host to register to.");
+  else if (new_user.empty ())
+    error = _("You did not supply a user name for that account.");
+  else if (new_timeout < 10)
+    error = _("The timeout should have a bigger value.");
+
+  if (!error.empty ()) {
+
+    Ekiga::FormRequestSimple request(sigc::mem_fun (this, &Opal::Account::on_edit_form_submitted));
+    result.visit (request);
+    request.error (error);
+
+    if (!questions.handle_request (&request)) {
 #ifdef __GNUC__
-        std::cout << "Unhandled form request in "
-          << __PRETTY_FUNCTION__ << std::endl;
+      std::cout << "Unhandled form request in "
+		<< __PRETTY_FUNCTION__ << std::endl;
 #endif
-      }
-    }
-    else {
-
-      disable ();
-      name = new_name;
-      host = new_host;
-      username = new_user;
-      auth_username = new_authentication_user;
-      password = new_password;
-      timeout = new_timeout;
-      enabled = new_enabled;
-      enable ();
-
-      updated.emit ();
-      trigger_saving.emit ();
     }
+  }
+  else {
+
+    disable ();
+    name = new_name;
+    host = new_host;
+    username = new_user;
+    auth_username = new_authentication_user;
+    password = new_password;
+    timeout = new_timeout;
+    enabled = new_enabled;
+    enable ();
 
-  } catch (Ekiga::Form::not_found) {
-
-    std::cerr << "Invalid result form" << std::endl; // FIXME: do better
+    updated.emit ();
+    trigger_saving.emit ();
   }
 }
 
diff --git a/lib/engine/components/opal/opal-bank.cpp b/lib/engine/components/opal/opal-bank.cpp
index 1e75205..e5d41c0 100644
--- a/lib/engine/components/opal/opal-bank.cpp
+++ b/lib/engine/components/opal/opal-bank.cpp
@@ -158,54 +158,47 @@ void Opal::Bank::on_new_account_form_submitted (bool submitted,
   if (!submitted)
     return;
 
-  try {
-
-    Ekiga::FormRequestSimple request(sigc::bind (sigc::mem_fun (this, &Opal::Bank::on_new_account_form_submitted) ,acc_type));
-
-    std::string error;
-    std::string new_name = (acc_type == Opal::Account::SIP
-			    || acc_type == Opal::Account::H323) ? result.text ("name") : result.hidden ("name");
-    std::string new_host = (acc_type == Opal::Account::SIP
-			    || acc_type == Opal::Account::H323) ? result.text ("host") : result.hidden ("host");
-    std::string new_user = result.text ("user");
-    std::string new_authentication_user = (acc_type == Opal::Account::SIP) ? result.text ("authentication_user") : new_user;
-    std::string new_password = result.private_text ("password");
-    bool new_enabled = result.boolean ("enabled");
-    unsigned new_timeout = atoi ((acc_type == Opal::Account::SIP
-				  || acc_type == Opal::Account::H323) ?
-                                 result.text ("timeout").c_str () : result.hidden ("timeout").c_str ());
-
-    result.visit (request);
-
-    if (new_name.empty ())
-      error = _("You did not supply a name for that account.");
-    else if (new_host.empty ())
-      error = _("You did not supply a host to register to.");
-    else if (new_user.empty ())
-      error = _("You did not supply a user name for that account.");
-    else if (new_timeout < 10)
-      error = _("The timeout should have a bigger value.");
-
-    if (!error.empty ()) {
-      request.error (error);
-
-      if (!questions.handle_request (&request)) {
+  Ekiga::FormRequestSimple request(sigc::bind (sigc::mem_fun (this, &Opal::Bank::on_new_account_form_submitted) ,acc_type));
+
+  std::string error;
+  std::string new_name = (acc_type == Opal::Account::SIP
+			  || acc_type == Opal::Account::H323) ? result.text ("name") : result.hidden ("name");
+  std::string new_host = (acc_type == Opal::Account::SIP
+			  || acc_type == Opal::Account::H323) ? result.text ("host") : result.hidden ("host");
+  std::string new_user = result.text ("user");
+  std::string new_authentication_user = (acc_type == Opal::Account::SIP) ? result.text ("authentication_user") : new_user;
+  std::string new_password = result.private_text ("password");
+  bool new_enabled = result.boolean ("enabled");
+  unsigned new_timeout = atoi ((acc_type == Opal::Account::SIP
+				|| acc_type == Opal::Account::H323) ?
+			       result.text ("timeout").c_str () : result.hidden ("timeout").c_str ());
+
+  result.visit (request);
+
+  if (new_name.empty ())
+    error = _("You did not supply a name for that account.");
+  else if (new_host.empty ())
+    error = _("You did not supply a host to register to.");
+  else if (new_user.empty ())
+    error = _("You did not supply a user name for that account.");
+  else if (new_timeout < 10)
+    error = _("The timeout should have a bigger value.");
+
+  if (!error.empty ()) {
+    request.error (error);
+
+    if (!questions.handle_request (&request)) {
 #ifdef __GNUC__
-        std::cout << "Unhandled form request in "
-		  << __PRETTY_FUNCTION__ << std::endl;
+      std::cout << "Unhandled form request in "
+		<< __PRETTY_FUNCTION__ << std::endl;
 #endif
-      }
     }
-    else {
-
-      add (acc_type, new_name, new_host, new_user, new_authentication_user,
-	   new_password, new_enabled, new_timeout);
-      save ();
-    }
-
-  } catch (Ekiga::Form::not_found) {
+  }
+  else {
 
-    std::cerr << "Invalid result form" << std::endl;
+    add (acc_type, new_name, new_host, new_user, new_authentication_user,
+	 new_password, new_enabled, new_timeout);
+    save ();
   }
 }
 
diff --git a/lib/engine/components/resource-list/rl-cluster.cpp b/lib/engine/components/resource-list/rl-cluster.cpp
index baebfe1..a9545c3 100644
--- a/lib/engine/components/resource-list/rl-cluster.cpp
+++ b/lib/engine/components/resource-list/rl-cluster.cpp
@@ -190,23 +190,14 @@ RL::Cluster::on_new_heap_form_submitted (bool submitted,
   if (!submitted)
     return;
 
-  try {
-
-    const std::string name = result.text ("name");
-    const std::string uri = result.text ("uri");
-    const std::string username = result.text ("username");
-    const std::string password = result.private_text ("password");
-    const std::string user = result.text ("user");
-    bool writable = result.boolean ("writable");
-
-    add (name, uri, username, password, user, writable);
-  } catch (Ekiga::Form::not_found) {
-
-#ifdef __GNUC__
-    std::cerr << "Invalid form submitted to "
-	      << __PRETTY_FUNCTION__ << std::endl;
-#endif
-  }
+  const std::string name = result.text ("name");
+  const std::string uri = result.text ("uri");
+  const std::string username = result.text ("username");
+  const std::string password = result.private_text ("password");
+  const std::string user = result.text ("user");
+  bool writable = result.boolean ("writable");
+
+  add (name, uri, username, password, user, writable);
 }
 
 
diff --git a/lib/engine/components/resource-list/rl-heap.cpp b/lib/engine/components/resource-list/rl-heap.cpp
index 8424e94..774be0b 100644
--- a/lib/engine/components/resource-list/rl-heap.cpp
+++ b/lib/engine/components/resource-list/rl-heap.cpp
@@ -491,32 +491,26 @@ RL::Heap::on_edit_form_submitted (bool submitted,
   if (!submitted)
     return;
 
-  try {
-
-    std::string name_str = result.text ("name");
-    std::string root_str = result.text ("root");
-    std::string user_str = result.text ("user");
-    std::string username_str = result.text ("username");
-    std::string password_str = result.private_text ("password");
-    bool writable = result.boolean ("writable");
-
-    if (writable)
-      xmlSetProp (node, BAD_CAST "writable", BAD_CAST "1");
-    else
-      xmlSetProp (node, BAD_CAST "writable", BAD_CAST "0");
-    robust_xmlNodeSetContent (node, &name, "name", name_str);
-    robust_xmlNodeSetContent (node, &root, "root", root_str);
-    robust_xmlNodeSetContent (node, &user, "user", user_str);
-    robust_xmlNodeSetContent (node, &username, "username", username_str);
-    robust_xmlNodeSetContent (node, &password, "password", password_str);
-
-    trigger_saving.emit ();
-    updated.emit ();
-    refresh ();
-  } catch (Ekiga::Form::not_found) {
-
-    std::cerr << "Invalid result form" << std::endl; // FIXME: do better
-  }
+  std::string name_str = result.text ("name");
+  std::string root_str = result.text ("root");
+  std::string user_str = result.text ("user");
+  std::string username_str = result.text ("username");
+  std::string password_str = result.private_text ("password");
+  bool writable = result.boolean ("writable");
+
+  if (writable)
+    xmlSetProp (node, BAD_CAST "writable", BAD_CAST "1");
+  else
+    xmlSetProp (node, BAD_CAST "writable", BAD_CAST "0");
+  robust_xmlNodeSetContent (node, &name, "name", name_str);
+  robust_xmlNodeSetContent (node, &root, "root", root_str);
+  robust_xmlNodeSetContent (node, &user, "user", user_str);
+  robust_xmlNodeSetContent (node, &username, "username", username_str);
+  robust_xmlNodeSetContent (node, &password, "password", password_str);
+
+  trigger_saving.emit ();
+  updated.emit ();
+  refresh ();
 }
 
 void
@@ -560,79 +554,73 @@ RL::Heap::on_new_entry_form_submitted (bool submitted,
   if (!submitted)
     return;
 
-  try {
-
-    std::string entry_name = result.text ("name");
-    std::string entry_uri = result.text ("uri");
-    std::set<std::string> entry_groups = result.editable_set ("groups");
-
-    xmlNodePtr entry_node = xmlNewChild (list_node, NULL,
-					 BAD_CAST "entry", NULL);
-    xmlSetProp (entry_node, BAD_CAST "uri",
-		BAD_CAST robust_xmlEscape (doc.get (), entry_uri).c_str ());
-    xmlNewChild (entry_node, NULL, BAD_CAST "display-name",
-		 BAD_CAST robust_xmlEscape (doc.get (), entry_name).c_str ());
-    xmlNsPtr ns = xmlSearchNsByHref (doc.get (), entry_node,
-				     BAD_CAST "http://www.ekiga.org");
-    if (ns == NULL) {
-
-      // FIXME: we should handle the case, even if it shouldn't happen
-    }
+  std::string entry_name = result.text ("name");
+  std::string entry_uri = result.text ("uri");
+  std::set<std::string> entry_groups = result.editable_set ("groups");
+
+  xmlNodePtr entry_node = xmlNewChild (list_node, NULL,
+				       BAD_CAST "entry", NULL);
+  xmlSetProp (entry_node, BAD_CAST "uri",
+	      BAD_CAST robust_xmlEscape (doc.get (), entry_uri).c_str ());
+  xmlNewChild (entry_node, NULL, BAD_CAST "display-name",
+	       BAD_CAST robust_xmlEscape (doc.get (), entry_name).c_str ());
+  xmlNsPtr ns = xmlSearchNsByHref (doc.get (), entry_node,
+				   BAD_CAST "http://www.ekiga.org");
+  if (ns == NULL) {
+
+    // FIXME: we should handle the case, even if it shouldn't happen
+  }
 
-    for (std::set<std::string>::const_iterator iter = entry_groups.begin ();
-	 iter != entry_groups.end ();
-	 ++iter) {
+  for (std::set<std::string>::const_iterator iter = entry_groups.begin ();
+       iter != entry_groups.end ();
+       ++iter) {
 
-      xmlNewChild (entry_node, ns, BAD_CAST "group",
-		   BAD_CAST robust_xmlEscape (doc.get (), *iter).c_str ());
-    }
+    xmlNewChild (entry_node, ns, BAD_CAST "group",
+		 BAD_CAST robust_xmlEscape (doc.get (), *iter).c_str ());
+  }
 
-    xmlBufferPtr buffer = xmlBufferCreate ();
-    int res = xmlNodeDump (buffer, doc.get (), entry_node, 0, 0);
+  xmlBufferPtr buffer = xmlBufferCreate ();
+  int res = xmlNodeDump (buffer, doc.get (), entry_node, 0, 0);
 
-    if (res >= 0) {
+  if (res >= 0) {
 
-      std::string root_str;
-      std::string username_str;
-      std::string password_str;
-      std::string user_str;
+    std::string root_str;
+    std::string username_str;
+    std::string password_str;
+    std::string user_str;
 
-      {
-	xmlChar* str = xmlNodeGetContent (root);
-	if (str != NULL)
-	  root_str = (const char*)str;
-      }
-      {
-	xmlChar* str = xmlNodeGetContent (user);
-	if (str != NULL)
-	  user_str = (const char*)str;
-      }
-      {
-	xmlChar* str = xmlNodeGetContent (username);
-	if (str != NULL)
-	  username_str = (const char*)str;
-      }
-      {
-	xmlChar* str = xmlNodeGetContent (password);
-	if (str != NULL)
-	  password_str = (const char*)str;
-      }
-      gmref_ptr<XCAP::Path> path(new XCAP::Path (root_str, "resource-lists",
-						 user_str));
-      path->set_credentials (username_str, password_str);
-      path = path->build_child ("resource-lists");
-      path = path->build_child ("list");
-      path = path->build_child_with_attribute ("entry", "uri", entry_uri);
-      gmref_ptr<XCAP::Core> xcap(services.get ("xcap-core"));
-      xcap->write (path, "application/xcap-el+xml",
-		   (const char*)xmlBufferContent (buffer),
-		   sigc::mem_fun (this, &RL::Heap::new_entry_result));
+    {
+      xmlChar* str = xmlNodeGetContent (root);
+      if (str != NULL)
+	root_str = (const char*)str;
     }
-    xmlBufferFree (buffer);
-  } catch (Ekiga::Form::not_found exc) {
-
-    std::cerr << "Invalid result form" << std::endl; // FIXME: do better
+    {
+      xmlChar* str = xmlNodeGetContent (user);
+      if (str != NULL)
+	user_str = (const char*)str;
+    }
+    {
+      xmlChar* str = xmlNodeGetContent (username);
+      if (str != NULL)
+	username_str = (const char*)str;
+    }
+    {
+      xmlChar* str = xmlNodeGetContent (password);
+      if (str != NULL)
+	password_str = (const char*)str;
+    }
+    gmref_ptr<XCAP::Path> path(new XCAP::Path (root_str, "resource-lists",
+					       user_str));
+    path->set_credentials (username_str, password_str);
+    path = path->build_child ("resource-lists");
+    path = path->build_child ("list");
+    path = path->build_child_with_attribute ("entry", "uri", entry_uri);
+    gmref_ptr<XCAP::Core> xcap(services.get ("xcap-core"));
+    xcap->write (path, "application/xcap-el+xml",
+		 (const char*)xmlBufferContent (buffer),
+		 sigc::mem_fun (this, &RL::Heap::new_entry_result));
   }
+  xmlBufferFree (buffer);
 }
 
 void
diff --git a/lib/engine/components/resource-list/rl-presentity.cpp b/lib/engine/components/resource-list/rl-presentity.cpp
index c673d36..1dbcdb2 100644
--- a/lib/engine/components/resource-list/rl-presentity.cpp
+++ b/lib/engine/components/resource-list/rl-presentity.cpp
@@ -73,7 +73,7 @@ RL::Presentity::Presentity (Ekiga::ServiceCore &services_,
   } else {
 
     // FIXME: we should handle the case, even if it shouldn't happen
-  
+
   }
 
   for (xmlNodePtr child = node->children ;
@@ -216,7 +216,7 @@ RL::Presentity::edit_presentity ()
 {
   Ekiga::FormRequestSimple request(sigc::mem_fun (this, &RL::Presentity::edit_presentity_form_submitted));
 
-   // FIXME: we should be able to know all groups in the heap
+  // FIXME: we should be able to know all groups in the heap
   std::set<std::string> all_groups = groups;
 
   request.title (_("Edit remote contact"));
@@ -246,61 +246,53 @@ RL::Presentity::edit_presentity_form_submitted (bool submitted,
   if (!submitted)
     return;
 
-  try {
-
-    const std::string new_name = result.text ("name");
-    const std::string new_uri = result.text ("uri");
-    const std::set<std::string> new_groups = result.editable_set ("groups");
-    std::map<std::string, xmlNodePtr> future_group_nodes;
-    xmlNsPtr ns = xmlSearchNsByHref (node->doc, node,
-				     BAD_CAST "http://www.ekiga.org");
-    bool reload = false;
+  const std::string new_name = result.text ("name");
+  const std::string new_uri = result.text ("uri");
+  const std::set<std::string> new_groups = result.editable_set ("groups");
+  std::map<std::string, xmlNodePtr> future_group_nodes;
+  xmlNsPtr ns = xmlSearchNsByHref (node->doc, node,
+				   BAD_CAST "http://www.ekiga.org");
+  bool reload = false;
 
-    robust_xmlNodeSetContent (node, &name_node, "name", new_name);
+  robust_xmlNodeSetContent (node, &name_node, "name", new_name);
 
-    if (uri != new_uri) {
+  if (uri != new_uri) {
 
-      xmlSetProp (node, (const xmlChar*)"uri", (const xmlChar*)uri.c_str ());
-      gmref_ptr<Ekiga::PresenceCore> presence_core(services.get ("presence-core"));
-      presence_core->unfetch_presence (uri);
-      reload = true;
-    }
+    xmlSetProp (node, (const xmlChar*)"uri", (const xmlChar*)uri.c_str ());
+    gmref_ptr<Ekiga::PresenceCore> presence_core(services.get ("presence-core"));
+    presence_core->unfetch_presence (uri);
+    reload = true;
+  }
 
-    for (std::map<std::string, xmlNodePtr>::const_iterator iter
-	   = group_nodes.begin ();
-	 iter != group_nodes.end () ;
-	 iter++) {
+  for (std::map<std::string, xmlNodePtr>::const_iterator iter
+	 = group_nodes.begin ();
+       iter != group_nodes.end () ;
+       iter++) {
 
-      if (new_groups.find (iter->first) == new_groups.end ()) {
+    if (new_groups.find (iter->first) == new_groups.end ()) {
 
-	xmlUnlinkNode (iter->second);
-	xmlFreeNode (iter->second);
-      }
-      else {
-	future_group_nodes[iter->first] = iter->second;
-      }
+      xmlUnlinkNode (iter->second);
+      xmlFreeNode (iter->second);
     }
-
-    for (std::set<std::string>::const_iterator iter = new_groups.begin ();
-	 iter != new_groups.end ();
-	 iter++) {
-
-      if (std::find (groups.begin (), groups.end (), *iter) == groups.end ())
-	future_group_nodes[*iter] = xmlNewChild (node, ns,
-						 BAD_CAST "group",
-						 BAD_CAST robust_xmlEscape (node->doc, *iter).c_str ());
+    else {
+      future_group_nodes[iter->first] = iter->second;
     }
+  }
 
-    group_nodes = future_group_nodes;
-    groups = new_groups;
+  for (std::set<std::string>::const_iterator iter = new_groups.begin ();
+       iter != new_groups.end ();
+       iter++) {
 
-    save (reload);
-  } catch (Ekiga::Form::not_found) {
-#ifdef __GNUC__
-    std::cerr << "Invalid form submitted to "
-	      << __PRETTY_FUNCTION__ << std::endl;
-#endif
+    if (std::find (groups.begin (), groups.end (), *iter) == groups.end ())
+      future_group_nodes[*iter] = xmlNewChild (node, ns,
+					       BAD_CAST "group",
+					       BAD_CAST robust_xmlEscape (node->doc, *iter).c_str ());
   }
+
+  group_nodes = future_group_nodes;
+  groups = new_groups;
+
+  save (reload);
 }
 
 void
diff --git a/lib/engine/framework/form-builder.cpp b/lib/engine/framework/form-builder.cpp
index c8ec683..1298aab 100644
--- a/lib/engine/framework/form-builder.cpp
+++ b/lib/engine/framework/form-builder.cpp
@@ -148,8 +148,6 @@ Ekiga::FormBuilder::hidden (const std::string name) const
        iter++)
     if (iter->name == name)
       return iter->value;
-
-  throw Ekiga::Form::not_found (name);
 }
 
 bool
@@ -161,7 +159,7 @@ Ekiga::FormBuilder::boolean (const std::string name) const
     if (iter->name == name)
       return iter->value;
 
-  throw Ekiga::Form::not_found (name);
+  return false; // shouldn't happen
 }
 
 const std::string
@@ -173,7 +171,7 @@ Ekiga::FormBuilder::private_text (const std::string name) const
     if (iter->name == name)
       return iter->value;
 
-  throw Ekiga::Form::not_found (name);
+  return ""; // shouldn't happen
 }
 
 const std::string
@@ -185,7 +183,7 @@ Ekiga::FormBuilder::text (const std::string name) const
     if (iter->name == name)
       return iter->value;
 
-  throw Ekiga::Form::not_found (name);
+  return ""; // shouldn't happen
 }
 
 const std::string
@@ -197,7 +195,7 @@ Ekiga::FormBuilder::multi_text (const std::string name) const
     if (iter->name == name)
       return iter->value;
 
-  throw Ekiga::Form::not_found (name);
+  return ""; // shouldn't happen
 }
 
 const std::string
@@ -209,7 +207,7 @@ Ekiga::FormBuilder::single_choice (const std::string name) const
     if (iter->name == name)
       return iter->value;
 
-  throw Ekiga::Form::not_found (name);
+  return ""; // shouldn't happen
 }
 
 const std::set<std::string>
@@ -221,7 +219,7 @@ Ekiga::FormBuilder::multiple_choice (const std::string name) const
     if (iter->name == name)
       return iter->values;
 
-  throw Ekiga::Form::not_found (name);
+  return std::set<std::string>(); // shouldn't happen
 }
 
 const std::set<std::string>
@@ -233,7 +231,7 @@ Ekiga::FormBuilder::editable_set (const std::string name) const
     if (iter->name == name)
       return iter->values;
 
-  throw Ekiga::Form::not_found (name);
+  return std::set<std::string>(); // shouldn't happen
 }
 
 void
diff --git a/lib/engine/framework/form.cpp b/lib/engine/framework/form.cpp
index 391490f..7a5f843 100644
--- a/lib/engine/framework/form.cpp
+++ b/lib/engine/framework/form.cpp
@@ -51,57 +51,48 @@ Ekiga::EmptyForm::visit (FormVisitor &/*visitor*/) const
 }
 
 const std::string
-Ekiga::EmptyForm::hidden (const std::string name) const
+Ekiga::EmptyForm::hidden (const std::string /*name*/) const
 {
-  throw Form::not_found (name);
   return "";
 }
 
-bool Ekiga::EmptyForm::boolean (const std::string name) const
+bool Ekiga::EmptyForm::boolean (const std::string /*name*/) const
 {
-  throw Form::not_found (name);
   return false;
 }
 
 const std::string
-Ekiga::EmptyForm::text (const std::string name) const
+Ekiga::EmptyForm::text (const std::string /*name*/) const
 {
-  throw Form::not_found (name);
   return "";
 }
 
 const std::string
-Ekiga::EmptyForm::private_text (const std::string name) const
+Ekiga::EmptyForm::private_text (const std::string /*name*/) const
 {
-  throw Form::not_found (name);
   return "";
 }
 
-
 const std::string
-Ekiga::EmptyForm::multi_text (const std::string name) const
+Ekiga::EmptyForm::multi_text (const std::string /*name*/) const
 {
-  throw Form::not_found (name);
   return "";
 }
 
 const std::string
-Ekiga::EmptyForm::single_choice (const std::string name) const
+Ekiga::EmptyForm::single_choice (const std::string /*name*/) const
 {
-  throw Form::not_found (name);
   return "";
 }
 
 const std::set<std::string>
-Ekiga::EmptyForm::multiple_choice (const std::string name) const
+Ekiga::EmptyForm::multiple_choice (const std::string /*name*/) const
 {
-  throw Form::not_found (name);
   return std::set<std::string>();
 }
 
 const std::set<std::string>
-Ekiga::EmptyForm::editable_set (const std::string name) const
+Ekiga::EmptyForm::editable_set (const std::string /*name*/) const
 {
-  throw Form::not_found (name);
   return std::set<std::string>();
 }
diff --git a/lib/engine/framework/form.h b/lib/engine/framework/form.h
index e0e51a5..a8bebb3 100644
--- a/lib/engine/framework/form.h
+++ b/lib/engine/framework/form.h
@@ -50,22 +50,6 @@ namespace Ekiga
   {
   public:
 
-    class not_found: public std::exception
-    {
-    public:
-
-      not_found (const std::string _name): name(_name)
-      {}
-
-      ~not_found () throw ()
-      {}
-
-      const char* what() const throw() { return "form field not found"; }
-
-      const std::string name;
-
-    };
-
     virtual ~Form () {}
 
     virtual void visit (FormVisitor &visitor) const = 0;
--
cgit v0.8.2


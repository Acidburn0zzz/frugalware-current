diff -ruN gnome-volume-manager-1.2.2/src/manager.c gnome-volume-manager-1.2.2.hal/src/manager.c
--- gnome-volume-manager-1.2.2/src/manager.c	2005-05-11 17:55:30.000000000 +0200
+++ gnome-volume-manager-1.2.2.hal/src/manager.c	2005-06-13 10:41:28.000000000 +0200
@@ -300,6 +300,7 @@
 	enum { IMPORT } action = -1;
 	GtkWidget *askme;
 	int retval = FALSE;
+  DBusError error;
 
 	dcim_path = g_build_path (G_DIR_SEPARATOR_S, mount_point, "dcim", NULL);
 
@@ -310,8 +311,14 @@
 	dbg ("Photos detected: %s\n", dcim_path);
 
 	/* add the "content.photos" capability to this device */
-	if (!hal_device_add_capability (hal_ctx, udi, "content.photos"))
-		warn ("failed to set content.photos on %s\n", device);
+  dbus_error_init (&error);
+	if (!libhal_device_add_capability (hal_ctx, udi,
+        "content.photos", &error)) {
+    warn ("failed to set content.photos on %s: %s\n",
+        device, error.message);
+    if (dbus_error_is_set (&error))
+        dbus_error_free (&error);
+  }
 
 	if (config.autophoto) {
 		askme = gtk_message_dialog_new (NULL, 0, GTK_MESSAGE_WARNING,
@@ -355,7 +362,7 @@
 	int retval = FALSE;
 
 	/* see if it's a camera */
-	if (!hal_device_query_capability(hal_ctx, udi, "camera"))
+	if (!libhal_device_query_capability(hal_ctx, udi, "camera", NULL))
 		goto out;
 
 	retval = TRUE;
@@ -397,16 +404,26 @@
 	char *device = NULL, *mount_point = NULL;
 	gboolean autorun_succeeded = FALSE;
 
-	device = hal_device_get_property_string (hal_ctx, udi, "block.device");
+  DBusError error;
+
+  dbus_error_init (&error);
+	device = libhal_device_get_property_string (hal_ctx, udi,
+      "block.device",
+      &error);
 	if (!device) {
-		warn ("cannot get block.device\n");
+		warn ("cannot get block.device: %s\n", error.message);
+    if (dbus_error_is_set (&error))
+      dbus_error_free (&error);
 		goto out;
 	}
 
-	mount_point = hal_device_get_property_string (hal_ctx, udi, 
-						      "volume.mount_point");
+	mount_point = libhal_device_get_property_string (hal_ctx, udi, 
+						      "volume.mount_point",
+                  &error);
 	if (!mount_point) {
-		warn ("cannot get volume.mount_point\n");
+		warn ("cannot get volume.mount_point: %s\n", error.message);
+    if (dbus_error_is_set (&error))
+      dbus_error_free (&error);
 		goto out;
 	}
 
@@ -459,8 +476,8 @@
 	}
 
 out:
-	hal_free_string (device);
-	hal_free_string (mount_point);
+	libhal_free_string (device);
+	libhal_free_string (mount_point);
 }
 
 /*
@@ -542,10 +559,16 @@
 {
 	enum { MOUNT, PLAY } action = -1;
 	char *device = NULL, *mount_point = NULL;
+  DBusError error;
 
-	device = hal_device_get_property_string (hal_ctx, udi, "block.device");
+  dbus_error_init (&error);
+	device = libhal_device_get_property_string (hal_ctx, udi,
+      "block.device",
+      &error);
 	if (!device) {
-		warn ("cannot get block.device\n");
+		warn ("cannot get block.device: %s\n", error.message);
+    if (dbus_error_is_set(&error))
+      dbus_error_free (&error);
 		goto out;
 	}
 
@@ -589,8 +612,8 @@
 	}
 
 out:
-	hal_free_string (device);
-	hal_free_string (mount_point);
+	libhal_free_string (device);
+	libhal_free_string (mount_point);
 }
 
 /*
@@ -610,12 +633,24 @@
 static gboolean
 gvm_device_is_writer (const char *udi)
 {
-	if ((hal_device_get_property_bool (hal_ctx, udi, "storage.cdrom.cdr")) ||
-	    (hal_device_get_property_bool (hal_ctx, udi, "storage.cdrom.cdrw")) ||
-	    (hal_device_get_property_bool (hal_ctx, udi, "storage.cdrom.dvdr")) ||
-	    (hal_device_get_property_bool (hal_ctx, udi, "storage.cdrom.dvdram")) ||
-	    (hal_device_get_property_bool (hal_ctx, udi, "storage.cdrom.dvdplusr")) ||
-	    (hal_device_get_property_bool (hal_ctx, udi, "storage.cdrom.dvdplusrw")))
+	if ((libhal_device_get_property_bool (hal_ctx, udi,
+                                        "storage.cdrom.cdr",
+                                        NULL)) ||
+	    (libhal_device_get_property_bool (hal_ctx, udi,
+                                        "storage.cdrom.cdrw",
+                                        NULL)) ||
+	    (libhal_device_get_property_bool (hal_ctx, udi, 
+                                        "storage.cdrom.dvdr",
+                                        NULL)) ||
+	    (libhal_device_get_property_bool (hal_ctx, udi, 
+                                        "storage.cdrom.dvdram",
+                                        NULL)) ||
+	    (libhal_device_get_property_bool (hal_ctx, udi, 
+                                     "storage.cdrom.dvdplusr",
+                                     NULL)) ||
+	    (libhal_device_get_property_bool (hal_ctx, udi, 
+                                     "storage.cdrom.dvdplusrw",
+                                     NULL)))
 		return TRUE;
 
 	return FALSE;
@@ -633,19 +668,29 @@
 	dbus_bool_t has_audio;
 	dbus_bool_t has_data;
 	dbus_bool_t is_blank;
+  DBusError error;
 
-	has_audio = hal_device_get_property_bool (hal_ctx, udi,
-						  "volume.disc.has_audio");
-	has_data = hal_device_get_property_bool (hal_ctx, udi,
-						  "volume.disc.has_data");
-	is_blank = hal_device_get_property_bool (hal_ctx, udi,
-						  "volume.disc.is_blank");
-	drive_udi = hal_device_get_property_string(hal_ctx, udi,
-			"info.parent");
-
-	device = hal_device_get_property_string (hal_ctx, udi, "block.device");
+  dbus_error_init (&error);
+	has_audio = libhal_device_get_property_bool (hal_ctx, udi,
+						  "volume.disc.has_audio",
+              NULL);
+	has_data = libhal_device_get_property_bool (hal_ctx, udi,
+						  "volume.disc.has_data",
+              NULL);
+	is_blank = libhal_device_get_property_bool (hal_ctx, udi,
+						  "volume.disc.is_blank",
+              NULL);
+	drive_udi = libhal_device_get_property_string(hal_ctx, udi,
+			"info.parent",
+      NULL);
+
+	device = libhal_device_get_property_string (hal_ctx, udi,
+      "block.device",
+      &error);
 	if (!device) {
-		warn ("cannot get block.device\n");
+		warn ("cannot get block.device: %s\n", error.message);
+    if (dbus_error_is_set (&error))
+      dbus_error_free (&error);
 		goto out;
 	}
 
@@ -666,8 +711,8 @@
 	/** @todo enforce policy for all the new disc types now supported */
 
 out:
-	hal_free_string (device);
-	hal_free_string (drive_udi);
+	libhal_free_string (device);
+	libhal_free_string (drive_udi);
 }
 
 /*
@@ -684,12 +729,18 @@
 gvm_media_changed (const char *udi, const char *storage_device, char *device)
 {
 	char *media_type;
+  DBusError error;
 
 	/* Refuse to enforce policy on removable media if drive is locked */
-	if (hal_device_property_exists (
-		    hal_ctx, storage_device, "info.locked") &&
-	    hal_device_get_property_bool (
-		    hal_ctx, storage_device, "info.locked")) {
+  dbus_error_init (&error);
+	if (libhal_device_property_exists (
+		    hal_ctx, storage_device,
+        "info.locked",
+        NULL) &&
+	    libhal_device_get_property_bool (
+		    hal_ctx, storage_device,
+        "info.locked",
+        NULL)) {
 		dbg ("Drive with udi %s is locked through hal; "
 		     "skipping policy\n", storage_device);
 		return;
@@ -699,10 +750,13 @@
 	 * Get HAL's interpretation of our media type.  Note that we must check
 	 * the storage device and not this UDI
 	 */
-	media_type = hal_device_get_property_string (hal_ctx, storage_device, 
-						     "storage.drive_type");
+	media_type = libhal_device_get_property_string (hal_ctx, storage_device, 
+						     "storage.drive_type",
+                 &error);
 	if (!media_type) {
-		warn ("cannot get storage.drive_type\n");
+		warn ("cannot get storage.drive_type: %s\n", error.message);
+    if (dbus_error_is_set (&error))
+      dbus_error_free (&error);
 		return;
 	}
 
@@ -717,7 +771,7 @@
 		}
 	}
 
-	hal_free_string (media_type);
+	libhal_free_string (media_type);
 }
 
 /** Invoked when a device is added to the Global Device List. 
@@ -730,33 +784,38 @@
 		  const char *udi)
 {
 	char *device = NULL, *storage_device = NULL;
+  DBusError error;
 
 	dbg ("New Device: %s\n", udi);
 
 	gvm_check_camera (udi);
 
-	if (!hal_device_query_capability(hal_ctx, udi, "block"))
+  dbus_error_init (&error);
+	if (!libhal_device_query_capability(hal_ctx, udi, "block", NULL))
 		goto out;
 	
 	/* is this a mountable volume ? */
-	if (!hal_device_get_property_bool (hal_ctx, udi, 
-					   "block.is_volume"))
+	if (!libhal_device_get_property_bool (hal_ctx, udi, 
+					   "block.is_volume",
+             NULL))
 		goto out;
 	
 	/* if it is a volume, it must have a device node */
-	device = hal_device_get_property_string (hal_ctx, udi, 
-						 "block.device");
+	device = libhal_device_get_property_string (hal_ctx, udi, 
+						 "block.device",
+             &error);
 	if (!device) {
-		dbg ("cannot get block.device\n");
+		dbg ("cannot get block.device: %s\n", error.message);
 		goto out;
 	}
 	
 	/* get the backing storage device */
-	storage_device = hal_device_get_property_string (
+	storage_device = libhal_device_get_property_string (
 		hal_ctx, udi,
-		"block.storage_device");
+		"block.storage_device",
+    &error);
 	if (!storage_device) {
-		dbg ("cannot get block.storage_device\n");
+		dbg ("cannot get block.storage_device: %s\n", error.message);
 		goto out;
 	}
 	
@@ -764,8 +823,9 @@
 	 * Does this device support removable media?  Note that we
 	 * check storage_device and not our own UDI
 	 */
-	if (hal_device_get_property_bool (hal_ctx, storage_device,
-					  "storage.removable")) {
+	if (libhal_device_get_property_bool (hal_ctx, storage_device,
+					  "storage.removable",
+            NULL)) {
 		/* we handle media change events separately */
 		dbg ("Changed: %s\n", device);
 		gvm_media_changed (udi, storage_device, device);
@@ -781,8 +841,10 @@
 	}
 	
 out:
-	hal_free_string (device);
-	hal_free_string (storage_device);
+	if (dbus_error_is_set (&error))
+    dbus_error_free (&error);
+  libhal_free_string (device);
+	libhal_free_string (storage_device);
 }
 
 /** Invoked when a device is removed from the Global Device List. 
@@ -850,7 +912,7 @@
 	if (g_strcasecmp (key, "volume.is_mounted") != 0)
 		return;
 
-	val = hal_device_get_property_bool (hal_ctx, udi, key);
+	val = libhal_device_get_property_bool (hal_ctx, udi, key, NULL);
 	if (val == TRUE) {
 		GSList *policy_udi;
 
@@ -905,56 +967,109 @@
 {
 }
 
-/** Invoked by libhal for integration with our mainloop. 
+/** Integrate a dbus mainloop.
  *
  *  @param  ctx                 LibHal context
- *  @param  dbus_connection     D-BUS connection to integrate
+ *  @param  error               pointer to a D-BUS error object
+ *
+ *  @return                     TRUE if we connected to the bus
  */
-static void
-hal_mainloop_integration (LibHalContext *ctx __attribute__((__unused__)),
-			  DBusConnection * dbus_connection)
+static dbus_bool_t
+hal_mainloop_integration (LibHalContext *ctx,
+    DBusError *error)
 {
-	dbus_connection_setup_with_g_main (dbus_connection, NULL);
+  DBusConnection *dbus_connection;
+
+  dbus_connection = dbus_bus_get (DBUS_BUS_SYSTEM, error);
+
+  if (dbus_error_is_set (error))
+    return FALSE;
+
+  dbus_connection_setup_with_g_main (dbus_connection, NULL);
+
+  libhal_ctx_set_dbus_connection (ctx, dbus_connection);
+
+  return TRUE;
 }
 
 /** Internal HAL initialization function
  *
- * @functions			The LibHalFunctions to register as callbacks.
  * @return			The LibHalContext of the HAL connection or
  *				NULL on error.
  */
 static LibHalContext *
-gvm_do_hal_init (LibHalFunctions *functions)
+gvm_do_hal_init ()
 {
 	LibHalContext *ctx;
+  DBusError error;
 	char **devices;
 	int nr;
 
-	ctx = hal_initialize (functions, FALSE);
+	ctx = libhal_ctx_new ();
 	if (!ctx) {
 		warn ("failed to initialize HAL!\n");
 		return NULL;
 	}
 
-	if (hal_device_property_watch_all (ctx)) {
-		warn ("failed to watch all HAL properties!\n");
-		hal_shutdown (ctx);
+  dbus_error_init (&error);
+  if (!hal_mainloop_integration (ctx,
+        &error)) {
+    g_warning ("hal_initialize failed: %s\n", error.message);
+    if (dbus_error_is_set (&error))
+      dbus_error_free (&error);
 		return NULL;
 	}
 
+  libhal_ctx_set_device_added (ctx,
+      hal_device_added);
+  libhal_ctx_set_device_removed (ctx,
+      hal_device_removed);
+  libhal_ctx_set_device_new_capability (ctx,
+      hal_device_new_capability);
+  libhal_ctx_set_device_lost_capability (ctx,
+      hal_device_lost_capability);
+  libhal_ctx_set_device_property_modified (ctx,
+      hal_property_modified);
+  libhal_ctx_set_device_condition (ctx,
+      hal_device_condition);
+
+  if (!libhal_device_property_watch_all (ctx, &error)) {
+    warn ("failed to watch all HAL properties!: %s\n", error.message);
+    if (dbus_error_is_set (&error))
+      dbus_error_free (&error);
+    libhal_ctx_free (ctx);
+    return NULL;
+  }
+
+  if (!libhal_ctx_init (ctx, &error)) {
+    warn ("hal_initialize failed: %s\n", error.message);
+    if (dbus_error_is_set (&error))
+      dbus_error_free (&error);
+    libhal_ctx_free (ctx);
+    return NULL;
+  }
+
 	/*
 	 * Do something to ping the HAL daemon - the above functions will
 	 * succeed even if hald is not running, so long as DBUS is.  But we
 	 * want to exit silently if hald is not running, to behave on
 	 * pre-2.6 systems.
 	 */
-	devices = hal_get_all_devices (ctx, &nr);
+	devices = libhal_get_all_devices (ctx, &nr, &error);
 	if (!devices) {
-		warn ("seems that HAL is not running\n");
-		hal_shutdown (ctx);
+		warn ("seems that HAL is not running: %s\n", error.message);
+    if (dbus_error_is_set (&error))
+      dbus_error_free (&error);
+
+    libhal_ctx_shutdown (ctx, &error);
+
+    if (dbus_error_is_set (&error))
+      dbus_error_free (&error);
+
+    libhal_ctx_free (ctx);
 		return NULL;
 	}
-	hal_free_string_array (devices);
+	libhal_free_string_array (devices);
 
 	return ctx;
 }
@@ -968,49 +1083,66 @@
 	int i;
 	int num_volumes;
 	char **volumes;
+  DBusError error;
 
 	if (!config.automount_media)
 		return;
 
-	volumes = hal_find_device_by_capability (ctx, "volume", &num_volumes);
+  dbus_error_init (&error);
+	volumes = libhal_find_device_by_capability (ctx, "volume", 
+      &num_volumes, &error);
+  if (dbus_error_is_set (&error)) {
+    warn ("%s", error.message);
+    dbus_error_free (&error);
+    return;
+  }
+
 	for (i = 0; i < num_volumes; i++) {
 		char *device_file, *udi;
 
 		udi = volumes [i];
 
 		/* don't attempt to mount already mounted volumes */
-		if (!hal_device_property_exists (ctx, udi, 
-						"volume.is_mounted") ||
-		    hal_device_get_property_bool (ctx, udi, 
-						  "volume.is_mounted"))
+		if (!libhal_device_property_exists (ctx, udi, 
+						"volume.is_mounted",
+            NULL) ||
+		    libhal_device_get_property_bool (ctx, udi, 
+						  "volume.is_mounted",
+              NULL))
 			continue;
 
 		/* only mount if the block device has a sensible filesystem */
-		if (!hal_device_property_exists (ctx, udi, "volume.fsusage"))
+		if (!libhal_device_property_exists (ctx, udi, 
+          "volume.fsusage",
+          NULL))
 			continue;
 		else {
 			char *fsusage;
-			fsusage = hal_device_get_property_string (ctx, udi,
-					"volume.fsusage");
+			fsusage = libhal_device_get_property_string (ctx, udi,
+					"volume.fsusage", NULL);
 			if (strcmp (fsusage, "filesystem") != 0) {
-				hal_free_string (fsusage);
+				libhal_free_string (fsusage);
 				continue;
 			}
-			hal_free_string (fsusage);
+			libhal_free_string (fsusage);
 		}
 
-		device_file = hal_device_get_property_string (ctx, udi,
-							      "block.device");
+		device_file = libhal_device_get_property_string (ctx, udi,
+							      "block.device", &error);
 
 		if (device_file != NULL ) {
 			dbg ("mount_all: mounting %s\n", device_file);
 			gvm_device_mount (device_file);
-			hal_free_string (device_file);
-		} else
-			warn ("no device_file for udi=%s\n", udi);
+			libhal_free_string (device_file);
+		} else {
+			warn ("no device_file for udi=%s: %s\n", udi, error.message);
+      if (dbus_error_is_set (&error))
+        dbus_error_free (&error);
+    }
+    
 	}
 
-	hal_free_string_array (volumes);
+	libhal_free_string_array (volumes);
 }
 
 /** Unmount all volumes that were mounted during the lifetime of this
@@ -1024,23 +1156,28 @@
 	GSList *i;
 	char *device_file;
 	char *udi;
+  DBusError error;
 
 	dbg ("unmounting all volumes that we saw mounted in our life\n");
 
+  dbus_error_init (&error);
 	for (i = all_mounted_volumes; i != NULL; i = g_slist_next (i)) {
 
 		udi = i->data;
 
-		device_file = hal_device_get_property_string (ctx, udi,
-							      "block.device");
+		device_file = libhal_device_get_property_string (ctx, udi,
+							      "block.device",
+                    &error);
 		if (device_file != NULL ) {
 
 			dbg ("unmount_all: unmounting %s\n", device_file);
 
 			gvm_device_unmount (device_file);
-			hal_free_string (device_file);
+			libhal_free_string (device_file);
 		} else {
-			warn ("no device_file for udi=%s\n", udi);
+			warn ("no device_file for udi=%s: %s\n", udi, error.message);
+      if (dbus_error_is_set (&error))
+        dbus_error_free (&error);
 		}
 	}
 }
@@ -1101,13 +1238,6 @@
 main (int argc, char *argv[])
 {
 	GnomeClient *client;
-	LibHalFunctions hal_functions = { hal_mainloop_integration,
-					  hal_device_added,
-					  hal_device_removed,
-					  hal_device_new_capability,
-					  hal_device_lost_capability,
-					  hal_property_modified,
-					  hal_device_condition };
 
 	gnome_program_init (PACKAGE, VERSION, LIBGNOMEUI_MODULE,
 			    argc, argv, GNOME_PARAM_NONE);
@@ -1128,7 +1258,7 @@
 	gtk_signal_connect (GTK_OBJECT (client), "die",
 			    GTK_SIGNAL_FUNC (gvm_die), NULL);
 
-	hal_ctx = gvm_do_hal_init (&hal_functions);
+	hal_ctx = gvm_do_hal_init ();
 	if (!hal_ctx)
 		return 1;
 
diff -ruN gnome-volume-manager-1.2.2/src/properties.c gnome-volume-manager-1.2.2.hal/src/properties.c
--- gnome-volume-manager-1.2.2/src/properties.c	2005-03-30 23:21:10.000000000 +0200
+++ gnome-volume-manager-1.2.2.hal/src/properties.c	2005-06-13 10:34:12.000000000 +0200
@@ -329,25 +329,47 @@
 	LibHalContext *ctx;
 	char **devices;
 	int nr;
+  DBusError error;
+  DBusConnection *conn;
 
-	ctx = hal_initialize (NULL, FALSE);
+	ctx = libhal_ctx_new ();
 	if (!ctx)
 		return FALSE;
 
+  dbus_error_init (&error);
+
+  conn = dbus_bus_get (DBUS_BUS_SYSTEM, &error);
+  if (dbus_error_is_set (&error)) {
+    dbus_error_free (&error);
+    return FALSE;
+  }
+
+  libhal_ctx_set_dbus_connection (ctx, conn);
+
+  if (!libhal_ctx_init (ctx, &error)) {
+    if (dbus_error_is_set (&error))
+      dbus_error_free (&error);
+    return FALSE;
+  }
+
 	/*
 	 * Do something to ping the HAL daemon - the above functions will
 	 * succeed even if hald is not running, so long as DBUS is.  But we
 	 * want to exit silently if hald is not running, to behave on
 	 * pre-2.6 systems.
 	 */
-	devices = hal_get_all_devices (ctx, &nr);
+	devices = libhal_get_all_devices (ctx, &nr, &error);
 	if (!devices) {
-		hal_shutdown (ctx);
+    libhal_ctx_shutdown (ctx, NULL);
+    libhal_ctx_free (ctx);
+    if (dbus_error_is_set(&error))
+      dbus_error_free (&error);
 		return FALSE;
 	}
-	hal_free_string_array (devices);
+	libhal_free_string_array (devices);
 
-	hal_shutdown (ctx);
+	libhal_ctx_shutdown (ctx, NULL);
+  libhal_ctx_free (ctx);
 	return TRUE;
 }
 

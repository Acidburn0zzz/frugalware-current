diff -Naur FreeImage/Source/FreeImage/PluginBMP.cpp FreeImage-p/Source/FreeImage/PluginBMP.cpp
--- FreeImage/Source/FreeImage/PluginBMP.cpp	2007-10-21 16:50:08.000000000 +0200
+++ FreeImage-p/Source/FreeImage/PluginBMP.cpp	2008-05-17 23:35:50.000000000 +0200
@@ -224,7 +224,7 @@
 				throw(1);
 			}
 			if (status_byte != 0)	{
-				status_byte = MIN(status_byte, end - q);
+				status_byte = (int)MIN((size_t)status_byte, (size_t)(end - q));
 				// Encoded mode
 				if(io->read_proc(&second_byte, sizeof(BYTE), 1, handle) != 1) {
 					throw(1);
@@ -279,7 +279,7 @@
 					default:
 					{
 						// Absolute mode
-						status_byte = MIN(status_byte, end - q);
+						status_byte = (int)MIN((size_t)status_byte, (size_t)(end - q));
 						for (int i = 0; i < status_byte; i++) {
 							if ((i & 0x01) == 0) {
 								if(io->read_proc(&second_byte, sizeof(BYTE), 1, handle) != 1) {
diff -Naur FreeImage/Source/Metadata/Exif.cpp FreeImage-p/Source/Metadata/Exif.cpp
--- FreeImage/Source/Metadata/Exif.cpp	2007-07-17 03:28:26.000000000 +0200
+++ FreeImage-p/Source/Metadata/Exif.cpp	2008-05-17 23:35:58.000000000 +0200
@@ -461,7 +461,7 @@
 	@return 
 */
 static BOOL 
-jpeg_read_exif_dir(FIBITMAP *dib, const BYTE *tiffp, unsigned int offset, unsigned int length, BOOL msb_order) {
+jpeg_read_exif_dir(FIBITMAP *dib, const BYTE *tiffp, unsigned long offset, unsigned int length, BOOL msb_order) {
 	WORD de, nde;
 
 	std::stack<WORD>			destack;	// directory entries stack
@@ -495,7 +495,7 @@
 		}
 
 		// remember that we've visited this directory so that we don't visit it again later
-		DWORD visited = (((DWORD)ifdp & 0xFFFF) << 16) | (DWORD)de;
+		DWORD visited = (DWORD)( (((size_t)ifdp & 0xFFFF) << 16) | (size_t)de );
 		if(visitedIFD.find(visited) != visitedIFD.end()) {
 			continue;
 		} else {
@@ -541,7 +541,7 @@
 
 				// if its bigger than 4 bytes, the directory entry contains an offset
 				offset_value = ReadUint32(msb_order, pde + 8);
-				if((size_t) (offset_value + FreeImage_GetTagLength(tag)) > length) {
+				if(offset_value > length - FreeImage_GetTagLength(tag)) {
 					// a problem occured : delete the tag (not free'd after)
 					FreeImage_DeleteTag(tag);
 					// jump to next entry
@@ -634,7 +634,7 @@
 	BYTE lsb_first[4] = { 0x49, 0x49, 0x2A, 0x00 };		// Intel order
 	BYTE msb_first[4] = { 0x4D, 0x4D, 0x00, 0x2A };		// Motorola order
 
-	size_t length = datalen;
+	unsigned int length = datalen;
 	BYTE *profile = (BYTE*)dataptr;
 
 	// verify the identifying string
@@ -663,7 +663,7 @@
 		}
 
 		// this is the offset to the first IFD
-		size_t first_offset = ReadUint32(bMotorolaOrder, profile + 4);
+		unsigned long first_offset = ReadUint32(bMotorolaOrder, profile + 4);
 
 		if (first_offset < 8 || first_offset > 16) {
 			// This is usually set to 8

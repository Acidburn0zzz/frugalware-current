--- ATi/common/lib/modules/fglrx/build_mod/firegl_public.c.old	2007-03-28 21:39:58.000000000 -0400
+++ ATi/common/lib/modules/fglrx/build_mod/firegl_public.c	2007-03-28 21:39:46.000000000 -0400
@@ -23,6 +23,8 @@
 
 // ============================================================
 #include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/freezer.h>
 #ifdef MODVERSIONS
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,71)
 #include <linux/modversions.h>
@@ -204,6 +204,70 @@
 int errno;
 #endif // __ia64__
 
+#if defined(__i386__)
+#define __syscall_return(type, res) \
+do { \
+        if ((unsigned long)(res) >= (unsigned long)(-(128 + 1))) { \
+                errno = -(res); \
+                res = -1; \
+        } \
+        return (type) (res); \
+} while (0)
+#define _syscall2(type,name,type1,arg1,type2,arg2) \
+type name(type1 arg1,type2 arg2) \
+{ \
+long __res; \
+__asm__ volatile ("push %%ebx ; movl %2,%%ebx ; int $0x80 ; pop %%ebx" \
+        : "=a" (__res) \
+        : "0" (__NR_##name),"ri" ((long)(arg1)),"c" ((long)(arg2)) \
+        : "memory"); \
+__syscall_return(type,__res); \
+}
+
+#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3) \
+type name(type1 arg1,type2 arg2,type3 arg3) \
+{ \
+long __res; \
+__asm__ volatile ("push %%ebx ; movl %2,%%ebx ; int $0x80 ; pop %%ebx" \
+        : "=a" (__res) \
+        : "0" (__NR_##name),"ri" ((long)(arg1)),"c" ((long)(arg2)), \
+                  "d" ((long)(arg3)) : "memory"); \
+__syscall_return(type,__res); \
+}
+#elif defined(__x86_64__)
+#define __syscall_clobber "r11","rcx","memory" 
+#define __syscall "syscall"
+
+#define __syscall_return(type, res) \
+do { \
+        if ((unsigned long)(res) >= (unsigned long)(-127)) { \
+                errno = -(res); \
+                res = -1; \
+        } \
+        return (type) (res); \
+} while (0)
+#define _syscall2(type,name,type1,arg1,type2,arg2) \
+type name(type1 arg1,type2 arg2) \
+{ \
+long __res; \
+__asm__ volatile (__syscall \
+        : "=a" (__res) \
+        : "0" (__NR_##name),"D" ((long)(arg1)),"S" ((long)(arg2)) : __syscall_clobber ); \
+__syscall_return(type,__res); \
+}
+
+#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3) \
+type name(type1 arg1,type2 arg2,type3 arg3) \
+{ \
+long __res; \
+__asm__ volatile (__syscall \
+        : "=a" (__res) \
+        : "0" (__NR_##name),"D" ((long)(arg1)),"S" ((long)(arg2)), \
+                  "d" ((long)(arg3)) : __syscall_clobber); \
+__syscall_return(type,__res); \
+}
+#endif
+
 // int mlock(const void *addr, size_t len);
 _syscall2(int, mlock, const void *, addr, size_t, len )
 // int munlock(const void *addr, size_t len);
@@ -5005,15 +5069,9 @@
 
     DBG_TRACE("destroying slab object '%s'", slabcache_obj->name);
 
-    if (kmem_cache_destroy(slabcache_obj->cache) == 0)
-    {
-        ret = 1;
-        slabcache_obj->cache = NULL;
-    }
-    else
-    {
-        DBG_ERROR("destroying failed");
-    }
+    kmem_cache_destroy(slabcache_obj->cache);
+    ret = 1;
+    slabcache_obj->cache = NULL;
 
     DBG_LEAVE("%d", ret);
     return ret;
